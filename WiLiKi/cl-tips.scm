(" %Tag:yason" . "(1668281026 (\"JSONのパース・生成\" :ctime 1346850276 :cuser #f :mtime 1346932427 :muser #f))")
(" %Tag:インターネットサービス'A=0" . "(1555828241)")
("Short Coding" . "(:ctime 1227696977 :cuser #f :mtime 1227701642 :muser #f){{{\n(multiple-value-bind (q r) (floor 5 3)\n  (list q r))\n;=> (1 2)\n\n(multiple-value-call #'list (floor 5 3))\n;=> (1 2)\n\n(multiple-value-list (floor 5 3))\n;=> (1 2)\n}}}\n{{{\n(let ((a 1) (b 2) (c 3) (d 4))\n   (list\n    ;; long\n    (1- (+ a b c d))\n    ;; short\n    (+ -1 a b c d)))\n;=> (9 9)\n}}}\n{{{\n;; long\n(let ((a 1) (b 2) (c 3) (d 4))\n   (list a b c d))\n;=> (1 2 3 4)\n\n;; short\n((lambda (a b c d)\n   (list a b c d))\n 1 2 3 4)\n;=> (1 2 3 4)\n\n;; cf.\n(destructuring-bind (a b c d) '(1 2 3 4)\n  (list a b c d))\n}}}\n{{{\n;; long\n(case :foo\n  (:foo (format t \"foo!~%\"))\n  (:bar (format t \"bar!~%\"))\n  (:baz (format t \"baz!~%\")))\n;-> foo!\n;=> nil\n\n;; short\n(format t (case :foo\n\t    (:foo \"foo!~%\")\n\t    (:bar \"bar!~%\")\n\t    (:baz \"baz!~%\")))\n;-> foo!\n;=> nil\n}}}\n")
(" %Tag:日付と時刻" . "(1668303270 (\"月の最後の日を調べる\" :ctime 1227414848 :cuser #f :mtime 1380364786 :muser #f) (\"何日後、何日前/何ヶ月後、何ヶ月前の日付を求める\" :ctime 1227414763 :cuser #f :mtime 1370595615 :muser #f) (\"時刻中の曜日を日本語に変換する\" :ctime 1227414645 :cuser #f :mtime 1347284004 :muser #f) (\"指定の日付が存在するかどうか調べる\" :ctime 1227414725 :cuser #f :mtime 1335998832 :muser #f) (\"日付が何曜日、何日、年初から何日め、年初から何週めになるかを求める\" :ctime 1232880617 :cuser #f :mtime 1232880617 :muser #f) (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f) (\"現在の日付を求める\" :ctime 1227414677 :cuser #f :mtime 1227947512 :muser #f) (\"うるう年かどうか判定する\" :ctime 1227414804 :cuser #f :mtime 1227714916 :muser #f) (\"2つの時刻の差を求める\" :ctime 1227414623 :cuser #f :mtime 1227414623 :muser #f) (\"時刻に任意の時間を加減する\" :ctime 1227414597 :cuser #f :mtime 1227414597 :muser #f) (\"Universal Timeを文字列に変換する\" :ctime 1227414526 :cuser #f :mtime 1227414526 :muser #f) (\"時刻の表現からUniversal Timeを作成する\" :ctime 1227414501 :cuser #f :mtime 1227414501 :muser #f) (\"現在の時刻(Universal Time)を取得する\" :ctime 1227414467 :cuser #f :mtime 1227414468 :muser #f) (\"Universal Time\" :ctime 1227414433 :cuser #f :mtime 1227414433 :muser #f))")
(" %Tag:制御構造" . "(1668187805 (\"loop\" :ctime 1336291276 :cuser #f :mtime 1630548022 :muser #f) (\"go to\" :ctime 1605275555 :cuser #f :mtime 1605275555 :muser #f) (\"制御構造\" :ctime 1227174305 :cuser #f :mtime 1458560623 :muser #f) (\"繰り返しからの脱出\" :ctime 1227416045 :cuser #f :mtime 1380287635 :muser #f) (\"多値を変数に代入する\" :ctime 1229603159 :cuser #f :mtime 1363963273 :muser #f) (\"繰り返し(do)\" :ctime 1227416036 :cuser #f :mtime 1350654890 :muser #f) (\"条件判断(cond マクロ)\" :ctime 1228888426 :cuser #f :mtime 1350654822 :muser #f) (\"条件判断(case)\" :ctime 1227415897 :cuser #f :mtime 1350654802 :muser #f) (\"loop:指定値までの繰り返し\" :ctime 1336291343 :cuser #f :mtime 1336291343 :muser #f) (\"代入(setf)\" :ctime 1237819188 :cuser #f :mtime 1237819785 :muser #f) (\"有意な値を返さない\" :ctime 1232958366 :cuser #f :mtime 1233045023 :muser #f) (\"一時変数を使わずに値を交換する\" :ctime 1230918931 :cuser #f :mtime 1230918931 :muser #f) (\"リスト構造を分解して変数に代入する\" :ctime 1229602567 :cuser #f :mtime 1229602567 :muser #f) (\"ブロックからの脱出\" :ctime 1229520442 :cuser #f :mtime 1229549658 :muser #f) (\"繰り返しの前処理・後処理\" :ctime 1229528833 :cuser #f :mtime 1229528833 :muser #f) (\"指定回数の繰り返し\" :ctime 1227415941 :cuser #f :mtime 1229527683 :muser #f) (\"指定値までの指定ステップ毎に繰り返し\" :ctime 1227415969 :cuser #f :mtime 1229527109 :muser #f) (\"確実に後処理を行なう\" :ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f) (\"条件判断(if スペシャルフォーム)\" :ctime 1228888390 :cuser #f :mtime 1228888391 :muser #f))")
("戻り値の型宣言" . "(:ctime 1329738055 :cuser #f :mtime 1329738055 :muser #f)戻り値に型を宣言することにより、コンパイル時や、実行時に型チェックをすることが可能です。~%\n※ただし、仕様では型宣言自体、処理系によっては無視しても問題ありませんので、移植性が重要な問題になる場合には別の方法を検討する必要もあるでしょう。\n\n*** return-integer は任意の型の引数を一つ受取りintegerを返すという宣言をした場合\n{{{\n(declaim (ftype (function (t) integer) return-integer))\n\n(defun return-integer (obj)\n  'foo)\n; 整合性がない場合、警告を出してくれる処理系もある\n; caught STYLE-WARNING:\n;   The result type from proclamation:\n;     (VALUES INTEGER &REST T)\n;   conflicts with the definition's result type:\n;     (VALUES (MEMBER FOO) &OPTIONAL)\n\n(defun return-integer (obj)\n  obj)\n\n(return-integer 'foo)\n;>>> The value FOO is not of type INTEGER. (処理系依存)\n}}}\n*** [[$$hs the]]を用いての直接的な指定\n{{{\n(defun return-list (obj)\n  (the list obj))\n\n(return-list 'foo)\n;>>> The value FOO is not of type LIST. (処理系依存)\n\n;;; 処理系拡張でvaluesが使える場合もある\n(defun return-vector (obj)\n  (declare (values vector))\n  obj)\n\n(return-vector 'foo)\n;>>> The value FOO is not of type VECTOR.\n}}}\n*** 多値の場合\n{{{\n(declaim (ftype (function (t) (values list integer)) return-list-and-integer))\n\n(defun return-list-and-integer (obj)\n  (values obj (car obj)))\n\n;; もしくは、theにより直接指定\n(defun return-list-and-integer2 (obj)\n  (the (values list integer)\n    (values obj (car obj))))\n\n(return-list-and-integer (list 1))\n;=>  (1)\n;    1\n\n(return-list-and-integer '(foo))\n;>>> The value FOO is not of type INTEGER. (処理系依存)\n}}}\n** 議論\n")
(" %Tag:xml" . "(1331441911)")
(" %Tag:CL-TEST-MORE2121121121212.1" . "(1582882531)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45) --  /*" . "(1624124296)")
("タスクを並列に実行する" . "(:ctime 1337148724 :cuser #f :mtime 1338672182 :muser #f)下記は、それぞれのタスクに依存性がなく、単に並列に実行する例です。~%\n[[CLiki:bordeaux-threads]] と [[CLiki:Xecto]] を利用しています。~%\n[[CLiki:bordeaux-threads]]は、処理系依存の記述をカバーする互換性向上のためのパッケージです。\n\n** bordeaux-threads\n[[CLiki:bordeaux-threads]] ライブラリの導入方法\n{{{\n(ql:quickload :bordeaux-threads)\n}}}\nスレッドを生成して、ジョインする、というパターンです。~%\nスレッドは、処理系依存ですが、make-threadでスレッドを生成し即実行という実装が多いようです。\n{{{\n(let ((out #.*standard-output*))\n  (let ((task1 (bt:make-thread (lambda ()\n                                 (format out \"~&start1 ...~%\")\n                                 (sleep 8)\n                                 (format out \"~&... end1~%\"))))\n        (task2 (bt:make-thread (lambda ()\n                                 (format out \"~&start2 ...~%\")\n                                 (sleep 5)\n                                 (format out \"~&... end2~%\")))))\n    (bt:join-thread task1)\n    (bt:join-thread task2)))\n;->  start1 ...\n;    start2 ...\n;    ... end2\n;    ... end1\n;\n;=>  NIL\n}}}\n** lparallel\n[[CLiki:lparallel]] ライブラリの導入方法\n{{{\n(ql:quickload :lparallel)\n}}}\n{{{\n(setf lparallel:*kernel* (lparallel:make-kernel 2))  ;; ワーカーの数を設定\n}}}\n{{{\n(let ((out #.*standard-output*))\n  (lparallel:plet ((task1 (progn\n                            (format out \"~&start1 ...~%\")\n                            (sleep 8)\n                            (format out \"~&... end1~%\")))\n                   (task2 (progn\n                            (format out \"~&start2 ...~%\")\n                            (sleep 5)\n                            (format out \"~&... end2~%\"))))\n      task1\n      task2\n      nil))\n;->  start2 ...\n;    start1 ...\n;    ... end2\n;    ... end1\n;\n;=>  NIL\n}}}\n\n** Xecto\n[[CLiki:Xecto]] ライブラリの導入方法(現在のところSBCLのみ対応)\n- https://github.com/pkhuong/Xecto\n\n{{{\n(defconstant max-threads 2)\n\n(let ((out #.*standard-output*))\n  (parallel-future:with-context (max-threads) ;max-threads の値まで並列実行\n    (parallel:let ((task1 (progn\n                            (format out \"~&start1 ...~%\")\n                            (sleep 8)\n                            (format out \"~&... end1~%\")))\n                   (task2 (progn\n                            (format out \"~&start2 ...~%\")\n                            (sleep 5)\n                            (format out \"~&... end2~%\")))\n                   (:parallel t))\n      (declare (ignore task1 task2))\n      ;; ボディは空\n      )))\n;->  start1 ...\n;    start2 ...\n;    ... end2\n;    ... end1\n;\n;=>  NIL\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' and 1=2-- -" . "(1656001225)")
("リストから重複した要素を取り除く" . "(:ctime 1227610615 :cuser #f :mtime 1328667883 :muser #f)[[$$tag リスト]]\n\n[[$$hs remove-duplicates]] や [[$$hs delete-duplicates]] を使います。[[$$hs delete-duplicates]] は引数として与えられたリストの内容を処理系が返り値を効率よく作成するために破壊しても構わないことになっています。\nまた、値をテストするための関数を :test キーワードにて与えることができます。(デフォルトでは [[$$hs eql]])\n返り値のリストは、基本では、前に出現した重複分が消去されますので、前のものを優先したい場合は、:from-end に非nil値を与えます。\n{{{\n(remove-duplicates '(\"abc\" \"cba\" \"abc\") :test #'equal) \n;=> (\"cba\" \"abc\")\n\n(remove-duplicates '(\"abc\" \"cba\" \"abc\") :test #'equal :from-end T) \n;=> (\"abc\" \"cba\")\n\n(let ((list (copy-list '(a b c a a b a c))))\n  (list (delete-duplicates list)\n        list))\n;=> ((B A C) (A B C A A B A C)) \n}}}\n")
("指定パスの複数の要素を取り出したい:cxml-stp" . "(:ctime 1336735954 :cuser #f :mtime 1336735954 :muser #f)このページでは、[[CLiki:plexippus-xpath]]を組み合せる例を紹介しています~%\n** ライブラリの導入方法\n{{{\n(ql:quickload :xpath)\n}}}\n\nXML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"<a><b><c>1</c></b><b><c>2</c></b><b><c>3</c><d>4</d></b></a>\"\n   (stp:make-builder)))\n}}}\nxpathで/a/b/cを探す\n{{{\n(mapcar #'stp:string-value\n        (xpath:all-nodes (xpath:evaluate \"/a/b/c\" *doc*)))\n;=>  (\"1\" \"2\" \"3\")\n}}}\nxpathは使わず、cxml-stpパッケージの関数のみでの実現\n{{{\n(labels ((fc (name parent)\n           (if (listp parent)\n               (mapcan (lambda (x) (fc name x))\n                       parent)\n               (remove-if-not (lambda (x) (string= x name))\n                              (stp:list-children parent)\n                              :key #'stp:local-name))))\n  (mapcar #'stp:string-value\n          (fc \"c\" (fc \"b\" (fc \"a\" *doc*)))))\n;=>  (\"1\" \"2\" \"3\")\n}}}\n")
(" %Tag:local-time'[0]" . "(1665677889)")
("URIエンコード" . "(:ctime 1227424464 :cuser #f :mtime 1228812075 :muser #f)[[$$tag インターネットサービス url-rewrite ライブラリ]]\n* URIエンコード\n[[ライブラリ:url-rewrite]]を利用した例\n{{{\n(url-rewrite:url-encode \"コモン・リスプ\")\n\"コモン・リスプ\" => \"%30B3%30E2%30F3%30FB%30EA%30B9%30D7\"と変換\n}}}\n\n\n")
(" %Tag:FIXME" . "(1667933914 (\"指定id属性の値をもつ要素を探す:klacks\" :ctime 1336648760 :cuser #f :mtime 1336652782 :muser #f) (\"外部からの入力バイト列を文字列にしたい(文字コード変換含む)\" :ctime 1229261302 :cuser #f :mtime 1236779813 :muser #f) (\"一時的にリードテーブルを変更して読み込む\" :ctime 1229846380 :cuser #f :mtime 1229846380 :muser #f))")
("引数リスト情報の表示を変更したい" . "(:ctime 1382897413 :cuser #f :mtime 1382897413 :muser #f)引数リスト情報の取り出し/設定はANSI CLの仕様では規定されていませんが、処理系によってはサポートしている場合があります。~%\n下記は、何らかの理由によって引数情報が貧弱な場合に設定し直す例です。\n\n{{{\n(defun arglist (fctn)\n  #+sbcl\n  (sb-kernel:%simple-fun-arglist (sb-kernel:%fun-fun fctn)))\n\n(defun (setf arglist) (arglist fctn)\n  #+sbcl \n  (setf (sb-kernel:%simple-fun-arglist (sb-kernel:%fun-fun fctn))\n        arglist))\n}}}\n{{{\n(defun foo (x y z)\n  (list (the string x) (the integer y) (the cons z)))\n\n(arglist #'foo)\n;=>  (X Y Z)\n\n(setf (arglist #'foo) '(string integer cons))\n\n(arglist #'foo)\n;=>  (STRING INTEGER CONS)\n\n(foo \"foo\" 8 '(foo))\n;=>  (\"foo\" 8 (FOO))\n}}}\n")
(" %Tag:CLISP'" . "(1570724567)")
("トップレベルのレキシカル変数" . "(:ctime 1394751745 :cuser #f :mtime 1394752049 :muser #f)Common Lispにはトップレベルのレキシカル変数はありませんが、シンボルマクロと格納用変数で動作を模倣することは可能です。\n\n{{{\n(defmacro deflex (var val &optional (doc nil docp))\n  (let* ((backing-var (intern (format nil \"*storage-for-deflex-var-~A*\" var) \n                              (symbol-package var))))\n    `(progn\n      (defparameter ,backing-var ,val ,@(when docp `(,doc)))\n      ,@(when docp\n          `((setf (documentation ',var 'variable) ,doc)))\n      (define-symbol-macro ,var ,backing-var))))\n}}}\n\n** 実行例\n{{{\n(deflex lexical-foo 42)\n\n\n(defun foo ()\n  (lambda () lexical-foo))\n\n\n(let ((lexical-foo 0))\n  (setq lexical-foo 44)\n  (print lexical-foo)\n  (funcall (foo)))\n;->  \n;->  0 \n;=>  42\nlexical-foo\n;=>  42\n\n\n(setq lexical-foo 100)\n;=>  100\n\n\n(let ((lexical-foo 0))\n  (setq lexical-foo -1)\n  (print lexical-foo)\n  (funcall (foo)))\n;->  \n;->  -1 \n;=>  100\n}}}\nこの方法であれば、意図しないスペシャル宣言を防止できることもメリットと考えられます。\n{{{\n(declaim (special lexical-foo))\n;!! Cannot proclaim a MACRO variable SPECIAL: LEXICAL-FOO\n\n(let ((lexical-foo 0))\n  (declare (special lexical-foo))\n  (print lexical-foo)\n  (funcall (foo)))\n;!! Can't declare macro variable locally special: LEXICAL-FOO\n}}}\n\n** 参考\n- http://rpw3.org/hacks/lisp/deflex.lisp\n\n\n")
(" %Tag:?????999999.1 union select unhex(hex(version())) -- and 1=1" . "(1584214742)")
("配列から指定条件を満たす要素を取り除く" . "(:ctime 1228980663 :cuser #f :mtime 1228980664 :muser #f)[[$$tag 配列]]\n\n* 配列から指定条件を満たす要素を取り除く\n\n[[$$hs remove-if]] [[$$hs delete-if]] は第1引数に与えられた関数が真(非nil)値を返した要素を除外したベクタを返します。\n{{{\n(let ((a (vector 30 100 50 80 79 40 95)))\n  (list (remove-if (lambda (x) (< x 80)) a)\n        a))\n;=> (#(100 80 95) #(30 100 50 80 79 40 95))\n}}}\n{{{\n(let ((a (vector 30 100 50 80 79 40 95)))\n  (list (delete-if (lambda (x) (< x 80)) a)\n        a))\n;=> (#(100 80 95) \n     #(100 80 95)) ;処理系依存\n}}}\n[[$$hs delete-if]] は破壊的に与えられたベクタを変更し結果を生成しますが、変更された元のベクタが結果と一致するとは限りません(処理系依存)ので処理系に依らず確実にしたい場合は、再度代入する必要があります。\n{{{\n(let ((a (vector 30 100 50 80 79 40 95)))\n  (setq a (delete-if (lambda (x) (< x 80)) a)))\n#(100 80 95)\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae) or(1=2)-- -" . "(1656001233)")
("ソースファイルの拡張子" . "(:ctime 1232299882 :cuser #f :mtime 1232306612 :muser #f)ここでは、慣習として使われている拡張子を挙げます\n\n* プログラムの拡張子\n:.lisp:\nもっともオーソドックスなものです。\nLispマシンの時代(80年代初頭)から使われていますので、拡張子だけではCommon Lispのプログラムがどうかは分かりませんが、現状ほぼCommon Lispのプログラムだと思って良いでしょう。\n\n:.cl:\nCommon Lispの頭文字から由来していると思われますが、.lispほどは一般的でありません。Franz社のCommon Lispのプログラム等では良くみかけるようです。\n\n:.lsp:\nMS-DOSや、古くは、MS-DOSが影響を受けたTOPS-20の命名規則により拡張子が3文字の環境で使われていました。\n\n:.l:\n80年代のUNIX環境で使われることが多かったようですが、Common LispというよりFranz Lispの場合が多いようです。\nEmacs系のエディタであるxyzzyでもプログラムの拡張子は、.lが用いられるようです。\n\n* コンパイル済みのファイル\nコンパイル済みのファイルの拡張子は、処理系が自動で付けますので手動で付けることはありませんが、代表的なものを挙げます。\n\n:.fasl:\nfast loadの略で、様々なバリエーションがあります。.fas、.ufasl等\n\n:.bin:\nあまり見掛けませんが、Symbolics等で用いられました。\n\n* ASDF定義ファイル\n\n:.asd:\n最近だと.asdというファイルを目にすることが多いかと思いますが、ASDFで利用する定義ファイルです。\n")
(" %Tag:CL-TEST-MORE and 1>1" . "(1582882534)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae) and 1=1 and (2=2" . "(1656001238)")
(" %Tag:portable-threads'nvOpzp" . "(1667416035)")
("Tutorial on Good Lisp Programming Style" . "(:ctime 1227969021 :cuser #f :mtime 1431247962 :muser #f)[[$$tag コーディングスタイル 参考文献]]\n\n* Tutorial on Good Programming Style\nPeter Norvig氏とKent Pitman氏がまとめたCLプログラミング指南書\n-- [http://norvig.com/luv-slides.ps PostScript版]\n-- [http://www.cs.umd.edu/~nau/cmsc421/norvig-lisp-style.pdf PDF版]\n-- [https://sites.google.com/site/okshirai/home/tutorial-on-good-lisp-programming-style-ja.txt 日本語訳]\n")
("asdf-installでインストールできるもの" . "(:ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f)* asdf-installでインストールできるもの\n[[$$tag asdf-install asdf ANSI規定外]]\n\nasdf-install:installで引数として処理できるものには、\n# パッケージの名前(キーワードで渡す)\n# URLの文字列\n# ファイルのパス名があります。\n\nパッケージの名前を指定した場合は、[[cliki]]に登録された内容を元にURLが割出されダウンロードされてきます。\nURLや、パス名で指定する場合は、tar.gzファイルを指定します。(インストール対象のファイルは、ASDFに対応している必要あり)\nそれぞれの例を挙げます。\n{{{\n;; パッケージの名前\n(asdf-install:install :foo)\n\n;; URL\n(asdf-install:install \"http://example.com/foo.tar.gz\")\n\n;; パス名\n(asdf-install:install \"/tmp/foo.tar.gz\")\n}}}\n\n\n\n\n\n\n\n\n\n")
("構造体を任意の初期値で埋める" . "(:ctime 1329735812 :cuser #f :mtime 1329735812 :muser #f)[[$$tag 【募集中】]]\n")
("大文字と小文字の使い分け" . "(:ctime 1232667473 :cuser #f :mtime 1529823156 :muser #f)[[$$tag コーディングスタイル]]\n\nCommon Lispでは伝統的なLISPと同様シンボルは読取時に大文字に畳み込まれます(case folding)。~%\n(※畳み込みをエスケープすすることも可能です||で囲んだり文字に\\を前置します。)\n\n伝統的なLISPでは、この性質を利用してソースコード上で見やすさへの配慮や、単に個人的な趣味で大文字小文字を使い分けることが行なわれています。\n下記に代表的な例を挙げます。\n\n*** [[$$hs format]]のフォーマット指示記号だけ大文字にする\n大文字と小文字の使い分けの最も一般的なものですが、主に見やすさと伝統に由来するものと思われます\n{{{\n(format nil \"~A: ~D => ~A~%\" foo bar baz)\n}}}\n\n*** 返り値を強調するために大文字にする\n{{{\n(defun foo (x)\n  ...\n  ....\n  (return-from foo NIL)\n  ...)\n}}}\n\n*** 関数名だけ大文字にする\n{{{\n(defun FOO-to-BAR (..)\n  ...)\n}}}\n\n*** 間に挟まるものが長くなる場合、対になるものを大文字にする\n{{{\n;; mapcar\n(MAPCAR (lambda (x y z)\n          .....\n          (let ((...))\n            .....\n            .....\n            (cond ((...))\n                  ....)\n            (let ((....))\n              ....\n              ....\n              ....)))\n        (LIST X Y Z))\n\n;; coerce\n(COERCE (list ....\n          .....\n          (let ((...))\n            .....\n            .....\n            (cond ((...))\n                  ....)\n            (let ((....))\n              ....\n              ....\n              ....)))\n        'VECTOR)\n}}}\n\n*** [[$$hs if]]で述語/then部が長い場合、各部分の開始行を大文字にする\n{{{\n(IF (AND FOO BAR BAZ\n         ...\n         ...)\n    (COND ((...)\n           (let ((...))\n             .....\n             .....\n             (cond ((...))\n                   ....)\n             (let ((....))\n               ....\n               ....\n               ....)))\n          (...)\n          (t ...))\n    (LET ((X Y Z))\n      .....\n      .....\n      (cond ((...))\n            ....)\n      (let ((....))\n        ....\n        ....\n        ....)))\n}}}\n\n*** [[$$hs cond]]のデフォルト節のTを区別しやすいように大文字にする\n{{{\n(cond ((...)\n       (..)\n      ((...))\n      ((......))\n      (T ...)))\n}}}\n\n** その他\n\n*** マクロの定義で展開結果となる部分(可変ではない部分)を大文字にする\n{{{\n(defmacro ONCE-ONLY (variable-list &body body)\n  (dolist (variable variable-list)\n    (if (not (symbolp variable))\n        (error \"~S is not a variable\" variable)))\n  (let ((bind-vars (gensym))\n        (bind-vals (gensym))\n        (tem (gensym)))\n    `(LET ((,bind-vars NIL)\n           (,bind-vals NIL))\n       (LET ((RESULT ((LAMBDA ,variable-list ,@body)\n                       ,@(loop for variable in variable-list\n                               collect `(IF (OR (ATOM ,variable)\n                                                (EQ (CAR ,variable) 'QUOTE)\n                                                (EQ (CAR ,variable) 'FUNCTION))\n                                            ,variable\n                                          (LET ((,tem (GENSYM)))\n                                            (PUSH ,tem ,bind-vars)\n                                            (PUSH ,variable ,bind-vals)\n                                            ,tem))))))\n         (IF (NULL ,bind-vars)\n             RESULT\n           `((LAMBDA ,(nreverse ,bind-vars) ,result) ,@(nreverse ,bind-vals)))))))\n}}}\n\n*** パッケージ名付きの場合、シンボル名だけを大文字にする\n{{{\n(drakma:HTTP-REQUEST ...)\n}}}\n\n*** 恐らく個人的なこだわり\n{{{\n(DefMacro MY-MACRO (... ) )\n\n(DefClass FOO ()\n  ...)\n\n(DefMethod MY-METHOD (...) \n  ...)\n}}}\n\n** 議論\n- clispの「-modern」オプションのように大文字と小文字を区別する(read時に大文字にしない)環境も存在するので、大文字と小文字を区別しないことに過度に依存するのはよくないかもしれません。\n- Allegro CLのmlisp等CLISP以外にもあるかと思いますが、処理系のオプションで大文字小文字を有効にすることの是非についてはc.l.lでも激しい議論になりがちですね。\n今のところ大文字と小文字を区別した環境で動くこと考慮するということは仕様外の可搬性を求めることになるかと思いますし、どちらかといえば過度に依存して良くないのは「大文字と小文字を区別することを前提としたコード」ではないでしょうか。詳しい議論はc.l.l等で度々されているようですね。 --g000001\n- 上の発言は大文字小文字を区別しない環境で動作することを前提に、大文字小文字を区別する環境でも動くことを意識した方がいいんじゃないかなぁという意図でした。「大文字と小文字を区別することを前提としたコード」はCLとしては間違っているので全く意識していませんでした。 -- NANRI\n")
("入出力" . "(:ctime 1227443658 :cuser #f :mtime 1631078775 :muser #f)[[$$tag 入出力]]\n\n** ファイルシステム\n- [[処理系を起動したディレクトリのパスネームを返す]]\n- [[ディレクトリ内のすべてのファイルを再帰的に処理する]]\n- [[ホームディレクトリを取得する]]\n- [[ディレクトリが存在するかどうかを判定する]]\n- [[一万のファイルがあるディレクトリから条件に合うファイルを一つ取り出す]]\n- [[ディレクトリのリスト表現からパスを生成する]]\n- [[ワイルドカードを展開したパスにする]]\n\n** ファイル操作\n- [[ファイルが存在するかどうかを判定する]]\n- [[ファイルをリネームする]]\n- [[テキストファイルをオープンして内容を出力する]]\n- [[ファイルに書き込む]]\n- [[ファイルサイズを知る]]\n- [[ファイルから行をランダムに取り出す]]\n- [[ファイル内の特定の行を読み込む]]\n- [[Lispオブジェクトをシリアライズ・デシリアライズする]]\n- [[ファイルの最終更新時刻を取得する]]\n\n** ストリーム\n- [[NULLストリームを使う]]\n- [[ベクタをバイナリのストリームとして扱いたい]]\n- [[ストリームを扱うように出力先としてシーケンスを指定したい]]\n- [[外部からの入力バイト列を文字列にしたい(文字コード変換含む)]]\n- [[プログラムの出力を収集する]]\n- [[リストの点対表記を生成したい]]\n- [[EOFを取得したい]]\n- [[同じストリームをバイトストリームやキャラクタストリームとして扱いたい]]\n\n** 外部プログラムとの連携\n- [[別のプログラムを起動する]]\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') and 1=2 and ('1'='1" . "(1656001231)")
("マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい" . "(:ctime 1228627796 :cuser #f :mtime 1228627796 :muser #f)[[$$tag SLIME 開発環境]]\n\n* マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい\n\nslime-who-macroexpands(C-c C-w C-m)を使用します。\n\n下記のようにmy-incというマクロがあり、fooとbarがmy-incを利用していて両者ともコンパイルされているとします。\n{{{\n(defmacro my-inc (var)\n  `(incf ,var))\n\n(defun foo (n)\n  (my-inc n))\n\n(defun bar (n)\n  (my-inc n))\n}}}\nここでマクロ定義を変更したとすると、fooとbarもコンパイルしなおす必要がありますが、探し出すのが面倒です。\n\nマクロ名のシンボルの上でC-c C-w C-m(slime-who-macroexpands)すると、そのマクロを利用している関数/マクロ一覧が*XREF[:macroexpands: 〜]*に表示されますので、\n{{{\n*XREF[:macroexpands: my-inc]*\n#<buffer cl-2008-12-07.lisp>\n  (DEFUN BAR)\n  (DEFUN FOO)\n〜\n}}}\n関数名のところでC-c C-cするか、C-c C-kで*XREFバッファ全体を指定してコンパイルすることが可能です。\n")
(" %Tag:ハッシュ" . "(1668191312 (\"最もよく現れるデータを見つけたい\" :ctime 1231407996 :cuser #f :mtime 1630548155 :muser #f) (\"ハッシュの要素をランダムに抽出する\" :ctime 1227413899 :cuser #f :mtime 1630548071 :muser #f) (\"ハッシュを値で降順、値が等しい場合キーで昇順にソートする\" :ctime 1227413847 :cuser #f :mtime 1380443347 :muser #f) (\"キーが存在しない場合のデフォルト値を設定する\" :ctime 1227413661 :cuser #f :mtime 1370593420 :muser #f) (\"ハッシュの全エントリに対して処理を実行する\" :ctime 1227413710 :cuser #f :mtime 1229517972 :muser #f) (\"ハッシュのキーに任意のオブジェクトを使用する\" :ctime 1229510098 :cuser #f :mtime 1229510099 :muser #f) (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f) (\"ハッシュをシーケンス(alist、plist、その他)に変換する\" :ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f) (\"ハッシュを空にする\" :ctime 1227413762 :cuser #f :mtime 1227413763 :muser #f) (\"ハッシュからエントリを削除する\" :ctime 1227413680 :cuser #f :mtime 1227413680 :muser #f) (\"ハッシュの要素数を取得する\" :ctime 1227413641 :cuser #f :mtime 1227413641 :muser #f) (\"ハッシュ内にキーが存在するかどうか調べる\" :ctime 1227413596 :cuser #f :mtime 1227413596 :muser #f) (\"ハッシュに要素を追加する\" :ctime 1227413572 :cuser #f :mtime 1227413572 :muser #f) (\"キーに関連付けられた値を取得する\" :ctime 1227413525 :cuser #f :mtime 1227413525 :muser #f))")
("CPUのワードサイズを調べる" . "(:ctime 1230404121 :cuser #f :mtime 1230404181 :muser #f)[[$$tag プラットフォーム固有の情報]]\n\n* CPUのワードサイズを調べる\n\nCPUのワードサイズを調べる確実な方法はありませんが、 [[$$hs machine-type]] にて主にアーキテクチャの情報、 [[$$hs machine-version]] でプロセッサ等のバージョンの情報を得られますので、これからマシンのアーキテクチャを割り出し判断することも可能でしょう。\nまた、多くの処理系では、アーキテクチャを*features*に格納していますので、これから判断する材料を得ることも可能でしょう。\n\n[[$$hs machine-version]]で確認\n{{{\n(machine-version)\n;=> \"AMD64\"                                           ;Scineer CL\n;=> \"Intel(R) Core(TM)2 CPU          6600  @ 2.40GHz\" ;SBCL\n;=> \"X86_64\"                                          ;CLISP\n\n;; AMD64アーキテクチャなので64bit\n}}}\n[[$$hs machine-type]]で確認\n{{{\n(machine-type)\n;=> \"X86_64\" ;clisp\n;=> \"X86-64\" ;sbcl\n;=> \"AMD64\"  ;scl\n\n;; AMD64アーキテクチャなので64bit\n}}}\n*features*で確認\n{{{\n;; SBCL\n(find :x86-64 *features*)\n;=> :X86-64\n}}}\nまた、確実ではありませんが、fixnumのサイズから推し量る方法も考えられるでしょう\n{{{\n(integer-length most-positive-fixnum)\n;=> 60 ;60bit以上の可能性が高い\n}}}\n")
(" %Tag:cl-irregsexp" . "(1668277486 (\"cl-irregsexp\" :ctime 1306254477 :cuser #f :mtime 1306347472 :muser #f))")
("McCLIM" . "(:ctime 1329736438 :cuser #f :mtime 1329736438 :muser #f)[[$$tag 【募集中】]]\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 561 #" . "(1624125206)")
(" %Tag:闂併垺鏆'[0]" . "(1631011587)")
(" %Tag:プラットフォーム固有の情報" . "(1668293939 (\"CPUのワードサイズを調べる\" :ctime 1230404121 :cuser #f :mtime 1230404181 :muser #f))")
(" %Tag:????99999\" union select unhex(hex(version())) -- \"x\"=\"x" . "(1587484326)")
(" %Tag:prove?p=Tag?Tag:prove?p=Tag" . "(1476570380)")
("インスタンス生成を記録しておき後で条件を満すものを抽出したい" . "(:ctime 1227530644 :cuser #f :mtime 1551866854 :muser #f)[[$$tag MOP c2mop ライブラリ]]\n* インスタンス生成を記録しておき後で条件を満すものを抽出したい\n\n記録するためのメタクラスを定義し、そのスロットに記録します。\n\n下記の例では、list-metaclassを定義し、list-metaclassをメタクラスとしたboxクラスのインスタンスが生成される度にメタクラスのスロット(all-instances)に生成されたインスタンスがpushされるようにします。\n\nMOPの互換性のため[[Closer to MOP]]を利用しています。\n{{{\n;; メタクラス\n(defclass list-metaclass (standard-class)\n  ((all-instances :initform () :accessor class-all-instances)))\n\n#-(or clisp allegro)\n(defmethod c2mop:validate-superclass ((class list-metaclass) \n                                      (super standard-class))\n  T)\n\n(defmethod make-instance ((class list-metaclass) &rest initargs)\n  (declare (ignore initargs))\n  (let ((new-instance (call-next-method)))\n    (push new-instance (class-all-instances class))\n    new-instance))\n\n;; list-metaclassをメタクラスとしたboxクラス\n(defclass box () \n  ((color :initform 'white :initarg :color :accessor box-color)\n   size)\n  (:metaclass list-metaclass))\n}}}\n{{{\n;; 動作\n(make-instance 'box :color 'green)\n(make-instance 'box :color 'black)\n...\n\n(mapc #'describe \n      (remove-if-not (lambda (box) (eq (box-color box) 'black))\n\t\t     (class-all-instances (find-class 'box))))\n\n;-> #<BOX {100A12CB51}> is an instance of class #<LIST-METACLASS BOX>.\n;   The following slots have :INSTANCE allocation:\n;    COLOR    BLACK\n;    SIZE     #<unbound slot>\n;...\n;=> (#<BOX {100A12CB51}> ...)\n}}}\n\n")
("ハッシュからエントリを削除する" . "(:ctime 1227413680 :cuser #f :mtime 1227413680 :muser #f)[[$$tag ハッシュ]]\n* ハッシュからエントリを削除する\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  ;; 削除\n  (remhash \"apple\" ht)\n\n  (gethash \"apple\" ht))\n;=> nil\n    nil(存在しない)\n}}}\n")
("文字列を Base64 エンコードする" . "(:ctime 1229665104 :cuser #f :mtime 1229665104 :muser #f)[[$$tag インターネットサービス]]\n\n* 文字列を Base64 エンコードする\n\nライブラリを利用するか自作します。\n下記の例では、[[CLiki:cl-base64]] と JPパッケージを利用しています。\n{{{\n(cl-base64:usb8-array-to-base64-string\n (jp:encode \"逆引き Common Lisp\" :utf-8))\n;=> \"6YCG5byV44GNIENvbW1vbiBMaXNw\"\n\n(jp:decode\n (cl-base64:base64-string-to-usb8-array \n  (cl-base64:usb8-array-to-base64-string (jp:encode \"逆引き Common Lisp\" :utf-8)))\n :utf-8)\n;=> \"逆引き Common Lisp\"\n}}}\njpパッケージの詳細については[http://lispuser.net/commonlisp/japanese.html Common Lisp と 日本語 と 文字コード]を参照して下さい\n")
(" %Tag:R6RS" . "(1270369523)")
(" %Tag:正規表現" . "(1668191471 (\"CL-PPCRE\" :ctime 1306251958 :cuser #f :mtime 1607226708 :muser #f) (\"正規表現\" :ctime 1236781854 :cuser #f :mtime 1430357064 :muser #f) (\"正規表現機能別一覧\" :ctime 1382545936 :cuser #f :mtime 1382729547 :muser #f) (\"文字列を検索する\" :ctime 1313411955 :cuser #f :mtime 1313434559 :muser #f) (\"cl-irregsexp\" :ctime 1306254477 :cuser #f :mtime 1306347472 :muser #f))")
("リストからNILを取り除く" . "(:ctime 1337645974 :cuser #f :mtime 1337646000 :muser #f)[[$$hs remove]]を使うのが直感的かと思いますが、[[$$hs mapcan]] を使うという方法もあります。\n\n{{{\n(remove nil (list 1 2 3 nil 4 5 6 nil 7 8 9 nil))\n;=>  (1 2 3 4 5 6 7 8 9)\n}}}\n\n{{{\n(mapcan (lambda (e)\n          (and e (list e)))\n        (list 1 2 3 nil 4 5 6 nil 7 8 9 nil))\n;=>  (1 2 3 4 5 6 7 8 9)\n}}}\n\n** 関連\n[[一致する要素を全て取り除く]]\n")
("処理系:選び方の目安" . "(:ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f)[[$$tag 処理系 ABCL CCL CLISP CMUCL ECL SBCL Lispbox \"Lisp Cabinet\"]]\n\n処理系の選び方の目安です。これが全面的に正しいとは思わないで、ひとつの意見として読んでください。\n\n----\n\n[[$$toc]]\n\n----\n\n* 初心者の方へ\n\n最初に使う処理系に悩んだら、ユーザーが多くて情報を集めやすい[[Steel Bank Common Lisp]]や[[CLISP]]をお薦めします。開発に必要なソフトウェア一式を揃えた、[[Lispbox]]や[http://lispcabinet.sourceforge.net/ Lisp Cabinet]などのお手軽セットや、[[roswell]]などを使うのも良いでしょう。そのうち、用途によって不都合が出て来たり、他の処理系に興味が湧いてくるかもしれませんので、そうしたら他の処理系も試してみるといいでしょう。\n\n規格に沿ったコードを書いている限り、Common Lispは処理系を移行しやすい言語です。気楽に選んで気軽に移行しましょう。\n\n* 速度が重要な場合\n\nまず、[http://ja.wikipedia.org/wiki/%E6%80%A7%E8%83%BD%E8%A7%A3%E6%9E%90#.E3.83.97.E3.83.AD.E3.83.95.E3.82.A1.E3.82.A4.E3.83.A9.E3.81.AE.E5.88.A9.E7.94.A8 プロファイラ]を備えているかどうかが重要です。これがないと、手探りで性能上の弱点を見つけなければいけなくなり、格段に高速化が難しくなります。判断材料としては欠かせません。\n\n原理上ではネイティブコードコンパイラが有利です。そのまま計算機が実行できる機械語を[http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB オブジェクトコード]として生成するためです。商用処理系の[[Allegro Common Lisp]]や[[LispWorks]]、[[CMU Common Lisp]]やCMU Common Lispから派生した[[Steel Bank Common Lisp]]が生成するオブジェクトコードの速さには定評があります。また、[[Clozure CL]]も一定の品質のコードを生成するようです。\n\n[http://ja.wikipedia.org/wiki/%E3%83%90%E3%82%A4%E3%83%88%E3%82%B3%E3%83%BC%E3%83%89 バイトコード]コンパイラはネイティブコードコンパイラに比べると速度面では不利です。生成されたバイトコードは[http://ja.wikipedia.org/wiki/%E4%BB%AE%E6%83%B3%E6%A9%9F%E6%A2%B0#.E3.83.97.E3.83.AD.E3.82.BB.E3.82.B9.E4.BB.AE.E6.83.B3.E6.A9.9F.E6.A2.B0 仮想マシン]で解釈することになりますが、そのまま実行できる機械語に比べてどうしても遅くなります。これは移植性などと性能を天秤にかけて選んだ結果のことなので、仕方がありません。\n\nCへのトランスレータは、最終的にCコンパイラでネイティブコードを生成するため、原理的にはバイトコードコンパイラよりも速くなりますが、Cへの変換を経由することで、生成されるオブジェクトコードにもCの仕様の影響が出ます。これが性能面で足を引っ張る可能性はあります。ただし、大抵、Common LispよりCのコンパイラのほうが高度な最適化をするので、それがプラスに働く場合もあるでしょう。\n\nJavaバイトコードコンパイラは[http://ja.wikipedia.org/wiki/Java%E4%BB%AE%E6%83%B3%E3%83%9E%E3%82%B7%E3%83%B3 Java仮想マシン]の速度次第です。Java仮想マシンが高速化されると、バイトコードの処理も自動的に高速化されますが、逆に言えば、Java仮想マシンの性能の上限が処理速度の上限になります。外部のソフトウェアに性能を依存するのはCへのトランスレータと似ています。\n\n一番大事なのは、自分の環境で実際に処理系を試してみることです。[[ベンチマーク]]を参考にしても良いでしょう。32ビットの環境では速く計算できても64ビットの環境では遅かったり、IA-32アーキテクチャでは速くてもARMアーキテクチャでは遅かったりするかもしれません。計測することは重要です。\n\n* 少ないメモリで動かしたい場合\n\n[[Embeddable Common Lisp]]や[[CLISP]]のように、カーネルと同じ言語でランタイムライブラリを書いている処理系が有利です。\n\n逆に、[[Steel Bank Common Lisp]]や[[Clozure CL]]のように、カーネルだけCで書き、ランタイムライブラリはCommon Lispで書いているような処理系はメモリ使用量が多くなりがちです。この場合、異なる言語で書いた似たような処理をいくつもメモリ上に置いておかなければならないためです。\n\n* 色々な環境で使いたい場合\n\n自分で処理系を移植するのでなければ、どの環境で動作するか処理系のサイトに必ず書いてありますので、まずそれを見てください。\n\n移植性の面からコンパイラについて考えたとき、大変なのはアーキテクチャごとに異なる機械語を扱わないといけないことです。[[CLISP]]などの[http://ja.wikipedia.org/wiki/%E3%83%90%E3%82%A4%E3%83%88%E3%82%B3%E3%83%BC%E3%83%89 バイトコード]コンパイラは直接機械語を扱う必要がないため、移植性に優れています。また、[[Embeddable Common Lisp]]のようなCへのトランスレータも、Cのコンパイラに機械語の扱いを任せてしまえるので有利です。\n\nネイティブコードコンパイラは、その仕組み上、色々なアーキテクチャの[http://ja.wikipedia.org/wiki/%E6%A9%9F%E6%A2%B0%E8%AA%9E 機械語]の生成に真っ向から取り組まないといけないので、移植性は低いです。\n\nJavaバイトコードコンパイラについては、性能と一緒で[http://ja.wikipedia.org/wiki/Java%E4%BB%AE%E6%83%B3%E3%83%9E%E3%82%B7%E3%83%B3 Java仮想マシン]の動作環境に依存します。Javaにとっての主要な環境では手厚いサポートがありますが、それ以外の環境では不利でしょう。\n\n** Windowsで使う場合\n\nWindowsはAPIがUnixとは大幅に異なるので、スレッドやプロセス間通信、ネットワークなどの、OSによって違いが大きい機能については、最初からWindowsをターゲットにしている処理系以外では、サポートしていないことも多いです。[http://www.cygwin.com/ Cygwin]を利用することで、上手く使うことができる場合もありますが、性能が落ちたり、Cygwin特有の問題に悩まされる場合もあります。\n\nWindowsを動かしているマシンの性能に余裕があれば、Linuxなど別のOSをインストールした仮想マシンを利用してもいいでしょう。多少設定に手間がかかるかもしれませんが、環境の差によるトラブルは確実に減らすことができます。\n\n* 他の言語と連携させたい場合\n\n** Cと連携させたい場合\n\nほとんどの処理系がFFI（Foreign Function Interface）を備えているので、共有ライブラリに含まれる関数を呼ぶことはできます。しかし、多くの処理系では、Cコンパイラなどが作った[http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB オブジェクトファイル]と直接リンクしたりすることはできません。また、共有ライブラリを直接作ることができる処理系もあまりありません。そういう用途では、Cへのトランスレータの[[Embeddable Common Lisp]]を使うと良いでしょう。\n\n*** Cのプログラムに組み込みたい場合\n\n[[Embeddable Common Lisp]]の本領発揮です。\n\n** Javaと連携させたい場合\n\n[[Armed Bear Common Lisp]]などの、Javaバイトコードコンパイラが有利です。Javaの機能をそのまま流用できます。\n")
(" %Tag:入出力'A=0" . "(1551294789)")
(" %Tag:CL-TEST-MORE\" and \"x\"=\"y" . "(1582882539)")
("インスタンス変数へアクセスするメソッドを簡単に定義する" . "(:ctime 1230699674 :cuser #f :mtime 1230699675 :muser #f)[[$$hs オブジェクトシステム(CLOS)]]\n\n* インスタンス変数へアクセスするメソッドを簡単に定義する\n\n[[$$hs defclass]] でのクラスの定義では :reader(読み出し専用)、 :writer(書き込み専用)、 accessor(読み書き)を指定することにより総称関数(メソッド)も一緒に定義できます。\n{{{\n(defclass sample-class ()\n  ((a :initform 0 :reader a)     ;aというリーダを設定\n   (b :initform 0 :writer b)     ;bというライタを設定\n   (c :initform 0 :accessor c))) ;cというアクセサを設定\n\n(let ((inst (make-instance 'sample-class)))\n  (b 10 inst)                    ;bメソッドでbスロットに10を設定\n  (setf (c inst) 100)            ;cメソッドでcスロットに100を設定\n  \n  (describe inst))\n;-> Instance: #<SAMPLE-CLASS {4002406CD2}>\n;   Class: #<STANDARD-CLASS SAMPLE-CLASS {40036857E2}>\n;    The following slots have :instance allocation:\n;     A   0\n;     B   10\n;     C   100\n}}}\n")
(" %Tag:url-encode" . "(1227425286)")
(" %Tag:alexandria?Tag?Tag?Tag:alexandria?Tag?Tag" . "(1467047273)")
(" %Tag:【募集中】/.env" . "(1585999614)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' or(1=1)#" . "(1656001228)")
(" %Tag:V[PX" . "(1508574772)")
("ディレクトリ内のすべてのファイルを再帰的に処理する" . "(:ctime 1232597586 :cuser #f :mtime 1232608615 :muser #f)[[$$tag 入出力]]\n\n# 処理系がワイルドカード文字をどう扱うか\n# OSの種類\n# OSがワイルドカード文字をどう扱うか\n\n等々の組み合わせ状況により結果が変わってくる可能性がありますが、CLのパス名には、任意の数のディレクトリにマッチさせる\"**\"という表現がありますので、[[$$hs directory]]でディレクトリ内のファイルにマッチさせ、それをマップ関数等で処理することができます。\n{{{\n;; /home/CLer/lisp/以下の *.*~にマッチするすべてのファイル\n(length\n (directory \"/home/CLer/lisp/**/*.*~\"))\n;=> 1234(サンプル結果)\n}}}\n{{{\n;; パス名を印字\n(map nil \n     #'print\n     (directory \"/home/CLer/lisp/**/*.*\"))\n;-> #P\"/home/CLer/lisp/Scratch/scm-2007-01-21.scm.~1~\"\n;   #P\"/home/CLer/lisp/bolio/bolio.lisp\n;   #P\"/home/CLer/lisp/bolio/bolio.lisp.~2~\"\n;   #P\"/home/CLer/lisp/bolio/cadr.lisp\n;   #P\"/home/CLer/lisp/bolio/common.lisp.~1~\"\n;   #P\"/home/CLer/lisp/bolio/common.lisp.~2~\"\n;   #P\"/home/CLer/lisp/bolio/common.lisp.~3~\"\n;   #P\"/home/CLer/lisp/bolio/lmm-settings.lisp.~1~\"\n;   #P\"/home/CLer/lisp/cl-2007-01-19.lisp\n;   #P\"/home/CLer/lisp/cl-2007-01-20.lisp.~1~\"\n;....\n;=> NIL\n}}}\nまた、処理系/OSの差を吸収することを目的としたコンパチブルレイヤのパッケージとしては、[[CLiki:CL-FAD]]がありますので、このようなものを利用することで可搬性が高められるかもしれません。\n{{{\n(cl-fad:walk-directory \"/home/CLer/lisp/\" #'print)\n;-> #P\"/home/CLer/lisp/Scratch/scm-2007-01-21.scm.~1~\"\n;   #P\"/home/CLer/lisp/bolio/bolio.lisp\n;   #P\"/home/CLer/lisp/bolio/bolio.lisp.~2~\"\n;   #P\"/home/CLer/lisp/bolio/cadr.lisp\n;   #P\"/home/CLer/lisp/bolio/common.lisp.~1~\"\n;   #P\"/home/CLer/lisp/bolio/common.lisp.~2~\"\n;   #P\"/home/CLer/lisp/bolio/common.lisp.~3~\"\n;   #P\"/home/CLer/lisp/bolio/lmm-settings.lisp.~1~\"\n;   #P\"/home/CLer/lisp/cl-2007-01-19.lisp\n;   #P\"/home/CLer/lisp/cl-2007-01-20.lisp.~1~\"\n;....\n;=> NIL\n}}}\n** 参考\n- [http://gigamonkeys.com/book/practical-a-portable-pathname-library.html PCL/Practical: A Portable Pathname Library]\n\n** 議論\n")
("SETF関数を取り出す" . "(:ctime 1233974927 :cuser #f :mtime 1233975138 :muser #f)[[$$tag 関数]]\n\n[[$$hs setf]]は汎変数を扱い、読み出されてくる場所(読み出す関数)に応じて関数を設定することが可能です。\n\n通常関数は、関数名のシンボルに束縛されていますので、[[$$hs symbol-function]]にて関数オブジェクトを取り出すことが可能ですが、対象は名前の通りシンボルのみですので、[[$$hs setf]]の場合は、[[$$hs fdefinition]]を利用します。\n\n[[$$hs fdefinition]]は、シンボルも取り扱うことが可能です。\n{{{\n(setf (fdefinition 'set-car)\n      (fdefinition '(setf car)))\n\n(let ((list (list 1 2 3 4)))\n  (set-car 'foo list)\n  list)\n\n;=> (FOO 2 3 4)\n}}}\n\nまた、(function (setf 名前))もしくは#'(setf 名前)という形で直接利用することも可能です。\n{{{\n(let ((list (list 1 2 3 4)))\n  (funcall #'(setf car) 'foo list)\n  list)\n\n;=> (FOO 2 3 4)\n}}}\n\n** 議論\n")
("リンク集" . "(:ctime 1447089681 :cuser #f :mtime 1606361804 :muser #f)* 言語リファレンス\n- [http://www.lispworks.com/documentation/HyperSpec/Front/ Common Lisp Hyperspec] : ANSI Common Lisp リファレンス\n- [http://clqr.boundp.org/ Common Lisp Quick Reference] : ANSI Common Lisp 標準機能の要約済みリファレンス(PDF)\n\n* 情報サイト\n- [http://qiita.com/tags/common-lisp Qiita.com タグ：Common Lisp]\n- [https://www.reddit.com/r/lisp_ja/ reddit/lisp_ja]\n\n* 未分類\n- [http://quickdocs.org/ Quickdocs] : ライブラリ検索 (既に閉鎖)\n- [https://lisphub.jp/common-lisp/users/ Common LISP users jp]\n- [https://lisphub.jp/common-lisp/cookbook/ 逆引き Common Lisp] : このページ\n- [http://cl-cookbook.sourceforge.net/ The Common Lisp Cookbook]\n\n- [https://mevius.5ch.net/test/read.cgi/tech/1411307361/【入門】Common Lisp その11【質問よろず】] : 2015年11月現在最新 2chスレ\n-- [http://wiki.fdiary.net/lisp/ 2chテンプレまとめwiki] (更新ほぼ停止)\n\n;; 個人サイトは載せてもよいのだろうか？\n;; [http://www.geocities.jp/m_hiroi/xyzzy_lisp.html xyzzy Lisp Programming]\n\n* Common Lispの兄弟たち(のまとめページ)\n- [http://tips.cddddr.org/scheme/ 逆引き Scheme]\n- [http://www42.atwiki.jp/elisp/pages/1.html 逆引き Emacs Lisp]\n;; 逆引き clojure 復活はよ\n\n- [https://github.com/clojure-cookbook/clojure-cookbook Clojure Cookbook] (Github ソースファイル)\n")
(" %Tag:Webサーバ'A=0" . "(1588785132)")
(" %Tag:【募集中】/misc/ajax.js" . "(1585999580)")
("Common Lisp基礎文法最速マスター" . "(:ctime 1529823923 :cuser #f :mtime 1529823923 :muser #f)かきかけ\n\n- [http://d.hatena.ne.jp/perlcodesample/20091226/1264257759 Perl基礎文法最速マスター]\n\n*  基礎\n** 文法チェック\n\nなし~%\n\n一応コンパイル時に文法のチェックがあり、使用の変数なども発見できる\n\n** print式\nprint式です。\n{{{\n(print \"Hello world\")\n;->\n;   \"Hello world\"\n;=> \"Hello world\"\n}}}\n{{{\n(format t \"Hello world~%\")\n;-> Hello world\n;\n;=> NIL\n}}}\n** コメント\nコメントです。\n{{{\n; コメント\n\n#|\n\n #| ネストしても大丈夫 |#\n\n|#\n}}}\n** 変数の宣言\n*** 大域変数\n{{{\n; スペシャル変数\n(defparameter *foo* \"foo\")\n\n(defvar *foo* \"foo\")\n\n;; defvarと defparameterの違い\n\n(progn\n  ;; 変数を初期化\n  (makunbound '*foo*)\n\n  (defvar *foo* \"foo\")\n  (defvar *foo* \"bar\")\n  *foo*)\n;=> \"foo\"\n\n(progn\n  ;; 変数を初期化\n  (makunbound '*foo*)\n\n  (defparameter *foo* \"foo\")\n  (defparameter *foo* \"bar\")\n  *foo*)\n;=> \"bar\"\n}}}\n*** ローカル変数\n{{{\n(let ((foo 3))\n  (let ((bar 4))\n    (list foo bar)))\n;=> (3 4)\n}}}\n\n** スクリプトの実行\n\n** コンパイルチェック\n{{{\n(compile-file \"foo.lisp\")\n}}}\n** デバッガの起動\n\n* 数値\n{{{\n1\n1.0d0\n1.0e0\n}}}\n** 四則演算\n　四則演算です。\n{{{\n(+ 1 1)\n;=> 2\n\n(- 1 1)\n;=> 0\n\n(* 1 2)\n;=> 2\n\n(/ 1 2)\n;=> 1/2\n\n(apply #'+ '(1 1 1 1 1 1 1))\n;=> 7\n}}}\n*** 余りと商の求め方です。\nfloorは商と余りを多値で返します\n{{{\n;; 商\n(floor 3 2)\n;=> 1\n    1\n\n(+ (floor 5 2) 1)\n;=> 3\n\n(floor (/ 1 2))\n;=> 0\n;   1/2\n\n(rem 3 2)\n;=> 1\n}}}\n\n** インクリメントとデクリメント\nインクリメントとデクリメントです。\n{{{\n;; インクリメント\n(incf i)\n\n;; デクリメント\n(decf i)\n}}}\n\n* 文字列\n** 文字列の表現\n文字列はダブルクォートで囲みます。PerlやRubyのようにダブルクォートの中で変数展開することはできません。\n{{{\n\"foo\"\n;=> \"foo\"\n}}}\n;バックスラッシュや、ダブルクォートを含める際には、バックスラッシュでエスケープされる必要があります。\n{{{\n\"\\f\\o\\o\"\n;=> \"foo\"\n\n\"\\\\f\\\\o\\\\o\"\n;=> \"\\\\f\\\\o\\\\o\"\n\n\"\\\"f\\\"o\\\"o\"\n;=> \"\\\"f\\\"o\\\"o\"\n}}}\n\n** 文字列操作\n各種文字列操作です。\n\n*** 結合\n{{{\n(concatenate 'string \"aaa\" \"bbb\")\n;=> \"aaabbb\"\n\n(format nil \"~@{~A~}\" \"aaa\" \"bbb\")\n;=> \"aaabbb\"\n\n(format nil \"~@{~A~^,~}\" \"aaa\" \"bbb\" \"ccc\")\n;=> \"aaa,bbb,ccc\"\n}}}\n\n*** 分割\n{{{\n(ql:quickload :cl-ppcre)\n\n(ppcre:split \",\" \"aaa,bbb,ccc\")\n;=> (\"aaa\" \"bbb\" \"ccc\")\n\n(labels ((foo (sep str acc)\n           (let ((pos (position sep str)))\n             (if (null pos)\n                 (nreverse (cons str acc))\n                 (foo sep\n                      (subseq str (1+ pos))\n                      (cons (subseq str 0 pos) acc))))))\n  (foo #\\, \"aaa,bbb,ccc\" () ))\n;=> (\"aaa\" \"bbb\" \"ccc\")\n}}}\n\n*** 長さ\n{{{\n(length \"abcdef\")\n;=> 6\n}}}\n\n*** 切り出し\n{{{\n(subseq \"abcd\" 0 2)\n;=> \"ab\"\n}}}\n*** 検索\n文字列から文字を探す\n{{{\n(position #\\c \"abcd\")\n;=> 2\n}}}\n文字列から文字列を探す (見つかった場合はその位置、見つからなかった場合はNILが返る)\n{{{\n(search \"cd\" \"abcd\")\n;=> 2\n\n(search \"ce\" \"abcd\")\n;=> NIL\n\n(ppcre:scan \"cd\" \"abcd\")\n;=> 2\n;   4\n;   #()\n;   #()\n\n(ppcre:scan \"ce\" \"abcd\")\n;=> NIL\n}}}\n\n* リスト\nlisp系言語では、配列よりはリストがデータ構造の基本です。~%\nリストは複数の値を格納することができます。変数に代入/束縛できます。\n{{{\n(list 1 2 3 4)\n;=> (1 2 3 4)\n\n(let ((foo (list 1 2 3 4)))\n  foo)\n;=> (1 2 3 4)\n\n(let ((foo (list 1 2 3 4)))\n  (setq foo (list 'a 'b 'c 'd)))\n;=> (A B C D)\n}}}\n\n** リストの要素の参照と代入\nリストの要素を参照と代入です。\n*** 要素の参照\n{{{\n(let ((foo (list 1 2 3 4)))\n  (elt foo 1))\n;=> 2\n}}}\n*** 要素の代入\n{{{\n(let ((foo (list 1 2 3 4)))\n  (setf (elt foo 1)\n        (* 100 (elt foo 1)))\n  foo)\n;=> (1 200 3 4)\n}}}\n*** リスト内の要素数\n{{{\n(length (list 1 2 3 4))\n;=> 4\n}}}\n*** リストの操作\nリストを操作する関数です。\n先頭の要素を取り出す\n{{{\n(car (list 1 2 3 4))\n;=> 1\n\n(first (list 1 2 3 4))\n;=> 1\n\n(elt (list 1 2 3 4) 1)\n;=> 2\n}}}\n\nリスト構造は、先頭に要素を追加する方が末尾に要素を追加するより効率が良いので、先頭への追加、先頭からの削除、が基本操作になります~%\n\n*** 先頭に要素を追加\n{{{\n(cons  0 (list 1 2 3 4))\n;=> (0 1 2 3 4)\n}}}\n\n*** 先頭の要素を取り出す\n{{{\n(let ((foo (list 1 2 3 4)))\n  (list (pop foo)\n        foo))\n;=> (1 (2 3 4))\n}}}\n*** 先頭に要素を追加\n{{{\n(let ((foo (list 1 2 3 4)))\n  (push 0 foo)\n  foo)\n;=> (0 1 2 3 4)\n}}}\n** ハッシュの宣言と代入\nハッシュの宣言と代入です。ハッシュは複数の対になる値を代入することのできるデータ型です\n{{{\n(let ((hash (make-hash-table)))\n  (setf (gethash 'a hash) 1)\n  (setf (gethash 'b hash) 2))\n}}}\n\n要素数が少ない場合は、キーと値をリストにしたalistも良く利用されます\n{{{\n(let ((alist () ))\n  (push '(a . 1) alist)\n  (push '(b . 1) alist)\n  alist)\n;=> ((B . 1) (A . 1))\n}}}\n\n*** ハッシュの要素の参照と代入\nハッシュの要素の参照と代入です。\n{{{\n(let ((hash (make-hash-table)))\n  (setf (gethash 'a hash) 1)\n  (setf (gethash 'b hash) 2)\n\n  (list (gethash 'a hash)\n        (gethash 'b hash)))\n;=> (1 2)\n}}}\n*** 要素の代入\n{{{\n(let ((hash (make-hash-table)))\n  (setf (gethash 'a hash) 1)\n  (setf (gethash 'b hash) 2)\n\n  ;; 書き換え\n  (setf (gethash 'a hash) 10)\n  (setf (gethash 'b hash) 20)\n\n  (list (gethash 'a hash)\n        (gethash 'b hash)))\n;=> (10 20)\n}}}\n{{{\n(let ((alist () ))\n  (push '(a . 1) alist)\n  (push '(b . 1) alist)\n  alist)\n}}}\n\n*** 要素の参照\n{{{\n(let ((alist '((a . 1) (b . 2))))\n  (list (cdr (assoc 'a alist))\n        (cdr (assoc 'b alist))))\n;=> (1 2)\n\n(let ((alist '((a . 1) (b . 2))))\n  (setf (cdr (assoc 'a alist)) 10)\n  (setf (cdr (assoc 'b alist)) 20)\n\n  (list (cdr (assoc 'a alist))\n        (cdr (assoc 'b alist))))\n;=> (1 2)\n}}}\n\n* 制御文\n** if式\nif式です。\n{{{\n(if (条件)\n    式)\n}}}\n")
(" %Tag:jp'A=0" . "(1577137634)")
("ドキュメンテーション" . "(:ctime 1229516095 :cuser #f :mtime 1229517828 :muser #f)[[$$tag ドキュメント]]\n* ドキュメンテーション文字列\n\n関数や変数、クラス定義にはドキュメント文字列を付ける事ができます。\nコメントと違い読み飛ばされないのでプログラム内から読み出すこともできます。\n\n (defun foo (x)\n    \"ドキュメント文字列\"\n    (+ x x))\n\n (defvar bar 10\n    \"ドキュメント文字列\")\n (defparameter baz 10\n    \"ドキュメント文字列\")\n\n (defclass bee ()\n    ()\n    (:documentation \"ドキュメント文字列\"))\n\nドキュメント文字列を取り出すには、総称関数 [[$$hs documentation]] を使用します。 \n\n (documentation 'foo 'function)\n (documentation 'bar 'variable)\n (documentation 'bee 'type)\n\n")
(" %Tag:CL-TEST-MORE\" and \"x\"=\"x" . "(1582882538)")
("Ltk:テキスト入力欄を表示する" . "(:ctime 1619742241 :cuser #f :mtime 1619744822 :muser #f)* テキスト入力欄\n\n{{{\n;;; LTKでテキスト入力欄\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-25\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-25)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"テキスト入力欄(entry)\")\n    (minsize *tk* 300 300)\n\n    (let* ((msg (make-instance\n                 'message\n                 :text \"テキスト入力欄を作ってみる\"\n                 :width 300\n                 :background \"#FFFFFF\"))\n\n           (ledit (make-instance\n                   'entry\n                   :width 200))\n;                   :background \"#FFFFFF\"))\n\n           (b1 (make-instance\n                'button\n                :text \"Close\"\n                :command (lambda ()\n                           (format t \"終了\")\n                           (setf *exit-mainloop* t)))))\n\n      (pack msg\n            :side :top\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n\n      (pack ledit\n            :side\n            :top)\n\n      (pack b1\n            :side :bottom\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n\n      ;; テキストメッセージを左寄せ（このconfigureを外すと中寄せになる）\n      (configure msg\n                 :anchor :w\n                 )\n\n      )))\n\n(main)\n\n}}}\n")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45) -- /* order by \"as /*" . "(1624124880)")
("Common Lisp標準が利用するキーワードシンボル一覧" . "(:ctime 1546471233 :cuser #f :mtime 1546512712 :muser #f)ANSI Common Lisp標準で利用されるキーワードシンボル一覧です\n\n参考: [http://www.lispworks.com/documentation/HyperSpec/Front/X_Mast_9.htm Common Lisp HyperSpec]\n----\n\n- キーワードシンボル\n-- 文脈\n\n----\n\n- :abort\n-- [[$$hs close]]\n- :absolute\n-- Pathname Components\n- :accessor\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n- :adjustable\n-- [[$$hs make-array]]\n- :after\n-- [[$$hs defmethod]]\n- :allocation\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n- :allow-other-keys\n-- Lambda list\n- :ansi-cl\n-- [[$$hs *features*]]\n- :append\n-- [[$$hs open]]\n- :argument-precedence-order\n-- [[$$hs defgeneric]]\n-- [[$$hs ensure-generic-function]]\n- :arguments\n-- [[$$hs define-method-combination]]\n- :around\n-- [[$$hs define-method-combination]]\n-- [[$$hs defmethod]]\n- :array\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :back\n-- [[$$hs merge-pathnames]]\n- :base\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :before\n-- [[$$hs defmethod]]\n- :block\n-- [[$$hs pprint-indent]]\n- :capitalize\n-- [[$$hs *print-case*]]\n- :case\n-- [[$$hs make-pathname]]\n-- [[$$hs pathname-device]]\n-- [[$$hs pathname-directory]]\n-- [[$$hs pathname-host]]\n-- [[$$hs pathname-name]]\n-- [[$$hs pathname-type]]\n-- [[$$hs pathname-version]]\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- Pathname Components\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :class\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n- :cltl1\n-- [[$$hs *features*]]\n- :cltl2\n-- [[$$hs *features*]]\n- :common\n-- [[$$hs make-pathname]]\n-- [[$$hs pathname-device]]\n-- [[$$hs pathname-directory]]\n-- [[$$hs pathname-host]]\n-- [[$$hs pathname-name]]\n-- [[$$hs pathname-type]]\n-- [[$$hs pathname-version]]\n- :common-lisp\n-- [[$$hs *features*]]\n- :compile-toplevel\n-- [[$$hs eval-when]]\n- :conc-name\n-- [[$$hs defstruct]]\n- :constructor\n-- [[$$hs defstruct]]\n- :copier\n-- [[$$hs copy-structure]]\n-- [[$$hs defstruct]]\n- :count\n-- [[$$hs delete]]\n-- [[$$hs delete-if]]\n-- [[$$hs delete-if-not]]\n-- [[$$hs nsubstitute]]\n-- [[$$hs nsubstitute-if]]\n-- [[$$hs nsubstitute-if-not]]\n-- [[$$hs remove]]\n-- [[$$hs remove-if]]\n-- [[$$hs remove-if-not]]\n-- [[$$hs substitute]]\n-- [[$$hs substitute-if]]\n-- [[$$hs substitute-if-not]]\n- :create\n-- [[$$hs open]]\n- :current\n-- [[$$hs pprint-indent]]\n- :declare\n-- [[$$hs ensure-generic-function]]\n- :default\n-- [[$$hs broadcast-stream]]\n-- [[$$hs compile-file]]\n-- [[$$hs load]]\n-- [[$$hs open]]\n-- [[$$hs room]]\n- :default-initargs\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n- :defaults\n-- [[$$hs make-pathname]]\n- :description\n-- [[$$hs define-method-combination]]\n- :device\n-- [[$$hs make-pathname]]\n-- [[$$hs wild-pathname-p]]\n- :direction\n-- [[$$hs open]]\n- :directory\n-- [[$$hs make-pathname]]\n-- [[$$hs wild-pathname-p]]\n- :displaced-index-offset\n-- [[$$hs adjust-array]]\n-- [[$$hs array-displacement]]\n-- [[$$hs make-array]]\n- :displaced-to\n-- [[$$hs adjust-array]]\n-- [[$$hs array-displacement]]\n-- [[$$hs make-array]]\n- :documentation\n-- [[$$hs defclass]]\n-- [[$$hs defgeneric]]\n-- [[$$hs define-condition]]\n-- [[$$hs define-method-combination]]\n-- [[$$hs defpackage]]\n-- [[$$hs ensure-generic-function]]\n- :downcase\n-- [[$$hs *print-case*]]\n-- [[$$hs readtable-case]]\n- :draft-ansi-cl\n-- [[$$hs *features*]]\n- :draft-ansi-cl-2\n-- [[$$hs *features*]]\n- :element-type\n-- [[$$hs adjust-array]]\n-- [[$$hs make-array]]\n-- [[$$hs make-string]]\n-- [[$$hs make-string-output-stream]]\n-- [[$$hs open]]\n-- [[$$hs with-output-to-string]]\n- :end\n-- [[$$hs count]]\n-- [[$$hs count-if]]\n-- [[$$hs count-if-not]]\n-- [[$$hs delete]]\n-- [[$$hs delete-duplicates]]\n-- [[$$hs delete-if]]\n-- [[$$hs delete-if-not]]\n-- [[$$hs fill]]\n-- [[$$hs find]]\n-- [[$$hs find-if]]\n-- [[$$hs find-if-not]]\n-- [[$$hs nstring-capitalize]]\n-- [[$$hs nstring-downcase]]\n-- [[$$hs nstring-upcase]]\n-- [[$$hs nsubstitute]]\n-- [[$$hs nsubstitute-if]]\n-- [[$$hs nsubstitute-if-not]]\n-- [[$$hs parse-integer]]\n-- [[$$hs parse-namestring]]\n-- [[$$hs position]]\n-- [[$$hs position-if]]\n-- [[$$hs position-if-not]]\n-- [[$$hs read-from-string]]\n-- [[$$hs read-sequence]]\n-- [[$$hs reduce]]\n-- [[$$hs remove]]\n-- [[$$hs remove-duplicates]]\n-- [[$$hs remove-if]]\n-- [[$$hs remove-if-not]]\n-- [[$$hs string-capitalize]]\n-- [[$$hs string-downcase]]\n-- [[$$hs string-upcase]]\n-- [[$$hs substitute]]\n-- [[$$hs substitute-if]]\n-- [[$$hs substitute-if-not]]\n-- [[$$hs with-input-from-string]]\n-- [[$$hs write-line]]\n-- [[$$hs write-sequence]]\n-- [[$$hs write-string]]\n- :end1\n-- [[$$hs mismatch]]\n-- [[$$hs replace]]\n-- [[$$hs search]]\n-- [[$$hs string-equal]]\n-- [[$$hs string-greaterp]]\n-- [[$$hs string-lessp]]\n-- [[$$hs string-not-equal]]\n-- [[$$hs string-not-greaterp]]\n-- [[$$hs string-not-lessp]]\n-- [[$$hs string/=]]\n-- [[$$hs string<]]\n-- [[$$hs string<=]]\n-- [[$$hs string=]]\n-- [[$$hs string>]]\n-- [[$$hs string>=]]\n- :end2\n-- [[$$hs mismatch]]\n-- [[$$hs replace]]\n-- [[$$hs search]]\n-- [[$$hs string-equal]]\n-- [[$$hs string-greaterp]]\n-- [[$$hs string-lessp]]\n-- [[$$hs string-not-equal]]\n-- [[$$hs string-not-greaterp]]\n-- [[$$hs string-not-lessp]]\n-- [[$$hs string/=]]\n-- [[$$hs string<]]\n-- [[$$hs string<=]]\n-- [[$$hs string=]]\n-- [[$$hs string>]]\n-- [[$$hs string>=]]\n- :environment\n-- [[$$hs ensure-generic-function]]\n-- [[$$hs make-load-form-saving-slots]]\n- :error\n-- [[$$hs open]]\n- :escape\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :execute\n-- [[$$hs eval-when]]\n- :expected-type\n-- [[$$hs type-error]]\n- :export\n-- [[$$hs defpackage]]\n- :external\n-- [[$$hs find-symbol]]\n-- [[$$hs intern]]\n-- [[$$hs with-package-iterator]]\n- :external-format\n-- [[$$hs compile-file]]\n-- [[$$hs load]]\n-- [[$$hs open]]\n-- [[$$hs stream-external-format]]\n- :fill\n-- [[$$hs pprint-newline]]\n- :fill-pointer\n-- [[$$hs adjust-array]]\n-- [[$$hs make-array]]\n- :format-arguments\n-- [[$$hs simple-condition]]\n- :from-end\n-- [[$$hs count]]\n-- [[$$hs count-if]]\n-- [[$$hs count-if-not]]\n-- [[$$hs delete]]\n-- [[$$hs delete-duplicates]]\n-- [[$$hs delete-if]]\n-- [[$$hs delete-if-not]]\n-- [[$$hs find]]\n-- [[$$hs find-if]]\n-- [[$$hs find-if-not]]\n-- [[$$hs mismatch]]\n-- [[$$hs nsubstitute]]\n-- [[$$hs nsubstitute-if]]\n-- [[$$hs nsubstitute-if-not]]\n-- [[$$hs position]]\n-- [[$$hs position-if]]\n-- [[$$hs position-if-not]]\n-- [[$$hs reduce]]\n-- [[$$hs remove]]\n-- [[$$hs remove-duplicates]]\n-- [[$$hs remove-if]]\n-- [[$$hs remove-if-not]]\n-- [[$$hs search]]\n-- [[$$hs substitute]]\n-- [[$$hs substitute-if]]\n-- [[$$hs substitute-if-not]]\n- :generic-function\n-- [[$$hs define-method-combination]]\n- :generic-function-class\n-- [[$$hs defgeneric]]\n-- [[$$hs ensure-generic-function]]\n- :gensym\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :host\n-- [[$$hs make-pathname]]\n-- [[$$hs wild-pathname-p]]\n- :identity\n-- [[$$hs print-unreadable-object]]\n- :identity-with-one-argument\n-- [[$$hs define-method-combination]]\n- :ieee-floating-point\n-- [[$$hs *features*]]\n- :if-does-not-exist\n-- [[$$hs load]]\n-- [[$$hs open]]\n- :if-exists\n-- [[$$hs open]]\n- :import-from\n-- [[$$hs defpackage]]\n- :include\n-- [[$$hs defstruct]]\n- :index\n-- [[$$hs with-input-from-string]]\n- :inherited\n-- [[$$hs find-symbol]]\n-- [[$$hs intern]]\n-- [[$$hs with-package-iterator]]\n- :init-form\n-- [[$$hs defclass]]\n- :initarg\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n-- [[$$hs reinitialize-instance]]\n-- [[$$hs shared-initialize]]\n-- [[$$hs update-instance-for-different-class]]\n-- [[$$hs update-instance-for-redefined-class]]\n- :initform\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n-- [[$$hs initialize-instance]]\n-- [[$$hs shared-initialize]]\n-- [[$$hs slot-unbound]]\n-- [[$$hs update-instance-for-different-class]]\n-- [[$$hs update-instance-for-redefined-class]]\n- :initial-contents\n-- [[$$hs adjust-array]]\n-- [[$$hs make-array]]\n- :initial-element\n-- [[$$hs adjust-array]]\n-- [[$$hs make-array]]\n-- [[$$hs make-list]]\n-- [[$$hs make-sequence]]\n-- [[$$hs make-string]]\n- :initial-offset\n-- [[$$hs defstruct]]\n- :initial-value\n-- [[$$hs reduce]]\n- :input\n-- [[$$hs open]]\n- :installed\n-- Pathname Components\n- :instance\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n- :interactive\n-- [[$$hs invoke-restart-interactively]]\n-- [[$$hs restart-case]]\n- :interactive-function\n-- [[$$hs invoke-restart-interactively]]\n-- [[$$hs restart-bind]]\n- :intern\n-- [[$$hs defpackage]]\n- :internal\n-- [[$$hs find-symbol]]\n-- [[$$hs intern]]\n-- [[$$hs with-package-iterator]]\n- :invert\n-- [[$$hs *print-case*]]\n-- [[$$hs readtable-case]]\n- :io\n-- [[$$hs open]]\n- :junk-allowed\n-- [[$$hs parse-integer]]\n-- [[$$hs parse-namestring]]\n- :key\n-- [[$$hs adjoin]]\n-- [[$$hs assoc]]\n-- [[$$hs assoc-if]]\n-- [[$$hs assoc-if-not]]\n-- [[$$hs count]]\n-- [[$$hs count-if]]\n-- [[$$hs count-if-not]]\n-- [[$$hs delete]]\n-- [[$$hs delete-duplicates]]\n-- [[$$hs delete-if]]\n-- [[$$hs delete-if-not]]\n-- [[$$hs find]]\n-- [[$$hs find-if]]\n-- [[$$hs find-if-not]]\n-- [[$$hs intersection]]\n-- [[$$hs member]]\n-- [[$$hs member-if]]\n-- [[$$hs member-if-not]]\n-- [[$$hs merge]]\n-- [[$$hs mismatch]]\n-- [[$$hs nintersection]]\n-- [[$$hs nset-difference]]\n-- [[$$hs nset-exclusive-or]]\n-- [[$$hs nsublis]]\n-- [[$$hs nsubst]]\n-- [[$$hs nsubst-if]]\n-- [[$$hs nsubst-if-not]]\n-- [[$$hs nsubstitute]]\n-- [[$$hs nsubstitute-if]]\n-- [[$$hs nsubstitute-if-not]]\n-- [[$$hs nunion]]\n-- [[$$hs position]]\n-- [[$$hs position-if]]\n-- [[$$hs position-if-not]]\n-- [[$$hs pushnew]]\n-- [[$$hs rassoc]]\n-- [[$$hs rassoc-if]]\n-- [[$$hs rassoc-if-not]]\n-- [[$$hs reduce]]\n-- [[$$hs remove]]\n-- [[$$hs remove-duplicates]]\n-- [[$$hs remove-if]]\n-- [[$$hs remove-if-not]]\n-- [[$$hs search]]\n-- [[$$hs set-difference]]\n-- [[$$hs set-exclusive-or]]\n-- [[$$hs sort]]\n-- [[$$hs stable-sort]]\n-- [[$$hs sublis]]\n-- [[$$hs subsetp]]\n-- [[$$hs subst]]\n-- [[$$hs subst-if]]\n-- [[$$hs subst-if-not]]\n-- [[$$hs substitute]]\n-- [[$$hs substitute-if]]\n-- [[$$hs substitute-if-not]]\n-- [[$$hs union]]\n- :lambda-list\n-- [[$$hs ensure-generic-function]]\n- :length\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :level\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :line\n-- [[$$hs pprint-tab]]\n- :line-relative\n-- [[$$hs pprint-tab]]\n- :linear\n-- [[$$hs pprint-newline]]\n- :lines\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :load-toplevel\n-- [[$$hs eval-when]]\n- :local\n-- [[$$hs make-pathname]]\n-- [[$$hs pathname-device]]\n-- [[$$hs pathname-directory]]\n-- [[$$hs pathname-host]]\n-- [[$$hs pathname-name]]\n-- [[$$hs pathname-type]]\n-- [[$$hs pathname-version]]\n-- Pathname Components\n- :mandatory\n-- [[$$hs pprint-newline]]\n- :metaclass\n-- [[$$hs defclass]]\n- :method\n-- [[$$hs defgeneric]]\n- :method-class\n-- [[$$hs defgeneric]]\n-- [[$$hs ensure-generic-function]]\n- :method-combination\n-- [[$$hs defgeneric]]\n-- [[$$hs define-method-combination]]\n-- [[$$hs ensure-generic-function]]\n- :miser\n-- [[$$hs pprint-newline]]\n- :miser-width\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :most-specific-first\n-- [[$$hs defgeneric]]\n-- [[$$hs define-method-combination]]\n- :most-specific-last\n-- [[$$hs defgeneric]]\n-- [[$$hs define-method-combination]]\n- :name\n-- [[$$hs make-pathname]]\n-- [[$$hs wild-pathname-p]]\n- :named\n-- [[$$hs defstruct]]\n- :new-version\n-- [[$$hs open]]\n- :newest\n-- [[$$hs merge-pathnames]]\n-- [[$$hs open]]\n-- Pathname Components\n- :nicknames\n-- [[$$hs defpackage]]\n-- [[$$hs make-package]]\n- :no-error\n-- [[$$hs handler-case]]\n- :oldest\n-- Pathname Components\n- :operands\n-- [[$$hs arithmetic-error]]\n- :operator\n-- [[$$hs define-method-combination]]\n- :order\n-- [[$$hs define-method-combination]]\n- :output\n-- [[$$hs open]]\n- :output-file\n-- [[$$hs compile-file]]\n-- [[$$hs compile-file-pathname]]\n- :override\n-- [[$$hs with-compilation-unit]]\n- :overwrite\n-- [[$$hs open]]\n- :per-line-prefix\n-- [[$$hs pprint-logical-block]]\n- :pprint-dispatch\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :pre-line-prefix\n-- [[$$hs pprint-logical-block]]\n- :predicate\n-- [[$$hs defstruct]]\n- :prefix\n-- [[$$hs pprint-logical-block]]\n- :preserve\n-- [[$$hs *print-case*]]\n-- [[$$hs readtable-case]]\n- :preserve-whitespace\n-- [[$$hs read-from-string]]\n- :pretty\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :previous\n-- Pathname Components\n- :print\n-- [[$$hs *compile-print*]]\n-- [[$$hs *compile-verbose*]]\n-- [[$$hs *load-print*]]\n-- [[$$hs *load-verbose*]]\n-- [[$$hs compile-file]]\n-- [[$$hs load]]\n- :print-function\n-- [[$$hs defstruct]]\n- :print-object\n-- [[$$hs defstruct]]\n- :probe\n-- [[$$hs open]]\n- :radix\n-- [[$$hs parse-integer]]\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :read-only\n-- [[$$hs defstruct]]\n- :readably\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :reader\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n- :rehash-size\n-- [[$$hs make-hash-table]]\n- :rehash-threshold\n-- [[$$hs make-hash-table]]\n- :relative\n-- [[$$hs merge-pathnames]]\n-- Pathname Components\n- :rename\n-- [[$$hs open]]\n- :rename-and-delete\n-- [[$$hs open]]\n- :report\n-- [[$$hs define-condition]]\n-- [[$$hs restart-case]]\n- :report-function\n-- [[$$hs restart-bind]]\n- :required\n-- [[$$hs define-method-combination]]\n- :right-margin\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs prin1-to-string]]\n-- [[$$hs princ]]\n-- [[$$hs princ-to-string]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n-- [[$$hs write-to-string]]\n- :section\n-- [[$$hs pprint-tab]]\n- :section-relative\n-- [[$$hs pprint-tab]]\n- :shadow\n-- [[$$hs defpackage]]\n- :shadowing-import-from\n-- [[$$hs defpackage]]\n- :size\n-- [[$$hs defpackage]]\n-- [[$$hs make-hash-table]]\n- :slot-names\n-- [[$$hs make-load-form-saving-slots]]\n- :start\n-- [[$$hs count]]\n-- [[$$hs count-if]]\n-- [[$$hs count-if-not]]\n-- [[$$hs delete]]\n-- [[$$hs delete-duplicates]]\n-- [[$$hs delete-if]]\n-- [[$$hs delete-if-not]]\n-- [[$$hs fill]]\n-- [[$$hs find]]\n-- [[$$hs find-if]]\n-- [[$$hs find-if-not]]\n-- [[$$hs nstring-capitalize]]\n-- [[$$hs nstring-downcase]]\n-- [[$$hs nstring-upcase]]\n-- [[$$hs nsubstitute]]\n-- [[$$hs nsubstitute-if]]\n-- [[$$hs nsubstitute-if-not]]\n-- [[$$hs parse-integer]]\n-- [[$$hs parse-namestring]]\n-- [[$$hs position]]\n-- [[$$hs position-if]]\n-- [[$$hs position-if-not]]\n-- [[$$hs read-from-string]]\n-- [[$$hs read-sequence]]\n-- [[$$hs reduce]]\n-- [[$$hs remove]]\n-- [[$$hs remove-duplicates]]\n-- [[$$hs remove-if]]\n-- [[$$hs remove-if-not]]\n-- [[$$hs string-capitalize]]\n-- [[$$hs string-downcase]]\n-- [[$$hs string-upcase]]\n-- [[$$hs substitute]]\n-- [[$$hs substitute-if]]\n-- [[$$hs substitute-if-not]]\n-- [[$$hs with-input-from-string]]\n-- [[$$hs write-line]]\n-- [[$$hs write-sequence]]\n-- [[$$hs write-string]]\n- :start1\n-- [[$$hs mismatch]]\n-- [[$$hs replace]]\n-- [[$$hs search]]\n-- [[$$hs string-equal]]\n-- [[$$hs string-greaterp]]\n-- [[$$hs string-lessp]]\n-- [[$$hs string-not-equal]]\n-- [[$$hs string-not-greaterp]]\n-- [[$$hs string-not-lessp]]\n-- [[$$hs string/=]]\n-- [[$$hs string<]]\n-- [[$$hs string<=]]\n-- [[$$hs string=]]\n-- [[$$hs string>]]\n-- [[$$hs string>=]]\n- :start2\n-- [[$$hs mismatch]]\n-- [[$$hs replace]]\n-- [[$$hs search]]\n-- [[$$hs string-equal]]\n-- [[$$hs string-greaterp]]\n-- [[$$hs string-lessp]]\n-- [[$$hs string-not-equal]]\n-- [[$$hs string-not-greaterp]]\n-- [[$$hs string-not-lessp]]\n-- [[$$hs string/=]]\n-- [[$$hs string<]]\n-- [[$$hs string<=]]\n-- [[$$hs string=]]\n-- [[$$hs string>]]\n-- [[$$hs string>=]]\n- :stream\n-- [[$$hs pprint]]\n-- [[$$hs prin1]]\n-- [[$$hs princ]]\n-- [[$$hs print]]\n-- [[$$hs write]]\n- :suffix\n-- [[$$hs pprint-logical-block]]\n- :supersede\n-- [[$$hs open]]\n- :test\n-- [[$$hs adjoin]]\n-- [[$$hs assoc]]\n-- [[$$hs assoc-if]]\n-- [[$$hs assoc-if-not]]\n-- [[$$hs complement]]\n-- [[$$hs count]]\n-- [[$$hs count-if]]\n-- [[$$hs count-if-not]]\n-- [[$$hs delete]]\n-- [[$$hs delete-duplicates]]\n-- [[$$hs delete-if]]\n-- [[$$hs delete-if-not]]\n-- [[$$hs equalp]]\n-- [[$$hs find]]\n-- [[$$hs find-if]]\n-- [[$$hs find-if-not]]\n-- [[$$hs intersection]]\n-- [[$$hs make-hash-table]]\n-- [[$$hs member]]\n-- [[$$hs member-if]]\n-- [[$$hs member-if-not]]\n-- [[$$hs mismatch]]\n-- [[$$hs nintersection]]\n-- [[$$hs nset-difference]]\n-- [[$$hs nset-exclusive-or]]\n-- [[$$hs nsublis]]\n-- [[$$hs nsubst]]\n-- [[$$hs nsubst-if]]\n-- [[$$hs nsubst-if-not]]\n-- [[$$hs nsubstitute]]\n-- [[$$hs nsubstitute-if]]\n-- [[$$hs nsubstitute-if-not]]\n-- [[$$hs nunion]]\n-- [[$$hs position]]\n-- [[$$hs position-if]]\n-- [[$$hs position-if-not]]\n-- [[$$hs pushnew]]\n-- [[$$hs rassoc]]\n-- [[$$hs rassoc-if]]\n-- [[$$hs rassoc-if-not]]\n-- [[$$hs remove]]\n-- [[$$hs remove-duplicates]]\n-- [[$$hs remove-if]]\n-- [[$$hs remove-if-not]]\n-- [[$$hs restart-case]]\n-- [[$$hs search]]\n-- [[$$hs set-difference]]\n-- [[$$hs set-exclusive-or]]\n-- [[$$hs sublis]]\n-- [[$$hs subsetp]]\n-- [[$$hs subst]]\n-- [[$$hs subst-if]]\n-- [[$$hs subst-if-not]]\n-- [[$$hs substitute]]\n-- [[$$hs substitute-if]]\n-- [[$$hs substitute-if-not]]\n-- [[$$hs tree-equal]]\n-- [[$$hs union]]\n- :test-function\n-- [[$$hs restart-bind]]\n- :test-not\n-- [[$$hs adjoin]]\n-- [[$$hs assoc]]\n-- [[$$hs assoc-if]]\n-- [[$$hs assoc-if-not]]\n-- [[$$hs complement]]\n-- [[$$hs count]]\n-- [[$$hs count-if]]\n-- [[$$hs count-if-not]]\n-- [[$$hs delete]]\n-- [[$$hs delete-duplicates]]\n-- [[$$hs delete-if]]\n-- [[$$hs delete-if-not]]\n-- [[$$hs find]]\n-- [[$$hs find-if]]\n-- [[$$hs find-if-not]]\n-- [[$$hs intersection]]\n-- [[$$hs member]]\n-- [[$$hs member-if]]\n-- [[$$hs member-if-not]]\n-- [[$$hs mismatch]]\n-- [[$$hs nintersection]]\n-- [[$$hs nset-difference]]\n-- [[$$hs nset-exclusive-or]]\n-- [[$$hs nsublis]]\n-- [[$$hs nsubst]]\n-- [[$$hs nsubst-if]]\n-- [[$$hs nsubst-if-not]]\n-- [[$$hs nsubstitute]]\n-- [[$$hs nsubstitute-if]]\n-- [[$$hs nsubstitute-if-not]]\n-- [[$$hs nunion]]\n-- [[$$hs position]]\n-- [[$$hs position-if]]\n-- [[$$hs position-if-not]]\n-- [[$$hs pushnew]]\n-- [[$$hs rassoc]]\n-- [[$$hs rassoc-if]]\n-- [[$$hs rassoc-if-not]]\n-- [[$$hs remove]]\n-- [[$$hs remove-duplicates]]\n-- [[$$hs remove-if]]\n-- [[$$hs remove-if-not]]\n-- [[$$hs search]]\n-- [[$$hs set-difference]]\n-- [[$$hs set-exclusive-or]]\n-- [[$$hs sublis]]\n-- [[$$hs subsetp]]\n-- [[$$hs subst]]\n-- [[$$hs subst-if]]\n-- [[$$hs subst-if-not]]\n-- [[$$hs substitute]]\n-- [[$$hs substitute-if]]\n-- [[$$hs substitute-if-not]]\n-- [[$$hs tree-equal]]\n-- [[$$hs union]]\n- :type\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n-- [[$$hs defstruct]]\n-- [[$$hs make-pathname]]\n-- [[$$hs print-unreadable-object]]\n-- [[$$hs type-of]]\n-- [[$$hs wild-pathname-p]]\n- :unspecific\n-- [[$$hs make-pathname]]\n-- Pathname Components\n-- [[$$hs user-homedir-pathname]]\n- :up\n-- Pathname Components\n- :upcase\n-- [[$$hs *print-case*]]\n-- [[$$hs readtable-case]]\n- :use\n-- [[$$hs defpackage]]\n-- [[$$hs make-package]]\n- :verbose\n-- [[$$hs *compile-print*]]\n-- [[$$hs *compile-verbose*]]\n-- [[$$hs *load-print*]]\n-- [[$$hs *load-verbose*]]\n-- [[$$hs compile-file]]\n-- [[$$hs ensure-directories-exist]]\n-- [[$$hs load]]\n- :version\n-- [[$$hs make-pathname]]\n-- [[$$hs wild-pathname-p]]\n- :wild\n-- [[$$hs make-pathname]]\n-- [[$$hs merge-pathnames]]\n-- [[$$hs pathname-match-p]]\n-- [[$$hs translate-pathname]]\n- :wild-inferiors\n-- [[$$hs make-pathname]]\n-- Pathname Components\n- :writer\n-- [[$$hs defclass]]\n-- [[$$hs define-condition]]\n- :x3j13\n-- [[$$hs *features*]]\n")
(" %Tag:????'\"" . "(1587484313)")
("ディスパッチ目的のインスタンスを都度生成しない" . "(:ctime 1546122245 :cuser #f :mtime 1546122245 :muser #f)[[$$tag MOP ライブラリ closer-mop]]\n\n主にCommon Lispの多重メソッドのディスパッチ機能のみを活用する場合、ディスパッチ目的のインスタンスは極力生成させたくない場合があります。\nこのような場合、MOP:[http://metamodular.com/CLOS-MOP/class-prototype.html class-prototype]が活用できます。~%\n\nCommon Lispのクラスは、各々インスタンスのプロトタイプを保持しており、 class-prototype はそのプロトタイプを取り出す総称関数です。~%\nMOPのコンパチブルレイヤーとして[[CLiki:Closer-MOP]]を利用します~%\n\n{{{\n(defclass level () ())\n(defclass role () ())\n\n(defclass R1 (role) ())\n(defclass R2 (role) ())\n\n(defclass L1 (level) ())\n(defclass L2 (level) ())\n\n(defmethod foo ((l level) (r role) arg)\n  (values arg \"default\"))\n\n(defmethod foo ((L1 level) (R2 role) arg)\n  (values arg \"[level 1] - [role 2]\"))\n}}}\n\nclass-prototype 利用と make-instanceを利用の場合を、それぞれ1,000,000回繰り返したものを計測してみます。\n\n{{{\n(defun foo/class-prototype ()\n  (dotimes (i (expt 10 6))\n    (foo (class-prototype 'L1) (class-prototype 'R2) 42)))\n\n(defun foo/make-instance ()\n  (dotimes (i (expt 10 6))\n    (foo (make-instance 'L1) (make-instance 'R2) 42)))\n\n(progn\n  (time\n   (foo/class-prototype))\n  (time\n   (foo/make-instance)))\n\nTiming the evaluation of (foo/class-prototype)\n\nUser time    =        0.190\nSystem time  =        0.000\nElapsed time =        0.184\nAllocation   = 7896 bytes\n0 Page faults\nTiming the evaluation of (foo/make-instance)\n\nUser time    =        0.310\nSystem time  =        0.000\nElapsed time =        0.318\nAllocation   = 64000000 bytes\n0 Page faults\n}}}\n\n1,000,000 回の繰り返しで、速度はそれ程変化がありませんが、アロケーションで約8100倍の差が出ています。~%\n(例はLispWorks 7.0で計測)\n")
("文字列中の関数と式を展開する" . "(:ctime 1232079306 :cuser #f :mtime 1232090805 :muser #f)[[$$tag 文字列]]\n\nANSI CL標準にPerlのように文字列に含まれる変数を展開する文字列補間は含まれていませんが、[[CLiki:cl-interpol]]のようなライブラリを利用することで文字列補間を実現できるでしょう。\n\n{{{\n(cl-interpol:enable-interpol-syntax)\n\n(let ((x 10000))\n  (multiple-value-bind (ig no re d mo y)\n      (decode-universal-time (- (get-universal-time) \n                                (* 60 60 24 (1- x))))\n    (declare (ignore ig no re))\n  #?\"こんにちは、人が生まれてから${x}日目を迎えるのは、${(truncate (/ x 365))}歳のときですが、\\n本日${x}日目を迎えるのは、${y}年${mo}月${d}日生まれの方です。\\nおめでとう。\"))\n;=> \"こんにちは、人が生まれてから10000日目を迎えるのは、27歳のときですが、\n本日10000日目を迎えるのは、1981年9月1日生まれの方です。\nおめでとう。\"\n}}}\n")
("隠蔽されたコンディションの発生を活性化する" . "(:ctime 1397873712 :cuser #f :mtime 1397875998 :muser #f)[[$$tag コンディション]]\n\n\n発生するコンディションは、[[$$hs handler-case]]等によって捕捉することが可能です。\n\n- [[特定のコンディションだけを捕捉する]]\n\n[[$$hs ignore-errors]]等でエラー等のコンディションを無視することにした場合、無視する範囲が広範囲になるとデバッグ時にエラーの発生場所の特定が困難になります。\n\nこのような場合、[[$$hs *break-on-signals*]]に発生時に中断したいコンディションを指定することで発生場所を特定することが可能です。\n\n{{{\n(define-condition x-error (error) ())\n\n\n(defun foo ()\n  (when (oddp (random 2))\n    (error 'x-error)))\n\n\n(defun bar ()\n  (when (oddp (random 3))\n    (error \"bar!\")))\n\n\n(defun baz ()\n  (handler-case (progn\n                  (foo)\n                  (bar)\n                  (ignore-errors (error \"ignore me\")))\n    (error () nil)))\n}}}\n\n** 通常の実行([[$$hs *break-on-signals*]]はnil)\n{{{\n(baz)\n;=>  NIL\n}}}\n\n** error(とそのサブクラス)を捕捉したい場合\n{{{\n(setq *break-on-signals* 'error)\n\n(baz)\n;!!> Condition X-ERROR was signalled.(fooで中断)\n; or\n;!!> ignore me(ignore-errorsで中断)\n; or\n;!!> bar!(barで中断)\n}}}\n\n** x-error(とそのサブクラス)を捕捉したい場合\n{{{\n(setq *break-on-signals* 'x-error)\n\n(baz)\n;!!> Condition X-ERROR was signalled.(fooで中断)\n}}}\n\n** errorとそのサブクラスでx-error以外を捕捉したい場合\n{{{\n(setq *break-on-signals* '(and error (not x-error)))\n\n(baz)\n;!!> ignore me(ignore-errorsで中断)\n; or\n;!!> bar!(barで中断)\n}}}\n")
(" %Tag:?????' and 'x'='x" . "(1584214737)")
("処理系" . "(:ctime 1227545106 :cuser #f :mtime 1529826720 :muser #f)[[$$tag 処理系]]\n\n- [[処理系:選び方の目安]]\n- [[各処理系毎に違うところ]]\n- [[処理系を表すfeature一覧]]\n- [[初期化ファイル]]\n- [[コマンドラインオプション]]\n- [[処理系:日本語の扱い]]\n----\n- [[SBCL]]\n- [[CLISP]]\n- [[Clozure CL]]\n- [[Clojure]]\n- [[LispWorks]]\n- [[GCL]]\n- [[Symbolics Common Lisp]]\n- [[TI Common Lisp]]\n- [[TOP-1 Common Lisp]]\n")
(" %Tag:???? or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- and 1=1" . "(1587484327)")
(" %Tag:drakma" . "(1668250567 (\"特定のURLからドキュメントを抽出する\" :ctime 1227424335 :cuser #f :mtime 1431159651 :muser #f) (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f) (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
(" %Tag:文字列'[0]" . "(1657544912)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45) --  /*" . "(1624124307)")
("値を真偽値に変換したい" . "(:ctime 1330191360 :cuser #f :mtime 1330191360 :muser #f)Common Lispでは、NIL以外は、真として扱われ、これを利用して真としての返り値にT以外を使う関数があります。(member等が代表的な例です。)\n{{{\n(member :foo '(:foo :bar :baz))\n;=>  (:FOO :BAR :BAZ)\n}}}\n場合によっては、TかNILかだけで値を返したい場合がありますが、慣用句としては、\n{{{\n(and (member :foo '(:foo :bar :baz)) t)\n;=>  T\n\n(and (member :quux '(:foo :bar :baz)) t)\n;=>  NIL\n\n(not (not (member :foo '(:foo :bar :baz))))\n;=>  T\n\n(not (not (member :quux '(:foo :bar :baz))))\n;=>  NIL\n}}}\nのようなものがあるようです。\nまた、\n{{{\n(defun truep (x) (not (not x)))\n\n(defun truthy (x) (not (not x)))\n}}}\nのような関数を作成して利用する人もいるようです。~%\nさらに関数呼び出しのコストが気になる場合は、\n{{{\n(defmacro truep (x) #+development `(not (not ,x)) #-development `,x)\n}}}\nとすることもあるでしょう。また、処理系によっては、(and (member...) t)のようなものを、余計なコストが発生しないようにコンパイルしてくれる処理系もあるようです。\n*** 参考\n- [http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/45ae9d6f831bf4c/08bb52093401d975 generalized boolean (comp.lang.lisp)]\n")
("要素名で探して処理する:cxml-stp" . "(:ctime 1336641072 :cuser #f :mtime 1336642601 :muser #f)XML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"<a xmlns='http://tips.lisp-users.org/common-lisp'><b>1</b><b>1</b><b>9</b><c>2</c></a>\"\n   (stp:make-builder)))\n}}}\n\nstp:filter-recursivelyで該当する要素をリストに抜き出してからリスト処理\n{{{\n(let ((elts (stp:filter-recursively (lambda (c)\n                                      (and (typep c 'stp:element)\n                                           (string= \"b\" (stp:local-name c))))\n                                    *doc* )))\n  (dolist (e elts)\n    (format t\n            \"~A => ~A~%\"\n            (stp:local-name e) (stp:string-value e))))\n;->  b => 1\n;    b => 1\n;    b => 9\n;\n;=>  NIL\n}}}\nstp:of-nameを利用した場合((typep c 'stp:element)(string= \"b\" (stp:local-name c))を一つにまとめたもの)\n{{{\n(let* ((ns (stp:namespace-uri (stp:document-element *doc*)))\n       (elts (stp:filter-recursively (stp:of-name \"b\" ns) *doc* )))\n  (dolist (e elts)\n    (format t\n            \"~A => ~A~%\"\n            (stp:local-name e) (stp:string-value e))))\n;->  b => 1\n;    b => 1\n;    b => 9\n;\n;=>  NIL\n}}}\nstp:do-recursivelyで、リストにはまとめず、再帰的に処理\n{{{\n(stp:do-recursively (e *doc*)\n  (when (and (typep e 'stp:element)\n             (string= \"b\" (stp:local-name e)))\n    (format t\n            \"~A => ~A~%\"\n            (stp:local-name e) (stp:string-value e))))\n;->  b => 1\n;    b => 1\n;    b => 9\n;\n;=>  NIL\n}}}\n")
(" %Tag:日付と時刻' and 'x'='y" . "(1532959359)")
("仮引数で宣言されていないキーワードを渡す" . "(:ctime 1599529695 :cuser #f :mtime 1599529753 :muser #f)仮引数で宣言されていないキーワードを渡すには、呼び出し側の実引数に、\n\n{{{\n:allow-other-keys T\n}}}\n\nを指定します。\n\n{{{\n(defun foo (&key x y)\n  (list x y))\n\n(defun bar (&rest args &key x)\n  (apply #'foo args))\n\n(bar)\n;=> (nil nil)\n\n(bar :y 42)\n;>>> error\n\n(bar :y 42 :allow-other-keys T)\n;=> (nil 42)\n}}}\n\n上記の例の場合、bar呼び出しているfooも\n{{{\n(foo :y 42 :allow-other-keys T)\n}}}\nとなっていることに注意してください。\n\n** 用途\n\n[[$$hs make-instance]] 等、総称関数で引数が多重に定義されている場合や、下請けも同様の引数を持ち回る場合などで問題を回避するために用いられることがあります。\n")
("標準のリードテーブルでライブラリを読み込む" . "(:ctime 1335796589 :cuser #f :mtime 1335796589 :muser #f)[[$$hs load]] や [[$$hs compile-file]] では、実行した環境の [[$$hs *readtable*]] を引き継ぎますので、リードテーブルをカスタマイズして標準から変更している場合、意図しないリーダーマクロの衝突を引き起す可能性があります。~%\n回避策は幾つかありますが、下記のように [[$$hs *raadtable*]] を標準の状態に束縛して読み込むことで回避することが可能です。~%\n\n{{{\n;;; load\n(let ((*readtable* (copy-readtable nil)))\n  (load \"foo.lisp\"))\n\n;;; asdf:load-op\n(let ((*readtable* (copy-readtable nil)))\n  (asdf:oos 'asdf:load-op :foo))\n\n;;; quickload\n(let ((*readtable* (copy-readtable nil)))\n  (ql:quickload :foo))\n\n;;; etc\n}}}\n*** 参照\n[[一時的にリードテーブルを変更して読み込む]]\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae and 1=1#" . "(1656001222)")
("XML" . "(:ctime 1363449059 :cuser #f :mtime 1363452380 :muser #f)Common Lispの規格にはXMLの処理に関することは書かれていませんが、XMLのデータを処理するためのライブラリがいくつか存在します。\n\n- [[XML:Closure XML]]\n- [[XML:XMLS]]\n\n* Closure XML\n\n[http://common-lisp.net/project/cxml/ Closure XML]はCommon Lispで書かれたXMLパーサです。名前空間やスキーマの検証、DOM、SAXなどに対応しているほか、追加のライブラリによって、Relax NG、XPath、XSLT、DOMの代わりになるものとして考案されたSTPなどにも対応します。\n\n* XMLS\n\n[http://www.common-lisp.net/project/xmls/ XMLS]はS式指向のシンプルなXMLパーサです。スキーマを検証したり親切にエラーを報告してくれる機能はありませんが、小さくて高速です。 \n\n")
("日付が何曜日、何日、年初から何日め、年初から何週めになるかを求める" . "(:ctime 1232880617 :cuser #f :mtime 1232880617 :muser #f)[[$$tag 日付と時刻]]\n\n日付についての操作は、標準の組み合わせでも賄えますが、PerlのDate::Calc互換を目指した[[CLiki:date-calc]]ようなライブラリもあり、日付についての関数がまとめられています。\n\n日付が何曜日、何日、年初から何日め、年初から何週めになるかを求めるのは下記のように書けるでしょう。\n{{{\n;; Date::Calc\n(multiple-value-bind (s m h day month year) \n    (decode-universal-time (get-universal-time))\n  (declare (ignore s m h))\n  (list \n   (date-calc:day-of-week year month day)\n   (date-calc:week-number year month day)\n   (date-calc:day-of-year year month day)))\n;; Sun 25 Jan 2009 19:43:42 の場合\n;=> (7 4 25)\n}}}\n")
("SLIME:slime-indentation" . "(:ctime 1529825505 :cuser #f :mtime 1573371720 :muser #f)[[$$tag SLIME]]\n\nEmacsに付属するcl-indent.elの機能を拡張した[[SLIME]]のcontribモジュールです。インデントのスタイルを定義でき、common-lisp-set-styleコマンドで切り替えられるようになっています。\n\n----\n\n[[$$toc]]\n\n----\n\n* 設定\n\nslime-indentationを有効にするには、slime-setupにslime-indentationを指定します。\n\n{{{\n(slime-setup '(slime-fancy slime-indentation))\n}}}\n\nのようなEmacs Lispコードを評価するとロードされます。.emacsに書いておけば良いでしょう。\n\n----\n\n* スタイルの切り替え\n\ncommon-lisp-set-styleコマンドを利用します。M-x common-lisp-set-styleすると\n\n{{{\nSpecify Common Lisp indentation style: \n}}}\n\nというプロンプトがEmacsのミニバッファに表示されるので、スタイルの名前を指定します。\n\n----\n\n* 定義済みのスタイル\n\n:basic:\nすべてのオプションをデフォルトに設定するスタイル。\n:classic:\n1995年当時のcl-indent.elをエミュレートするスタイル。[[$$hs if]]のthen部とelse部のインデントがスペース2個分になり、[[$$hs case]]の各clauseのbody部がkey部よりスペース2個分深くインデントされる。\n:modern:\n汎用的なスタイル。[[$$hs glossary/lambda_list ラムダリスト]]のキーワードとキーワードパラメータを揃え、[[$$hs loop]]のsubclauseのインデントをしない。\n:sbcl:\n[[Steel Bank Common Lisp]]のソースコードで使われているスタイル。modernスタイルをベースに、SBCL固有の構文への対応、タブによるインデントの禁止、78桁での折り返し、whitespace-modeによるタブと連続するスペースの可視化をする。\n\n----\n\n* インデント例\n\n** ラムダリスト\n\n{{{\n;; basic\n(lambda (x y &optional z\n         &key a b\n           c\n         &rest rest)\n  t)\n\n;; modern, sbcl\n(lambda (x y &optional z\n             &key a b\n                  c\n             &rest rest)\n  t)\n\n;; classic\n(lambda (x y &optional z\n         &key a b\n         c\n         &rest rest)\n  t)\n}}}\n\n** if\n\n{{{\n;; basic, modern, sbcl\n(if (atom t)\n    t\n    nil)\n\n;; classic\n(if (atom t)\n  t\n  nil)\n}}}\n\n** case\n\n{{{\n;; basic, modern, sbcl\n(case x\n  ((1 3 5 7 9)\n   :odd)\n  ((0 2 4 6 8)\n   :even))\n\n;; classic\n(case x\n  ((1 3 5 7 9)\n     :odd)\n  ((0 2 4 6 8)\n     :even))\n}}}\n\n** loop\n\n{{{\n;; basic, classic\n(loop for i\n        from 0\n          below 10\n      collect i)\n\n;; modern, sbcl\n(loop for i\n      from 0\n      below 10\n      collect i)\n}}}\n\n----\n\n* 参考資料\n\n- [https://github.com/slime/slime/blob/master/contrib/slime-cl-indent.el slime-cl-indent.el]\n- \"[http://common-lisp.net/project/slime/doc/html/Loading-Contribs.html#Loading-Contribs 8.1 Loading Contrib Packages]\" - [http://common-lisp.net/project/slime/doc/html/ SLIME User Manual]\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45) -- /* order by 'as /*" . "(1624124755)")
("別のプログラムを起動する" . "(:ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f)[[$$tag 入出力 ライブラリ kmrcl]]\n\n* 別のプログラムを起動する\n\n下記の例では、[[CLiki:KMRCL]] の run-shell-command を利用して、firefoxで/etc/fstabを開いています。\nrun-shell-command はシェルを呼び出しシェルの返したステータスを返します。\n{{{\n(let ((myfile \"/etc/fstab\"))\n  (let ((status (kmrcl:run-shell-command \"firefox ~A\" myfile)))\n    status))\n;=> 0 ;成功\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') or(1=1)#" . "(1656001234)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') as tempxtestxtable where 1=1-- -" . "(1656001239)")
(" %Tag:bordeaux-threads" . "(1667934026 (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f) (\"スレッドに引数を渡す\" :ctime 1229082548 :cuser #f :mtime 1229092264 :muser #f))")
("ハッシュをシーケンス(alist、plist、その他)に変換する" . "(:ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f)[[$$tag ハッシュ Alexandria ライブラリ]]\n* ハッシュをシーケンス(alist、plist、その他)に変換する\n自作するか、ライブラリを利用します。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (let ((alist () ))\n    (maphash (lambda (key val)\n               (push (cons key val) alist))\n             ht)\n    alist))\n}}}\n[[ライブラリ:Alexandria]]を利用し、ハッシュテーブルからplistへ変換\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (alexandria:hash-table-plist ht))\n;=> (\"lemon\" 300 \"banana\" 300 \"apple\" 150)\n}}}\n")
(" %Tag:eXgt[[N" . "(1473731616)")
("format:右寄せしたい" . "(:ctime 1337061637 :cuser #f :mtime 1337061637 :muser #f)** 行幅16で右寄せ\n{{{\n(format nil \"~16@A\" \"foo\")\n;=>  \"             foo\"\n}}}\n10進の数字の場合\n{{{\n(format nil \"~16D\" 10)\n;=>  \"              10\"\n}}}\n16進の数字の場合\n{{{\n(format nil \"~16X\" 10)\n;=>  \"               A\"\n}}}\n2進\n{{{\n(format nil \"~16B\" 10)\n;=>  \"            1010\"\n}}}\n8進\n{{{\n(format nil \"~16O\" 10)\n;=>  \"              12\"\n}}}\n2〜36進\n{{{\n(format nil \"~7,16R\" 10)\n;=>  \"              13\"\n}}}\n浮動小数点数\n{{{\n(format nil \"~16F\" 10)\n;=>  \"            10.0\"\n}}}\n浮動小数点数の指数表記\n{{{\n(format nil \"~16E\" 10)\n;=>  \"           1.e+1\"\n}}}\n読み取り可能なS式\n{{{\n(format nil \"~16@S\" '(\"foo\"))\n;=>  \"         (\\\"foo\\\")\"\n}}}\n** 行幅16で右寄せ 埋め草文字は \".\"\n{{{\n(format nil \"~16,,,'.@A\" \"foo\")\n;=>  \".............foo\"\n}}}\n10進の数字の場合\n{{{\n(format nil \"~16,'.D\" 10)\n;=>  \"..............10\"\n}}}\n16進の数字の場合\n{{{\n(format nil \"~16,'.X\" 10)\n;=>  \"...............A\"\n}}}\n2進\n{{{\n(format nil \"~16,'.B\" 10)\n;=>  \"............1010\"\n}}}\n8進\n{{{\n(format nil \"~16,'.O\" 10)\n;=>  \"..............12\"\n}}}\n2〜36進(例では7進)\n{{{\n(format nil \"~7,16,'.R\" 10)\n;=>  \"..............13\"\n}}}\n浮動小数点数\n{{{\n(format nil \"~16,,,,'.F\" 10)\n;=>  \"............10.0\"\n}}}\n浮動小数点数の指数表記\n{{{\n(format nil \"~16,,,,,'.E\" 10)\n;=>  \"...........1.e+1\"\n}}}\n読み取り可能なS式 (余計なものを付けるので当然ながら読み戻せない)\n{{{\n(format nil \"~16,,,'.@S\" '(\"foo\"))\n;=>  \".........(\\\"foo\\\")\"\n}}}\n")
(" %Tag:日付と時刻' or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- 'x'='x" . "(1532959372)")
("ハッシュテーブル" . "(:ctime 1227248242 :cuser #f :mtime 1380362275 :muser #f)- [[プログラム中でハッシュを定義する]]\n- [[キーに関連付けられた値を取得する]]\n- [[ハッシュに要素を追加する]]\n- [[ハッシュ内にキーが存在するかどうか調べる]]\n- [[ハッシュの要素数を取得する]]\n- [[キーが存在しない場合のデフォルト値を設定する]]\n- [[ハッシュからエントリを削除する]]\n- [[ハッシュの全エントリに対して処理を実行する]]\n- [[ハッシュをシーケンス(alist、plist、その他)に変換する]]\n- [[ハッシュを空にする]]\n- [[ハッシュを値で降順、値が等しい場合キーで昇順にソートする]]\n- [[ハッシュの要素をランダムに抽出する]]\n\n")
(" %Tag:配列99999\" union select unhex(hex(version())) -- \"x\"=\"x" . "(1624125395)")
("繰り返し(do)" . "(:ctime 1227416036 :cuser #f :mtime 1350654890 :muser #f)[[$$tag 制御構造]]\n* 繰り返し（do）\n\n繰り返し毎に変化する変数を複数使うことができます。\n\n{{{\n(do ((変数1　初期値1　更新方法1)\n     (変数2　初期値2　更新方法2)\n     ・・・\n     (変数n　初期値n　更新方法n))\n    (終了条件　[戻り値])\n  式　・・・  )\n}}}\n\n初期値１０００で１０％増加する a に~%\n初期値　３００で３０％増加する b が勝つのは何ターン後？\n{{{\n (do ((a 1000 (* a 1.1))\n      (b  300 (* b 1.3))\n      (y    0 (1+ y)))\n     ((> b a) y))\n;=> 8\n}}}\nというように、式を書かないで済ますことも多い。\n")
("null合体演算子" . "(:ctime 1336345762 :cuser #f :mtime 1336345782 :muser #f)C#でいう[http://msdn.microsoft.com/ja-jp/library/ms173224.aspx null合体演算子]のようなものは、lisp系言語では古くから[[$$hs or]]として良く使われていました。\n{{{\n(or a b)\n}}}\n上記の場合、aがnilであれば、bの値が使われ、aが非nilであれば、aの値が返ります。\n")
("&rest引数をとる関数の最適化" . "(:ctime 1338953889 :cuser #f :mtime 1338953938 :muser #f)[[$$hs &rest]]引数をとる関数では、可変長の引数を処理するためのルーチンがオーバーヘッドとなり意図したパフォーマンスが得られない場合があります。~%\n大抵の処理系では、可変長引数の関数は下請けに2引数の関数を持っていますが、\n最適化の際には、可変長の引数を処理するためのルーチンを回避して下請けの固定長引数の関数を直に利用しているかどうか確かめる必要があるでしょう。~%\n確かめる方法には[[$$hs disassemble]]等を利用する、等がありますが、何が効いてくるかは処理系次第になります。\n{{{\n(defconstant 100_000_000 (expt 10 8))\n\n;;; 一億の要素を持つbit-vector\n(declaim ((simple-bit-vector *) *big-vector-simple-bit-vector*))\n(defvar *big-vector-simple-bit-vector*\n  (make-array 100_000_000 :element-type 'bit))\n}}}\nそのまま[[$$hs +]]を使った場合\n{{{\n(reduce #'+ *big-vector-simple-bit-vector*)\n;⇒ 0\n#|------------------------------------------------------------|\nEvaluation took:\n  22.724 seconds of real time\n  22.593413 seconds of total run time (21.861367 user, 0.732046 system)\n  [ Run times consist of 3.092 seconds GC time, and 19.502 seconds non-GC time. ]\n  99.42% CPU\n  54,401,620,446 processor cycles\n  3,200,049,712 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n引数が2つであることがコンパイラに分かるように書いた場合(SBCLの場合)\n{{{\n(reduce (lambda (x y) (+ x y))\n        *big-vector-simple-bit-vector*)\n;⇒ 0\n#|------------------------------------------------------------|\nEvaluation took:\n  4.905 seconds of real time\n  4.904307 seconds of total run time (4.900307 user, 0.004000 system)\n  99.98% CPU\n  11,742,306,462 processor cycles\n  164,368 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n*** +と (lambda (x y) (+ x y))の違い (sbclの場合)\n{{{\n(disassemble (lambda (x y) (+ x y)))\n; disassembly for (LAMBDA (X Y))\n; 515CAEED:       498B442450       MOV RAX, [R12+80]          ; no-arg-parsing entry point\n;      EF2:       4883C010         ADD RAX, 16\n;      EF6:       48C740F851000000 MOV QWORD PTR [RAX-8], 81\n;      EFE:       488968F0         MOV [RAX-16], RBP\n;      F02:       4989442450       MOV [R12+80], RAX\n;      F07:       4981BC24E000000017001020 CMP QWORD PTR [R12+224], 537919511\n;      F13:       7402             JEQ L0\n;      F15:       CC0F             BREAK 15                   ; single-step trap (before)\n;      F17: L0:   488B55F8         MOV RDX, [RBP-8]\n;      F1B:       488B7DF0         MOV RDI, [RBP-16]\n;      F1F:       4C8D1C25E0010020 LEA R11, [#x200001E0]      ; GENERIC-+\n;      F27:       41FFD3           CALL R11\n;      F2A:       480F42E3         CMOVB RSP, RBX\n;      F2E:       498B442450       MOV RAX, [R12+80]\n;      F33:       48C740F000000000 MOV QWORD PTR [RAX-16], 0\n;      F3B:       48C740F800000000 MOV QWORD PTR [RAX-8], 0\n;      F43:       4883E810         SUB RAX, 16\n;      F47:       4989442450       MOV [R12+80], RAX\n;      F4C:       488BE5           MOV RSP, RBP\n;      F4F:       F8               CLC\n;      F50:       5D               POP RBP\n;      F51:       C3               RET\n;      F52:       CC0A             BREAK 10                   ; error trap\n;      F54:       02               BYTE #X02\n;      F55:       18               BYTE #X18                  ; INVALID-ARG-COUNT-ERROR\n;      F56:       54               BYTE #X54                  ; RCX\n}}}\n{{{\n(disassemble #'+)\n; disassembly for +\n; 00CA6240:       .ENTRY +(&REST ARGS)                        ; (FUNCTION\n                                                              ;  (&REST T) ..)\n;      278:       8F4508           POP QWORD PTR [RBP+8]\n;      27B:       E34B             JRCXZ L2\n;      27D:       4C8BD1           MOV R10, RCX\n;      280:       49F7DA           NEG R10\n;      283:       4A8D6495D0       LEA RSP, [RBP+R10*4-48]\n;      288:       488BD9           MOV RBX, RCX\n;      28B:       4883E906         SUB RCX, 6\n;      28F:       761A             JBE L1\n;      291:       4E8D4C9510       LEA R9, [RBP+R10*4+16]\n;      296:       4D31C0           XOR R8, R8\n;      299: L0:   4F8B1401         MOV R10, [R9+R8]\n;      29D:       4E891404         MOV [RSP+R8], R10\n;      2A1:       4983C008         ADD R8, 8\n;      2A5:       4883E902         SUB RCX, 2\n;      2A9:       75EE             JNE L0\n;      2AB: L1:   488BCB           MOV RCX, RBX\n;      2AE:       488955C8         MOV [RBP-56], RDX\n;      2B2:       4883F902         CMP RCX, 2\n;      2B6:       7414             JEQ L3\n;      2B8:       48897DC0         MOV [RBP-64], RDI\n;      2BC:       4883F904         CMP RCX, 4\n;      2C0:       740A             JEQ L3\n;      2C2:       488975B8         MOV [RBP-72], RSI\n;      2C6:       EB04             JMP L3\n;      2C8: L2:   488D65D0         LEA RSP, [RBP-48]\n;      2CC: L3:   488D748CF8       LEA RSI, [RSP+RCX*4-8]\n;      2D1:       BB17001020       MOV EBX, 537919511\n;      2D6:       E35A             JRCXZ L7\n;      2D8:       488D14CD00000000 LEA RDX, [RCX*8]\n;      2E0:       49896C2440       MOV [R12+64], RBP\n;      2E5:       4D8B5C2418       MOV R11, [R12+24]\n;      2EA:       4C01DA           ADD RDX, R11\n;      2ED:       4939542420       CMP [R12+32], RDX\n;      2F2:       0F86CA000000     JBE L14\n;      2F8:       4989542418       MOV [R12+24], RDX\n;      2FD:       498D5307         LEA RDX, [R11+7]\n;      301: L4:   FD               STD\n;      302:       488BDA           MOV RBX, RDX\n;      305:       EB08             JMP L6\n;      307: L5:   4883C210         ADD RDX, 16\n;      30B:       488952F1         MOV [RDX-15], RDX\n;      30F: L6:   488B06           MOV RAX, [RSI]\n;      312:       4883EE08         SUB RSI, 8\n;      316:       488942F9         MOV [RDX-7], RAX\n;      31A:       4883E902         SUB RCX, 2\n;      31E:       75E7             JNE L5\n;      320:       48C7420117001020 MOV QWORD PTR [RDX+1], 537919511\n;      328:       FC               CLD\n;      329:       49316C2440       XOR [R12+64], RBP\n;      32E:       7402             JEQ L7\n;      330:       CC09             BREAK 9                    ; pending interrupt trap\n;      332: L7:   4881FB17001020   CMP RBX, 537919511\n;      339:       0F847F000000     JEQ L13\n;      33F:       488B4B01         MOV RCX, [RBX+1]\n;      343:       488B53F9         MOV RDX, [RBX-7]\n;      347:       F6C201           TEST DL, 1\n;      34A:       741A             JEQ L8\n;      34C:       80FA19           CMP DL, 25\n;      34F:       7415             JEQ L8\n;      351:       8BC2             MOV EAX, EDX\n;      353:       240F             AND AL, 15\n;      355:       3C0F             CMP AL, 15\n;      357:       7558             JNE L12\n;      359:       8B42F1           MOV EAX, [RDX-15]\n;      35C:       3C15             CMP AL, 21\n;      35E:       7606             JBE L8\n;      360:       2C1D             SUB AL, 29\n;      362:       3C0C             CMP AL, 12\n;      364:       774B             JNBE L12\n;      366: L8:   EB3A             JMP L10\n;      368:       90               NOP\n;      369:       90               NOP\n;      36A:       90               NOP\n;      36B:       90               NOP\n;      36C:       90               NOP\n;      36D:       90               NOP\n;      36E:       90               NOP\n;      36F:       90               NOP\n;      370: L9:   48895DF0         MOV [RBP-16], RBX\n;      374:       8BC1             MOV EAX, ECX\n;      376:       240F             AND AL, 15\n;      378:       3C07             CMP AL, 7\n;      37A:       7561             JNE L15\n;      37C:       488BC1           MOV RAX, RCX\n;      37F:       488B4001         MOV RAX, [RAX+1]\n;      383:       488945F8         MOV [RBP-8], RAX\n;      387:       488B79F9         MOV RDI, [RCX-7]\n;      38B:       4C8D1C25E0010020 LEA R11, [#x200001E0]      ; GENERIC-+\n;      393:       41FFD3           CALL R11\n;      396:       480F42E3         CMOVB RSP, RBX\n;      39A:       488B5DF0         MOV RBX, [RBP-16]\n;      39E:       488B4DF8         MOV RCX, [RBP-8]\n;      3A2: L10:  4881F917001020   CMP RCX, 537919511\n;      3A9:       75C5             JNE L9\n;      3AB: L11:  488BE5           MOV RSP, RBP\n;      3AE:       F8               CLC\n;      3AF:       5D               POP RBP\n;      3B0:       C3               RET\n;      3B1: L12:  488B0578FEFFFF   MOV RAX, [RIP-392]         ; 'NUMBER\n;      3B8:       CC0A             BREAK 10                   ; error trap\n;      3BA:       03               BYTE #X03\n;      3BB:       1F               BYTE #X1F                  ; OBJECT-NOT-TYPE-ERROR\n;      3BC:       95               BYTE #X95                  ; RDX\n;      3BD:       15               BYTE #X15                  ; RAX\n;      3BE: L13:  31D2             XOR EDX, EDX\n;      3C0:       EBE9             JMP L11\n;      3C2: L14:  492B542418       SUB RDX, [R12+24]\n;      3C7:       52               PUSH RDX\n;      3C8:       4C8D1C2540354200 LEA R11, [#x423540]        ; alloc_tramp\n;      3D0:       41FFD3           CALL R11\n;      3D3:       5A               POP RDX\n;      3D4:       488D5207         LEA RDX, [RDX+7]\n;      3D8:       E924FFFFFF       JMP L4\n;      3DD: L15:  CC0A             BREAK 10                   ; error trap\n;      3DF:       02               BYTE #X02\n;      3E0:       02               BYTE #X02                  ; OBJECT-NOT-LIST-ERROR\n;      3E1:       55               BYTE #X55                  ; RCX\n}}}\n")
(" %Tag:日付と時刻 AND 1=1" . "(1532959363)")
("#xNNNNNNという16進RGB形式を色ごとに分解する" . "(:ctime 1235192973 :cuser #f :mtime 1235213428 :muser #f)[[$$tag 数値]]\n\nHTMLの色の指定などで利用される、16進のRGB形式(#00ff00 etc)ですが、色ごとに分解して扱うには、[[$$hs ldb]]等でビットフィールドを操作することになるでしょう。\n下記では、#xNNNNNNという数値を、NN. NN. NN. のR、G、Bの数値とみなして分解し、他の形式(1を最高値に設定したsingle-floatの数値のリスト)に変換しています。\n{{{\n(defun |#xNNNNNN-to-(N.N N.N N.N)| (num)\n  (mapcar (lambda (x) (/ x 255s0))\n          (list (ldb (byte 8 16) num)\n                (ldb (byte 8  8) num)\n                (ldb (byte 8  0) num))))\n}}}\n\n使用例\n{{{\n;; LispWorks\n(apply #'color:make-rgb\n       (|#xNNNNNN-to-(N.N N.N N.N)| #xabcdef))\n;=> #(:RGB 0.67058826 0.8039216 0.9372549)\n}}}\n\n** 変更履歴\n{{{\n(defun |#xNNNNNN-to-(N.N N.N N.N)| (num)\n  (mapcar (lambda (x) (/ x 255s0))\n          (list (ldb (byte 8 16) num)\n                (ldb (byte 8  8) num)\n                (ldb (byte 8  0) num))))\n}}}\nで良いような気がします。\n\nその通りでした!\n当初255で割るコードでなかったのを、そのまま引き継いでいました。\n頂いた例に変更しました。 --g000001\n\n")
("発生したコンディションからの回復手段（再起動）を提供する" . "(:ctime 1236617333 :cuser #f :mtime 1238213866 :muser #f)[[$$tag コンディション]]\n\n発生したエラーについて単に上位側に通知するだけでなく、どのように回復できるかという手段を上位側に提供できます。\n\n次の関数fooはerror関数でエラーを通知するだけのものです。しかし同時に再起動も提供しています。\n{{{\n(defun foo ()\n  (restart-case (error \"Error!\")\n    (use-value (value)        ;与えられた値を返す再起動\n     :report \"Use a value.\"\n     :interactive (lambda () \n                    (format t \"New value: \")\n                    (list (read)))\n     value)\n    (ignore ()                ;エラーを無視する(NILを返す)再起動\n     :report \"Ignore.\"\n     nil)))\n}}}\n\n普通に呼び出すとエラーが通知されデバッガに落ちるなどします。\n{{{\n(foo)\n; Evaluation aborted.\n}}}\n\nデバッガから対話的に再起動の方法を選ぶほかにプログラムからも制御できます。\n{{{\n(handler-bind ((error  ;フォームからerror型のコンディションを受けたら \n                (lambda (c) \n                  (declare (ignore c)) ;(引数にコンディションを受け取るのだけど今は無視します)\n                  (invoke-restart 'use-value 10)))) ;use-value再起動を引数付きで呼び出します\n  (foo))              ;評価するフォーム\n; => 10\n(handler-bind ((error (lambda (c) \n                       (declare (ignore c))\n                       (invoke-restart 'ignore))))\n  (foo))\n; => NIL\n}}}\n")
("Clozure CL" . "(:ctime 1566555078 :cuser #f :mtime 1566555078 :muser #f)(length '(a b c))\n")
("リストの点対表記を生成したい" . "(:ctime 1333797563 :cuser #f :mtime 1333797563 :muser #f)リスト:\n{{{\n((A B (C NIL D (E NIL NIL F))))\n}}}\nは、点対の表記では、\n{{{\n((A B (C NIL D (E NIL NIL F . NIL) . NIL) . NIL) . NIL)\n}}}\nとなります。リストから点対の表記を生成したい場合、手抜きですが[[$$hs subst]]を利用して nil を\"nil\"等に置き換えることでも実現できるでしょう\n\n{{{\n(format t \"~A\" (subst \"()\" nil '((A B (C () D (E () () F))))))\n;->  ((A B (C () D (E () () F . ()) . ()) . ()) . ())\n;=>  NIL\n\n(format t \"~A\" (subst \"NIL\" nil '((A B (C () D (E () () F))))))\n;->  ((A B (C NIL D (E NIL NIL F . NIL) . NIL) . NIL) . NIL)\n;=>  NIL\n}}}\n")
(" %Tag:【募集中】/plugins/system/debug/debug.xml" . "(1585999576)")
("配列を空にする" . "(:ctime 1228630645 :cuser #f :mtime 1228630645 :muser #f)[[$$tag 配列]]\n\n* 配列を空にする\n\n配列の要素を削除して空にする訳ではありませんが、フィルポインタ付きのベクタの場合、フィルポインタを0にセットすることにより空にすることが可能です。FIXME\n{{{\n(let ((a (make-array 3 :adjustable T \n                       :fill-pointer 3\n                       :initial-contents '(1 2 3))))\n  (print a)\n  (setf (fill-pointer a) 0)             ;フィルポインタを0にセット\n  (print a)                             ;#()になった\n  (vector-push 'a a)                    ;'Aをプッシュ\n  (print a))                            ;#(A)になった\n;-> #(1 2 3) \n;-> #() \n;-> #(A)\n;=> #(A)\n}}}\n")
(" %Tag:Webオートメーション'A=0" . "(1565908908)")
(" %Tag:os" . "(1668118543 (\"Linuxのディストリビューションを判定する\" :ctime 1586446374 :cuser #f :mtime 1586447198 :muser #f) (\"OS\" :ctime 1586446166 :cuser #f :mtime 1586446166 :muser #f))")
(" %Tag:prove" . "(1667934170 (\"prove\" :ctime 1460644309 :cuser #f :mtime 1460644309 :muser #f))")
("配列に要素を追加する" . "(:ctime 1228549816 :cuser #f :mtime 1228549869 :muser #f)[[$$tag 配列]]\n\n* 配列に要素を追加する\nフィルポインタ付きでベクタを作成すると後に要素を追加することが可能です。\n追加には、 [[$$hs vector-push]] や、 [[$$hs vector-push-extend]] を使用します。\nリストと違い要素は末尾に追加されて行きます。\n{{{\n(let ((a (make-array 10 :adjustable T :fill-pointer 0)))\n  (vector-push 1 a)\n  (vector-push 2 a)\n  (vector-push 3 a)\n  a)\n;=> #(1 2 3)\n}}}\n先頭に追加する場合\nvector-push-frontという関数を自作 FIXME \n;; 他にもっと良い方法がある気がする…。\n{{{\n(defun vector-push-front (new-el array)\n  (incf (fill-pointer array))\n  (setf (subseq array 1) (subseq array 0)\n        (aref array 0) new-el))\n\n(let ((a (make-array 1 :adjustable T :fill-pointer 0)))\n  (vector-push 1 a)\n  (vector-push 2 a)\n  (vector-push 3 a)\n  (vector-push-front 0 a)\n  a)\n;=> #(0 1 2 3)\n}}}\n")
(" %Tag:????" . "(1587484314)")
("HTML を処理する" . "(:ctime 1231232078 :cuser #f :mtime 1336654189 :muser #f)[[$$tag インターネットサービス HTML]]\n\n* HTML を処理する\n\nHTML から必要な情報を抜き出すためのライブラリは様々ありますが、下記では、[[CLiki:closure-html]]を使用しています。\n\n# drakma:http-requestでWilikiのページ一覧を取得し\n# <li>の項目の数を数える\n\n{{{\n(defun count-pages (url)\n  (let* ((page (drakma:http-request url))\n         (doc (chtml:parse page (cxml-stp:make-builder)))\n         (ans 0))\n    (stp:do-recursively (a doc)\n      (when (and (typep a 'stp:element)\n                 (equal (stp:local-name a) \"li\"))\n        (incf ans)))\n    ans))\n\n;; 試してみる\n(mapcar #'count-pages\n        '(\"http://practical-scheme.net/wiliki/wiliki.cgi?c=a\"\n          \"http://tips.lisp-users.org/common-lisp/index.cgi?c=a\"\n          \"http://tips.lisp-users.org/scheme/index.cgi?c=a\"))\n;=>(942 202 114)\n}}}\n# drakma:http-requestでWilikiのページ一覧を取得し\n# <li>の項目の中の文字列を取得する\n\n{{{\n(defun all-items (url)\n  (let* ((page (drakma:http-request url))\n         (doc (chtml:parse page (cxml-stp:make-builder)))\n         (ns (stp:namespace-uri (stp:document-element doc))))\n    (mapcar #'stp:string-value\n            (stp:filter-recursively (stp:of-name \"li\" ns) doc))))\n\n;; 逆引きSchemeに存在して 逆引きCLに存在しない項目をリストにする\n(let ((p1 (all-items \"http://tips.lisp-users.org/common-lisp/index.cgi?c=a\"))\n      (p2 (all-items \"http://tips.lisp-users.org/scheme/index.cgi?c=a\")))\n  (set-difference p2 p1 :test #'string=))\n;=> (\"CGI を作る\" \"CPUのエンディアンを調べる\" ...)\n}}}\n")
("多値" . "(:ctime 1319129540 :cuser #f :mtime 1319129540 :muser #f)[[$$tag 多値]]\n\n- [[多値を変数に代入する]]\n- [[有意な値を返さない]]\n- [[多値を連結する]]\n")
(" %Tag:ハッシュ'A=0" . "(1564982758)")
("正規表現機能別一覧" . "(:ctime 1382545936 :cuser #f :mtime 1382729547 :muser #f)[[$$tag 正規表現]]\n\n- 注意\n-- Common Lispの文字列の表現では、\"\\x\"と記述した場合は\"x\"と等価になります。~%\nこのためバックスラッシュを含む表現の場合、バックスラッシュ自体をエスケープして\"\\\\x\"と記述する必要があります。\n\n||||cl-ppcre||ACL regexp2||Perl (5.8)||\n||任意の1文字||.||.||.||\n||いずれか1文字||[…]||[…]||[…]||\n||いずれか以外の1文字||[^…]||[^…]||[^…]||\n||エスケープ||\\\\||\\\\||\\\\||\n||選択||r1|r2||r1|r2||r1|r2||\n||一回または零回（欲張り）||?||?||?||\n||零回以上（欲張り）||*||*||*||\n||一回以上（欲張り）||+||+||+||\n||n回以上m回以下（欲張り）||{n,m}||{n,m}||{n,m}||\n||n回以上（欲張り）||{n,}||{n,}||{n,}||\n||零回以上n回以下（欲張り）||{,n}||{,n}||{,n}||\n||n回（欲張り）||{n}||{n}||{n}||\n||一回または零回（ものぐさ）||??||??||??||\n||零回以上（ものぐさ）||*?||*?||*?||\n||一回以上（ものぐさ）||+?||+?||+?||\n||n回以上m回以下（ものぐさ）||{n,m}?||{n,m}?||{n,m}?||\n||n回以上（ものぐさ）||{n,}?||{n,}?||{n,}?||\n||零回以上n回以下（ものぐさ）||{,n}?||{,n}?||{,n}?||\n||行先頭||^||^||^||\n||行末尾||$||$||$||\n||単語先頭||なし||なし||なし||\n||単語末尾||なし||なし||なし||\n||単語境界||\\b||\\b||\\b||\n||非単語境界||\\B||\\B||\\B||\n||文字列先頭||\\A||\\A||\\A||\n||文字列末尾、または文字列末尾の改行の直前||\\Z||\\Z||\\Z||\n||文字列末尾||\\z||\\z||\\z||\n||グループ||('''regex''')  ||('''regex''')  ||('''regex''')  ||\n||グループ(キャプチャ無し)||(?:'''regex''')  ||(?:'''regex''')  ||(?:'''regex''')  ||\n||肯定先読み/後方一致指定||(?='''regex''')||(?='''regex''')||(?='''regex''')||\n||否定先読み||(?!'''regex''')||(?!'''regex''')||(?!'''regex''')||\n||肯定戻り読み||(?<='''regex''')||(?<='''regex''')||(?<='''regex''')||\n||否定戻り読み||(?<!'''regex''')||(?<!'''regex''')||(?<!'''regex''')||\n||バックトラック禁止||(?>式)||(?>式)||(?>式)||\n||条件付き展開||(?(?cond)true|false)||(?(?cond)true|false)||(?(?cond)true|false)||\n||名前付きキャプチャ||(?<name>式)||(?<name>式)||(?<name>式)||\n||名前付きキャプチャ参照||\\k<name> ※1||\\k<name>||\\k<name>||\n||キャプチャ参照||\\1 \\2 \\3 ...||\\1 \\2 \\3 ...||\\1 \\2 \\3 ...||\n||正規表現内のスペースを無視する||(?x:'''regex''')||(?x:'''regex''')||(?x:'''regex''')||\n||「.」を改行にマッチさせる~%(シングルラインモード)||(?s:'''regex''')||(?s:'''regex''')||(?s:'''regex''')||\n||「^」と「$」を行の先頭と末尾にマッチさせる~%(マルチラインモード)||(?m:'''regex''')||(?m:'''regex''')||(?m:'''regex''')||\n||大文字と小文字を区別しない||(?i:'''regex''')||(?i:'''regex''')||(?i:'''regex''')||\n||正規表現内のスペースを無視する||(?x:'''regex''') ※2||(?x:'''regex''')||(?x:'''regex''')||\n||水平タブ||\\t||\\t||\\t||\n||垂直タブ||なし||なし||\\v||\n||改行||\\n||\\n||\\n||\n||復帰||\\r||\\r||\\r||\n||バックスペース||\\b||\\b||\\b||\n||改ページ||\\f||\\f||\\f||\n||ベル||\\a||\\a||\\a||\n||エスケープ||\\e||\\e||\\e||\n||制御文字表現||\\c||\\c||\\c||\n||8進数表現||\\nnn||\\nnn||\\nnn||\n||16進数表現||\\xHH||\\xHH||\\xHH||\n||単語構成文字||\\w||\\w||\\w||\n||非単語構成文字||\\W||\\W||\\W||\n||空白文字||\\s||\\s||\\s||\n||非空白文字||\\S||\\S||\\S||\n||10進数字||\\d||\\d||\\d||\n||非10進数字||\\D||\\D||\\D||\n||16進数字||なし||\\h||\\h||\n||非16進数字||なし||\\H||\\H||\n||8進数字||なし||なし||なし||\n||非8進数字||なし||なし||なし||\n||Unicodeプロパティによる文字クラス指定||\\p ※3||なし||\\p||\n||Unicodeプロパティによる文字クラス指定の否定||\\P ※3||なし||\\P||\n||正規表現文字のエスケープ||\\Q'''regex'''\\E ※4||なし||\\Q'''regex'''\\E||\n\n\n※1 cl-ppcre:*allow-named-registers* を非nilに設定した場合、正規表現文字列の中だけで使える~%\n{{{\n(let* ((ppcre:*allow-named-registers* T)\n       (re (ppcre:create-scanner \"(?<quux>foo)\\\\k<quux>\"))) ;コンパイルする\n  (ppcre:scan-to-strings re \"barfoofoobar\"))\n;=>  \"foofoo\"\n;    #(\"foo\")\n}}}\n{{{\n;;; allegro cl regexp2\n(replace-re  \"bazfoofoobar\"\n             \"(?<baz>.*)(?<foo>foo)\\\\k<foo>(?<bar>.*)\"\n             \"\\\\k<foo>,\\\\k<bar>,\\\\k<baz>,quux\")\n;=>  \"foo,bar,baz,quux\"\n\n\n(let* ((ppcre:*allow-named-registers* 'T)\n       (re (ppcre:create-scanner \"(?<baz>.*)(?<foo>foo)\\\\k<foo>(?<bar>.*)\")))\n  (ppcre:regex-replace re \n                       \"bazfoofoobar\" \n                       \"\\\\k<foo>,\\\\k<bar>,\\\\k<baz>,quux\"))\n;=>  \"\\\\k<foo>,\\\\k<bar>,\\\\k<baz>,quux\"\n;    T\n\n;;; 参考:番号での参照\n(let* ((ppcre:*allow-named-registers* 'T)\n       (re (ppcre:create-scanner \"(.*)(foo)\\\\2(.*)\")))\n  (ppcre:regex-replace re \n                       \"bazfoofoobar\" \n                       \"\\\\2,\\\\3,\\\\1,quux\"))\n;=>  \"foo,bar,baz,quux\"\n;    T\n}}}\n※2 コメントは、『;』ではなくPerl互換の『#』で開始\n{{{\n(ppcre:scan-to-strings \"(?x:\nfoo  #ふー\nbar  #ばー\nbaz  #ばず\n)\" \"foobarbaz\")\n;=>  \"foobarbaz\"\n;    #()\n}}}\n※3 cl-ppcre-unicodeを導入することにより利用可能\n{{{\n(ql:quickload :cl-ppcre-unicode)\n\n(ppcre:scan \"\\\\p{Letter}+\" \"あaＡＢｃ123\")\n;=>  0\n;    5\n;    #()\n;    #()\n}}}\n※4 cl-ppcre:*allow-quoting*を非nilにした場合に利用可能\n{{{\n(let* ((ppcre:*allow-quoting* t)\n       (re (ppcre:create-scanner \"\\\\Q.txt\\\\E\")))\n  (values (ppcre:scan-to-strings re \".txt\")\n          (ppcre:scan-to-strings re \"otxt\")))\n;=>  \".txt\"\n;    NIL\n}}}\n")
(" %Tag:【募集中】/js/header-rollup-554.js" . "(1585999588)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45) -- /* order by 'as /*" . "(1624124654)")
("計算結果を分数から小数にしたい" . "(:ctime 1227349345 :cuser #f :mtime 1238675808 :muser #f)[[$$tag 数値]]\n* 計算結果を分数から小数にしたい\n分数の状態は、計算結果が ratio となっているので float 関数で変換します。\n{{{\n(float (/ 2 3)) ;=> 0.6666667\n}}}\ndouble-floatにしたい場合は二番目の引数に適当に double-float を指定します。\n{{{\n(float (/ 2 3) 1.0d0)                   ;=> 0.6666666666666666d0\n}}}\n変換するだけならば、coerce を使ったり適当に演算したりという方法もあります。\n{{{\n(coerce 2/3 'double-float)              ;=> 0.6666666666666666d0\n(* 2/3 1.0d0)                           ;=> 0.6666666666666666d0\n(+ 2/3 0.0d0)                           ;=> 0.6666666666666666d0\n}}}\n\n* 計算結果を小数から分数にしたい\nrationalまたはrationalizeを使います。\n{{{\n(rational 0.6666667)\n;=> 11184811/16777216\n(rationalize 0.6666667)\n;=> 2/3\n}}}\n\nrationalが厳密に等しい有理数を返すのにたいし、rationalizeは浮動小数点表現の精度を考慮した近似値を返します。\n\n")
(" %Tag:インターネットサービス'[0]" . "(1657808729)")
(" %Tag:local-time and 1=2#" . "(1660041629)")
(" %Tag:local-time and 1=1-- -" . "(1660041654)")
("1のビットを数え上げる" . "(:ctime 1238600498 :cuser #f :mtime 1238600548 :muser #f)[[$$tag 数値]]\n\n[[$$hs integer]]の1のビットを数え上げるには、[[$$hs logcount]]が利用できます。\n\n{{{\n(logcount #b11111111)\n;=> 8\n\n(logcount 255)\n;=> 8\n\n(logcount 256)\n;=> 1\n}}}\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45) -- /* order by 'as /*" . "(1624124520)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45) -- /* order by \"as /*" . "(1624124812)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae or(1=1)-- -" . "(1656001227)")
("パッケージを作りたい" . "(:ctime 1227800307 :cuser #f :mtime 1434017204 :muser #f)[[$$tag パッケージ]]\n* パッケージを作りたい\n一番オーソドックスな方法としては、defpackageを利用してパッケージを作ります。\n\nfooというパッケージを作る場合\n{{{\n(defpackage :foo (:use :cl))\n}}}\nこれは、fooという名前のパッケージを作り、cl(common-lisp)パッケージのシンボルをuseしています。\n通常clパッケージは常にuseして利用することが多いです。\nclパッケージのシンボルはuseしないことも可能ですが、その場合、clパッケージのシンボルはすべてプレフィクス付きで記述する必要があります。~%\nclパッケージをuseしない場合は、(:use)というようにclパッケージの記述を抜いた:use節を記述します。:use節を省略した場合は処理系のデフォルトでuseされるパッケージがuseされることになりclパッケージがuseされる場合があります。\n\nまた、defpackageでのパッケージ名では、fooと書かれたり、:foo、#:foo、\"FOO\"と様々ありますが、パッケージ名は、[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_designator string designator]であること、と規定されていますので、どれも同じ意味を持ちます。\n\ndefpackageはマクロで上記の内容は、\n{{{\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (make-package :foo)      ; fooパッケージを作成\n  (use-package :cl :foo))  ; clパッケージをfooでuseする\n}}}\nに近いものになります。\n\n:use 指定では外部パッケージのシンボルをすべてインポートしますが、一部だけインポートあるいは一部を除いてインポートすることもできます。\n:export 指定で外部にエクスポートするシンボルを指定できます。\n\n{{{\n(defpackage :foo (:use :cl)\n  (:import-from :ppcre :register-groups-bind)\n  (:shadow :scan)\n  (:export :save :load))\n}}}\n\n")
(" %Tag:local-time' and 1=1-- -" . "(1660041657)")
(" %Tag:オブジェクトシステム(CLOS)'" . "(1594964726)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45) -- /* order by 'as /*" . "(1624124631)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' or (1=1) and 'a'='a" . "(1656001221)")
(" %Tag:local-time') and 1=2#" . "(1660041696)")
(" %Tag:マクロ" . "(1668191441 (\"マクロ\" :ctime 1229194985 :cuser #f :mtime 1588024744 :muser #f) (\"一時的にリードテーブルを変更して読み込む\" :ctime 1229846380 :cuser #f :mtime 1229846380 :muser #f) (\"リードテーブルを標準の状態に復元する方法\" :ctime 1229195021 :cuser #f :mtime 1229195129 :muser #f) (\"確実に後処理を行なう\" :ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f))")
(" %Tag:trivial-http" . "(1668289539 (\"特定のURLからファイルをダウンロードする\" :ctime 1431153805 :cuser #f :mtime 1431269795 :muser #f))")
(" %Tag:配列\" or (1,2)=(select*from(select name_const(CHAR(120,102,89,74,111,86,118,78,69,101),1),name_const(CHAR(120,102,89,74,111,86,118,78,69,101),1))a) -- \"x\"=\"x" . "(1624125362)")
("コマンドライン" . "(:ctime 1397291363 :cuser #f :mtime 1608385391 :muser #f)- [[コマンドラインオプション]]\n- [[スクリプトの実行]]\n- [[環境変数を取得する]]\n- [[ソースファイルの拡張子]]\n- [[trivial-shell]]\n- [[inferior-shell]]\n")
("リストを平坦にする" . "(:ctime 1302448675 :cuser #f :mtime 1302448825 :muser #f)[[$$tag リスト alexandria kmrcl ライブラリ]]\n\nリストを含むリスト（いわゆるツリー）を平坦なリストにする処理は、自分でも簡単に書くことができるでしょうが、古くからflattenという名前の関数として知られていて、[[CLiki:Alexandria]]や[[CLiki:KMRCL]]などのライブラリに収録されています。\n\n{{{\n(alexandria:flatten '(0 (1 (2 (3) 4) 5)))\n;=> (0 1 2 3 4 5)\n}}}\n")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45) --  /*" . "(1624124274)")
("Ltk:pack後のオブジェクトのパラメータ設定をする" . "(:ctime 1619742134 :cuser #f :mtime 1619744725 :muser #f)* pack後のオブジェクトに対するパラメータ設定(configure)\n\n{{{\n;;; pack後のオブジェクトに対するパラメータ設定(configure)\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-10\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-10)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"ConfigureによるRGB設定テスト\")\n    (let* (\n           ;; ベース用フレーム(赤色)\n           (f-red (make-instance\n                     'frame))\n\n           ;; ベース用フレーム(青色)\n           (f-blue (make-instance\n                     'frame))\n\n           ;; ベース用フレーム(緑色)\n           (f-green (make-instance\n                     'frame))\n\n           ;; ベース用フレーム(ボタン)\n           (f-btn (make-instance\n                     'frame))\n           \n\n           ;; RGB値目視用ラベル\n           (lbl-rgb (make-instance\n                     'label\n                     :master f-btn\n                     :text \"RGB Color\"))\n           \n           ;; 赤色ラベル\n           (lbl-red (make-instance\n                     'label\n                     :text \"  RED:\"\n                     :master f-red))\n           \n           ;; 青色ラベル\n           (lbl-blue (make-instance\n                     'label\n                     :text \" BLUE:\"\n                     :master f-blue))\n\n           ;; 緑色ラベル\n           (lbl-green (make-instance\n                     'label\n                     :text \"GREEN:\"\n                     :master f-green))\n\n           ;; 赤色スケール値\n           (lbl-scale-red (make-instance 'label\n                                         :master f-red\n                                         :foreground :red\n                                         :text \"00\"))\n\n           ;; 青色スケール値\n           (lbl-scale-blue (make-instance 'label\n                                          :master f-blue\n                                          :foreground :blue\n                                          :text \"00\"))\n\n           ;; 緑色スケール値\n           (lbl-scale-green (make-instance 'label\n                                           :master f-green\n                                           :foreground :green\n                                           :text \"00\"))\n\n           ;; 赤色スケール\n           (sc-red (make-instance 'scale\n                                  :master f-red\n                                  :from 0\n                                  :to 255\n                                  :length 300\n                                  :command (lambda (value)\n                                             (setf (text lbl-scale-red) (format nil \"~2,'0x\" (floor value))) ;１６進数でラベルに表示(必ず２桁表示)\n                                             (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-green) (text lbl-scale-blue)))\n                                             )))\n           ;; 青色スケール\n           (sc-blue (make-instance 'scale\n                                   :master f-blue\n                                   :from 0\n                                   :to 255\n                                   :length 300\n                                   :command (lambda (value)\n                                              (setf (text lbl-scale-blue) (format nil \"~2,'0x\" (floor value))) ;１６進数でラベルに表示(必ず２桁表示)\n                                              (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-green) (text lbl-scale-blue)))\n                                              )))\n           ;; 緑色スケール\n           (sc-green (make-instance 'scale\n                                    :master f-green\n                                    :from 0\n                                    :to 255\n                                    :length 300\n                                    :command (lambda (value)\n                                               (setf (text lbl-scale-green) (format nil \"~2,'0x\" (floor value))) ;１６進数でラベルに表示(必ず２桁表示)\n                                               (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-green) (text lbl-scale-blue)))\n                                               )))\n\n\n           ;; RGB値取得\n           (btn-get-scale (make-instance\n                           'button\n                           :master f-btn\n                           :text \"Get RGB!!\"\n                           :command (lambda ()\n                                      (format t \"ボタンを押しました~%\"))))\n           \n           ;; 終了\n           (btn-close (make-instance\n                       'button\n                       :text \"終了\"\n                       :command (lambda ()\n                                  (format t \"終了\")\n                                  (setf *exit-mainloop* t))))\n           )\n\n      ;; ベースフレームの配置\n      (pack (list f-red f-blue f-green f-btn) :side :top :fill :both :expand :yes)\n\n      ;; 赤色設定フレーム内の配置\n      (pack lbl-red :side :left :fill :both :expand :yes)\n      (pack (list lbl-scale-red sc-red) :side :top :fill :both :expand :yes)\n\n      ;; 青色設定フレーム内の配置\n      (pack lbl-blue :side :left :fill :both :expand :yes)\n      (pack (list lbl-scale-blue sc-blue) :side :top :fill :both :expand :yes)\n\n      ;; 緑色設定フレーム内の配置\n      (pack lbl-green :side :left :fill :both :expand :yes)\n      (pack (list lbl-scale-green sc-green) :side :top :fill :both :expand :yes)\n\n      ;; ボタンフレーム内の配置\n      (pack (list lbl-rgb btn-get-scale btn-close) :side :top :fill :both :expand :yes)\n\n\n      ;; ボタンクリックでボタンの前景色を変更する\n      (configure lbl-red :background :red)\n      (configure lbl-blue :background :blue)\n      (configure lbl-green :background :green)\n;      (configure lbl-rgb :background \"#FF00FF\")\n      (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-blue) (text lbl-scale-green)))\n      )))\n\n(main)\n\n}}}\n")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45) -- /* order by \"as /*" . "(1624124993)")
("キーワード引数を使って大域変数を束縛する" . "(:ctime 1296990237 :cuser #f :mtime 1296990361 :muser #f)キーワード引数で受けとった値を大域変数に束縛することがあります\n{{{\n(defun print-bar (obj &key (base 10))\n  (let ((*print-base* base))\n    (print obj)))\n\n(print-bar 33)\n;->\n;   33\n;=> 33\n\n(print-bar 33 :base 16)\n;->\n;   21\n;=> 33\n}}}\nこのような場合は、\n{{{\n(defun print-foo (obj &key ((:base *print-base*) 10))\n  (print obj))\n\n(print-foo 33)\n;->\n;   33\n;=> 33\n\n(print-foo 33 :base 16)\n;->\n;   21\n;=> 33\n}}}\nと書くことが可能です。~%\n上記の場合、関数定義フォームのボディ全体が(let ((*print-base* base)...)で囲まれたと考えることもできるでしょう。(baseという変数は参照できませんが)\n** 議論\n")
("同一のインターンされないシンボルを複数個所で使う" . "(:ctime 1233607862 :cuser #f :mtime 1233794032 :muser #f)[[$$tag シンボル]]\n\nCLでは、インターンされないシンボルを記述することができ、#:fooのように記述します。\n#:はリーダマクロで、リーダは#:に遭遇する度にインターンされないシンボルを新しく生成しますので、字面上同じにみえても同一のシンボルではありません\n{{{\n(eq '#:foo '#:foo)\n;=> nil\n}}}\nなんらかの事情でインターンされないシンボルを複数箇所で利用したい場合は、リーダーマクロのラベル記法を用いることになります。\n{{{\n(eq #1='#:foo #1#)\n;=> T\n}}}\nラベルは複数利用することが可能です。\n{{{\n(let ((#1=#:foo 1)\n      (#2=#:bar 2)\n      #3=#:baz)\n  (list #1# #2# #3#))\n;=> (1 2 NIL)\n}}}\nまた、このラベルはリードマクロであり、変数のスコープとは有効範囲が異なります。競合するとエラーになります。\n{{{\n(let ((#1=#:foo 1))\n  (let ((#1=#:foo 2))\n    #1#))\n;>>> エラー\n}}}\n{{{\n(let ((#1=#:foo 1))\n  (eval \n   (read-from-string \n    \"(let ((#1=#:foo 42))\n      #1#)\")))\n;=> 42\n}}}\nまた、インターンされないシンボルについては、インターンされないこと以外は通常のシンボルと同様です([[$$hs symbol-package]]はNILを返します)\n{{{\n(progn\n  (defconstant #1=#:constant 42)\n  \n  (let ((#1# 44))\n    #1#))\n;>>> エラー\n\n(progn\n  (defvar #1=#:special)\n  \n  (let ((#1# 100))\n    (symbol-value '#1#)))\n;=> 100\n}}}\n** 議論\n")
("ローマ数字を扱う" . "(:ctime 1230925747 :cuser #f :mtime 1315563898 :muser #f)[[$$tag 数値]]\n\n* ローマ数字を扱う\nアラビア数字からローマ数字への変換は、[[$$hs format]]関数が使えます。\n[[$$hs format]]関数は通常の書式と古い書式をオプションで切り換えることが可能です。\n\nアラビア数字→ローマ数字(文字列)\n{{{\n(mapcar (lambda (x) (format nil \"~@R\" x))\n        '(1 2 3 4 500 999))\n;=> (\"I\" \"II\" \"III\" \"IV\" \"D\" \"CMXCIX\")\n\n;; 古い書式\n(mapcar (lambda (x) (format nil \"~@:R\" x))\n        '(1 2 3 4 500 999))\n;=> (\"I\" \"II\" \"III\" \"IIII\" \"D\" \"DCCCCLXXXXVIIII\")\n}}}\nローマ数字からアラビア数字へ変換するための関数はANSI CLには含まれていませんので自作するかライブラリを利用することになります。\n\nローマ数字(文字列)→アラビア数字\n{{{\n;; 素朴な実装 FIXME\n(defun roman-to-arabic (str)\n  (let ((nums (nreverse (map 'list #'*roman-to-arabic str))))\n    (reduce #'+ (mapcar (lambda (x y) (if (> x y) (- y) y))\n                        (cons 0 nums)\n                        nums))))\n\n(defun *roman-to-arabic (char)\n  (case char\n    ((#\\i #\\I) 1)\n    ((#\\v #\\V) 5)\n    ((#\\x #\\X) 10)\n    ((#\\l #\\L) 50)\n    ((#\\c #\\C) 100)\n    ((#\\d #\\D) 500)\n    ((#\\m #\\M) 1000)))\n\n;; 動作\n(mapcar #'roman-to-arabic\n        '(\"I\" \"II\" \"III\" \"IV\" \"D\" \"CMXCIX\"))\n;=> (1 2 3 4 500 999)\n\n;; 古い書式\n(mapcar #'roman-to-arabic\n        '(\"I\" \"II\" \"III\" \"IIII\" \"D\" \"DCCCCLXXXXVIIII\"))\n;=> (1 2 3 4 500 999)\n}}}\n\n\n\n")
("簡単なDNSルックアップ" . "(:ctime 1230782977 :cuser #f :mtime 1230783022 :muser #f)[[$$tag インターネットサービス]]\n* 簡単なDNSルックアップ\nネットワーク周りについては、ANSI Common Lispの仕様では規定されていませんので処理系依存になります。\nここでは、処理系依存を吸収するパッケージである[[CLiki:usocket]]を利用しています。\n\n{{{\n;; ※exportされていない\n(usocket::get-host-by-name \"tips.lisp-users.org\") \n;=> #(67 205 51 34)\n}}}\n[[$$tag ライブラリ usocket]]\n")
(" %Tag:cl-ppcre?Tag:cl-ppcre" . "(1491321944)")
(" %Tag:local-time'A=0" . "(1565013506)")
("指定値までの指定ステップ毎に繰り返し" . "(:ctime 1227415969 :cuser #f :mtime 1229527109 :muser #f)[[$$tag 制御構造]]\n* 指定値までの指定ステップ毎に繰り返し\n指定値まで繰り返します。 \n{{{\n(loop :for i :from 5 :to 10 :by 2\n      :do (print i))\n;=> 5,7,9\n; この例では、5から2ステップ毎に10を超えないように繰り返します。\n}}}\n\n** リスト上での指定ステップ毎の繰り返し\nby キーワードでリストの次のステップの取り出し方を指定できます。\n{{{\n(loop for i in '(1 2 3 4 5) by #'cddr\n      while (<= i 4)\n      do (print i))\n;=> 1,3\n; 要素を先頭からひとつ飛び毎に4以下のあいだ繰り返します。\n}}}\n")
("リストから要素を取り出す" . "(:ctime 1227519371 :cuser #f :mtime 1328667648 :muser #f)[[$$tag リスト]]\n\nリストの n 番目の要素を参照するには [[$$hs nth]] 手続きを使います。\nより汎用なシーケンス用の関数として[[$$hs elt]]も利用できます。(汎用のかわりリスト専用の[[$$hs nth]]より低速です)\n\n{{{\n(defparameter *xs* '(0 1 2 3 4 5))\n\n(nth 0 *xs*) ;=> 0\n(nth 4 *xs*) ;=> 4\n(elt *xs* 4) ;=> 4\n}}}\n\nリストの先頭要素を参照するには [[$$hs car]] 手続きも使えます。\nまた [[$$hs first]] から [[$$hs tenth]] までのリスト参照手続きが用意されています。\n\n{{{\n(first '(1 2 3)) ; => 1\n(ninth '(1 3 5 7 9 11 13 15 17 19 21)) ; => 19\n}}}\n\nリストを cons セルの列なりや木構造として考える場合には [[$$hs car]], [[$$hs cdr]], [[$$hs caar]] といった手続きを使うことが多くなります。\n{{{\n(car '(a b)) ;=> a\n(caar '((a 1) (b 2) (c 3)) ;=> a\n}}}\n\n\nn番目以降の要素を取り出すには[[$$hs nthcdr]]関数が使えます。\n\n{{{\n(nthcdr 0 *xs*) ;=> (0 1 2 3 4 5)\n(nthcdr 4 *xs*) ;=> (4 5)\n(nthcdr 8 *xs*) ;=> NIL\n}}}\n\n後ろから数えたn番目以降の要素を取り出すには[[$$hs last]]関数が使えます。\n{{{\n(last *xs*) ;=> (5)\n(last *xs* 4) ;=> (2 3 4 5)\n(last *xs* 8) ;=> (0 1 2 3 4 5)\n}}}\n\n")
("文字列を作成する" . "(:ctime 1285689071 :cuser #f :mtime 1285689071 :muser #f)[[$$tag 文字列]]\n\n[[$$hs make-string]]に長さを指定することで任意の長さの文字列を生成することが可能です。~%\n{{{\n(make-string 15 :initial-element #\\x)\n;⇒ \"xxxxxxxxxxxxxxx\"\n}}}\nまた、もちろん\"xxxxxxxxxxxxxxx\"とそのまま書くことも可能です。\nなお、生成されるタイミングにより生成されるオブジェクトも変わってきます。\n{{{\n(defun mkstring ()\n  (let ((x \"xxxxxxxxxx\")     ;READ時に生成\n        (y #.(make-string 10 :initial-element #\\x)) ;READ時に生成\n        (z (make-string 10 :initial-element #\\x)))  ;実行時に生成\n    (list x y z)))\n\n(mapcar #'eq\n        (mkstring)\n        (mkstring))\n;⇒ (T T NIL)\n\n(mapcar #'equalp\n        (mkstring)\n        (mkstring))\n;⇒ (T T T)\n}}}\n")
("代入(setf)" . "(:ctime 1237819188 :cuser #f :mtime 1237819785 :muser #f)[[$$tag 制御構造]]\n\nsetfは値を格納する場所への読み込みと書き込みの操作をシンボル以外の任意のものに一般化し拡張した構文（マクロ）です。\n\n{{{\n> x\n;=> 1\n> (setf x 2)\n;=> 2\n> (car y)\n;=> 1\n> (setf (car y) 2)\n;=> 2\n> z\n;=> #(1 2 3)\n> (setf (aref z 2) 4)\n;=> 4\n> z\n;=> #(1 2 4)\n}}}\n\n一般になんらかの読み込み操作が与えられた場合、\n{{{\n(setf (読み込み操作) 新しい値)\n}}}\nによって書き込み操作を行えます。\n\nsetfは第2引数を返します。\n\n")
(" %Tag:日本語'A=0" . "(1558798542)")
("リスト同士の和・差・積を取る" . "(:ctime 1228451910 :cuser #f :mtime 1228451910 :muser #f)[[$$tag リスト]]\n\n* リスト同士の和・差・積を取る\n\nリストの和集合を得るには、[[$$hs union]]\n\nリストの差集合を得るには、[[$$hs set-difference]]\n\nリストの積集合を得るには、[[$$hs intersection]]\n\nが使えます。\n結果リストの要素の順番については、保証されていません。\n{{{\n(union '(1 3 5 7) '(2 4 6 8)) ;=> (8 6 4 2 1 3 5 7)\n(union '(1 2 3 4) '(3 4 5 6) :test #'eql) ;=> (6 5 1 2 3 4)\n\n(set-difference '(1 3 5 7) '(2 4 6 8)) ;=> (7 5 3 1)\n(set-difference '(1 2 3 4) '(3 4 5 6)) ;=> (2 1)\n\n(intersection '(1 3 5 7) '(2 4 6 8)) ;=> ()\n(intersection '(i 2 3 4) '(3 4 5 6)) ;=> (4 3)\n}}}\nまた、処理系依存で与えられたリストと結果の内容が同一の場合は、元のリストを返却しても構わないことになっていますので、上記3つの処理の結果のリストを破壊的に変更する場合にはコピーを渡してやる必要があります。\n{{{\n(let ((x '(1 2 3 4)))\n  (eq x (union x ())))\n;=> T(or nil 処理系依存)\n}}}\n\n")
("clbuildを使う" . "(:ctime 1238075435 :cuser #f :mtime 1257333862 :muser #f)[[$$tag ライブラリ管理]]\n\n[[CLiki:clbuild]]はオープンソースで公開されているCommon Lispパッケージのソースの最新版を取得してasdfから利用可能な形にセットアップしてくれるUNIXのコマンドラインツールです。bashのスクリプトとして書かれています。\n\n一度インストールしたCommon Lispパッケージをとても簡単に最新版に更新できるので、常に開発中のコードの最前線を追いかけるような利用スタイルに向いています。\n\nソースコードの最新版の取得のためにclbuildの他にバージョン管理ツールのインストールが必要です。\nパッケージの作者やチームによって使われているバージョン管理ツールは様々ですので今のところ以下のツールをインストールしなければなりません。\n- darcs\n- Subversion\n- Mercurial\n- git\n- cvs\n\n例えば[http://www.ubuntulinux.jp/ Ubuntu]をお使いでしたら次のコマンドでインストールできます。\n{{{\nsudo aptitude install darcs subversion mercurial git-core cvs\n}}}\n\nこれらのバージョン管理ツールをインストールできたら、コマンドラインから次のように入力してclbuild自体を取得します。\n darcs get http://common-lisp.net/project/clbuild/clbuild\nカレントディレクトリにclbuildというディレクトリができるので、中に移動してclbuildコマンドを実行可能にします。\n cd clbuild\n chmod +x clbuild\n次にclbuildが動作可能かclbuild自身にチェックさせます。\n ./clbuild check\n\n----\n ./clbuild help\n ./clbuild install cl-ppcre\n ./clbuild update --installed\n ./clbuild lisp\n\n----\nCommon Lispパッケージの追加が簡単、という特長もあります。\n\n試しにjpパッケージを追加してみます。\n\nclbuild/my-projects というファイルをエディタなどで開き（なければ作成し）次の行を追加します。（1行です）\n jp     get_tarball http://lispuser.net/files/jp.tar.gz #Basic utility for Japanese\n\nこれだけでパッケージがclbuildに認識されます。\nインストールしてみましょう。\n\n ./clbuild install jp\n\nclbuildから起動したLisp処理系内で利用可能になっています。\n{{{\n./clbuild lisp\n* (asdf:oos 'asdf:load-op 'jp)\n}}}\n\n----\n自作するasdf対応のLispパッケージの開発にも便利に使えます。\n\n{{{\n./clbuild make-project my-great-project\n}}}\nclbuildのインストールディレクトリのsource/my-great-projectディレクトリにasdfからロード可能な雛型が作成されます。\n\n{{{\n./clbuild lisp\n* (asdf:operate 'asdf:load-op :my-great-project)\n* (my-great-project:test)\n-> Hello World from new project my-great-project\n=> NIL\n}}}\n")
(" %Tag:構造体'" . "(1596074596)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45) --  /*" . "(1624124241)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45) --  /*" . "(1624124285)")
("スクリプトの実行" . "(:ctime 1294026709 :cuser #f :mtime 1294026709 :muser #f)* コマンドラインでファイルを実行\n\n** CLISP\n\n$ clisp filename.lisp\n\n** SBCL\n\n$ sbcl --script filename.lisp\n\n** CMUCL\n\n$ cmucl -load filename.lisp -eval '(quit)'\n\n** Allegro CL\n\n$ alisp -#! filename.lisp\n\n** ECL\n\n$ ecl -shell filename.lisp\n\n** Clozure CL\n\n$ ccl --load filename.lisp --eval '(quit)'\n\n以下のシェルスクリプトを使えばSBCLのように--scriptで実行できるようになる。\n\n{{{\n#!/bin/bash\n\nccl=\"/Applications/ccl/dx86cl64\"\nif [ \"$1\" = \"--script\" ] ; then\n  $ccl --load \"$2\" --eval '(ccl:quit)'\nelse\n  $ccl \"$@\"\nfi\n}}}\n\n$ ccl --script filename.lisp\n\n* コマンドライン引数の取得\n\nスクリプトからコマンドライン引数を利用したいとき、引数の取得方法が処理系によって違います。以下のような関数を利用すればポータブルなスクリプトが書けます。\n\n{{{\n(defun args ()\n  #+allegro (system:command-line-arguments)\n  #+sbcl sb-ext:*posix-argv*\n  #+clisp ext:*args*\n  #+ecl (si:command-args)\n  #+cmu ext:*command-line-words*\n  #+ccl ccl:*command-line-argument-list*\n  #+lispworks system:*line-arguments-list*)\n}}}\n")
("loop:リストを回しつつ、要素の数え上げもする" . "(:ctime 1336291895 :cuser #f :mtime 1336291895 :muser #f){{{\n(defvar *names*\n  '(nil \"おそ松\" \"カラ松\" \"チョロ松\" \"一松\" \"十四松\" \"トド松\" nil))\n\n\n(loop :for n :in *names*\n      :for c :from 1\n      :collect (list c n))\n;=>  ((1 NIL) (2 \"おそ松\") (3 \"カラ松\") (4 \"チョロ松\")\n;     (5 \"一松\") (6 \"十四松\") (7 \"トド松\") (8 NIL))\n\n\n;; nilは除外したい、というような場合\n(loop :for n :in *names*\n      :count n :into c\n      :when n :collect (list c n))\n;=>  ((1 \"おそ松\") (2 \"カラ松\") (3 \"チョロ松\") (4 \"一松\")\n;     (5 \"十四松\") (6 \"トド松\"))\n}}}\n")
("現在の時刻(Universal Time)を取得する" . "(:ctime 1227414467 :cuser #f :mtime 1227414468 :muser #f)[[$$tag 日付と時刻]]\n* 現在の時刻(Universal Time)を取得する\nget-universal-timeで取得できる\n{{{\n(get-universal-time)\n;=> 3436143023\n}}}\n通常は、decode-universal-timeで取得した時刻を変換して利用する\n{{{\n(decode-universal-time 3436143023)\n;=> 23\n    10\n    13\n    20\n    11\n    2008\n    3\n    NIL\n    -9\n}}}\ndecode-universal-timeは9つの[[多値]]で\nsecond, minute, hour, date, month, year, day, daylight-p, zone\nを返す\n")
(" %Tag:????\" and \"x\"=\"x" . "(1587484320)")
("Lispオブジェクトをシリアライズ・デシリアライズする" . "(:ctime 1329736370 :cuser #f :mtime 1329736370 :muser #f)[[$$tag 【募集中】]]\n")
(" %Tag:工事中" . "(1460644251)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45) --  /*" . "(1624124363)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45),CHAR(45,120,50,53,45,81,45) -- /* order by 'as /*" . "(1624124779)")
("2つのハッシュの両方にあるキー、または一方にしかないキーを見つける" . "(:ctime 1231752347 :cuser #f :mtime 1231752347 :muser #f)[[$$tag ハッシュテーブル]]\n\n* 2つのハッシュの両方にあるキー、または一方にしかないキーを見つける\n\nハッシュテーブルを対象にした集合演算の関数は標準にはありませんのでライブラリを利用するか自作することになるでしょう。\n\n2つのハッシュの両方にあるキーを見つける\n{{{\n;; 素朴な実装\n(defun hash-key-and (tab1 tab2)\n  (loop :for k :being :each :hash-key :of tab1\n        :when (gethash k tab2) :collect k))\n}}}\n{{{\n;; 実行例\n(import 'alexandria:plist-hash-table)\n\n(let ((tab1 (plist-hash-table \n              '(:a \"foo\" :b \"bar\" :c \"baz\")))\n      (tab2 (plist-hash-table\n              '(:a \"foo\" :b \"bar\" :c \"baz\" :q \"quux\"))))\n  (hash-key-and tab1 tab2))\n;=> (:A :C :B)\n}}}\n\n2つのハッシュで一方にしかないキーを見つける\n{{{\n;; 素朴な実装\n(defun hash-key-xor (tab1 tab2)\n  (let (ans)\n    (flet ((frob (tab1 tab2)\n             (loop :for k :being :each :hash-key :of tab1\n                   :do (unless (gethash k tab2) (push k ans)))))\n      (frob tab1 tab2)\n      (frob tab2 tab1))\n    ans))\n}}}\n{{{\n;; 実行例\n(import 'alexandria:plist-hash-table)\n\n(let ((tab1 (plist-hash-table \n              '(:a \"foo\" :b \"bar\" :c \"baz\" :z \"zot\")))\n      (tab2 (plist-hash-table\n              '(:a \"a\" :b \"b\" :d \"d\"))))\n  (hash-key-xor tab1 tab2))\n;=> (:D :Z :C)\n}}}\n\n** 議論\n\n\n\n\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 631 #" . "(1624125239)")
("シンボルが外部シンボルか内部シンボルか継承されているかを調べる" . "(:ctime 1293347321 :cuser #f :mtime 1293348989 :muser #f)[[$$hs find-symbol]]を使うことで、シンボルの状態(外部シンボル/内部シンボル/継承)を調べることができます。\n[[$$hs find-symbol]]は[[$$hs intern]]のように実行すると新たにシンボルが生成されるということはありません。\n{{{\n;; foo パッケージを作成\n(defpackage :foo\n  (:export :a :b :c))\n\n;; foo::aシンボルの状態を確認\n(find-symbol \"A\" :foo)\n;=> FOO:A\n;   :EXTERNAL (foo::aは外部シンボル)\n\n;; bar パッケージを作成 (fooの外部シンボルを内部シンボルとして取り込む)\n(defpackage :bar\n  (:use :foo))\n\n;; bar::aでアクセスできるシンボルの状態を確認\n(find-symbol \"A\" :bar)\n;=> FOO:A\n;   :INHERITED\n}}}\n{{{\n;; 応用\n;; fooパッケージの外部シンボルをbarに取り込み\n;; さらにbarの外部シンボルとしてアクセスできるようにする\n(do-symbols (s :foo)\n  (multiple-value-bind (sym stat)\n                       (find-symbol (string s) :foo)\n    (when (eq :external stat)\n      (export sym :bar)))) ; パッケージbarを指定してexport\n\n(find-symbol \"A\" :bar)\n;=> FOO:A\n;   :EXTERNAL\n\n(eq 'foo:a 'bar:a)\n;=> T\n}}}\n** 議論\n")
(" %Tag:????? and 1=1" . "(1584214735)")
("オブジェクトの印字方法をカスタマイズする" . "(:ctime 1236781678 :cuser #f :mtime 1236781678 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n総称関数 print-object を定義します。\n\n{{{\n(defclass my-class () ())\n\n(defmethod print-object ((object my-class) stream)\n  (print-unreadable-object (object stream :type t)\n    (format stream \"my object\")))\n}}}\n\n読み込み不可能な印字表現を処理系に依存しない方法で書ける print-unreadable-object がよく使われます。\n\n{{{\n> (make-instance 'my-class)\n; => #<MY-CLASS my object>\n}}}\n\n")
("任意のビット位置の値を参照する" . "(:ctime 1230696694 :cuser #f :mtime 1230696734 :muser #f)[[$$tag 数値]]\n\n* 任意のビット位置の値を参照する\n\n任意のビット位置の値を参照するには[[$$hs ldb]]を使用し、数値とバイト指定子を与えます。\n{{{\n(let ((i #x10)\n      (pos 0))\n  (ldb (byte 1 pos) i))\n;=> 0\n\n(let ((i #x10)\n      (pos 4))\n  (ldb (byte 1 pos) i))\n;=> 1\n}}}\n任意のビット位置の値が1であるかを確かめるには、[[$$hs logbitp]]を使用します。\n{{{\n(let ((i #x10))\n  (logbitp 4 i))\n;=> T\n}}}\n")
("クラスに必須スロットを設定する" . "(:ctime 1338974638 :cuser #f :mtime 1339113652 :muser #f)[[$$tag MOP c2mop]]\n** MOPを利用しない場合\n:initformにエラーを発する式を与えることにより、初期化時に明示的に上書きしない場合、エラーを発します。\n{{{\n(defclass foo ()\n  ((r1 :initform (error \"Required slot unbound R1.\") :initarg :r1)\n   (r2 :initform (error \"Required slot unbound R2.\") :initarg :r2)\n   (r3 :initform (error \"Required slot unbound R3.\") :initarg :r3)\n   (x :initarg :x)))\n}}}\n動作\n{{{\n(make-instance 'foo)\n;>>> Required slot unbound R1.\n\n(describe (make-instance 'foo :r1 1 :r2 2 :r3 3))\n;->  #<FOO {104A159393}>\n;      [standard-object]\n;\n;    Slots with :INSTANCE allocation:\n;      R1  = 1\n;      R2  = 2\n;      R3  = 3\n;      X   = #<unbound slot>\n;\n;=>  No value.\n}}}\n*** MOPを利用した場合\n下記では、required-slot-classという必須スロットのメタクラスを作成し、make-instance時にチェックし条件が満されていない場合にエラーを発します。~%\nMOPのコンパチブルレイヤーとして[[CLiki:Closer-MOP]]を利用します~%\n導入方法\n{{{\n(ql:quickload :closer-mop)\n}}}\n{{{\n(defclass required-slot-class (standard-class)\n  ((direct-required-slots\n    ;; メタクラスの:initargは、defclassのslot-optionとして利用できる\n    :initarg :required-slots\n    :initform '()\n    :reader direct-required-slots)\n   (class-required-slots :accessor class-required-slots)))\n\n\n(defmethod c2mop:validate-superclass ((class required-slot-class)\n                                      (super standard-class))\n  ;; standard-class、required-slot-classの異なるメタクラス間で\n  ;; クラスが継承できるようにする\n  t)\n\n\n(defmethod direct-required-slots ((class class))\n  ;; required-slot-classでない場合は空リストを返す\n  '())\n\n\n(defmethod c2mop:finalize-inheritance :after ((class required-slot-class))\n  ;; class-precedence-listを継承順に辿り、direct-required-slotsをマージして\n  ;; class-required-slotsを作成する\n  (setf (class-required-slots class)\n        (remove-duplicates (mapcan (lambda (ds)\n                                     (copy-list (direct-required-slots ds)))\n                                   (c2mop:class-precedence-list class))\n                           :from-end T\n                           :test #'equal)))\n\n\n(defmethod unbound-required-slot-using-class ((class required-slot-class) object slot-name)\n  ;; required-slotがunboundの場合エラーを発する\n  (error \"Required slot unbound ~A.\" slot-name))\n\n\n(defmethod check-required-slots-using-class ((class required-slot-class) object)\n  ;; required-slotのクラスとインスタンスを用いてrequired-slotがunboundでないかを\n  ;; チェックする\n  (dolist (rs (class-required-slots class))\n    (unless (and (symbolp rs) (slot-boundp object rs))\n      (unbound-required-slot-using-class class object rs))))\n\n\n(defmethod make-instance ((class required-slot-class) &rest args)\n  ;; インスタンスを生成し、スロットをcheck-required-slots-using-classでチェックする\n  (let ((instance (call-next-method)))\n    (check-required-slots-using-class class instance)\n    instance))\n}}}\n動作\n{{{\n(defclass required-slots-demo ()\n  ((r1 :initarg :r1)                    ;必須1\n   (r2 :initarg :r2)                    ;必須2\n   (r3 :initarg :r3)                    ;必須3\n   (x :initarg :x)\n   (y :initarg :y)\n   (z :initarg :z))\n  (:metaclass required-slot-class)\n  (:required-slots r1 r2 r3))           ;必須スロット名を指定\n\n\n(describe (make-instance 'required-slots-demo :r1 1 :r2 2 :r3 3))\n;->  #<REQUIRED-SLOTS-DEMO {104BD22F33}>\n;      [standard-object]\n;\n;    Slots with :INSTANCE allocation:\n;      R1  = 1\n;      R2  = 2\n;      R3  = 3\n;      X   = #<unbound slot>\n;      Y   = #<unbound slot>\n;      Z   = #<unbound slot>\n;\n;=>  No value\n\n\n(make-instance 'required-slots-demo :r2 2 :r3 3 :x 4)\n;>>> Required slot unbound R1.\n}}}\n*** 参考\n- [http://www.amazon.co.jp/dp/4000077066 オブジェクト指向コンピューティング (岩波コンピュータサイエンス)] P153〜P188\n")
("指定回数の繰り返し" . "(:ctime 1227415941 :cuser #f :mtime 1229527683 :muser #f)[[$$tag 制御構造]]\n* 指定回数の繰り返し\n指定回数だけ繰り返します。\n{{{\n(dotimes (i 3) (print i))\n;>>> 0,1,2\n\n(loop :for i :from 0 :repeat 3\n      :do (print i))\n;>>> 0,1,2\n; この例では、0から2まで繰り返します。\n\n(loop :repeat 3 :do (print 1))\n; 単純に指定回数だけ繰り返します。\n; カウントする変数を指定していないので何回目の繰り返しかは得られません。\n}}}\n")
("配列の各要素に関数を適用し配列を作成する" . "(:ctime 1228101170 :cuser #f :mtime 1228112053 :muser #f)[[$$tag 配列]]\n\n* 配列の各要素に関数を適用し配列を作成する\n\n[[$$hs map]] はシークエンス全般に使用できます。第1引数にシークエンスの型を指定することにより任意のシークエンスが作成可能です。\n{{{\n(let ((v (vector 1 2 3 2 1 2 3 2 1)))\n  (map 'vector #'1+ v ))\n;=> #(2 3 4 3 2 3 4 3 2)\n}}}\nまた、[[$$hs map-into]] は、第1引数にシークエンスそのものを指定することにより、結果を元のシークエンスに代入して返します。\n元のシークエンスは破壊的に変更されます。\n{{{\n(let ((v (vector 1 2 3 2 1 2 3 2 1)))\n  (map-into v #'1+ v ))\n;=> #(2 3 4 3 2 3 4 3 2)\n}}}\n")
("リードテーブルを標準の状態に復元する方法" . "(:ctime 1229195021 :cuser #f :mtime 1229195129 :muser #f)[[$$tag マクロ リーダーマクロ]]\n\n* リードテーブルを標準の状態に復元する方法\n\n[[$$hs set-macro-character]] 等で色々と変更を加えた [[$$hs *readtablbe*]] を標準の状態に戻すには、[[$$hs copy-readtable]] にnilを指定し、[[$$hs *readtablbe*]]に再度セットします。\n{{{\n(setq *readtable* (copy-readtable nil))\n}}}\n")
("文字列の末端の改行を削除する" . "(:ctime 1362794093 :cuser #f :mtime 1362794093 :muser #f)文字列の末尾の改行を削除するには、[[$$hs string-right-trim]] を使用します。~%第一引数は削除する文字のリストが指定できるので、CR+LF、LF等も処理が可能です。\n\n{{{\n(string-right-trim '(#\\Newline) \"abc\n\")\n;=>  \"abc\"\n\n\n(string-right-trim '(#\\Newline) \"abc\n\n\n\n\")\n;=>  \"abc\"\n\n\n(string-right-trim '(#\\Return #\\Newline) \"abc^M\n\")\n;=>  \"abc\"\n}}}\n")
("go to" . "(:ctime 1605275555 :cuser #f :mtime 1605275555 :muser #f)[[$$tag 制御構造]]\n* go to\n\n手続き型言語でいうところのgo to文も使えます。\nLispらしくないとか構造化言語には不要であるとかいろいろあるでしょうが、用意はされているので使うかどうかはあなた次第です。\n\n制御を任意の場所に移すには、[[$$hs tagbody]] と [[$$hs go]] を使います。\n{{{\n(defun foo ()\n  (tagbody\n   label1\n     (print 1)\n     (go label3)\n   label2\n     (print 2)\n     (return-from foo 2)\n   label3\n     (print 3)\n     (go label2)))\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') and 1=2#" . "(1656001236)")
("mudballsを使う" . "(:ctime 1229134338 :cuser #f :mtime 1335997943 :muser #f)[[$$tag mudballs]]\n* mudballsを使う\nmudballsはプロジェクトが無くなってしまいました。~%\n2012年現在は、quicklispがメジャーになっています。\n\nhttp://mudballs.com/\n\n- (mb:search \"ppcre\")\n- (mb:install :cl-ppcre)\n- (mb:load :cl-ppcre)\n\n")
(" %Tag:早見表" . "(1666576174 (\"reduceと一般的なfold系関数との比較\" :ctime 1331810349 :cuser #f :mtime 1335996460 :muser #f))")
("読み方を知りたい" . "(:ctime 1237824999 :cuser #f :mtime 1294119593 :muser #f)[[$$tag その他]]\n\nHyperSpecでは難読のものに発音方法が一緒に示されていますので、それが有用かと思います。\n例、setq、ldb\n{{{\n Pronunciation: setq\n \n ['set,kyoo] => せっときゅー\n}}}\n{{{\nPronunciation: ldb\n\n['lidib] or ['liduhb] or ['el'dee'bee] => りでぃぶ 等\n}}}\n\n** 議論\n 書籍ではなかなか情報を得られないので。\nHyperSpecでは難読のものに発音方法が一緒に示されていますので、それが有用かと思います。\n例、setq、ldb\n{{{\n Pronunciation: setq\n \n ['set,kyoo] => せっときゅー\n}}}\n{{{\nPronunciation: ldb\n\n['lidib] or ['liduhb] or ['el'dee'bee] => りでぃぶ 等\n}}}\nしかし、往年のPDP-10ハッカーでもない限りldbを「りでぃぶ」と発音している人はいないのではないかと思います…。 --g000001\n\nこの項目を作ったものです。ずばり回答いただけましたので自分の書いた部分は捨てて差し替えました。--koga\n")
("Cusp" . "(:ctime 1329736647 :cuser #f :mtime 1329736647 :muser #f)[[$$tag 【募集中】]]\n")
("確実に後処理を行なう" . "(:ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f)[[$$tag 例外処理 制御構造 マクロ]]\n\n* 確実に後処理を行なう\n\t\nファイルを開いた場合やネットワークに接続した場合、例外が発生した場合でもその後処理を確実に行ないたいことがあります。そのような場合、 [[$$hs unwind-protect]] を使い例外が発生しても後処理を確実に行なうようにします。\n{{{\n(let ((in (open \"foo.txt\")) \n      (delete? t))                        ;後処理確認のためのフラグ\n  (unwind-protect \n       (multiple-value-prog1 \n           (progn \n             (job1)\n             (job2)\n             (job3)) \n         (setq delete? nil))              ;無事に辿り着いたらフラグをnilに\n    (when in\n      (close in :abort delete?))))        ;delete? => T ならば\n                                          ; close が後処理をする\n}}}\nこの一連の流れは定型となっていて標準のマクロ with-open-file 等も内部で [[$$hs unwind-protect]] を利用しています。\n\n上記は、 [[$$hs with-open-file]] を利用すると下記のように書けます。\n{{{\n(with-open-file (in \"foo.txt\")\n  (job1)\n  (job2)\n  (job3))\n}}}\n")
(" %Tag:日付と時刻\" or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- \"x\"=\"x" . "(1532959373)")
("InterWikiName" . "(:ctime 1228811927 :cuser #f :mtime 1228813752 :muser #f):CLiki:\nwww.cliki.net/\n\n:WiLiKi:\npractical-scheme.net/wiliki/wiliki.cgi?p= \n\n:isbn:\nwww.amazon.co.jp/exec/obidos/ASIN/ \n\n:Wikipedia:\nwww.wikipedia.org/wiki/ \n\n\n:Wikipedia-ja:\nja.wikipedia.org/wiki/ \n")
(" %Tag:Weblocks?Tag:Weblocks" . "(1476570702)")
(" %Tag:portable-threads'[0]" . "(1659332340)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45) -- /* order by 'as /*" . "(1624124587)")
("ライブラリ管理" . "(:ctime 1227511449 :cuser #f :mtime 1292892954 :muser #f)- [[asdf-installでインストールできるもの]]\n- [[mudballsを使う]]\n- [[clbuildを使う]]\n- [[Quicklispを使う]]\n")
("リーダーマクロを定義する" . "(:ctime 1335982556 :cuser #f :mtime 1335982556 :muser #f)リーダーマクロとは、文字にマクロを定義し、読み取り時に展開させるという機能です。~%\nCommon Lispには、一文字を展開する[[$$hs set-macro-character]]と、二文字+引数で展開させる[[$$hs set-dispatch-macro-character]]があり、主にこれらを用いて定義します。~%\n標準で定義されているリーダーマクロには、「'」、「\"」、「(」、「;」等があります。~%\n\n- [[リーダーマクロを定義する:クォート型]]\n- [[リーダーマクロを定義する:一行コメント型]]\n- [[リーダーマクロを定義する:ダブルクォート型]]\n\n*** 参考文献\n- [http://www.lispworks.com/documentation/HyperSpec/Body/f_set_ma.htm CLHS: Function SET-MACRO-CHARACTER, GET-MACRO-CHARACTER]\n- [http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/html/cltl/clm/node195.html#SECTION002621000000000000000 CLtL2: 22.2.1. Input from Character Streams]\n- [http://www.bookshelf.jp/texi/onlisp/onlisp_18.html#Macro%20Characters On Lisp: 17.1 Macro Characters ]\n")
("Universal Time" . "(:ctime 1227414433 :cuser #f :mtime 1227414433 :muser #f)[[$$tag 日付と時刻]]\n* Universal Time\nCLでは、1900年を基点とした秒数(非負のinteger)をUniversal timeと呼ぶ。\n- [http://www.lispworks.com/documentation/HyperSpec/Body/25_adb.htm universal time]\n;;bignumがウタガワし。非負の整数？そして閏秒は無視される。\n")
("ソースコードからドキュメント（関数仕様）を生成する" . "(:ctime 1329738499 :cuser #f :mtime 1370782776 :muser #f)[[$$tag 【募集中】]]\n* [[$$hs documentation]], [[$$hs describe]]関数を使う\n単にドキュメントを見るには[[$$hs documentation]]を使います。\n同じ名前のシンボルに変数と関数がありうるのでタイプを指定する必要があります。\n{{{\n(documentation 'print 'variable)\n;=>NIL\n(documentation 'print 'function)\n;->\"Output a newline, the mostly READable printed representation of OBJECT, and\n  space to the specified STREAM.\"\n}}}\nもう少し詳しく引数などの情報を得るには[[$$hs describe]]を使います。\n{{{\n(describe 'print)\n;->COMMON-LISP:PRINT\n  [symbol]\n\nPRINT names a compiled function:\n  Lambda-list: (OBJECT &OPTIONAL STREAM)\n  Declared type: (FUNCTION (T &OPTIONAL (OR STREAM (MEMBER NIL T)))\n                  (VALUES T &OPTIONAL))\n  Derived type: (FUNCTION (T &OPTIONAL T) (VALUES T &OPTIONAL))\n  Documentation:\n    Output a newline, the mostly READable printed representation of OBJECT, and\n      space to the specified STREAM.\n  Known attributes: call, unwind, any, explicit-check\n  Source file: SYS:SRC;CODE;PRINT.LISP\n=>; No value\n}}}\n\n* ドキュメンテーションライブラリを使う\n** manifest\n[[CLiki:manifest]]はインストールされてるパッケージ（？）のドキュメントを見れるサーバーを立ち上げます。\n{{{\n(manifest:start)\n;=>\"http://localhost:4567/\"\n}}}\nhttp://localhost:4567/quicklisp でquicklispの管理もできます。\n** cl-api\n[[CLiki:cl-api]]は指定したパッケージのAPIを作成してくれます。\n{{{\n(cl-api:api-gen :cl-user #p\"~/Lisp/APIs/\")\nGeneration complete: \"~/Lisp/APIs/cl-user.html\"\n;=>NIL\n}}}\n")
(" %Tag:����\"" . "(1577118415)")
("ANSI-CL/CLtL2/CLtL1シンボル比較表" . "(:ctime 1616468946 :cuser #f :mtime 1619714066 :muser #f)|| ANSI-CL || CLtL2 || CLtL1 ||\n|| [[$$hs &allow-other-keys]] || &allow-other-keys || &allow-other-keys ||\n|| [[$$hs &aux]] || &aux || &aux ||\n|| [[$$hs &body]] || &body || &body ||\n|| [[$$hs &environment]] || &environment || &environment ||\n|| [[$$hs &key]] || &key || &key ||\n|| [[$$hs &optional]] || &optional || &optional ||\n|| [[$$hs &rest]] || &rest || &rest ||\n|| [[$$hs &whole]] || &whole || &whole ||\n|| [[$$hs *]] || * || * ||\n|| [[$$hs *]] || * || * ||\n|| [[$$hs **]] || ** || ** ||\n|| [[$$hs ***]] || *** || *** ||\n||  ||  || *applyhook* ||\n|| [[$$hs *break-on-signals*]] || *break-on-signals* ||  ||\n||  ||  || *break-on-warnings* ||\n|| [[$$hs *compile-file-pathname*]] || *compile-file-pathname* ||  ||\n|| [[$$hs *compile-file-truename*]] || *compile-file-truename* ||  ||\n|| [[$$hs *compile-print*]] || *compile-print* ||  ||\n|| [[$$hs *compile-verbose*]] || *compile-verbose* ||  ||\n|| [[$$hs *debug-io*]] || *debug-io* || *debug-io* ||\n|| [[$$hs *debugger-hook*]] || *debugger-hook* ||  ||\n|| [[$$hs *default-pathname-defaults*]] || *default-pathname-defaults* || *default-pathname-defaults* ||\n|| [[$$hs *error-output*]] || *error-output* || *error-output* ||\n||  ||  || *evalhook* ||\n|| [[$$hs *features*]] || *features* || *features* ||\n|| [[$$hs *gensym-counter*]] || *gensym-counter* ||  ||\n|| [[$$hs *load-pathname*]] || *load-pathname* ||  ||\n|| [[$$hs *load-print*]] || *load-print* ||  ||\n|| [[$$hs *load-truename*]] || *load-truename* ||  ||\n|| [[$$hs *load-verbose*]] || *load-verbose* || *load-verbose* ||\n|| [[$$hs *macroexpand-hook*]] || *macroexpand-hook* || *macroexpand-hook* ||\n|| [[$$hs *modules*]] || *modules* || *modules* ||\n|| [[$$hs *package*]] || *package* || *package* ||\n|| [[$$hs *print-array*]] || *print-array* || *print-array* ||\n|| [[$$hs *print-base*]] || *print-base* || *print-base* ||\n|| [[$$hs *print-case*]] || *print-case* || *print-case* ||\n|| [[$$hs *print-circle*]] || *print-circle* || *print-circle* ||\n|| [[$$hs *print-escape*]] || *print-escape* || *print-escape* ||\n|| [[$$hs *print-gensym*]] || *print-gensym* || *print-gensym* ||\n|| [[$$hs *print-length*]] || *print-length* || *print-length* ||\n|| [[$$hs *print-level*]] || *print-level* || *print-level* ||\n|| [[$$hs *print-lines*]] || *print-lines* ||  ||\n|| [[$$hs *print-miser-width*]] || *print-miser-width* ||  ||\n|| [[$$hs *print-pprint-dispatch*]] || *print-pprint-dispatch* ||  ||\n|| [[$$hs *print-pretty*]] || *print-pretty* || *print-pretty* ||\n|| [[$$hs *print-radix*]] || *print-radix* || *print-radix* ||\n|| [[$$hs *print-readably*]] || *print-readably* ||  ||\n|| [[$$hs *print-right-margin*]] || *print-right-margin* ||  ||\n|| [[$$hs *query-io*]] || *query-io* || *query-io* ||\n|| [[$$hs *random-state*]] || *random-state* || *random-state* ||\n|| [[$$hs *read-base*]] || *read-base* || *read-base* ||\n|| [[$$hs *read-default-float-format*]] || *read-default-float-format* || *read-default-float-format* ||\n|| [[$$hs *read-eval*]] || *read-eval* ||  ||\n|| [[$$hs *read-suppress*]] || *read-suppress* || *read-suppress* ||\n|| [[$$hs *readtable*]] || *readtable* || *readtable* ||\n|| [[$$hs *standard-input*]] || *standard-input* || *standard-input* ||\n|| [[$$hs *standard-output*]] || *standard-output* || *standard-output* ||\n|| [[$$hs *terminal-io*]] || *terminal-io* || *terminal-io* ||\n|| [[$$hs *trace-output*]] || *trace-output* || *trace-output* ||\n|| [[$$hs +]] || + || + ||\n|| [[$$hs +]] || + || + ||\n|| [[$$hs ++]] || ++ || ++ ||\n|| [[$$hs +++]] || +++ || +++ ||\n|| [[$$hs -]] || - || - ||\n|| [[$$hs -]] || - || - ||\n|| [[$$hs /]] || / || / ||\n|| [[$$hs /]] || / || / ||\n|| [[$$hs //]] || // || // ||\n|| [[$$hs ///]] || /// || /// ||\n|| [[$$hs /=]] || /= || /= ||\n|| [[$$hs 1+]] || 1+ || 1+ ||\n|| [[$$hs 1-]] || 1- || 1- ||\n|| [[$$hs <]] || < || < ||\n|| [[$$hs <=]] || <= || <= ||\n|| [[$$hs =]] || = || = ||\n|| [[$$hs >]] || > || > ||\n|| [[$$hs >=]] || >= || >= ||\n|| [[$$hs abort]] || abort ||  ||\n|| [[$$hs abs]] || abs || abs ||\n|| [[$$hs acons]] || acons || acons ||\n|| [[$$hs acos]] || acos || acos ||\n|| [[$$hs acosh]] || acosh || acosh ||\n|| [[$$hs add-method]] || add-method ||  ||\n|| [[$$hs adjoin]] || adjoin || adjoin ||\n|| [[$$hs adjust-array]] || adjust-array || adjust-array ||\n|| [[$$hs adjustable-array-p]] || adjustable-array-p || adjustable-array-p ||\n|| [[$$hs allocate-instance]] ||  ||  ||\n|| [[$$hs alpha-char-p]] || alpha-char-p || alpha-char-p ||\n|| [[$$hs alphanumericp]] || alphanumericp || alphanumericp ||\n|| [[$$hs and]] || and || and ||\n|| [[$$hs append]] || append || append ||\n|| [[$$hs apply]] || apply || apply ||\n||  ||  || applyhook ||\n|| [[$$hs apropos]] || apropos || apropos ||\n|| [[$$hs apropos-list]] || apropos-list || apropos-list ||\n|| [[$$hs aref]] || aref || aref ||\n|| [[$$hs arithmetic-error]] || arithmetic-error ||  ||\n|| [[$$hs arithmetic-error-operands]] || arithmetic-error-operands ||  ||\n|| [[$$hs arithmetic-error-operation]] || arithmetic-error-operation ||  ||\n|| [[$$hs array]] || array || array ||\n|| [[$$hs array-dimension]] || array-dimension || array-dimension ||\n|| [[$$hs array-dimension-limit]] || array-dimension-limit || array-dimension-limit ||\n|| [[$$hs array-dimensions]] || array-dimensions || array-dimensions ||\n|| [[$$hs array-displacement]] || array-displacement ||  ||\n|| [[$$hs array-element-type]] || array-element-type || array-element-type ||\n|| [[$$hs array-has-fill-pointer-p]] || array-has-fill-pointer-p || array-has-fill-pointer-p ||\n|| [[$$hs array-in-bounds-p]] || array-in-bounds-p || array-in-bounds-p ||\n|| [[$$hs array-rank]] || array-rank || array-rank ||\n|| [[$$hs array-rank-limit]] || array-rank-limit || array-rank-limit ||\n|| [[$$hs array-row-major-index]] || array-row-major-index || array-row-major-index ||\n|| [[$$hs array-total-size]] || array-total-size || array-total-size ||\n|| [[$$hs array-total-size-limit]] || array-total-size-limit || array-total-size-limit ||\n|| [[$$hs arrayp]] || arrayp || arrayp ||\n|| [[$$hs ash]] || ash || ash ||\n|| [[$$hs asin]] || asin || asin ||\n|| [[$$hs asinh]] || asinh || asinh ||\n|| [[$$hs assert]] || assert || assert ||\n|| [[$$hs assoc]] || assoc || assoc ||\n|| [[$$hs assoc-if]] || assoc-if || assoc-if ||\n|| [[$$hs assoc-if-not]] || assoc-if-not || assoc-if-not ||\n|| [[$$hs atan]] || atan || atan ||\n|| [[$$hs atanh]] || atanh || atanh ||\n|| [[$$hs atom]] || atom || atom ||\n|| [[$$hs base-char]] || base-char ||  ||\n|| [[$$hs base-string]] || base-string ||  ||\n|| [[$$hs bignum]] || bignum ||  ||\n|| [[$$hs bit]] || bit || bit ||\n|| [[$$hs bit]] || bit || bit ||\n|| [[$$hs bit-and]] || bit-and || bit-and ||\n|| [[$$hs bit-and]] || bit-and || bit-and ||\n|| [[$$hs bit-andc1]] || bit-andc1 || bit-andc1 ||\n|| [[$$hs bit-andc1]] || bit-andc1 || bit-andc1 ||\n|| [[$$hs bit-andc2]] || bit-andc2 || bit-andc2 ||\n|| [[$$hs bit-andc2]] || bit-andc2 || bit-andc2 ||\n|| [[$$hs bit-eqv]] || bit-eqv || bit-eqv ||\n|| [[$$hs bit-eqv]] || bit-eqv || bit-eqv ||\n|| [[$$hs bit-ior]] || bit-ior || bit-ior ||\n|| [[$$hs bit-ior]] || bit-ior || bit-ior ||\n|| [[$$hs bit-nand]] || bit-nand || bit-nand ||\n|| [[$$hs bit-nand]] || bit-nand || bit-nand ||\n|| [[$$hs bit-nor]] || bit-nor || bit-nor ||\n|| [[$$hs bit-nor]] || bit-nor || bit-nor ||\n|| [[$$hs bit-not]] || bit-not || bit-not ||\n|| [[$$hs bit-not]] || bit-not || bit-not ||\n|| [[$$hs bit-orc1]] || bit-orc1 || bit-orc1 ||\n|| [[$$hs bit-orc1]] || bit-orc1 || bit-orc1 ||\n|| [[$$hs bit-orc2]] || bit-orc2 || bit-orc2 ||\n|| [[$$hs bit-orc2]] || bit-orc2 || bit-orc2 ||\n|| [[$$hs bit-vector]] || bit-vector || bit-vector ||\n|| [[$$hs bit-vector-p]] || bit-vector-p || bit-vector-p ||\n|| [[$$hs bit-xor]] || bit-xor || bit-xor ||\n|| [[$$hs bit-xor]] || bit-xor || bit-xor ||\n|| [[$$hs block]] || block || block ||\n|| [[$$hs boole]] || boole || boole ||\n|| [[$$hs boole-1]] || boole-1 || boole-1 ||\n|| [[$$hs boole-2]] || boole-2 || boole-2 ||\n|| [[$$hs boole-and]] || boole-and || boole-and ||\n|| [[$$hs boole-andc1]] || boole-andc1 || boole-andc1 ||\n|| [[$$hs boole-andc2]] || boole-andc2 || boole-andc2 ||\n|| [[$$hs boole-c1]] || boole-c1 || boole-c1 ||\n|| [[$$hs boole-c2]] || boole-c2 || boole-c2 ||\n|| [[$$hs boole-clr]] || boole-clr || boole-clr ||\n|| [[$$hs boole-eqv]] || boole-eqv || boole-eqv ||\n|| [[$$hs boole-ior]] || boole-ior || boole-ior ||\n|| [[$$hs boole-nand]] || boole-nand || boole-nand ||\n|| [[$$hs boole-nor]] || boole-nor || boole-nor ||\n|| [[$$hs boole-orc1]] || boole-orc1 || boole-orc1 ||\n|| [[$$hs boole-orc2]] || boole-orc2 || boole-orc2 ||\n|| [[$$hs boole-set]] || boole-set || boole-set ||\n|| [[$$hs boole-xor]] || boole-xor || boole-xor ||\n|| [[$$hs boolean]] || boolean ||  ||\n|| [[$$hs both-case-p]] || both-case-p || both-case-p ||\n|| [[$$hs boundp]] || boundp || boundp ||\n|| [[$$hs break]] || break || break ||\n|| [[$$hs broadcast-stream]] || broadcast-stream ||  ||\n|| [[$$hs broadcast-stream-streams]] || broadcast-stream-streams ||  ||\n|| [[$$hs built-in-class]] || built-in-class ||  ||\n|| [[$$hs butlast]] || butlast || butlast ||\n|| [[$$hs byte]] || byte || byte ||\n|| [[$$hs byte-position]] || byte-position || byte-position ||\n|| [[$$hs byte-size]] || byte-size || byte-size ||\n|| [[$$hs caaaar]] || caaaar || caaaar ||\n|| [[$$hs caaadr]] || caaadr || caaadr ||\n|| [[$$hs caaar]] || caaar || caaar ||\n|| [[$$hs caadar]] || caadar || caadar ||\n|| [[$$hs caaddr]] || caaddr || caaddr ||\n|| [[$$hs caadr]] || caadr || caadr ||\n|| [[$$hs caar]] || caar || caar ||\n|| [[$$hs cadaar]] || cadaar || cadaar ||\n|| [[$$hs cadadr]] || cadadr || cadadr ||\n|| [[$$hs cadar]] || cadar || cadar ||\n|| [[$$hs caddar]] || caddar || caddar ||\n|| [[$$hs cadddr]] || cadddr || cadddr ||\n|| [[$$hs caddr]] || caddr || caddr ||\n|| [[$$hs cadr]] || cadr || cadr ||\n|| [[$$hs call-arguments-limit]] || call-arguments-limit || call-arguments-limit ||\n|| [[$$hs call-method]] || call-method ||  ||\n|| [[$$hs call-next-method]] || call-next-method ||  ||\n|| [[$$hs car]] || car || car ||\n|| [[$$hs case]] || case || case ||\n|| [[$$hs catch]] || catch || catch ||\n|| [[$$hs ccase]] || ccase || ccase ||\n|| [[$$hs cdaaar]] || cdaaar || cdaaar ||\n|| [[$$hs cdaadr]] || cdaadr || cdaadr ||\n|| [[$$hs cdaar]] || cdaar || cdaar ||\n|| [[$$hs cdadar]] || cdadar || cdadar ||\n|| [[$$hs cdaddr]] || cdaddr || cdaddr ||\n|| [[$$hs cdadr]] || cdadr || cdadr ||\n|| [[$$hs cdar]] || cdar || cdar ||\n|| [[$$hs cddaar]] || cddaar || cddaar ||\n|| [[$$hs cddadr]] || cddadr || cddadr ||\n|| [[$$hs cddar]] || cddar || cddar ||\n|| [[$$hs cdddar]] || cdddar || cdddar ||\n|| [[$$hs cddddr]] || cddddr || cddddr ||\n|| [[$$hs cdddr]] || cdddr || cdddr ||\n|| [[$$hs cddr]] || cddr || cddr ||\n|| [[$$hs cdr]] || cdr || cdr ||\n|| [[$$hs ceiling]] || ceiling || ceiling ||\n|| [[$$hs cell-error]] || cell-error ||  ||\n|| [[$$hs cell-error-name]] || cell-error-name ||  ||\n|| [[$$hs cerror]] || cerror || cerror ||\n|| [[$$hs change-class]] || change-class ||  ||\n|| [[$$hs char]] || char || char ||\n||  ||  || char-bit ||\n||  ||  || char-bits ||\n||  ||  || char-bits-limit ||\n|| [[$$hs char-code]] || char-code || char-code ||\n|| [[$$hs char-code-limit]] || char-code-limit || char-code-limit ||\n||  ||  || char-control-bit ||\n|| [[$$hs char-downcase]] || char-downcase || char-downcase ||\n|| [[$$hs char-equal]] || char-equal || char-equal ||\n||  ||  || char-font ||\n||  ||  || char-font-limit ||\n|| [[$$hs char-greaterp]] || char-greaterp || char-greaterp ||\n||  ||  || char-hyper-bit ||\n|| [[$$hs char-int]] || char-int || char-int ||\n|| [[$$hs char-lessp]] || char-lessp || char-lessp ||\n||  ||  || char-meta-bit ||\n|| [[$$hs char-name]] || char-name || char-name ||\n|| [[$$hs char-not-equal]] || char-not-equal || char-not-equal ||\n|| [[$$hs char-not-greaterp]] || char-not-greaterp || char-not-greaterp ||\n|| [[$$hs char-not-lessp]] || char-not-lessp || char-not-lessp ||\n||  ||  || char-super-bit ||\n|| [[$$hs char-upcase]] || char-upcase || char-upcase ||\n|| [[$$hs char/=]] || char/= || char/= ||\n|| [[$$hs char<]] || char< || char< ||\n|| [[$$hs char<=]] || char<= || char<= ||\n|| [[$$hs char=]] || char= || char= ||\n|| [[$$hs char>]] || char> || char> ||\n|| [[$$hs char>=]] || char>= || char>= ||\n|| [[$$hs character]] || character || character ||\n|| [[$$hs characterp]] || characterp || characterp ||\n|| [[$$hs check-type]] || check-type || check-type ||\n|| [[$$hs cis]] || cis || cis ||\n|| [[$$hs class]] || class ||  ||\n|| [[$$hs class-name]] || class-name ||  ||\n|| [[$$hs class-of]] || class-of ||  ||\n|| [[$$hs clear-input]] || clear-input || clear-input ||\n|| [[$$hs clear-output]] || clear-output || clear-output ||\n|| [[$$hs close]] || close || close ||\n|| [[$$hs clrhash]] || clrhash || clrhash ||\n|| [[$$hs code-char]] || code-char || code-char ||\n|| [[$$hs coerce]] || coerce || coerce ||\n||  ||  || commonp ||\n|| [[$$hs compilation-speed]] || compilation-speed || compilation-speed ||\n|| [[$$hs compile]] || compile || compile ||\n|| [[$$hs compile-file]] || compile-file || compile-file ||\n|| [[$$hs compile-file-pathname]] || compile-file-pathname ||  ||\n|| [[$$hs compiled-function]] || compiled-function || compiled-function ||\n|| [[$$hs compiled-function-p]] || compiled-function-p || compiled-function-p ||\n||  ||  || compiler-let ||\n|| [[$$hs compiler-macro]] || compiler-macro ||  ||\n|| [[$$hs compiler-macro-function]] || compiler-macro-function ||  ||\n|| [[$$hs complement]] || complement ||  ||\n|| [[$$hs complex]] || complex || complex ||\n|| [[$$hs complexp]] || complexp || complexp ||\n|| [[$$hs compute-applicable-methods]] || compute-applicable-methods ||  ||\n|| [[$$hs compute-restarts]] || compute-restarts ||  ||\n|| [[$$hs concatenate]] || concatenate || concatenate ||\n|| [[$$hs concatenated-stream]] || concatenated-stream ||  ||\n|| [[$$hs concatenated-stream-streams]] || concatenated-stream-streams ||  ||\n|| [[$$hs cond]] || cond || cond ||\n|| [[$$hs condition]] || condition ||  ||\n|| [[$$hs conjugate]] || conjugate || conjugate ||\n|| [[$$hs cons]] || cons || cons ||\n|| [[$$hs consp]] || consp || consp ||\n|| [[$$hs constantly]] || constantly ||  ||\n|| [[$$hs constantp]] || constantp || constantp ||\n|| [[$$hs continue]] || continue ||  ||\n|| [[$$hs control-error]] || control-error ||  ||\n|| [[$$hs copy-alist]] || copy-alist || copy-alist ||\n|| [[$$hs copy-list]] || copy-list || copy-list ||\n|| [[$$hs copy-pprint-dispatch]] || copy-pprint-dispatch ||  ||\n|| [[$$hs copy-readtable]] || copy-readtable || copy-readtable ||\n|| [[$$hs copy-seq]] || copy-seq || copy-seq ||\n|| [[$$hs copy-structure]] || copy-structure ||  ||\n|| [[$$hs copy-symbol]] || copy-symbol || copy-symbol ||\n|| [[$$hs copy-tree]] || copy-tree || copy-tree ||\n|| [[$$hs cos]] || cos || cos ||\n|| [[$$hs cosh]] || cosh || cosh ||\n|| [[$$hs count]] || count || count ||\n|| [[$$hs count-if]] || count-if || count-if ||\n|| [[$$hs count-if-not]] || count-if-not || count-if-not ||\n|| [[$$hs ctypecase]] || ctypecase || ctypecase ||\n|| [[$$hs debug]] || debug || debug ||\n|| [[$$hs decf]] || decf || decf ||\n|| [[$$hs declaim]] || declaim ||  ||\n|| [[$$hs declaration]] || declaration || declaration ||\n|| [[$$hs declare]] || declare || declare ||\n|| [[$$hs decode-float]] || decode-float || decode-float ||\n|| [[$$hs decode-universal-time]] || decode-universal-time || decode-universal-time ||\n|| [[$$hs defclass]] || defclass ||  ||\n|| [[$$hs defconstant]] || defconstant || defconstant ||\n|| [[$$hs defgeneric]] || defgeneric ||  ||\n|| [[$$hs define-compiler-macro]] || define-compiler-macro ||  ||\n|| [[$$hs define-condition]] || define-condition ||  ||\n|| [[$$hs define-method-combination]] || define-method-combination ||  ||\n|| [[$$hs define-modify-macro]] || define-modify-macro || define-modify-macro ||\n|| [[$$hs define-setf-expander]] || define-setf-expander ||  ||\n||  ||  || define-setf-method ||\n|| [[$$hs define-symbol-macro]] || define-symbol-macro ||  ||\n|| [[$$hs defmacro]] || defmacro || defmacro ||\n|| [[$$hs defmethod]] || defmethod ||  ||\n|| [[$$hs defpackage]] || defpackage ||  ||\n|| [[$$hs defparameter]] || defparameter || defparameter ||\n|| [[$$hs defsetf]] || defsetf || defsetf ||\n|| [[$$hs defstruct]] || defstruct || defstruct ||\n|| [[$$hs deftype]] || deftype || deftype ||\n|| [[$$hs defun]] || defun || defun ||\n|| [[$$hs defvar]] || defvar || defvar ||\n|| [[$$hs delete]] || delete || delete ||\n|| [[$$hs delete-duplicates]] || delete-duplicates || delete-duplicates ||\n|| [[$$hs delete-file]] || delete-file || delete-file ||\n|| [[$$hs delete-if]] || delete-if || delete-if ||\n|| [[$$hs delete-if-not]] || delete-if-not || delete-if-not ||\n|| [[$$hs delete-package]] || delete-package ||  ||\n|| [[$$hs denominator]] || denominator || denominator ||\n|| [[$$hs deposit-field]] || deposit-field || deposit-field ||\n|| [[$$hs describe]] || describe || describe ||\n|| [[$$hs describe-object]] || describe-object ||  ||\n|| [[$$hs destructuring-bind]] || destructuring-bind ||  ||\n|| [[$$hs digit-char]] || digit-char || digit-char ||\n|| [[$$hs digit-char-p]] || digit-char-p || digit-char-p ||\n|| [[$$hs directory]] || directory || directory ||\n|| [[$$hs directory-namestring]] || directory-namestring || directory-namestring ||\n|| [[$$hs disassemble]] || disassemble || disassemble ||\n|| [[$$hs division-by-zero]] || division-by-zero ||  ||\n|| [[$$hs do]] || do || do ||\n|| [[$$hs do*]] || do* || do* ||\n|| [[$$hs do-all-symbols]] || do-all-symbols || do-all-symbols ||\n|| [[$$hs do-external-symbols]] || do-external-symbols || do-external-symbols ||\n|| [[$$hs do-symbols]] || do-symbols || do-symbols ||\n|| [[$$hs documentation]] || documentation || documentation ||\n|| [[$$hs dolist]] || dolist || dolist ||\n|| [[$$hs dotimes]] || dotimes || dotimes ||\n|| [[$$hs double-float]] || double-float || double-float ||\n|| [[$$hs double-float-epsilon]] || double-float-epsilon || double-float-epsilon ||\n|| [[$$hs double-float-negative-epsilon]] || double-float-negative-epsilon || double-float-negative-epsilon ||\n|| [[$$hs dpb]] || dpb || dpb ||\n|| [[$$hs dribble]] || dribble || dribble ||\n|| [[$$hs dynamic-extent]] || dynamic-extent ||  ||\n|| [[$$hs ecase]] || ecase || ecase ||\n|| [[$$hs echo-stream]] || echo-stream ||  ||\n|| [[$$hs echo-stream-input-stream]] || echo-stream-input-stream ||  ||\n|| [[$$hs echo-stream-output-stream]] || echo-stream-output-stream ||  ||\n|| [[$$hs ed]] || ed || ed ||\n|| [[$$hs eighth]] || eighth || eighth ||\n|| [[$$hs elt]] || elt || elt ||\n|| [[$$hs encode-universal-time]] || encode-universal-time || encode-universal-time ||\n|| [[$$hs end-of-file]] || end-of-file ||  ||\n|| [[$$hs endp]] || endp || endp ||\n|| [[$$hs enough-namestring]] || enough-namestring || enough-namestring ||\n|| [[$$hs ensure-directories-exist]] || ensure-directories-exist ||  ||\n|| [[$$hs ensure-generic-function]] || ensure-generic-function ||  ||\n|| [[$$hs eq]] || eq || eq ||\n|| [[$$hs eql]] || eql || eql ||\n|| [[$$hs equal]] || equal || equal ||\n|| [[$$hs equalp]] || equalp || equalp ||\n|| [[$$hs error]] || error || error ||\n|| [[$$hs etypecase]] || etypecase || etypecase ||\n|| [[$$hs eval]] || eval || eval ||\n|| [[$$hs eval-when]] || eval-when || eval-when ||\n||  ||  || evalhook ||\n|| [[$$hs evenp]] || evenp || evenp ||\n|| [[$$hs every]] || every || every ||\n|| [[$$hs exp]] || exp || exp ||\n|| [[$$hs export]] || export || export ||\n|| [[$$hs expt]] || expt || expt ||\n|| [[$$hs extended-char]] || extended-char ||  ||\n|| [[$$hs fboundp]] || fboundp || fboundp ||\n|| [[$$hs fceiling]] || fceiling || fceiling ||\n|| [[$$hs fdefinition]] || fdefinition ||  ||\n|| [[$$hs ffloor]] || ffloor || ffloor ||\n|| [[$$hs fifth]] || fifth || fifth ||\n|| [[$$hs file-author]] || file-author || file-author ||\n|| [[$$hs file-error]] || file-error ||  ||\n|| [[$$hs file-error-pathname]] || file-error-pathname ||  ||\n|| [[$$hs file-length]] || file-length || file-length ||\n|| [[$$hs file-namestring]] || file-namestring || file-namestring ||\n|| [[$$hs file-position]] || file-position || file-position ||\n|| [[$$hs file-stream]] || file-stream ||  ||\n|| [[$$hs file-string-length]] || file-string-length ||  ||\n|| [[$$hs file-write-date]] || file-write-date || file-write-date ||\n|| [[$$hs fill]] || fill || fill ||\n|| [[$$hs fill-pointer]] || fill-pointer || fill-pointer ||\n|| [[$$hs find]] || find || find ||\n|| [[$$hs find-all-symbols]] || find-all-symbols || find-all-symbols ||\n|| [[$$hs find-class]] || find-class ||  ||\n|| [[$$hs find-if]] || find-if || find-if ||\n|| [[$$hs find-if-not]] || find-if-not || find-if-not ||\n|| [[$$hs find-method]] || find-method ||  ||\n|| [[$$hs find-package]] || find-package || find-package ||\n|| [[$$hs find-restart]] || find-restart ||  ||\n|| [[$$hs find-symbol]] || find-symbol || find-symbol ||\n|| [[$$hs finish-output]] || finish-output || finish-output ||\n|| [[$$hs first]] || first || first ||\n|| [[$$hs fixnum]] || fixnum || fixnum ||\n|| [[$$hs flet]] || flet || flet ||\n|| [[$$hs float]] || float || float ||\n|| [[$$hs float-digits]] || float-digits || float-digits ||\n|| [[$$hs float-precision]] || float-precision || float-precision ||\n|| [[$$hs float-radix]] || float-radix || float-radix ||\n|| [[$$hs float-sign]] || float-sign || float-sign ||\n|| [[$$hs floating-point-inexact]] || floating-point-inexact ||  ||\n|| [[$$hs floating-point-invalid-operation]] || floating-point-invalid-operation ||  ||\n|| [[$$hs floating-point-overflow]] || floating-point-overflow ||  ||\n|| [[$$hs floating-point-underflow]] || floating-point-underflow ||  ||\n|| [[$$hs floatp]] || floatp || floatp ||\n|| [[$$hs floor]] || floor || floor ||\n|| [[$$hs fmakunbound]] || fmakunbound || fmakunbound ||\n|| [[$$hs force-output]] || force-output || force-output ||\n|| [[$$hs format]] || format || format ||\n|| [[$$hs formatter]] || formatter ||  ||\n|| [[$$hs fourth]] || fourth || fourth ||\n|| [[$$hs fresh-line]] || fresh-line || fresh-line ||\n|| [[$$hs fround]] || fround || fround ||\n|| [[$$hs ftruncate]] || ftruncate || ftruncate ||\n|| [[$$hs ftype]] || ftype || ftype ||\n|| [[$$hs funcall]] || funcall || funcall ||\n|| [[$$hs function]] || function || function ||\n|| [[$$hs function-keywords]] || function-keywords ||  ||\n|| [[$$hs function-lambda-expression]] || function-lambda-expression ||  ||\n|| [[$$hs functionp]] || functionp || functionp ||\n|| [[$$hs gcd]] || gcd || gcd ||\n|| [[$$hs generic-function]] || generic-function ||  ||\n|| [[$$hs gensym]] || gensym || gensym ||\n|| [[$$hs gentemp]] || gentemp || gentemp ||\n|| [[$$hs get]] || get || get ||\n|| [[$$hs get-decoded-time]] || get-decoded-time || get-decoded-time ||\n|| [[$$hs get-dispatch-macro-character]] || get-dispatch-macro-character || get-dispatch-macro-character ||\n|| [[$$hs get-internal-real-time]] || get-internal-real-time || get-internal-real-time ||\n|| [[$$hs get-internal-run-time]] || get-internal-run-time || get-internal-run-time ||\n|| [[$$hs get-macro-character]] || get-macro-character || get-macro-character ||\n|| [[$$hs get-output-stream-string]] || get-output-stream-string || get-output-stream-string ||\n|| [[$$hs get-properties]] || get-properties || get-properties ||\n|| [[$$hs get-setf-expansion]] || get-setf-expansion ||  ||\n||  ||  || get-setf-method ||\n||  ||  || get-setf-method-multiple-value ||\n|| [[$$hs get-universal-time]] || get-universal-time || get-universal-time ||\n|| [[$$hs getf]] || getf || getf ||\n|| [[$$hs gethash]] || gethash || gethash ||\n|| [[$$hs go]] || go || go ||\n|| [[$$hs graphic-char-p]] || graphic-char-p || graphic-char-p ||\n|| [[$$hs handler-bind]] || handler-bind ||  ||\n|| [[$$hs handler-case]] || handler-case ||  ||\n|| [[$$hs hash-table]] || hash-table || hash-table ||\n|| [[$$hs hash-table-count]] || hash-table-count || hash-table-count ||\n|| [[$$hs hash-table-p]] || hash-table-p || hash-table-p ||\n|| [[$$hs hash-table-rehash-size]] || hash-table-rehash-size ||  ||\n|| [[$$hs hash-table-rehash-threshold]] || hash-table-rehash-threshold ||  ||\n|| [[$$hs hash-table-size]] || hash-table-size ||  ||\n|| [[$$hs hash-table-test]] || hash-table-test ||  ||\n|| [[$$hs host-namestring]] || host-namestring || host-namestring ||\n|| [[$$hs identity]] || identity || identity ||\n|| [[$$hs if]] || if || if ||\n|| [[$$hs ignorable]] || ignorable ||  ||\n|| [[$$hs ignore]] || ignore || ignore ||\n|| [[$$hs ignore-errors]] || ignore-errors ||  ||\n|| [[$$hs imagpart]] || imagpart || imagpart ||\n|| [[$$hs import]] || import || import ||\n|| [[$$hs in-package]] || in-package || in-package ||\n|| [[$$hs incf]] || incf || incf ||\n|| [[$$hs initialize-instance]] || initialize-instance ||  ||\n|| [[$$hs inline]] || inline || inline ||\n|| [[$$hs input-stream-p]] || input-stream-p || input-stream-p ||\n|| [[$$hs inspect]] || inspect || inspect ||\n||  ||  || int-char ||\n|| [[$$hs integer]] || integer || integer ||\n|| [[$$hs integer-decode-float]] || integer-decode-float || integer-decode-float ||\n|| [[$$hs integer-length]] || integer-length || integer-length ||\n|| [[$$hs integerp]] || integerp || integerp ||\n|| [[$$hs interactive-stream-p]] || interactive-stream-p ||  ||\n|| [[$$hs intern]] || intern || intern ||\n|| [[$$hs internal-time-units-per-second]] || internal-time-units-per-second || internal-time-units-per-second ||\n|| [[$$hs intersection]] || intersection || intersection ||\n|| [[$$hs invalid-method-error]] || invalid-method-error ||  ||\n|| [[$$hs invoke-debugger]] || invoke-debugger ||  ||\n|| [[$$hs invoke-restart]] || invoke-restart ||  ||\n|| [[$$hs invoke-restart-interactively]] || invoke-restart-interactively ||  ||\n|| [[$$hs isqrt]] || isqrt || isqrt ||\n|| [[$$hs keyword]] || keyword || keyword ||\n|| [[$$hs keywordp]] || keywordp || keywordp ||\n|| [[$$hs labels]] || labels || labels ||\n|| [[$$hs lambda]] || lambda || lambda ||\n|| [[$$hs lambda-list-keywords]] || lambda-list-keywords || lambda-list-keywords ||\n|| [[$$hs lambda-parameters-limit]] || lambda-parameters-limit || lambda-parameters-limit ||\n|| [[$$hs last]] || last || last ||\n|| [[$$hs lcm]] || lcm || lcm ||\n|| [[$$hs ldb]] || ldb || ldb ||\n|| [[$$hs ldb-test]] || ldb-test || ldb-test ||\n|| [[$$hs ldiff]] || ldiff || ldiff ||\n|| [[$$hs least-negative-double-float]] || least-negative-double-float || least-negative-double-float ||\n|| [[$$hs least-negative-long-float]] || least-negative-long-float || least-negative-long-float ||\n|| [[$$hs least-negative-normalized-double-float]] || least-negative-normalized-double-float ||  ||\n|| [[$$hs least-negative-normalized-long-float]] || least-negative-normalized-long-float ||  ||\n|| [[$$hs least-negative-normalized-short-float]] || least-negative-normalized-short-float ||  ||\n|| [[$$hs least-negative-normalized-single-float]] || least-negative-normalized-single-float ||  ||\n|| [[$$hs least-negative-short-float]] || least-negative-short-float || least-negative-short-float ||\n|| [[$$hs least-negative-single-float]] || least-negative-single-float || least-negative-single-float ||\n|| [[$$hs least-positive-double-float]] || least-positive-double-float || least-positive-double-float ||\n|| [[$$hs least-positive-long-float]] || least-positive-long-float || least-positive-long-float ||\n|| [[$$hs least-positive-normalized-double-float]] || least-positive-normalized-double-float ||  ||\n|| [[$$hs least-positive-normalized-long-float]] || least-positive-normalized-long-float ||  ||\n|| [[$$hs least-positive-normalized-short-float]] || least-positive-normalized-short-float ||  ||\n|| [[$$hs least-positive-normalized-single-float]] || least-positive-normalized-single-float ||  ||\n|| [[$$hs least-positive-short-float]] || least-positive-short-float || least-positive-short-float ||\n|| [[$$hs least-positive-single-float]] || least-positive-single-float || least-positive-single-float ||\n|| [[$$hs length]] || length || length ||\n|| [[$$hs let]] || let || let ||\n|| [[$$hs let*]] || let* || let* ||\n|| [[$$hs lisp-implementation-type]] || lisp-implementation-type || lisp-implementation-type ||\n|| [[$$hs lisp-implementation-version]] || lisp-implementation-version || lisp-implementation-version ||\n|| [[$$hs list]] || list || list ||\n|| [[$$hs list*]] || list* || list* ||\n|| [[$$hs list-all-packages]] || list-all-packages || list-all-packages ||\n|| [[$$hs list-length]] || list-length || list-length ||\n|| [[$$hs listen]] || listen || listen ||\n|| [[$$hs listp]] || listp || listp ||\n|| [[$$hs load]] || load || load ||\n|| [[$$hs load-logical-pathname-translations]] || load-logical-pathname-translations ||  ||\n|| [[$$hs load-time-value]] || load-time-value ||  ||\n|| [[$$hs locally]] || locally || locally ||\n|| [[$$hs log]] || log || log ||\n|| [[$$hs logand]] || logand || logand ||\n|| [[$$hs logandc1]] || logandc1 || logandc1 ||\n|| [[$$hs logandc2]] || logandc2 || logandc2 ||\n|| [[$$hs logbitp]] || logbitp || logbitp ||\n|| [[$$hs logcount]] || logcount || logcount ||\n|| [[$$hs logeqv]] || logeqv || logeqv ||\n|| [[$$hs logical-pathname]] || logical-pathname ||  ||\n|| [[$$hs logical-pathname-translations]] || logical-pathname-translations ||  ||\n|| [[$$hs logior]] || logior || logior ||\n|| [[$$hs lognand]] || lognand || lognand ||\n|| [[$$hs lognor]] || lognor || lognor ||\n|| [[$$hs lognot]] || lognot || lognot ||\n|| [[$$hs logorc1]] || logorc1 || logorc1 ||\n|| [[$$hs logorc2]] || logorc2 || logorc2 ||\n|| [[$$hs logtest]] || logtest || logtest ||\n|| [[$$hs logxor]] || logxor || logxor ||\n|| [[$$hs long-float]] || long-float || long-float ||\n|| [[$$hs long-float-epsilon]] || long-float-epsilon || long-float-epsilon ||\n|| [[$$hs long-float-negative-epsilon]] || long-float-negative-epsilon || long-float-negative-epsilon ||\n|| [[$$hs long-site-name]] || long-site-name || long-site-name ||\n|| [[$$hs loop]] || loop || loop ||\n|| [[$$hs loop-finish]] || loop-finish ||  ||\n|| [[$$hs lower-case-p]] || lower-case-p || lower-case-p ||\n|| [[$$hs machine-instance]] || machine-instance || machine-instance ||\n|| [[$$hs machine-type]] || machine-type || machine-type ||\n|| [[$$hs machine-version]] || machine-version || machine-version ||\n|| [[$$hs macro-function]] || macro-function || macro-function ||\n|| [[$$hs macroexpand]] || macroexpand || macroexpand ||\n|| [[$$hs macroexpand-1]] || macroexpand-1 || macroexpand-1 ||\n|| [[$$hs macrolet]] || macrolet || macrolet ||\n|| [[$$hs make-array]] || make-array || make-array ||\n||  ||  || make-bit-vector ||\n|| [[$$hs make-broadcast-stream]] || make-broadcast-stream || make-broadcast-stream ||\n||  ||  || make-char ||\n|| [[$$hs make-concatenated-stream]] || make-concatenated-stream || make-concatenated-stream ||\n|| [[$$hs make-condition]] || make-condition ||  ||\n|| [[$$hs make-dispatch-macro-character]] || make-dispatch-macro-character || make-dispatch-macro-character ||\n|| [[$$hs make-echo-stream]] || make-echo-stream || make-echo-stream ||\n|| [[$$hs make-hash-table]] || make-hash-table || make-hash-table ||\n|| [[$$hs make-instance]] || make-instance ||  ||\n|| [[$$hs make-instances-obsolete]] || make-instances-obsolete ||  ||\n|| [[$$hs make-list]] || make-list || make-list ||\n|| [[$$hs make-load-form]] || make-load-form ||  ||\n|| [[$$hs make-load-form-saving-slots]] || make-load-form-saving-slots ||  ||\n|| [[$$hs make-method]] || make-method ||  ||\n|| [[$$hs make-package]] || make-package || make-package ||\n|| [[$$hs make-pathname]] || make-pathname || make-pathname ||\n|| [[$$hs make-random-state]] || make-random-state || make-random-state ||\n|| [[$$hs make-sequence]] || make-sequence || make-sequence ||\n|| [[$$hs make-string]] || make-string || make-string ||\n|| [[$$hs make-string-input-stream]] || make-string-input-stream || make-string-input-stream ||\n|| [[$$hs make-string-output-stream]] || make-string-output-stream || make-string-output-stream ||\n|| [[$$hs make-symbol]] || make-symbol || make-symbol ||\n|| [[$$hs make-synonym-stream]] || make-synonym-stream || make-synonym-stream ||\n|| [[$$hs make-two-way-stream]] || make-two-way-stream || make-two-way-stream ||\n|| [[$$hs makunbound]] || makunbound || makunbound ||\n|| [[$$hs map]] || map || map ||\n|| [[$$hs map-into]] || map-into ||  ||\n|| [[$$hs mapc]] || mapc || mapc ||\n|| [[$$hs mapcan]] || mapcan || mapcan ||\n|| [[$$hs mapcar]] || mapcar || mapcar ||\n|| [[$$hs mapcon]] || mapcon || mapcon ||\n|| [[$$hs maphash]] || maphash || maphash ||\n|| [[$$hs mapl]] || mapl || mapl ||\n|| [[$$hs maplist]] || maplist || maplist ||\n|| [[$$hs mask-field]] || mask-field || mask-field ||\n|| [[$$hs max]] || max || max ||\n|| [[$$hs member]] || member || member ||\n|| [[$$hs member-if]] || member-if || member-if ||\n|| [[$$hs member-if-not]] || member-if-not || member-if-not ||\n|| [[$$hs merge]] || merge || merge ||\n|| [[$$hs merge-pathnames]] || merge-pathnames || merge-pathnames ||\n|| [[$$hs method]] || method ||  ||\n|| [[$$hs method-combination]] || method-combination ||  ||\n|| [[$$hs method-combination-error]] || method-combination-error ||  ||\n|| [[$$hs method-qualifiers]] || method-qualifiers ||  ||\n|| [[$$hs min]] || min || min ||\n|| [[$$hs minusp]] || minusp || minusp ||\n|| [[$$hs mismatch]] || mismatch || mismatch ||\n|| [[$$hs mod]] || mod || mod ||\n|| [[$$hs most-negative-double-float]] || most-negative-double-float || most-negative-double-float ||\n|| [[$$hs most-negative-fixnum]] || most-negative-fixnum || most-negative-fixnum ||\n|| [[$$hs most-negative-long-float]] || most-negative-long-float || most-negative-long-float ||\n|| [[$$hs most-negative-short-float]] || most-negative-short-float || most-negative-short-float ||\n|| [[$$hs most-negative-single-float]] || most-negative-single-float || most-negative-single-float ||\n|| [[$$hs most-positive-double-float]] || most-positive-double-float || most-positive-double-float ||\n|| [[$$hs most-positive-fixnum]] || most-positive-fixnum || most-positive-fixnum ||\n|| [[$$hs most-positive-long-float]] || most-positive-long-float || most-positive-long-float ||\n|| [[$$hs most-positive-short-float]] || most-positive-short-float || most-positive-short-float ||\n|| [[$$hs most-positive-single-float]] || most-positive-single-float || most-positive-single-float ||\n|| [[$$hs muffle-warning]] || muffle-warning ||  ||\n|| [[$$hs multiple-value-bind]] || multiple-value-bind || multiple-value-bind ||\n|| [[$$hs multiple-value-call]] || multiple-value-call || multiple-value-call ||\n|| [[$$hs multiple-value-list]] || multiple-value-list || multiple-value-list ||\n|| [[$$hs multiple-value-prog1]] || multiple-value-prog1 || multiple-value-prog1 ||\n|| [[$$hs multiple-value-setq]] || multiple-value-setq || multiple-value-setq ||\n|| [[$$hs multiple-values-limit]] || multiple-values-limit || multiple-values-limit ||\n|| [[$$hs name-char]] || name-char || name-char ||\n|| [[$$hs namestring]] || namestring || namestring ||\n|| [[$$hs nbutlast]] || nbutlast || nbutlast ||\n|| [[$$hs nconc]] || nconc || nconc ||\n|| [[$$hs next-method-p]] || next-method-p ||  ||\n|| [[$$hs nintersection]] || nintersection || nintersection ||\n|| [[$$hs ninth]] || ninth || ninth ||\n|| [[$$hs no-applicable-method]] || no-applicable-method ||  ||\n|| [[$$hs no-next-method]] || no-next-method ||  ||\n|| [[$$hs not]] || not || not ||\n|| [[$$hs notany]] || notany || notany ||\n|| [[$$hs notevery]] || notevery || notevery ||\n|| [[$$hs notinline]] || notinline || notinline ||\n|| [[$$hs nreconc]] || nreconc || nreconc ||\n|| [[$$hs nreverse]] || nreverse || nreverse ||\n|| [[$$hs nset-difference]] || nset-difference || nset-difference ||\n|| [[$$hs nset-exclusive-or]] || nset-exclusive-or || nset-exclusive-or ||\n|| [[$$hs nstring-capitalize]] || nstring-capitalize || nstring-capitalize ||\n|| [[$$hs nstring-downcase]] || nstring-downcase || nstring-downcase ||\n|| [[$$hs nstring-upcase]] || nstring-upcase || nstring-upcase ||\n|| [[$$hs nsublis]] || nsublis || nsublis ||\n|| [[$$hs nsubst]] || nsubst || nsubst ||\n|| [[$$hs nsubst-if]] || nsubst-if || nsubst-if ||\n|| [[$$hs nsubst-if-not]] || nsubst-if-not || nsubst-if-not ||\n|| [[$$hs nsubstitute]] || nsubstitute || nsubstitute ||\n|| [[$$hs nsubstitute-if]] || nsubstitute-if || nsubstitute-if ||\n|| [[$$hs nsubstitute-if-not]] || nsubstitute-if-not || nsubstitute-if-not ||\n|| [[$$hs nth]] || nth || nth ||\n|| [[$$hs nth-value]] || nth-value ||  ||\n|| [[$$hs nthcdr]] || nthcdr || nthcdr ||\n|| [[$$hs null]] || null || null ||\n|| [[$$hs number]] || number || number ||\n|| [[$$hs numberp]] || numberp || numberp ||\n|| [[$$hs numerator]] || numerator || numerator ||\n|| [[$$hs nunion]] || nunion || nunion ||\n|| [[$$hs oddp]] || oddp || oddp ||\n|| [[$$hs open]] || open || open ||\n|| [[$$hs open-stream-p]] || open-stream-p ||  ||\n|| [[$$hs optimize]] || optimize || optimize ||\n|| [[$$hs or]] || or || or ||\n|| [[$$hs otherwise]] || otherwise || otherwise ||\n|| [[$$hs output-stream-p]] || output-stream-p || output-stream-p ||\n|| [[$$hs package]] || package || package ||\n|| [[$$hs package-error]] || package-error ||  ||\n|| [[$$hs package-error-package]] || package-error-package ||  ||\n|| [[$$hs package-name]] || package-name || package-name ||\n|| [[$$hs package-nicknames]] || package-nicknames || package-nicknames ||\n|| [[$$hs package-shadowing-symbols]] || package-shadowing-symbols || package-shadowing-symbols ||\n|| [[$$hs package-use-list]] || package-use-list || package-use-list ||\n|| [[$$hs package-used-by-list]] || package-used-by-list || package-used-by-list ||\n|| [[$$hs packagep]] || packagep || packagep ||\n|| [[$$hs pairlis]] || pairlis || pairlis ||\n|| [[$$hs parse-error]] || parse-error ||  ||\n|| [[$$hs parse-integer]] || parse-integer || parse-integer ||\n|| [[$$hs parse-namestring]] || parse-namestring || parse-namestring ||\n|| [[$$hs pathname]] || pathname || pathname ||\n|| [[$$hs pathname-device]] || pathname-device || pathname-device ||\n|| [[$$hs pathname-directory]] || pathname-directory || pathname-directory ||\n|| [[$$hs pathname-host]] || pathname-host || pathname-host ||\n|| [[$$hs pathname-match-p]] || pathname-match-p ||  ||\n|| [[$$hs pathname-name]] || pathname-name || pathname-name ||\n|| [[$$hs pathname-type]] || pathname-type || pathname-type ||\n|| [[$$hs pathname-version]] || pathname-version || pathname-version ||\n|| [[$$hs pathnamep]] || pathnamep || pathnamep ||\n|| [[$$hs peek-char]] || peek-char || peek-char ||\n|| [[$$hs phase]] || phase || phase ||\n|| [[$$hs pi]] || pi || pi ||\n|| [[$$hs plusp]] || plusp || plusp ||\n|| [[$$hs pop]] || pop || pop ||\n|| [[$$hs position]] || position || position ||\n|| [[$$hs position-if]] || position-if || position-if ||\n|| [[$$hs position-if-not]] || position-if-not || position-if-not ||\n|| [[$$hs pprint]] || pprint || pprint ||\n|| [[$$hs pprint-dispatch]] || pprint-dispatch ||  ||\n|| [[$$hs pprint-exit-if-list-exhausted]] || pprint-exit-if-list-exhausted ||  ||\n|| [[$$hs pprint-fill]] || pprint-fill ||  ||\n|| [[$$hs pprint-indent]] || pprint-indent ||  ||\n|| [[$$hs pprint-linear]] || pprint-linear ||  ||\n|| [[$$hs pprint-logical-block]] || pprint-logical-block ||  ||\n|| [[$$hs pprint-newline]] || pprint-newline ||  ||\n|| [[$$hs pprint-pop]] || pprint-pop ||  ||\n|| [[$$hs pprint-tab]] || pprint-tab ||  ||\n|| [[$$hs pprint-tabular]] || pprint-tabular ||  ||\n|| [[$$hs prin1]] || prin1 || prin1 ||\n|| [[$$hs prin1-to-string]] || prin1-to-string || prin1-to-string ||\n|| [[$$hs princ]] || princ || princ ||\n|| [[$$hs princ-to-string]] || princ-to-string || princ-to-string ||\n|| [[$$hs print]] || print || print ||\n|| [[$$hs print-not-readable]] || print-not-readable ||  ||\n|| [[$$hs print-not-readable-object]] || print-not-readable-object ||  ||\n|| [[$$hs print-object]] || print-object ||  ||\n|| [[$$hs print-unreadable-object]] || print-unreadable-object ||  ||\n|| [[$$hs probe-file]] || probe-file || probe-file ||\n|| [[$$hs proclaim]] || proclaim || proclaim ||\n|| [[$$hs prog]] || prog || prog ||\n|| [[$$hs prog*]] || prog* || prog* ||\n|| [[$$hs prog1]] || prog1 || prog1 ||\n|| [[$$hs prog2]] || prog2 || prog2 ||\n|| [[$$hs progn]] || progn || progn ||\n|| [[$$hs program-error]] || program-error ||  ||\n|| [[$$hs progv]] || progv || progv ||\n|| [[$$hs provide]] || provide || provide ||\n|| [[$$hs psetf]] || psetf || psetf ||\n|| [[$$hs psetq]] || psetq || psetq ||\n|| [[$$hs push]] || push || push ||\n|| [[$$hs pushnew]] || pushnew || pushnew ||\n|| [[$$hs quote]] || quote || quote ||\n|| [[$$hs random]] || random || random ||\n|| [[$$hs random-state]] || random-state || random-state ||\n|| [[$$hs random-state-p]] || random-state-p || random-state-p ||\n|| [[$$hs rassoc]] || rassoc || rassoc ||\n|| [[$$hs rassoc-if]] || rassoc-if || rassoc-if ||\n|| [[$$hs rassoc-if-not]] || rassoc-if-not || rassoc-if-not ||\n|| [[$$hs ratio]] || ratio || ratio ||\n|| [[$$hs rational]] || rational || rational ||\n|| [[$$hs rationalize]] || rationalize || rationalize ||\n|| [[$$hs rationalp]] || rationalp || rationalp ||\n|| [[$$hs read]] || read || read ||\n|| [[$$hs read-byte]] || read-byte || read-byte ||\n|| [[$$hs read-char]] || read-char || read-char ||\n|| [[$$hs read-char-no-hang]] || read-char-no-hang || read-char-no-hang ||\n|| [[$$hs read-delimited-list]] || read-delimited-list || read-delimited-list ||\n|| [[$$hs read-from-string]] || read-from-string || read-from-string ||\n|| [[$$hs read-line]] || read-line || read-line ||\n|| [[$$hs read-preserving-whitespace]] || read-preserving-whitespace || read-preserving-whitespace ||\n|| [[$$hs read-sequence]] || read-sequence ||  ||\n|| [[$$hs reader-error]] || reader-error ||  ||\n|| [[$$hs readtable]] || readtable || readtable ||\n|| [[$$hs readtable-case]] || readtable-case ||  ||\n|| [[$$hs readtablep]] || readtablep || readtablep ||\n|| [[$$hs real]] || real ||  ||\n|| [[$$hs realp]] || realp ||  ||\n|| [[$$hs realpart]] || realpart || realpart ||\n|| [[$$hs reduce]] || reduce || reduce ||\n|| [[$$hs reinitialize-instance]] || reinitialize-instance ||  ||\n|| [[$$hs rem]] || rem || rem ||\n|| [[$$hs remf]] || remf || remf ||\n|| [[$$hs remhash]] || remhash || remhash ||\n|| [[$$hs remove]] || remove || remove ||\n|| [[$$hs remove-duplicates]] || remove-duplicates || remove-duplicates ||\n|| [[$$hs remove-if]] || remove-if || remove-if ||\n|| [[$$hs remove-if-not]] || remove-if-not || remove-if-not ||\n|| [[$$hs remove-method]] || remove-method ||  ||\n|| [[$$hs remprop]] || remprop || remprop ||\n|| [[$$hs rename-file]] || rename-file || rename-file ||\n|| [[$$hs rename-package]] || rename-package || rename-package ||\n|| [[$$hs replace]] || replace || replace ||\n|| [[$$hs require]] || require || require ||\n|| [[$$hs rest]] || rest || rest ||\n|| [[$$hs restart]] || restart ||  ||\n|| [[$$hs restart-bind]] || restart-bind ||  ||\n|| [[$$hs restart-case]] || restart-case ||  ||\n|| [[$$hs restart-name]] || restart-name ||  ||\n|| [[$$hs return]] || return || return ||\n|| [[$$hs return-from]] || return-from || return-from ||\n|| [[$$hs revappend]] || revappend || revappend ||\n|| [[$$hs reverse]] || reverse || reverse ||\n|| [[$$hs room]] || room || room ||\n|| [[$$hs rotatef]] || rotatef || rotatef ||\n|| [[$$hs round]] || round || round ||\n|| [[$$hs row-major-aref]] || row-major-aref ||  ||\n|| [[$$hs rplaca]] || rplaca || rplaca ||\n||  ||  || rplacbit ||\n|| [[$$hs rplacd]] || rplacd || rplacd ||\n|| [[$$hs safety]] || safety || safety ||\n|| [[$$hs satisfies]] || satisfies || satisfies ||\n|| [[$$hs sbit]] || sbit || sbit ||\n|| [[$$hs scale-float]] || scale-float || scale-float ||\n|| [[$$hs schar]] || schar || schar ||\n|| [[$$hs search]] || search || search ||\n|| [[$$hs second]] || second || second ||\n|| [[$$hs sequence]] || sequence || sequence ||\n|| [[$$hs serious-condition]] || serious-condition ||  ||\n|| [[$$hs set]] || set || set ||\n||  ||  || set-char-bit ||\n|| [[$$hs set-difference]] || set-difference || set-difference ||\n|| [[$$hs set-dispatch-macro-character]] || set-dispatch-macro-character || set-dispatch-macro-character ||\n|| [[$$hs set-exclusive-or]] || set-exclusive-or || set-exclusive-or ||\n|| [[$$hs set-macro-character]] || set-macro-character || set-macro-character ||\n|| [[$$hs set-pprint-dispatch]] || set-pprint-dispatch ||  ||\n|| [[$$hs set-syntax-from-char]] || set-syntax-from-char || set-syntax-from-char ||\n|| [[$$hs setf]] || setf || setf ||\n|| [[$$hs setq]] || setq || setq ||\n|| [[$$hs seventh]] || seventh || seventh ||\n|| [[$$hs shadow]] || shadow || shadow ||\n|| [[$$hs shadowing-import]] || shadowing-import || shadowing-import ||\n|| [[$$hs shared-initialize]] || shared-initialize ||  ||\n|| [[$$hs shiftf]] || shiftf || shiftf ||\n|| [[$$hs short-float]] || short-float || short-float ||\n|| [[$$hs short-float-epsilon]] || short-float-epsilon || short-float-epsilon ||\n|| [[$$hs short-float-negative-epsilon]] || short-float-negative-epsilon || short-float-negative-epsilon ||\n|| [[$$hs short-site-name]] || short-site-name || short-site-name ||\n|| [[$$hs signal]] || signal ||  ||\n|| [[$$hs signed-byte]] || signed-byte || signed-byte ||\n|| [[$$hs signum]] || signum || signum ||\n|| [[$$hs simple-array]] || simple-array || simple-array ||\n|| [[$$hs simple-base-string]] || simple-base-string ||  ||\n|| [[$$hs simple-bit-vector]] || simple-bit-vector || simple-bit-vector ||\n|| [[$$hs simple-bit-vector-p]] || simple-bit-vector-p || simple-bit-vector-p ||\n|| [[$$hs simple-condition]] || simple-condition ||  ||\n|| [[$$hs simple-condition-format-arguments]] || simple-condition-format-arguments ||  ||\n|| [[$$hs simple-condition-format-control]] || simple-condition-format-control ||  ||\n|| [[$$hs simple-error]] || simple-error ||  ||\n|| [[$$hs simple-string]] || simple-string ||  ||\n|| [[$$hs simple-string-p]] || simple-string-p || simple-string-p ||\n|| [[$$hs simple-type-error]] || simple-type-error ||  ||\n|| [[$$hs simple-vector]] || simple-vector || simple-vector ||\n|| [[$$hs simple-vector-p]] || simple-vector-p || simple-vector-p ||\n|| [[$$hs simple-warning]] || simple-warning ||  ||\n|| [[$$hs sin]] || sin || sin ||\n|| [[$$hs single-float]] || single-float || single-float ||\n|| [[$$hs single-float-epsilon]] || single-float-epsilon || single-float-epsilon ||\n|| [[$$hs single-float-negative-epsilon]] || single-float-negative-epsilon || single-float-negative-epsilon ||\n|| [[$$hs sinh]] || sinh || sinh ||\n|| [[$$hs sixth]] || sixth || sixth ||\n|| [[$$hs sleep]] || sleep || sleep ||\n|| [[$$hs slot-boundp]] || slot-boundp ||  ||\n|| [[$$hs slot-exists-p]] || slot-exists-p ||  ||\n|| [[$$hs slot-makunbound]] || slot-makunbound ||  ||\n|| [[$$hs slot-missing]] || slot-missing ||  ||\n|| [[$$hs slot-unbound]] || slot-unbound ||  ||\n|| [[$$hs slot-value]] || slot-value ||  ||\n|| [[$$hs software-type]] || software-type || software-type ||\n|| [[$$hs software-version]] || software-version || software-version ||\n|| [[$$hs some]] || some || some ||\n|| [[$$hs sort]] || sort || sort ||\n|| [[$$hs space]] || space || space ||\n|| [[$$hs special]] || special || special ||\n||  ||  || special-form-p ||\n|| [[$$hs special-operator-p]] || special-operator-p ||  ||\n|| [[$$hs speed]] || speed || speed ||\n|| [[$$hs sqrt]] || sqrt || sqrt ||\n|| [[$$hs stable-sort]] || stable-sort || stable-sort ||\n|| [[$$hs standard]] || standard ||  ||\n|| [[$$hs standard-char]] || standard-char || standard-char ||\n|| [[$$hs standard-char-p]] || standard-char-p || standard-char-p ||\n|| [[$$hs standard-class]] || standard-class ||  ||\n|| [[$$hs standard-generic-function]] || standard-generic-function ||  ||\n|| [[$$hs standard-method]] || standard-method ||  ||\n|| [[$$hs standard-object]] || standard-object ||  ||\n|| [[$$hs step]] || step || step ||\n|| [[$$hs storage-condition]] || storage-condition ||  ||\n|| [[$$hs store-value]] || store-value ||  ||\n|| [[$$hs stream]] || stream || stream ||\n|| [[$$hs stream-element-type]] || stream-element-type || stream-element-type ||\n|| [[$$hs stream-error]] || stream-error ||  ||\n|| [[$$hs stream-error-stream]] || stream-error-stream ||  ||\n|| [[$$hs stream-external-format]] || stream-external-format ||  ||\n|| [[$$hs streamp]] || streamp || streamp ||\n|| [[$$hs string]] || string || string ||\n|| [[$$hs string-capitalize]] || string-capitalize || string-capitalize ||\n||  ||  || string-char-p ||\n|| [[$$hs string-downcase]] || string-downcase || string-downcase ||\n|| [[$$hs string-equal]] || string-equal || string-equal ||\n|| [[$$hs string-greaterp]] || string-greaterp || string-greaterp ||\n|| [[$$hs string-left-trim]] || string-left-trim || string-left-trim ||\n|| [[$$hs string-lessp]] || string-lessp || string-lessp ||\n|| [[$$hs string-not-equal]] || string-not-equal || string-not-equal ||\n|| [[$$hs string-not-greaterp]] || string-not-greaterp || string-not-greaterp ||\n|| [[$$hs string-not-lessp]] || string-not-lessp || string-not-lessp ||\n|| [[$$hs string-right-trim]] || string-right-trim || string-right-trim ||\n|| [[$$hs string-stream]] || string-stream ||  ||\n|| [[$$hs string-trim]] || string-trim || string-trim ||\n|| [[$$hs string-upcase]] || string-upcase || string-upcase ||\n|| [[$$hs string/=]] || string/= || string/= ||\n|| [[$$hs string<]] || string< || string< ||\n|| [[$$hs string<=]] || string<= || string<= ||\n|| [[$$hs string=]] || string= || string= ||\n|| [[$$hs string>]] || string> || string> ||\n|| [[$$hs string>=]] || string>= || string>= ||\n|| [[$$hs stringp]] || stringp || stringp ||\n|| [[$$hs structure]] || structure || structure ||\n|| [[$$hs structure-class]] || structure-class ||  ||\n|| [[$$hs structure-object]] || structure-object ||  ||\n|| [[$$hs style-warning]] || style-warning ||  ||\n|| [[$$hs sublis]] || sublis || sublis ||\n|| [[$$hs subseq]] || subseq || subseq ||\n|| [[$$hs subsetp]] || subsetp || subsetp ||\n|| [[$$hs subst]] || subst || subst ||\n|| [[$$hs subst-if]] || subst-if || subst-if ||\n|| [[$$hs subst-if-not]] || subst-if-not || subst-if-not ||\n|| [[$$hs substitute]] || substitute || substitute ||\n|| [[$$hs substitute-if]] || substitute-if || substitute-if ||\n|| [[$$hs substitute-if-not]] || substitute-if-not || substitute-if-not ||\n|| [[$$hs subtypep]] || subtypep || subtypep ||\n|| [[$$hs svref]] || svref || svref ||\n|| [[$$hs sxhash]] || sxhash || sxhash ||\n|| [[$$hs symbol]] || symbol || symbol ||\n|| [[$$hs symbol-function]] || symbol-function || symbol-function ||\n|| [[$$hs symbol-macrolet]] || symbol-macrolet ||  ||\n|| [[$$hs symbol-name]] || symbol-name || symbol-name ||\n|| [[$$hs symbol-package]] || symbol-package || symbol-package ||\n|| [[$$hs symbol-plist]] || symbol-plist || symbol-plist ||\n|| [[$$hs symbol-value]] || symbol-value || symbol-value ||\n|| [[$$hs symbolp]] || symbolp || symbolp ||\n|| [[$$hs synonym-stream]] || synonym-stream ||  ||\n|| [[$$hs synonym-stream-symbol]] || synonym-stream-symbol ||  ||\n|| [[$$hs t]] || t || t ||\n|| [[$$hs tagbody]] || tagbody || tagbody ||\n|| [[$$hs tailp]] || tailp || tailp ||\n|| [[$$hs tan]] || tan || tan ||\n|| [[$$hs tanh]] || tanh || tanh ||\n|| [[$$hs tenth]] || tenth || tenth ||\n|| [[$$hs terpri]] || terpri || terpri ||\n|| [[$$hs the]] || the || the ||\n|| [[$$hs third]] || third || third ||\n|| [[$$hs throw]] || throw || throw ||\n|| [[$$hs time]] || time || time ||\n|| [[$$hs trace]] || trace || trace ||\n|| [[$$hs translate-logical-pathname]] || translate-logical-pathname ||  ||\n|| [[$$hs translate-pathname]] || translate-pathname ||  ||\n|| [[$$hs tree-equal]] || tree-equal || tree-equal ||\n|| [[$$hs truename]] || truename || truename ||\n|| [[$$hs truncate]] || truncate || truncate ||\n|| [[$$hs two-way-stream]] || two-way-stream ||  ||\n|| [[$$hs two-way-stream-input-stream]] || two-way-stream-input-stream ||  ||\n|| [[$$hs two-way-stream-output-stream]] || two-way-stream-output-stream ||  ||\n|| [[$$hs type]] || type || type ||\n|| [[$$hs type-error]] || type-error ||  ||\n|| [[$$hs type-error-datum]] || type-error-datum ||  ||\n|| [[$$hs type-error-expected-type]] || type-error-expected-type ||  ||\n|| [[$$hs type-of]] || type-of || type-of ||\n|| [[$$hs typecase]] || typecase || typecase ||\n|| [[$$hs typep]] || typep || typep ||\n|| [[$$hs unbound-slot]] || unbound-slot ||  ||\n|| [[$$hs unbound-slot-instance]] || unbound-slot-instance ||  ||\n|| [[$$hs unbound-variable]] || unbound-variable ||  ||\n|| [[$$hs undefined-function]] || undefined-function ||  ||\n|| [[$$hs unexport]] || unexport || unexport ||\n|| [[$$hs unintern]] || unintern || unintern ||\n|| [[$$hs union]] || union || union ||\n|| [[$$hs unless]] || unless || unless ||\n|| [[$$hs unread-char]] || unread-char || unread-char ||\n|| [[$$hs unsigned-byte]] || unsigned-byte || unsigned-byte ||\n|| [[$$hs untrace]] || untrace || untrace ||\n|| [[$$hs unuse-package]] || unuse-package || unuse-package ||\n|| [[$$hs unwind-protect]] || unwind-protect || unwind-protect ||\n|| [[$$hs update-instance-for-different-class]] || update-instance-for-different-class ||  ||\n|| [[$$hs update-instance-for-redefined-class]] || update-instance-for-redefined-class ||  ||\n|| [[$$hs upgraded-array-element-type]] || upgraded-array-element-type ||  ||\n|| [[$$hs upgraded-complex-part-type]] || upgraded-complex-part-type ||  ||\n|| [[$$hs upper-case-p]] || upper-case-p || upper-case-p ||\n|| [[$$hs use-package]] || use-package || use-package ||\n|| [[$$hs use-value]] || use-value ||  ||\n|| [[$$hs user-homedir-pathname]] || user-homedir-pathname || user-homedir-pathname ||\n|| [[$$hs values]] || values || values ||\n|| [[$$hs values-list]] || values-list || values-list ||\n|| [[$$hs variable]] || variable || variable ||\n|| [[$$hs vector]] || vector || vector ||\n|| [[$$hs vector-pop]] || vector-pop || vector-pop ||\n|| [[$$hs vector-push]] || vector-push || vector-push ||\n|| [[$$hs vector-push-extend]] || vector-push-extend || vector-push-extend ||\n|| [[$$hs vectorp]] || vectorp || vectorp ||\n|| [[$$hs warn]] || warn || warn ||\n|| [[$$hs warning]] || warning ||  ||\n|| [[$$hs when]] || when || when ||\n|| [[$$hs wild-pathname-p]] || wild-pathname-p ||  ||\n|| [[$$hs with-accessors]] || with-accessors ||  ||\n|| [[$$hs with-compilation-unit]] || with-compilation-unit ||  ||\n|| [[$$hs with-condition-restarts]] || with-condition-restarts ||  ||\n|| [[$$hs with-hash-table-iterator]] || with-hash-table-iterator ||  ||\n|| [[$$hs with-input-from-string]] || with-input-from-string || with-input-from-string ||\n|| [[$$hs with-open-file]] || with-open-file || with-open-file ||\n|| [[$$hs with-open-stream]] || with-open-stream || with-open-stream ||\n|| [[$$hs with-output-to-string]] || with-output-to-string || with-output-to-string ||\n|| [[$$hs with-package-iterator]] || with-package-iterator ||  ||\n|| [[$$hs with-simple-restart]] || with-simple-restart ||  ||\n|| [[$$hs with-slots]] || with-slots ||  ||\n|| [[$$hs with-standard-io-syntax]] || with-standard-io-syntax ||  ||\n|| [[$$hs write]] || write || write ||\n|| [[$$hs write-byte]] || write-byte || write-byte ||\n|| [[$$hs write-char]] || write-char || write-char ||\n|| [[$$hs write-line]] || write-line || write-line ||\n|| [[$$hs write-sequence]] || write-sequence ||  ||\n|| [[$$hs write-string]] || write-string || write-string ||\n|| [[$$hs write-to-string]] || write-to-string || write-to-string ||\n|| [[$$hs y-or-n-p]] || y-or-n-p || y-or-n-p ||\n|| [[$$hs yes-or-no-p]] || yes-or-no-p || yes-or-no-p ||\n|| [[$$hs zerop]] || zerop || zerop ||\n")
(" %Tag:local-time') and 1=1 and ('1'='1" . "(1660041686)")
(" %Tag:【募集中】/images/editor/separator.gif" . "(1585999587)")
("標準入出力" . "(:ctime 1452098230 :cuser #f :mtime 1545306715 :muser #f)* 主な標準出力関数\n\n[[$$hs format]]関数が使われることが多いです。 : [[format]]関数のページ\n\n第一引数に [[$$hs t]] を指定することで標準出力へ書き出します。\n{{{\n(format t \"Hello World!\")\n;-> Hello World!\n;=> NIL\n}}}\n\nまた、シンプルな出力関数[[$$hs print]], [[$$hs princ]], [[$$hs prin1]] は標準出力へ文字列を出力します。\n\n[[$$hs print]] は出力に先立って改行を出力する点に注意が必要です。\n\n{{{\n(print \"Hello World!\")\n;-> \n;   \"Hello World!\"\n;=> \"Hello World!\"\n\n(prin1 \"Hello World!\")\n;-> \"Hello World!\"\n;=> \"Hello World!\"\n\n(princ \"Hello World!\")\n;-> Hello World!\n;=> \"Hello World!\"\n}}}\n\n* 主な標準入力関数\n\n[[$$hs read]], [[$$hs read-char]], [[$$hs read-line]]を標準入力の取得に利用できます。\n\n''標準入力''\n{{{\nHello World !\n}}}\n\n''実行結果''\n{{{\n(read)\n;=> \"Hello World!\"\n\n(read-char)\n;=> #\\H\n\n(read-line)\n;=> \"Hello World!\"\n}}}\n\nまた、数値を標準入力から与えた場合、\n[[$$hs read]]は入力のストリームから一度につき一式のlispのデータを読み込みます。\n[[$$hs read-char]], [[$$hs read-line]]は入力を文字・文字列として読み込みます。\n\n''標準入力''\n{{{\n100\n}}}\n\n\n''実行結果''\n{{{\n(read)\n;=> 100\n\n(read-char)\n;=> #\\1\n\n(read-line)\n;=> \"100\"\n}}}\n\n実行方法の例 : Windows, PowerShell + SBCL で [[$$hs read-line]] 関数を実行する場合\n{{{\nPS> echo \"Hello World!`n1\" | sbcl --eval \"(progn (print (read-line)) (quit))\"\n}}}\n\n* 注意点\nどのような動作をするかは実行方法（REPL上での動作か、スクリプト動作か、など）や\n実行環境(CLISP, ccl, sbcl,,)により異なりますので、使用する際には注意が必要です。\n\nCommon Lisp では、標準入力は[[$$hs *standard-input*]] というストリームの一種です\nそのため、このページに掲載していないストリーム読み込み用関数も\n標準入力の読み込みに使用することができます。。\nまた、これらの関数は標準入力以外のストリームを対象とした読み込みが可能です。\n\n* 参考\n''出力''\n- [http://clhs.lisp.se/Body/f_wr_pr.htm WRITE, PRIN1, PRINT, PPRINT, PRINC](HyperSpec)\n- [http://www.fireproject.jp/feature/common-lisp/details/io.html FireProject 入出力]\n\n''入力''\n- [[$$hs read]](Hyperspec)\n- [[$$hs read-char]](Hyperspec)\n- [[$$hs read-line]](Hyperspec)\n\n''標準入出力''\n- [http://www.lispworks.com/documentation/HyperSpec/Body/v_debug_.htm standard-input, standard-output] (Hyperspec)\n")
(" %Tag:数値" . "(1668256915 (\"xのn乗（べき乗・累乗）を計算する\" :ctime 1457056251 :cuser #f :mtime 1457278229 :muser #f) (\"数値\" :ctime 1227412843 :cuser #f :mtime 1457056255 :muser #f) (\"最大値・最小値を求める\" :ctime 1453044354 :cuser #f :mtime 1453044355 :muser #f) (\"無限大\" :ctime 1328597182 :cuser #f :mtime 1368602900 :muser #f) (\"三角関数を計算する\" :ctime 1302500063 :cuser #f :mtime 1364079086 :muser #f) (\"四捨五入する\" :ctime 1228831221 :cuser #f :mtime 1328665576 :muser #f) (\"数値を2進数・8進数・16進数表現の文字列に変換するには\" :ctime 1227837042 :cuser #f :mtime 1328663527 :muser #f) (\"数値を文字列に変換する\" :ctime 1228788799 :cuser #f :mtime 1328663465 :muser #f) (\"除算の商と余りを求める\" :ctime 1227870704 :cuser #f :mtime 1328663291 :muser #f) (\"平方根を求める\" :ctime 1227495967 :cuser #f :mtime 1328663208 :muser #f) (\"整数と浮動小数点を相互変換する（精度の変換）\" :ctime 1328577886 :cuser #f :mtime 1328579187 :muser #f) (\"読み取り時のデフォルトの浮動小数点の精度を指定する\" :ctime 1328578994 :cuser #f :mtime 1328579022 :muser #f) (\"ローマ数字を扱う\" :ctime 1230925747 :cuser #f :mtime 1315563898 :muser #f) (\"計算結果を分数から小数にしたい\" :ctime 1227349345 :cuser #f :mtime 1238675808 :muser #f) (\"1のビットを数え上げる\" :ctime 1238600498 :cuser #f :mtime 1238600548 :muser #f) (\"小数点を切り上げ・切り捨て\" :ctime 1236786098 :cuser #f :mtime 1237111566 :muser #f) (\"#xNNNNNNという16進RGB形式を色ごとに分解する\" :ctime 1235192973 :cuser #f :mtime 1235213428 :muser #f) (\"数値を位取り用のカンマで区切る\" :ctime 1232874597 :cuser #f :mtime 1232879591 :muser #f) (\"数値に応じて複数形と単数形を切り換える\" :ctime 1232048921 :cuser #f :mtime 1232048967 :muser #f) (\"任意のビット位置の値を参照する\" :ctime 1230696694 :cuser #f :mtime 1230696734 :muser #f) (\"対数を計算する\" :ctime 1230695185 :cuser #f :mtime 1230695227 :muser #f) (\"絶対値を求める\" :ctime 1229676067 :cuser #f :mtime 1229676067 :muser #f) (\"2進数・8進数・16進数で数値を扱うには\" :ctime 1227836450 :cuser #f :mtime 1227836450 :muser #f) (\"乱数を生成する\" :ctime 1227497166 :cuser #f :mtime 1227671316 :muser #f))")
("配列の並列MAP処理" . "(:ctime 1337153593 :cuser #f :mtime 1338671463 :muser #f)一つの配列を複数のタスクに分けてMAP処理する例です。~%\n下記の例では、[[CLiki:lparallel]]、[[CLiki:Xecto]] を利用しています。~%\n\n{{{\n;;; #(\"1\" \"2\" \"3\" ...)というような整数を文字列にしたものを要素にもつ配列\n(declaim ((simple-vector 100000) *number-strings*))\n(defvar *number-strings*\n  (make-array 100000))\n\n;; 初期化\n(dotimes (i 100000)\n  (setf (svref *number-strings* i)\n        (write-to-string i)))\n\n(aref *number-strings* 100)\n;=>  \"100\"\n}}}\n** lparallel\n{{{\n(setf lparallel:*kernel* (lparallel:make-kernel 2)) ;; ワーカーの数を設定\n}}}\n処理例\n{{{\n(reduce #'+\n  (lparallel:pmap  '(simple-array integer (100000))\n                   #'parse-integer\n                   *number-strings*))\n;⇒ 4999950000\n#|------------------------------------------------------------|\nEvaluation took:\n  0.025 seconds of real time\n  0.044003 seconds of total run time (0.044003 user, 0.000000 system)\n  176.00% CPU\n  60,653,268 processor cycles\n  7,223,200 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\nreduceも並列にした場合\n{{{\n(lparallel:preduce  #'+\n  (lparallel:pmap  '(simple-array integer (100000))\n                   #'parse-integer\n                   *number-strings*))\n;⇒ 4999950000\n#|------------------------------------------------------------|\nEvaluation took:\n  0.025 seconds of real time\n  0.036002 seconds of total run time (0.036002 user, 0.000000 system)\n  144.00% CPU\n  58,463,136 processor cycles\n  7,224,768 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n\n** Xecto\nライブラリの導入方法 (今のところSBCLのみ対応)\n- https://github.com/pkhuong/Xecto\n\n処理例\n{{{\n(defconstant max-threads 2)\n\n(reduce #'+\n  (parallel-future:with-context (max-threads) ;max-threadsの値まで並列実行\n    (parallel:map '(simple-array integer (100000))\n                  #'parse-integer\n                  *number-strings*)))\n;⇒ 4999950000\n#|------------------------------------------------------------|\nEvaluation took:\n  0.051 seconds of real time\n  0.080005 seconds of total run time (0.076005 user, 0.004000 system)\n  156.86% CPU\n  121,893,030 processor cycles\n  4,047,616 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n;=>  4999950000\n}}}\nreduceも並列にした場合\n{{{\n(parallel-future:with-context (max-threads) ;max-threadsの値まで並列実行\n  (parallel:reduce #'+\n                   (parallel:map '(simple-array integer (100000))\n                                 #'parse-integer\n                                   *number-strings*)\n                   0))\n;⇒ 4999950000\n#|------------------------------------------------------------|\nEvaluation took:\n  0.041 seconds of real time\n  0.080005 seconds of total run time (0.080005 user, 0.000000 system)\n  195.12% CPU\n  97,143,192 processor cycles\n  3,945,728 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n並列にしない場合\n{{{\n(reduce #'+\n        (map '(simple-array integer (100000))\n             #'parse-integer\n             *number-strings*))\n;⇒ 4999950000\n#|------------------------------------------------------------|\nEvaluation took:\n  0.068 seconds of real time\n  0.068004 seconds of total run time (0.064004 user, 0.004000 system)\n  100.00% CPU\n  162,015,912 processor cycles\n  3,978,496 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45) --  /*" . "(1624124464)")
("ワイルドカードを展開したパスにする" . "(:ctime 1631079351 :cuser #f :mtime 1631079351 :muser #f)/tmp/foo/bar/baz/quux.txt というファイルが存在し、このファイル(および近隣ファイル)をワイルドカード指定したい場合、下記のようにパスを作成することが可能でしょう。~%\n\n{{{\n(make-pathname :name \"quux\" :type \"txt\" :directory '(:absolute \"tmp\" \"foo\" :wild-inferiors \"baz\"))\n→ #P\"/tmp/foo/**/baz/quux.txt\"\n}}}\n\nしかし、ワイルドカードを含んだパス名を [[$$hs open]]等の入出力関数に渡すことはできませんので展開して渡す必要があります。  \n\n- [http://www.lispworks.com/documentation/HyperSpec/Body/19_bbc.htm 19.2.2.3 Restrictions on Wildcard Pathnames]\n\n[[$$hs directory]] はワイルドカードを処理可能ですので、可搬的には下記のように書くことが可能でしょう。\n\n{{{\n(defun glob (path)\n  (if (wild-pathname-p path)\n      (car (directory path))\n      path))\n\n(glob (make-pathname :name \"quux\" :type \"txt\" :directory '(:absolute \"tmp\" \"foo\" :wild-inferiors \"baz\")))\n→ #P\"/private/tmp/foo/bar/baz/quux.txt\"\n}}}\n\n* 議論\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' and 1=1#" . "(1656001223)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae%' and 1=2 and '%'='" . "(1656001230)")
(" %Tag:local-time') or(1=1)#" . "(1660041692)")
(" %Tag:bordeaux-threads'A=0" . "(1561725185)")
(" %Tag:kmrcl?Tag?Tag:kmrcl?Tag" . "(1491336325)")
("ベクタをバイナリのストリームとして扱いたい" . "(:ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f)[[$$tag 入出力 ライブラリ flexi-streams]]\n\n* ベクタをバイナリのストリームとして扱いたい\n\n自作するかライブラリを利用します。\n\n下記の例では、 [[ライブラリ:flexi-streams]]を利用しています。\n{{{\n(flexi-streams:with-input-from-sequence (in #(#x31 #x32))\n  (loop for i = (read-byte in nil) while i\n        collect (code-char i)))\n;=> (#\\1 #\\2)\n}}}\n")
(" %Tag:local-time' and 1=1#" . "(1660041634)")
(" %Tag:local-time) and 1=1-- -" . "(1660041695)")
(" %Tag:?????'\"" . "(1584214733)")
(" %Tag:数値?p=Tag?Tag?Tag:数値?p=Tag?Tag" . "(1467042901)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45) --  /*" . "(1624124408)")
(" %Tag:文字列'nvOpzp" . "(1662402728)")
("リストを定義する" . "(:ctime 1228807123 :cuser #f :mtime 1328667397 :muser #f)[[$$tag リスト]]\n\n* リストを定義する\n\nCommon Lisp のプログラムはリストです。\nプログラムのリストとデータのリストを区別するため、データのリストは [[$$hs quote]] する必要があり、[[$$hs quote]]で定義された式は定数とみなされます。\n{{{\n(quote (1 2 3))\n}}}\n[[$$hs quote]] には標準で「'」というリーダーマクロが定義されていますので略記として「'」を使うことができます。\n{{{\n'(1 2 3)\n}}}\n「`」バッククオート を使うとリスト内に式を含むことができます。\n「,」コンマ は式を一つ取り、式の結果がリスト内の要素になります。\n「,@」コンマアットマーク はリストを返す式を一つ取り、式の結果をリスト内に展開します。\n{{{\n`(1 2 ,(+ 1 2) 4 5)\n;=> (1 2 3 4 5)\n\n`(1 2 ,@(list 3 4 5) 6 7 8)\n;=> (1 2 3 4 5 6 7 8)\n\n`(1 2 ,@(list 3 4 5) 6 7 8)\n;=> (1 2 3 4 5 6 7 8)\n}}}\n")
("最適化" . "(:ctime 1228170916 :cuser #f :mtime 1529824649 :muser #f)[[$$tag 最適化]]\n\n- [[最適化指針]]\n- [[末尾呼び出しの最適化]]\n- [[変数の型宣言]]\n- [[戻り値の型宣言]]\n- [[sequenceの最適化]]\n- [[&rest引数をとる関数の最適化]]\n\n- [[処理時間の計測]]\n")
("シンボルを生成する" . "(:ctime 1342176041 :cuser #f :mtime 1342176041 :muser #f)シンボルを生成するには、何通りかの方法があります。\n\n** 直に書く ([[$$hs read]]する)\n{{{\n(in-package :cl-user)\n\n'foo\n;=>  FOO\n\n'cl-user::foo\n;=>  FOO\n}}}\n特に何もせず、シンボルを記述すれば、リード時にシンボルが生成されます。\n既に同名のシンボルが存在している場合は、新規に生成はされません\n\n\n** 文字列から生成する\n\n[[$$hs intern]]を利用することにより、文字列からシンボルを生成することが可能です。\n第二引数は、パッケージの指定で、省略した場合は、現在のパッケージを指定したことになります。~%\n注意点としては、シンボル名の扱いが挙げられます。Common Lispの標準では、リード時にシンボルの名前は大文字に変換して扱われ、\"\"\"'foo\"\"\"と書いても \"\"\"'FOO\"\"\"と書いても、\"\"\"\"FOO\"\"\"\"という名前を持つシンボルになりますが、[[$$hs intern]]では、[[$$hs read]]を介さず直接生成しますので、大文字にしてやる必要があります(意図的に外す場合は別です)。また、\"\"\"'|foo|\"\"\"・\"\"\"'FOO\"\"\"・\"\"\"'|Foo|\"\"\"というシンボルはそれぞれ別のシンボルです。(|で囲んで記述すると[[$$hs read]]は中身の大文字小文字維持したまま読み込みます)\n{{{\n(in-package :cl-user)\n\n(intern \"FOO\")\n;=>  FOO\n;    NIL\n\n(intern \"FOO\" :cl-user)\n;=>  FOO\n;    :INTERNAL\n\n(intern \"foo\")\n;=>  |foo|\n;    NIL\n}}}\n** 参考\n- [[キーワードを生成したい]]\n")
(" %Tag:WebT[o" . "(1456583371)")
(" %Tag:Lisp Cabinet" . "(1667975509 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f))")
("既存のシンボルに文字列を追加して新しいシンボルを生成する" . "(:ctime 1236523298 :cuser #f :mtime 1236523298 :muser #f)[[$$tag シンボル]]\n\n与えられたシンボルから新規にシンボルを作ります。\n\n{{{\n(defun symbol+ (x y)\n  (intern (concatenate 'string (symbol-name x) (symbol-name y))))\n; => SYMBOL+\n(symbol+ 'a '#:-view)\n; => A-VIEW\n}}}\n\nマクロの定義で便利ではないでしょうか。\n")
("Ltk:ラジオボタンを表示する" . "(:ctime 1619742040 :cuser #f :mtime 1619744698 :muser #f)* ラジオボタン\n\n{{{\n;;; LTKでラジオボタンを表示する\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-06\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-06)\n\n(defun main ()\n  (with-ltk ()\n    (let* (\n           (fradio (make-instance 'frame))\n           (r1 (make-instance 'radio-button :master fradio :text \"fried\" :value 1 :variable \"group1\"\n                              :command (lambda (value)\n                                         (format t \"radio-button1_click!:~A~%\" value))))\n           (r2 (make-instance 'radio-button :master fradio :text \"stirred\" :value 2 :variable \"group1\"\n                              :command (lambda (value)\n                                         (format t \"radio-button2_click!:~A~%\" value))))\n\n           (r3 (make-instance 'radio-button :master fradio :text \"cooked\" :value 3 :variable \"group1\"\n                              :command (lambda (value)\n                                         (format t \"radio-button3_click!:~A~%\" value))))\n           (btn (make-instance\n                 'button\n                 :text \"radio watch\"\n                 :command (lambda ()\n                            ;; r1〜r3のすべてが同じ値を表示する\n                            ;; つまり、同じグループで値が共通になるので、グループのどれかのvalueを調べれば何が選択されているかわかる\n                             (print (value r1))\n                             (print (value r2))\n                             (print (value r3)))))\n\n\n      )\n      (pack fradio :side :top :fill :x)\n      (pack (list r1 r2 r3) :side :left)\n      (pack btn)\n\n      ;; 初期状態を決める（r1を選択状態にする）\n      ;; :valueで決めた値をセットしなければ、選択状態にならない\n      (setf (value r1) 1)\n\n      )))\n\n(main)\n}}}\n")
("編集記録" . "(:ctime 1227239300 :cuser #f :mtime 1228111859 :muser #f)[[$$hs format]]\n[[$$hs destructuring-bind]]\n[[$$mop compute-slots]]\n")
("ハッシュのキーに任意のオブジェクトを使用する" . "(:ctime 1229510098 :cuser #f :mtime 1229510099 :muser #f)[[$$tag ハッシュ 【募集中】]]\n* ハッシュのキーに任意のオブジェクトを使用する\n\nハッシュテーブルのキーの比較に用いる関数は :test キーワードパラメタで指定できます。\n\nただし、指定できるのは #'eq #'eql #'equal #'equalp のいずれかだけです。\nつまり、キーに使用できるオブジェクトはこれらの関数で同値判定できるものに限られます。\n\n処理系の独自拡張で任意の比較関数を指定できる場合があります。\n比較関数とハッシュ値計算関数の両方をあたえる必要があるようです。\n\n (make-hash-table :test #'my-eql :hash-function #'my-hash)\n\nor\n\n (sb-int:define-hash-table-test 'my-test #'my-eql #'my-hash)\n (make-hash-table :test 'my-test)\n\nmore【募集中】\n")
(" %Tag:net-telent-date" . "(1668240019 (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f) (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f))")
("整数と浮動小数点を相互変換する（精度の変換）" . "(:ctime 1328577886 :cuser #f :mtime 1328579187 :muser #f)[[$$tag 数値]]\n\n[[$$hs float]] や [[$$hs coerce]] を使うことによって変換することが可能です~%\n参照: [[計算結果を分数から小数にしたい]]\n{{{\n;;; 整数から浮動小数点数へ\n(float 1)\n;=>  1.0\n\n(coerce 1 'single-float)\n;=>  1.0\n\n(float 1 0d0)\n;=>  1.0d0\n\n(coerce 1 'double-float)\n;=>  1.0d0\n\n;;; 精度の変換\n(float 1.0 0d0)\n;=>  1.0d0\n\n(float 1.0d0 0s0)\n;=>  1.0\n\n(coerce 1.0d0 'double-float)\n;=>  1.0d0\n}}}\n\n浮動小数点数から整数への変換は、[[小数点を切り上げ・切り捨て]]をすることになるでしょう。\n")
("スレッド" . "(:ctime 1229079964 :cuser #f :mtime 1337154190 :muser #f)[[$$tag スレッド]]\n\n* スレッド\n\nスレッドについては、ANSI Common Lispの仕様では決められておらず、処理系が各々実装している状況です。\n\n処理系間のポータビリティの確保のためのパッケージはいくつか存在し、 [[CLiki:Portable-Threads]] [[CLiki:Bordeaux-Threads]] 等が主なものです。\n\n- [[スレッドを生成する]]\n- [[スレッドに引数を渡す]]\n- [[スレッドの終了を待つ]]\n- [[スレッドの実行を終了させる]]\n- [[スレッドを停止する]]\n- [[実行中のスレッド一覧を取得する]]\n- [[スレッド間で通信する]]\n- [[スレッド間の競合を回避する(Mutex)]]\n- [[操作をタイムアウトにする]]\n\n- [[タスクを並列に実行する]]\n- [[配列の並列処理]]\n- [[配列の並列MAP処理]]\n- [[ハッシュの並列処理]]\n")
(" %Tag:【募集中】?Tag:【募集中】" . "(1476573356)")
("多次元配列の要素をランダムに抽出する" . "(:ctime 1612437944 :cuser #f :mtime 1612437979 :muser #f)[[$$tag 配列]]\n\n* 多次元配列の要素をランダムに抽出する\n\n多次元配列であっても[[$$hs row-major-aref]] を使うことで一次元配列のように扱うことが可能ですので、あとは [[$$hs random]] と [[$$hs array-total-size]] を組み合わせることで実現できます。\n\n{{{\n(defvar *foods* \n  #2A((\"apple\" \"pine\" \"banana\" \"orange\")\n      (\"carrot\" \"broccoli\" \"celery\" \"lettuce\")\n      (\"coffee\" \"tea\" \"wine\" \"beer\")))\n\n(loop :repeat 10 :collect (row-major-aref *foods* (random (array-total-size *foods*))))\n;=> (\"pine\" \"apple\" \"pine\" \"wine\" \"beer\" \"lettuce\" \"apple\" \"wine\" \"celery\" \"tea\")\n}}}\n\n* 参考\n\n- [[配列の要素をランダムに抽出する]]\n- [[多次元の配列を1つのインデックスで扱う]]\n")
("平方根を求める" . "(:ctime 1227495967 :cuser #f :mtime 1328663208 :muser #f)[[$$tag 数値]]\n* 平方根を求める\n[[$$hs sqrt]] 関数を使います\n{{{\n(sqrt 9.0) ;=>  3.0\n}}}\n負の数を与えると複素数が得られます\n{{{\n(sqrt -9.0) ;=>  #C(0.0 3.0)\n}}}\n\n[[$$hs isqrt]] は自然数の正確な整の平方根を超えない整数値を返します\n{{{\n(isqrt 2) ;=>  1\n}}}\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45) -- /* order by 'as /*" . "(1624124576)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45) -- /* order by \"as /*" . "(1624124903)")
("NULLストリームを使う" . "(:ctime 1232161530 :cuser #f :mtime 1314943450 :muser #f)[[$$tag 入出力]]\n\nUNIXで言うところの/dev/nullのようなビットバケツ(ビットシンク)を実現するには、様々な方法があります。\n\n*** 自作する\n\n自作の場合は、読み込みでEOFを返すのに[[$$hs make-concatenated-stream]]や、[[$$hs make-string-input-stream]]に\"\"の引数を与えたもの、出力には[[$$hs make-broadcast-stream]]を利用し作成することが多いようです。\n処理系に依存しませんので最も可搬性が高い方法になります。\n{{{\n(defvar *null-stream* (make-two-way-stream \n                        (make-concatenated-stream) \n                        (make-broadcast-stream)))\n(time\n (loop :repeat 10000 \n       :do\n       (format *null-stream* \"こんにちは!\")\n       (read *null-stream* nil :eof)))\n;-> cpu time (non-gc) 180 msec user, 0 msec system\n;   cpu time (gc)     0 msec user, 0 msec system\n;   cpu time (total)  180 msec user, 0 msec system\n;   real time  187 msec\n;   space allocation:\n;    230,354 cons cells, 271,024 other bytes, 0 static bytes\n;=> NIL\n\n;; 他に\n(make-two-way-stream (make-string-input-stream \"\")\n                     (make-broadcast-stream))\n}}}\n\n*** 処理系備え付けを利用する\n\n処理系によっては、ビットバケツを用意している場合があります。Allegro CLのexcl::*null-stream*等。\n\n下記では、simple-streamなどでNULLストリームを作成しています。\n{{{\n(let ((null-stream \n       #+LispWorks (make-instance 'stream::null-stream)\n       #+Allegro (make-instance 'stream::null-stream)\n       #+sbcl (make-instance 'sb-simple-streams:null-simple-stream)\n       ))\n (time\n  (loop :repeat 10000 \n        :do\n        (format null-stream \"こんにちは!\")\n        (read null-stream nil :eof))))\n}}}\n\n*** UNIXの/dev/nullを利用する\n\nUNIX限定となりますが、下記のようなものを利用する場合もあるようです\n{{{\n(defvar *null-stream* \n        (open #p\"/dev/null\" :direction :output :if-exists :overwrite))\n}}}\n\n*** ライブラリを利用する\n[[CLiki:KMRCL]]にはnull-output-streamがありますが、UNIXの/dev/nullを利用する実装になっています。\n\n** 議論\n")
(" %Tag:日付と時刻 and 1=1" . "(1532959356)")
(" %Tag:日付と時刻99999\" union select unhex(hex(version())) -- \"x\"=\"x" . "(1532959369)")
(" %Tag:【募集中】?Tag?Tag:【募集中】?Tag" . "(1476573535)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45) -- /* order by \"as /*" . "(1624124982)")
(" %Tag:cl-cron" . "(1667840344 (\"タイマーとスケジューリング\" :ctime 1458229030 :cuser #f :mtime 1458229030 :muser #f))")
(" %Tag:コーディングスタイル" . "(1668191174 (\"コーディングスタイル\" :ctime 1227967130 :cuser #f :mtime 1529826119 :muser #f) (\"大文字と小文字の使い分け\" :ctime 1232667473 :cuser #f :mtime 1529823156 :muser #f) (\"Tutorial on Good Lisp Programming Style\" :ctime 1227969021 :cuser #f :mtime 1431247962 :muser #f) (\"コメント\" :ctime 1227971104 :cuser #f :mtime 1227971659 :muser #f))")
("文字列からXML文章を構築する:cxml-stp" . "(:ctime 1336640081 :cuser #f :mtime 1336640081 :muser #f)この例では、文字列からSTPを構築しています。\n{{{\n(defparameter *data*\n  (cxml:parse \"<tips>こんにちは</tips>\" (stp:make-builder)))\n\n*data*\n;=>  #.(CXML-STP-IMPL::DOCUMENT\n;       :CHILDREN '(#.(CXML-STP:ELEMENT\n;                      #| :PARENT of type DOCUMENT |#\n;                      :CHILDREN '(#.(CXML-STP:TEXT\n;                                     #| :PARENT of type ELEMENT |#\n;                                     :DATA \"こんにちは\"))\n;                      :LOCAL-NAME \"tips\")))\n}}}\n\n文字列として出力してみる\n{{{\n(stp:serialize *data* (cxml:make-string-sink))\n;=>  \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n;    <tips>こんにちは</tips>\"\n}}}\n")
(" %Tag:cl-ppcre'" . "(1610123349)")
("配列の各要素に対して関数を適用する" . "(:ctime 1228103803 :cuser #f :mtime 1228111982 :muser #f)[[$$tag 配列]]\n\n* 配列の各要素に対して関数を適用する\n\n[[$$hs map]]はシークエンス全般に使用できます。第1引数にnilを指定する場合返り値はnilとなり主に副作用目的で使用できます。\n{{{\n(let ((v (vector 1 2 3 2 1 2 3 2 1)))\n  (map nil #'print v))\n;-> 1 \n;   2 \n;   3 \n;   2 \n;   1 \n;   2 \n;   3 \n;   2 \n;   1 \n;=> nil\n}}}\n")
(" %Tag:weblocks)" . "(1521643060)")
(" %Tag:ライブラリ'[0]" . "(1667104198)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 640 #" . "(1624125294)")
("文字列を比較する" . "(:ctime 1313330953 :cuser #f :mtime 1313330953 :muser #f)[[$$tag 文字列]]\n\n文字列を比較するときは、一般的に[[$$hs equal]]か[[$$hs string=]]を使います。また、大文字と小文字を区別したくない場合は[[$$hs equalp]]か[[$$hs string-equal]]を使います。\n\n{{{\n;; より一般的な比較関数のequal\n(equal \"a\" \"a\")         ;=> T\n(equal \"a\" \"b\")         ;=> NIL\n\n;; 文字列に特化した比較関数のstring=\n(string= \"a\" \"a\")       ;=> T\n(string= \"a\" \"b\")       ;=> NIL\n\n;; 大文字と小文字を区別するequalとstring=\n(equal \"a\" \"A\")         ;=> NIL\n(string= \"a\" \"A\")       ;=> NIL\n\n;; 大文字と小文字を区別しないequalpとstring-equal\n(equalp \"a\" \"A\")        ;=> T\n(string-equal \"a\" \"A\")  ;=> T\n}}}\n")
(" %Tag:制限" . "(1667973895 (\"MOST-POSITIVE-FIXNUM\" :ctime 1529822476 :cuser #f :mtime 1529822476 :muser #f) (\"ARRAY-TOTAL-SIZE-LIMIT\" :ctime 1529821655 :cuser #f :mtime 1529821655 :muser #f))")
("一万のファイルがあるディレクトリから条件に合うファイルを一つ取り出す" . "(:ctime 1337067237 :cuser #f :mtime 1337067457 :muser #f)一万のファイルがあるディレクトリから条件に合うファイルを一つ取り出す例です~%\n\n[[$$hs directory]] でディレクトリの内容を取得し条件に合う最初のものを返す\n{{{\n;;; ファイルの拡張子が .txt かを判定\n(defun txt-p (path)\n  (string= \"TXT\" (pathname-type path :case :common)))\n\n;;; /tmp/10000 or C:\\tmp\\10000 etc...\n(defparameter *dir*\n  (make-pathname :directory '(:absolute \"TMP\" \"10000\") :case :common))\n\n\n(dolist (f (directory\n            (merge-pathnames *dir*\n                             (make-pathname :name :wild\n                                            :type \"TXT\"\n                                            :case :common))))\n  (when (txt-p f)\n    (return f)))\n;⇒ #P\"/tmp/10000/00001.txt\"\n#|------------------------------------------------------------|\nEvaluation took:\n  1.124 seconds of real time\n  1.116070 seconds of total run time (0.908057 user, 0.208013 system)\n  99.29% CPU\n  2,688,891,030 processor cycles\n  46,603,728 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n処理系依存の機能でイテレータを使った場合\n{{{\n#+sbcl\n(sb-impl::with-native-directory-iterator (p (namestring *dir*))\n  (loop :for p := (p) :while p\n        :when (txt-p p) :return p))\n;⇒ \"05524.txt\"\n#|------------------------------------------------------------|\nEvaluation took:\n  0.002 seconds of real time\n  0.000000 seconds of total run time (0.000000 user, 0.000000 system)\n  0.00% CPU\n  4,192,794 processor cycles\n  0 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n")
(" %Tag:リーダーマクロ'A=0" . "(1558370178)")
(" %Tag:配列 and 1=1" . "(1624124140)")
(" %Tag:local-time and 1=1#" . "(1660041630)")
(" %Tag:local-time%' and 1=1 and '%'='" . "(1660041671)")
(" %Tag:?????' and 'x'='y" . "(1584214738)")
(" %Tag:FiveAM" . "(1668277237 (\"FiveAM\" :ctime 1460645375 :cuser #f :mtime 1660192441 :muser #f))")
(" %Tag:fare-utils" . "(1667934094 (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f))")
("スーパークラスのメソッドを呼び出す" . "(:ctime 1230216117 :cuser #f :mtime 1230216117 :muser #f)[[$$hs オブジェクトシステム(CLOS)]]\n\n* スーパークラスのメソッドを呼び出す\n\nスーパークラスのメソッドを呼び出すには、メソッド定義の中で [[$$hs call-next-method]] を使用します。\n標準のメソッド結合(メソッドコンビネーション)では、プライマリメソッドとaroundメソッドの中で [[$$hs call-next-method]] が利用できます。\nまた、aroundメソッドを利用した場合 [[$$hs call-next-method]] を呼びださないとプライマリメソッドが呼びだされません。\n{{{\n(defclass foo () ())\n(defclass bar (foo) ())\n\n(defgeneric foo (self))\n(defmethod foo ((self foo))\n  \"foo!!\")\n(defmethod foo ((self bar))\n  (call-next-method))\n(defmethod foo :around ((self bar))\n  (format nil \"<bar>~A</bar>\" (call-next-method)))\n\n;; 試してみる\n(foo (make-instance 'bar))\n;=> \"<bar>foo!!</bar>\"\n}}}\n\n標準のメソッド結合以外では、aroundメソッドの中から [[$$hs call-next-method]] が使用できます。\nそれ以外から呼び出すとエラーになります。\n{{{\n(defclass foo () ())\n(defclass bar (foo) ())\n\n(defgeneric foo-list (self)\n  (:method-combination list))\n(defmethod foo-list list ((self foo))\n  \"foo!!\")\n(defmethod foo-list :around ((self foo))\n  (cons \"foo:around!!\" (call-next-method)))\n(defmethod foo-list list ((self bar))\n  \"bar!!\")\n(defmethod foo-list :around ((self bar))\n  (cons \"bar:around!!\" (call-next-method)))\n\n;; 試してみる\n(foo-list (make-instance 'bar))\n;=> (\"bar:around!!\" \"foo:around!!\" \"bar!!\" \"foo!!\")\n}}}\n")
("ELI" . "(:ctime 1252164417 :cuser #f :mtime 1252324712 :muser #f)[[$$tag eli]]\n- [[基本的構成を確立する]] (Lispひとつ Emacsひとつ Listenerひとつ)\n- [[複数 Listener を使う]]\n- [[起動済みの Lisp に Emacs を接続する]]\n- [[関数定義の場所を、TAGSではなく、Lisp に問い合わせる]]\n- [[Allegro Composer との連携]]\n- [[Lisp-Emacs protocol (LEP) を直接使って Lisp と対話する]]\n")
("Postmodern" . "(:ctime 1329736541 :cuser #f :mtime 1329736541 :muser #f)[[$$tag 【募集中】]]\n")
("コマンドラインオプション" . "(:ctime 1330402382 :cuser #f :mtime 1437404817 :muser #f)処理系やOSによりそれぞれですが大まかには下記のようになります。\n||||SBCL||CCL||ACL||CLISP||ECL||LispWorks||\n||ヘルプ||--help||-h, --help||-||-h, --help||-?, --help||-||\n||<form>を評価||--eval <form>||-e, --eval <form>||-e <form>||-x <form>||-eval <form>||-eval <form>||\n||<file>をロード||--load <file>||-l, --load <file>||-L <file>||<file>||-load <file>||-load <file>||\n||<file>のイメージで起動||--core <file>||-I, --image-name <file>||-I <file>||-M <file>||-||-||\n||初期化ファイルを<file>とする(システム全体)||--userinit(--sysinit) <file>||-||-||-i <file>||-||-init (-siteinit) <file> ||\n||初期化ファイルを読まない(システム全体)||--no-userinit(--no-sysinit)||-n, --no-init||-q(-qq)||-norc||-norc||-init (-siteinit) - ||\n\n||||CMUCL||ABCL||\n||ヘルプ||-help||--help||\n||<form>を評価||-eval <form>||--eval <form>||\n||<file>をロード||-load <file>||--load <form>||\n||<file>のイメージで起動||-core <file>||-||\n||初期化ファイルを<file>とする(システム全体)||-init <file>||--load <file> --noinit(--load-system-file <file> --nosystem)||\n||初期化ファイルを読まない(システム全体)||-noinit(-nositeinit)||--noinit(--nosystem)||\n")
(" %Tag:オブジェクトシステム(CLOS)" . "(1668277886 (\"インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい\" :ctime 1227349451 :cuser #f :mtime 1526405639 :muser #f) (\"初回の起動でしか実行されないフックを作成したい\" :ctime 1318391632 :cuser #f :mtime 1370597684 :muser #f) (\"匿名クラスをつくりたい\" :ctime 1230011124 :cuser #f :mtime 1364489487 :muser #f) (\"定義したメソッドを削除するには\" :ctime 1238222807 :cuser #f :mtime 1238223605 :muser #f) (\"オブジェクトの印字方法をカスタマイズする\" :ctime 1236781678 :cuser #f :mtime 1236781678 :muser #f) (\"サブクラス関係かどうか判定する\" :ctime 1233062751 :cuser #f :mtime 1233062836 :muser #f) (\"インスタンス変数・クラス変数を定義する\" :ctime 1230290536 :cuser #f :mtime 1230290689 :muser #f) (\"メソッドの可視性を定義する\" :ctime 1230214962 :cuser #f :mtime 1230214962 :muser #f) (\"オブジェクトの初期化を行う\" :ctime 1229748239 :cuser #f :mtime 1229748296 :muser #f) (\"メソッドを定義するには\" :ctime 1229673282 :cuser #f :mtime 1229673589 :muser #f) (\"クラスを定義する\" :ctime 1229668892 :cuser #f :mtime 1229668892 :muser #f) (\"定義されていないスーパクラスメソッドの呼び出しを防ぎたい\" :ctime 1228017976 :cuser #f :mtime 1228017977 :muser #f) (\"同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい\" :ctime 1228012693 :cuser #f :mtime 1228012694 :muser #f) (\"インスタンス初期化時に複数のスロットを同じ値で埋めたい\" :ctime 1228011914 :cuser #f :mtime 1228011915 :muser #f) (\"CLOSの読みはシーロスとクロスどちらが正しいか\" :ctime 1227899666 :cuser #f :mtime 1227899678 :muser #f))")
(" %Tag:制御構造?p=Tag:制御構造" . "(1491321819)")
("条件判断(cond マクロ)" . "(:ctime 1228888426 :cuser #f :mtime 1350654822 :muser #f)[[$$tag 制御構造]]\n* 条件判断(cond :マクロ)\n他の言語でいう if-then-else に相当する機能です。\n\n{{{\n(cond (条件式1\n       処理1\n       処理2 ...)\n      (条件式2\n       処理3 ...))\n}}}\n\n条件式が先頭から順に評価され、真(NIL以外)のとき続く処理が評価されます。\n\nifと違い処理1、処理2...と続けることができて、最後の式の値がcondの値として返ります。\n\nどの条件式も真にならなかった場合NILが返ります。途中の条件式が真になった場合、以降に書かれた条件式は評価されません。\n\n条件式のところにtと書く事で、いづれの条件も真にならなかった場合の処理(else相当)を書くのが習慣です。\n\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae) and 1=2 and (2=2" . "(1656001238)")
(" %Tag:入出力'[0]" . "(1665855836)")
(" %Tag:その他'A=0" . "(1558237207)")
(" %Tag:Webサーバ" . "(1668191560 (\"Hunchentootを起動する\" :ctime 1292947409 :cuser #f :mtime 1292947883 :muser #f) (\"Hunchentoot\" :ctime 1292946216 :cuser #f :mtime 1292947854 :muser #f) (\"Webサーバ\" :ctime 1292927796 :cuser #f :mtime 1292927979 :muser #f))")
("trivial-shell" . "(:ctime 1432435430 :cuser #f :mtime 1432435430 :muser #f)[[$$tag コマンドライン trivial-shell ライブラリ]]\n\n[[CLiki:trivial-shell]]はシェルの呼び出し機能の処理系ごとの違いを吸収して可搬性を向上させるライブラリ\n\n\n{{{\n;; Quicklispでインストール\n(ql:quickload :trivial-shell)\n\n\n;; 環境編集を取得する\n(trivial-shell:get-env-var \"SHELL\")\n;=>  \"/bin/zsh\"\n\n;; シェルのパスの設定\ntrivial-shell:*shell-search-paths*\n;=>  (\"/usr/bin/\" \"/usr/local/bin/\")\n\n;; シェルコマンドを呼び出して文字列を取得\n(trivial-shell:shell-command \"wc /usr/share/dict/words\")\n;=>  \" 99171  99171 938848 /usr/share/dict/words\n\n;; 処理系の終了\n(trivial-shell:exit) \n\n}}}\n")
("リストの要素数を取得する" . "(:ctime 1227517615 :cuser #f :mtime 1328667572 :muser #f)[[$$tag リスト]]\n\nリストの長さは [[$$hs length]] 関数で調べることができます。\n\n{{{\n(length '(1 2 3 4)) ;=> 4\n}}}\n\nただし、リストの構造を調べるような場合には [[$$hs length]] を使うよりも [[$$hs car]], [[$$hs cdr]], [[$$hs null]] を使って構造を調べた方が効率がよいです。例えばリストが [[$$hs if]] フォームとして適正な形をしているか調べる関数を考えます。\n\n{{{\n(defun if? (xs)\n  (and (<= 3 (length xs) 4)\n       (eql (car xs) 'if)))\n}}}\n\nこの場合、[[$$hs length]] で長さを調べると、引数で与えられたリストの長さが大きい場合、余計な時間がかかってしまいます。\n\n{{{\n(defun if? (xs)\n  (and (consp xs)\n       (eql (car xs) 'if)\n       (not (null (cdr xs)))\n       (not (null (cddr xs)))\n       (or (null (cdddr xs))\n           (null (cddddr xs)))))\n}}}\nとすれば引数のリストの長さにかかわらず定数時間で計算が終了します。\n\n同じ理由で、リストが空かどうか調べるには [[$$hs length]] を使うよりも [[$$hs null]] を使う方が良いでしょう。\n{{{\n;; fast version\n(null (make-list 5000000 0)) ;=> nil\n\n;; slow version\n(zerop (length (make-list 5000000))) ;=> nil\n}}}\n同様のアイディアとして、Paul Graham著の[[On Lisp]]にsingleという例があります。\n要素が1つならば真を返しますが、長さではなく、1つ目の要素の後が終端(nil)かどうかを判定しています。\n{{{\n(defun single (lst)\n  (and (consp lst) (not (cdr lst))))\n}}}\n")
(" %Tag:リスト'A=0" . "(1565188409)")
(" %Tag:配列 or (1,2)=(select*from(select name_const(CHAR(120,102,89,74,111,86,118,78,69,101),1),name_const(CHAR(120,102,89,74,111,86,118,78,69,101),1))a) -- and 1=1" . "(1624125340)")
("メソッドの可視性を定義する" . "(:ctime 1230214962 :cuser #f :mtime 1230214962 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* メソッドの可視性を定義する\n\nCLOSの場合、Rubyのpublic、private、protectedのように呼び出し制限機構はありません。\n\n情報の隠蔽については、専らパッケージでエクスポートするかどうかで制御することが一般的でしょう。\n")
("プログラムの出力を収集する" . "(:ctime 1230407977 :cuser #f :mtime 1302577221 :muser #f)[[$$tag 入出力 ライブラリ kmrcl cl-ppcre ]]\n\n* プログラムの出力を収集する\n\n外部のプログラムを呼ぶ方法については処理系依存になりますが、大抵の処理系は呼び出す機能を備えています。\n下記の例では、[[CLiki:KMRCL]] の command-outputを利用しています。\n\n** 出力を一つの文字列として収集\n{{{\n(let ((output (kmrcl:command-output \"ls /bin/z*\")))\n  output)\n;=> \"/bin/zcat\n/bin/zcmp\n/bin/zdiff\n/bin/zegrep\n/bin/zfgrep\n/bin/zforce\n/bin/zgrep\n/bin/zless\n/bin/zmore\n/bin/znew\n/bin/zsh\n/bin/zsh4\n\"\n}}}\n\n** 出力を行ごとに分けたリストにする\n[[CLiki:cl-ppcre]] を利用\n{{{\n(let ((output (ppcre:split \"\\\\n\" \n                (kmrcl:command-output \"ls /bin/z*\"))))\n  output)\n;=> (\"/bin/zcat\" \"/bin/zcmp\" \"/bin/zdiff\" \"/bin/zegrep\" \n     \"/bin/zfgrep\" \"/bin/zforce\" \"/bin/zgrep\" \"/bin/zless\"\n     \"/bin/zmore\" \"/bin/znew\" \"/bin/zsh\" \"/bin/zsh4\")\n}}}\n")
("匿名クラスをつくりたい" . "(:ctime 1230011124 :cuser #f :mtime 1364489487 :muser #f)[[$$tag オブジェクトシステム(CLOS) MOP]]\n\n* 匿名クラスをつくりたい\n\n匿名クラスは名前がNILのクラスとなり、[[$$hs standard-class]]のインスタンスとして作成できるでしょう。\n\n{{{\n(defclass foo ()\n  ((x :initarg :x :accessor foo-x)))\n\n;; fooを継承した匿名クラス FIXME\n(let ((anon (make-instance 'standard-class\n                           :direct-superclasses\n                           (list (find-class 'foo))\n                           :direct-slots\n                           ;; スロット(Y)を追加\n                           '((:name y)))))\n  (let ((inst (make-instance anon :x 42)))\n    (with-slots (y) inst\n      (setf y 100)\n      (list (foo-x inst) y))))\n;=> (42 100)\n}}}\n{{{\n;; 匿名クラス(a)を継承した匿名クラス(b)\n(let* ((a (make-instance 'standard-class\n                         :direct-superclasses '()\n                         :direct-slots '((:name a :initargs (:a)))))\n       (b (make-instance 'standard-class\n                         :direct-superclasses (list a)\n                         :direct-slots '((:name b :initargs (:b))))))\n  (let ((inst (make-instance b :a 0 :b 1)))\n    (describe inst)))\n;->  #<#<STANDARD-CLASS NIL {101A8BC263}> {101A96F4B3}>\n;      [standard-object]\n;\n;    Slots with :INSTANCE allocation:\n;      A  = 0\n;      B  = 1\n;\n;=>  No value\n}}}\n\n{{{\n;; 複数生成された場合、class-nameはNILになるものの別々クラスとなる\n(let ((anon1(make-instance 'standard-class\n                           :direct-superclasses\n                           (list (find-class 'foo))\n                           :direct-slots\n                           ;; スロット(Y)を追加\n                           '((:name y))))\n      (anon2 (make-instance 'standard-class\n                            :direct-superclasses\n                            (list (find-class 'foo))\n                            :direct-slots\n                            ;; スロット(Y)を追加\n                            '((:name y)))))\n  (let ((inst1 (make-instance anon1 :x 42))\n        (inst2 (make-instance anon2 :x 97)))\n    (with-slots (y) inst1\n      (setf y 100)\n      (list (foo-x inst1) \n            y\n            (foo-x inst2)\n            :class-name\n            (list (class-name (class-of inst1))\n                  (class-name (class-of inst2)))\n            :class=\n            (eq (class-of inst1)\n                (class-of inst2))))))\n;=>  (42 100 97 :CLASS-NAME (NIL NIL) :CLASS= NIL)\n}}}\n\n\n*** 参考\n- [http://www.lisp.org/mop/concepts.html#metaobject-initialization-protocols Metaobject Initialization Protocols]\n")
(" %Tag:入出力" . "(1668270283 (\"入出力\" :ctime 1227443658 :cuser #f :mtime 1631078775 :muser #f) (\"処理系を起動したディレクトリのパスネームを返す\" :ctime 1227447346 :cuser #f :mtime 1579751086 :muser #f) (\"CL-FAD\" :ctime 1432468963 :cuser #f :mtime 1432468963 :muser #f) (\"ファイルに書き込む\" :ctime 1227946735 :cuser #f :mtime 1363819506 :muser #f) (\"テキストファイルをオープンして内容を出力する\" :ctime 1227871186 :cuser #f :mtime 1362891077 :muser #f) (\"ディレクトリのリスト表現からパスを生成する\" :ctime 1337330938 :cuser #f :mtime 1337330938 :muser #f) (\"NULLストリームを使う\" :ctime 1232161530 :cuser #f :mtime 1314943450 :muser #f) (\"ファイルの最終更新時刻を取得する\" :ctime 1312884726 :cuser #f :mtime 1312884726 :muser #f) (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1302577221 :muser #f) (\"ファイルサイズを知る\" :ctime 1238425394 :cuser #f :mtime 1238425394 :muser #f) (\"ホームディレクトリを取得する\" :ctime 1237730376 :cuser #f :mtime 1238226847 :muser #f) (\"外部からの入力バイト列を文字列にしたい(文字コード変換含む)\" :ctime 1229261302 :cuser #f :mtime 1236779813 :muser #f) (\"ディレクトリ内のすべてのファイルを再帰的に処理する\" :ctime 1232597586 :cuser #f :mtime 1232608615 :muser #f) (\"ファイル内の特定の行を読み込む\" :ctime 1231655622 :cuser #f :mtime 1231655622 :muser #f) (\"ファイルから行をランダムに取り出す\" :ctime 1231136258 :cuser #f :mtime 1231164888 :muser #f) (\"ファイルをリネームする\" :ctime 1231087938 :cuser #f :mtime 1231087938 :muser #f) (\"別のプログラムを起動する\" :ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f) (\"ストリームを扱うように出力先としてシーケンスを指定したい\" :ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f) (\"ベクタをバイナリのストリームとして扱いたい\" :ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f))")
(" %Tag:local-time' or(1=2)#" . "(1660041662)")
("特定のコンディションだけを捕捉する" . "(:ctime 1238214428 :cuser #f :mtime 1238214428 :muser #f)[[$$tag コンディション]]\n\n\n{{{\n(handler-case (error \"Error!\")\n  (simple-error () \"no error\"))\n; => \"no error\"\n}}}\n\n")
("最大値・最小値を求める" . "(:ctime 1453044354 :cuser #f :mtime 1453044355 :muser #f)[[$$tag 数値]]\n\n* 最大値・最小値を求める\n\nmax, min 関数を用いることができます, 複数値の入力に対応しています。\n\n{{{\n(max 1 5 4 3 2)\n;=> 5\n\n(max 1 5.3 -2.5 3e1)\n;=> 30.0\n\n(max 10000000000001d0 1.01d10)\n;=> 1.0000000000001d13\n}}}\n\n{{{\n(min 1 5 3 2 10)\n;=> 1\n\n(min 1 500.3 -2.5 3e1)\n;=> -2.5\n\n(min -1.00000001d0 -1.1)\n;=> -1.1\n}}}\n")
(" %Tag:配列\" and \"x\"=\"y" . "(1624124197)")
(" %Tag:local-time) or(1=2)-- -" . "(1660041688)")
(" %Tag:arnesi" . "(1668279679 (\"環境変数を取得する\" :ctime 1232400758 :cuser #f :mtime 1232400886 :muser #f) (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f))")
("逆引きCommon Lisp" . "(:ctime 1228398922 :cuser #f :mtime 1586446118 :muser #f)* 逆引きCommon Lisp\n- [[逆引きCommon Lisp書式]]\n- [[ライセンスについて]]\n- [[編集に関する基本方針]]\n- [[新規ページ作成の手順]]\n----\n** 基本処理と言語標準機能\n- [[文字列]]\n- [[シンボル]]\n- [[数値]]\n- [[リスト]]\n- [[配列]]\n- [[ハッシュテーブル]]\n- [[構造体]]\n- [[多値]]\n- [[標準入出力]]\n- [[format]]\n- [[日付と時刻]]\n- [[変数とスコープ]]\n- [[制御構造]]\n- [[コンディション]]\n- [[入出力]]\n- [[関数]]\n- [[マクロ]]\n- [[パッケージ]]\n- [[オブジェクトシステム(CLOS)]]\n----\n** 目的別\nライブラリ一覧はこちら : [[ライブラリ]]\n- [[OS]]\n- [[正規表現]]\n- [[スレッド]]\n- [[ネットワーク]]\n- [[コマンドライン]]\n- [[GUI]]\n- [[XML]]\n- [[インターネットサービス]]\n- [[サーバ]]\n- [[Webオートメーション]]\n- [[データベース]]\n- [[ライブラリ管理]]\n- [[テストフレームワーク]]\n- [[タイマーとスケジューリング]]\n----\n** その他\n- [[落とし穴]]\n- [[開発環境]]\n- [[最適化]]\n- [[処理系]]\n- [[コーディングスタイル]]\n- [[仕様/ドキュメント]]\n- [[その他]]\n- [[リンク集]]\n- [[Tag:【募集中】]]\n----\n欲しい項目、質問事項があれば直接編集、もしくは[[リクエスト]]へどうぞ!!\n")
(" %Tag:ベクタ'A=0" . "(1558210411)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') or(1=2)#" . "(1656001234)")
("数値" . "(:ctime 1227412843 :cuser #f :mtime 1457056255 :muser #f)[[$$tag 数値]]\n\n* 計算\n- [[平方根を求める]]\n- [[除算の商と余りを求める]]\n- [[四捨五入する]]\n- [[絶対値を求める]]\n- [[小数点を切り上げ・切り捨て]]\n- [[三角関数を計算する]]\n- [[対数を計算する]]\n- [[最大値・最小値を求める]]\n- [[xのn乗（べき乗・累乗）を計算する]]\n\n* 乱数\n- [[乱数を生成する]]\n- [[同じランダムステートを使い回したい]]\n\n* ビット演算\n- [[基本的なビット演算をする]]\n- [[任意のビット位置の値を参照する]]\n- [[1のビットを数え上げる]]\n- [[整数値のビット長を求める]]\n- [[#xNNNNNNという16進RGB形式を色ごとに分解する]]\n\n* 内部の扱い（精度・分数/小数・定数表現など）\n\n- [[計算結果を分数から小数にしたい]]\n- [[整数と浮動小数点を相互変換する（精度の変換）]]\n- [[読み取り時のデフォルトの浮動小数点の精度を指定する]]\n\n- [[2進数・8進数・16進数で数値を扱うには]]\n\n- [[無限大]]\n\n* 文字・数値変換\n- [[文字を数値に変換する]]\n- [[文字列を数値に変換する]]\n\n- [[数値を文字列に変換する]]\n- [[数値を2進数・8進数・16進数表現の文字列に変換するには]]\n\n- [[数値を位取り用のカンマで区切る]]\n- [[数値に応じて複数形と単数形を切り換える]]\n- [[ローマ数字を扱う]]\n\n")
("prove" . "(:ctime 1460644309 :cuser #f :mtime 1460644309 :muser #f)[[$$tag prove テストフレームワーク]]\n\nhttps://github.com/fukamachi/prove\n\n[[CL-TEST-MORE]] は名前が変わって prove となりました。\n\n* 特徴\n\n- TAPでの結果出力\n- テストのスクリプトとしての実行をサポート\n\n* 使用方法\n\n\n[[$$tag 【募集中】]]\n\n[[CL-TEST-MORE]] を参照してください。\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' and 1=2#" . "(1656001223)")
("配列の要素数を取得する" . "(:ctime 1228547522 :cuser #f :mtime 1228547523 :muser #f)[[$$tag 配列]]\n* 配列の要素数を取得する\n\n[[$$hs length]] はシーケンス全体に適用できますのでベクタにも使用できます。\n{{{\n(length #(foo bar baz))\n;=> 3\n}}}\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45) -- /* order by 'as /*" . "(1624124710)")
("XML文章内のデータをソート:plexippus-xpath" . "(:ctime 1336652312 :cuser #f :mtime 1336652313 :muser #f)抜き出した結果に、[[$$hs sort]]のkeyにstp:string-value 等を渡したものをかければソートできるでしょう~%\nライブラリの導入方法\n{{{\n(ql:quickload :xpath)\n}}}\nXML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"\n<a xmlns='http://tips.lisp-users.org/common-lisp'>\n  <b name='おそ松'>1</b>\n  <b name='トド松'>6</b>\n  <b name='チョロ松'>3</b>\n  <b name='一松'>4</b>\n  <b name='カラ松'>2</b>\n  <b name='十四松'>5</b>\n</a>\n\"\n   (stp:make-builder)))\n}}}\n{{{\n(xpath:with-namespaces ((\"x\" (stp:namespace-uri (stp:document-element *doc*))))\n  (let ((elts (xpath:all-nodes (xpath:evaluate \"//x:b\" *doc*))))\n    (dolist (e (cl:sort elts #'<\n                        :key (lambda (x) (parse-integer (stp:string-value x)))))\n      (format t\n              \"~A: ~A~%\"\n              (stp:string-value e) (stp:attribute-value e \"name\")))))\n;->  1: おそ松\n;    2: カラ松\n;    3: チョロ松\n;    4: 一松\n;    5: 十四松\n;    6: トド松\n;\n;=>  NIL\n}}}\n")
(" %Tag:CL-TEST-MORE?Tag:CL-TEST-MORE" . "(1491321612)")
("乱数を生成する" . "(:ctime 1227497166 :cuser #f :mtime 1227671316 :muser #f)[[$$tag 数値]]\n* 乱数を生成する\n関数 [http://www.lispworks.com/documentation/HyperSpec/Body/f_random.htm RANDOM]を使います。第一引数で乱数の範囲を指定します。整数値を与えるとその上限未満の整数値を返します。\n{{{\n(random 100) ;=> 0以上100未満の整数が得られる\n}}}\n浮動小数値を与えると、同じくその上限未満の浮動小数値を返します。\n{{{\n(random 1.0) ;=> 0以上1.0未満の浮動小数値が得られる\n}}}\n\n第二引数に [http://www.lispworks.com/documentation/HyperSpec/Body/t_rnd_st.htm#random-state random-state] を渡すことで乱数列を指定することができます。省略した場合は、現在の random-state である [http://www.lispworks.com/documentation/HyperSpec/Body/v_rnd_st.htm#STrandom-stateST *random-state*] が使われます。\n\n副作用として、random-state の内容が更新されます。\n")
(" %Tag:ABCL" . "(1667933830 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f) (\"ABCLでDISASSEMBLEする\" :ctime 1230125046 :cuser #f :mtime 1365504930 :muser #f))")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45) --  /*" . "(1624124396)")
("XML文章のツリーを構築する:cxml-stp" . "(:ctime 1336639706 :cuser #f :mtime 1363448072 :muser #f)* XMLデータからSTPツリーを作る\n\nClosure XMLの[http://common-lisp.net/project/cxml/sax.html#parser cxml:parse]を使います。\n\n{{{\n;; ファイルからXMLデータを読み込んでSTPツリーを作る\n(cxml:parse #p\"data.xml\" (stp:make-builder))\n\n;; 文字列からSTPツリーを作る\n(cxml:parse \"<element>content</element>\" (stp:make-builder))\n\n;; :element-typeが(unsigned-byte 8)のストリームからXMLデータを読み込んでSTPツリーを作る\n(cxml:parse octet-stream (stp:make-builder))\n}}}\n\n* 新しくSTPツリーを作る\n\nAPIを使って一からSTPツリーを組み立てることもできます。\n\n{{{\n(defparameter *tips-cl*\n  (let* ((ns \"http://tips.lisp-users.org/common-lisp\")      ; 名前空間\n         (e (stp:make-element \"root\" ns))                   ; ルート要素\n         (a (stp:make-attribute \"attribute\" \"sample\"))      ; ルート要素に設定する属性\n         (child-1 (stp:make-element \"child1\" ns))           ; 子要素\n         (child-2 (stp:make-element \"child2\" ns)) )         ; もうひとつの子要素\n    (stp:append-child child-1 (stp:make-text \"sample1\"))    ; 子要素の内容を設定\n    (stp:append-child child-2 (stp:make-text \"sample2\"))    ; 同上\n    (stp:add-attribute e a)                                 ; ルート要素に属性を設定\n    (stp:append-child e child-1)                            ; ルート要素に子要素を追加\n    (stp:append-child e child-2)                            ; 同上\n    (stp:make-document e)))                                 ; ルート要素をもとにXMLデータを生成\n}}}\n\nちゃんと組み立てられたかどうか、文字列として出力してみましょう。\n\n{{{\n(stp:serialize *tips-cl* (cxml:make-string-sink))\n;=>  \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n;    <root xmlns=\\\"http://tips.lisp-users.org/common-lisp\\\" sample=\\\"att\\\"><child1>sample1</child1><child2>sample2</child2></root>\"\n}}}\n")
("CL-PPCRE" . "(:ctime 1306251958 :cuser #f :mtime 1607226708 :muser #f)[[$$tag 正規表現 cl-ppcre]]\n\n[[CLiki:CL-PPCRE]]では正規表現を文字列かS式で表現します。文字列で正規表現を表現する場合は、文字クラスを使うときなど、Perlなどで使われる表記をエスケープしなければならないことがあります。\n\n* 導入\nQuicklispから入れることができます。\n\n{{{\n(ql:quickload :cl-ppcre)\n}}}\n\n* パターンの例\n\n基本的にPerlの正規表現を文字列で渡せば問題ありません。ただし、上にもありますが、文字列で正規表現を表す場合、表記をエスケープしなければならないことがあります。\n\n{{{\n;; bにマッチする\n(ppcre:scan \"b\" \"abc\")\n(ppcre:scan #\\b \"abc\")\n;=> 1\n;   2\n;   #()\n;   #()\n\n;; 任意の文字にマッチする\n(ppcre:scan \".\" \"abc\")\n(ppcre:scan :everything \"abc\")\n;=> 0\n;   1\n;   #()\n;   #()\n\n;; 任意の3文字にマッチする\n(ppcre:scan \"...\" \"abc\")\n(ppcre:scan '(:sequence :everything :everything :everything) \"abc\")\n;=> 0\n;   3\n;   #()\n;   #()\n\n;; Perlの文字クラス\\wにマッチする\n;; \"\\w\"は\"w\"と同じ意味になってしまうため、\"\\\\w\"としなければならない\n(ppcre:scan \"\\\\w\" \"abc\")\n(ppcre:scan :word-char-class \"abc\")\n;=> 0\n;   1\n;   #()\n;   #()\n\n;; aとbとcのいずれかにマッチする\n(ppcre:scan \"[abc]\" \"a\")\n(ppcre:scan '(:char-class #\\a #\\b #\\c) \"a\")\n;=> 0\n;   1\n;   #()\n;   #()\n(ppcre:scan \"[abc]\" \"c\")\n(ppcre:scan '(:char-class #\\a #\\b #\\c) \"c\")\n;=> 0\n;   1\n;   #()\n;   #()\n\n;; aとbとc以外にマッチする\n(ppcre:scan \"[^abc]\" \"c\")\n(ppcre:scan '(:inverted-char-class #\\a #\\b #\\c) \"c\")\n;=> NIL\n(ppcre:scan \"[^abc]\" \"d\")\n(ppcre:scan '(:inverted-char-class #\\a #\\b #\\c) \"d\")\n;=> 0\n;   1\n;   #()\n;   #()\n\n;; 行の最初のaにマッチする\n(ppcre:scan \"^a\" \"abc\")\n(ppcre:scan '(:sequence :start-anchor #\\a) \"abc\")\n;=> 0\n;   1\n;   #()\n;   #()\n(ppcre:scan \"^a\" \"cba\")\n(ppcre:scan '(:sequence :start-anchor #\\a) \"cba\")\n;=> NIL\n\n;; 行の最後のcにマッチする\n(ppcre:scan \"c$\" \"abc\")\n(ppcre:scan '(:sequence #\\c :end-anchor) \"abc\")\n;=> 2\n;   3\n;   #()\n;   #()\n(ppcre:scan \"c$\" \"aaa\")\n(ppcre:scan '(:sequence #\\c :end-anchor) \"aaa\")\n;=> NIL\n\n;; 0文字以上の数字にマッチする\n(ppcre:scan \"\\\\d*\" \"01234\")\n(ppcre:scan '(:greedy-repetition 0 nil :digit-class) \"01234\")\n;=> 0\n;   5\n;   #()\n;   #()\n\n;; 1文字以上の数字にマッチする\n(ppcre:scan \"\\\\d+\" \"01234\")\n(ppcre:scan '(:greedy-repetition 1 nil :digit-class) \"01234\")\n;=> 0\n;   5\n;   #()\n;   #()\n(ppcre:scan \"\\\\d+\" \"abc012\")\n(ppcre:scan '(:greedy-repetition 1 nil :digit-class) \"abc012\")\n;=> 3\n;   6\n;   #()\n;   #()\n}}}\n\n* メタ文字自体へのマッチ\n\n文字列で表した正規表現でメタ文字自体へマッチさせたい場合、メタ文字をエスケープしてパターンに指定しなければなりません。\n\n{{{\n;; 「^」にマッチする\n(ppcre:scan \"\\\\^\" \"^\")\n(ppcre:scan #\\^ \"^\")\n;=> 0\n;   1\n;   #()\n;   #()\n\n;; 「^」でありがちなミス（行の先頭にマッチ）\n(ppcre:scan \"^\" \"^\")\n;=> 0\n;   0\n;   #()\n;   #()\n\n;; 応用例：指数を取り出す\n(ppcre:register-groups-bind (e)\n    (\"\\\\^([0-9]+)=\" \"2^10=1024\")\n  e)\n(ppcre:register-groups-bind (e)\n    ('(:sequence\n       #\\^\n       (:register (:greedy-repetition 1 nil (:char-class (:range #\\0 #\\9))))\n       #\\=)\n      \"2^10=1024\")\n  e)\n;=> \"10\"\n\n;; 「(」や「)」にマッチする\n(ppcre:scan \"\\\\(\" \"(\")\n(ppcre:scan #\\( \"(\")\n(ppcre:scan \"\\\\)\" \")\")\n(ppcre:scan #\\) \")\")\n;=> 0\n;   1\n;   #()\n;   #()\n\n;; 「(」や「)」でありがちなミス（正規表現の構文エラー）\n(ppcre:scan \"(\" \"(\")\n(ppcre:scan \")\" \")\")\n;>> Error: Expected end of string.\n\n;; 応用例：括弧内の文字を取り出す\n(ppcre:register-groups-bind (n)\n    (\"\\\\(([0-9]+)\\\\)$\" \"math(85)\")\n  n)\n(ppcre:register-groups-bind (n)\n    ('(:sequence\n       #\\(\n       (:register (:greedy-repetition 1 nil (:char-class (:range #\\0 #\\9))))\n       #\\)\n       :end-anchor)\n      \"math(85)\")\n  n)\n;=> \"85\"\n}}}\n\n* パターンマッチ\n\n{{{\n;; マッチした位置を返す\n(ppcre:scan \"[c-e]+\" \"abcdefg\")\n;=> 2\n;   5\n;   #()\n;   #()\n\n;; 三番目と四番目の戻り値はグループ化されたパターンがマッチした位置\n(ppcre:scan \"((a)(b)(c))\" \"abc\")\n;=> 0\n;   3\n;   #(0 0 1 2)\n;   #(3 1 2 3)\n\n;; マッチする部分がないときはNILが返る\n(ppcre:scan \"a\" \"b\")\n;=> NIL\n\n;; マッチした部分文字列を返す\n(ppcre:scan-to-strings \"\\\\d+\" \"Originally specified in 1958, Lisp is\")\n;=> \"1958\"\n;   #()\n\n;; パターンにマッチする全ての部分文字列をリストで返す\n(ppcre:all-matches-as-strings \"\\\\w+\" \"foo bar baz\")\n;=> (\"foo\" \"bar\" \"baz\")\n}}}\n\n* 変数への束縛\n\nパターンにマッチした文字列を変数に束縛します。\n\n{{{\n;; グループ化されたパターンがマッチした部分の文字列を順番に束縛する\n(ppcre:register-groups-bind (base _ exp)\n    (\"(\\\\d+)(\\\\^(\\\\d+))?\" \"10^1000\")\n  (declare (ignore _))\n  (values (read-from-string base)\n          (read-from-string exp)))\n;=> 10\n;   1000\n\n;; グループ化されたパターンがないとエラー\n(ppcre:register-groups-bind (match)\n    (\"a\" \"abc\")\n  match)\n;>> Error: Array index 0 out of bounds for #() .\n}}}\n\n* 繰り返し\n\nパターンにマッチする部分が見付かるごとに処理を繰り返します。\n\n{{{\n;; マッチした部分の位置が渡される\n(let ((target \"1 20 300 4000 50000\"))\n  (ppcre:do-matches (start end \"\\\\d+\" target)\n    (format t \"~A~%\" (subseq target start end))))\n;-> 1\n;   20\n;   300\n;   4000\n;   50000\n;=> NIL\n\n;; マッチした部分の文字列が渡される\n(ppcre:do-matches-as-strings (match \"\\\\d+\" \"1 20 300 4000 50000\")\n  (format t \"~A~%\" match))\n;-> 1\n;   20\n;   300\n;   4000\n;   50000\n;=> NIL\n}}}\n\n* パターンの置換\n\n{{{\n;; 置換後の文字列とマッチしたかどうかを返す\n(ppcre:regex-replace \"<\" \"<<<\" \"&lt;\")\n;=> \"&lt;<<\"\n;   T\n\n;; マッチしなければ二番目の戻り値はNIL\n(ppcre:regex-replace \">\" \"<<<\" \"&lt;\")\n;=> \"<<<\"\n;   NIL\n\n;; マッチするパターンすべてを置き換える\n(ppcre:regex-replace-all \"<\" \"<<<\" \"&lt;\")\n;=> \"&lt;&lt;&lt;\"\n;   T\n\n;; 応用例：改行を空白に置換する\n(ppcre:regex-replace-all \"\\\\n\" \"a\nb\nc\" \" \")\n(ppcre:regex-replace-all #\\newline \"a\nb\nc\" \" \")\n;=> \"a b c\"\n;   T\n}}}\n\n* パターンによる分割\n\n{{{\n;; 分割してリストで返す\n(ppcre:split \",\" \"a,b,c\")\n;=> (\"a\" \"b\" \"c\")\n\n;; マッチしたパターンが文字列の最後にあるときは無視される\n(ppcre:split \",\" \"a,b,c,\")\n;=> (\"a\" \"b\" \"c\")\n\n;; マッチしないときはそのままの文字列をリストにして返す\n(ppcre:split \",\" \"abc\")\n;=> (\"abc\")\n}}}\n\n* 参考文献\n\n- [http://weitz.de/cl-ppcre/ CL-PPCRE - Portable Perl-compatible regular expressions for Common Lisp]\n- [http://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE 正規表現 - Wikipedia]\n")
("数値に応じて複数形と単数形を切り換える" . "(:ctime 1232048921 :cuser #f :mtime 1232048967 :muser #f)[[$$tag 数値]]\n\n* 数値に応じて複数形と単数形を切り換える\n\n多機能な[[$$hs format]]の機能の一つとして数値に応じて複数形と単数形を切り換える機能がありますので、これが利用できるでしょう。\n\n-[http://www.lispworks.com/documentation/HyperSpec/Body/22_chc.htm Tilde P: Plural]\n{{{\n(dotimes (i 5)\n  (format t \"~D: tom~P and jerr~@P~%\" i i i))\n;-> 0: toms and jerries\n;   1: tom and jerry\n;   2: toms and jerries\n;   3: toms and jerries\n;   4: toms and jerries\n;=> NIL\n}}}\n")
("GUI" . "(:ctime 1291356725 :cuser #f :mtime 1620086563 :muser #f)- [[McCLIM]]\n- [[Ltk]]\n- [[CAPI]] / LispWorks\n")
(" %Tag:CL-TEST-MORE" . "(1668296784 (\"CL-TEST-MORE\" :ctime 1294028420 :cuser #f :mtime 1460644076 :muser #f))")
("コンパイル時に非推奨関数の利用について警告を出す" . "(:ctime 1538552591 :cuser #f :mtime 1538552673 :muser #f)公開したAPIが後に変更になり、古いAPIの利用を非推奨としたい場合があります。~%\nそのような場合、関数やマクロについては、コンパイラマクロがコンパイル時に作用することを利用して警告を出すことが可能です。~%\nコンパイラマクロの定義には、[[$$hs define-compiler-macro]]を使用します。\n\n* 旧API\n\n{{{\n(defun foo (x y)\n  (+ x y))\n\n(defmacro defbaz (x y)\n  `(devfar ,x ,y))\n}}}\n\n* 現行API\n\n{{{\n(defun new-foo (x y)\n  (+ x y))\n\n(defmacro new-defbaz (x y)\n  `(devfar ,x ,y))\n}}}\n\n* 旧APIに非推奨警告を定義\n\n{{{\n(define-compiler-macro foo (x y)\n  (declare (ignore x y))\n  (warn \"~S is obsoleted. Please use ~S instead.\" \n        'foo\n        'new-foo))\n\n(define-compiler-macro defbaz (x y)\n  (declare (ignore x y))\n  (warn \"~S is obsoleted. Please use ~S instead.\" \n        'defbaz\n        'new-defbaz))\n}}}\n\n* 非推奨関数 foo をコンパイルした場合\n\n{{{\n(defun bar ()\n  (foo 1 2))\n;;;*** Warning in bar: foo is obsoleted. Please use new-foo instead.\n}}}\n\n* 非推奨マクロ baz-zot をコンパイルした場合\n\n{{{\n(defbaz baz-zot 42)\n;;;*** Warning between functions:   defbaz is obsoleted. Please use new-defbaz instead.\n}}}\n")
(" %Tag:mudballsを使う【募集中】" . "(1242182325)")
("繰り返しの前処理・後処理" . "(:ctime 1229528833 :cuser #f :mtime 1229528833 :muser #f)[[$$tag 制御構造]]\n* 繰り返しの前処理・後処理 (loop)\n\nloopの開始処理・終了処理を initially finally キーワードを使って書けます。\n{{{\n(loop for i in '(1 2 3)\n      do (print i)\n      initially (print \"begin\")\n      finally (print \"end\"))\n;-> \"begin\"\n    1\n    2\n    3\n    \"end\"\n;=> NIL\n}}}\n\ninitially で指定されたフォームは繰り返しが一度もなくても必ず評価されます。\n\nfinally で指定されたフォームは return キーワードで中断された場合など必ずしも評価されません。=> [[確実に後処理を行なう]]\n")
("落とし穴" . "(:ctime 1548434646 :cuser #f :mtime 1630548541 :muser #f)Common Lispでありがちなミス、はまりどころについてです。\n\n----\n\n[[$$toc]]\n\n----\n操作篇\n\n* 巨大なリスト/配列をプリントして大変なことになる\n\n:例:\nREPLで\n{{{\n(make-array (* 1024 1024 16) :element-type '(unsigned-byte 8))\n}}}\nしたら処理系が落ちた…\n\n:原因:\n例の場合、16777216個の0を表示することになり、表示が大変なことになるのが理由です。\n{{{\n(progn\n  (setq foo (make-array (* 1024 1024 16) :element-type '(unsigned-byte 8)))\n  nil)\n}}}\nなどとすれば良いでしょう。~%\nどうしても表示させたい場合は、\n{{{\n(setq *print-length* 100)\n}}}\n等、表示に制限を付ければ大抵大丈夫です。\n----\n\n* 対話的に変更した部分をコードとして保存し忘れる\n\nREPLを使っているときによくあるパターンです。\n\n関数や変数などの定義を追加したり変更したのに、ソースコードへ保存するのを忘れてしまうと「アプリケーションを再起動したら正しく動作しなくなった」「実際の動作とコードの内容がどうも一致しない」なんてことになります。\n\nそれほど深刻ではない例を紹介します。ライブラリを作ったときに、シンボルを[[$$hs g:export エクスポート]]し忘れた場合を考えましょう。次のコードではapplicationパッケージでのyの呼び出しはエラーになります。\n\n{{{\n(defpackage :library\n  (:use :cl)\n  (:export :x))  ; yをエクスポートし忘れている\n(in-package :library)\n\n(defun x () (print \"x\"))\n(defun y () (print \"y\"))\n\n(defpackage :application (:use :cl :library))\n(in-package :application)\n\n(y)\n;>> Error: Undefined function Y called with arguments () .\n}}}\n\nこれを修正するためにREPLからapplication::yを[[$$hs g:unintern アンインターン]]して、library::yを[[$$hs g:import インポート]]します。\n\n{{{\nAPPLICATION> (unintern 'y)\nT\nAPPLICATION> (import 'library::y)\nT\nAPPLICATION> (y)\n\n\"y\" \n\"y\"\n}}}\n\n正しく動作するようになりました。が、ここでlibraryパッケージの定義を修正するのを忘れたままにしてしまうと、次回同じコードをロードしたとき、また同じエラーが発生します。この例では原因の発見は簡単ですが、シンボルの[[$$hs g:shadow シャドウイング]]などが絡んだりすると、予想外に面倒なバグになりかねません。\n\n----\n\n* マクロやインライン関数を変更したときに再コンパイルを忘れる\n\n変更したコードを部分的に評価しながら開発していると引っかかることがあります。\n\nマクロやインライン関数の定義は評価しても、それを使っている側の関数をコンパイルし直さないと、以前の定義のままで動作し続けてしまいます。用途を考えれば当然なのですが、マクロやインライン関数がコンパイル時に展開されるのが原因です。コード全体をコンパイルしてから実行するタイプの開発では問題になりにくい部分でもあります。\n\n例えば、平面上の座標を[[$$hs g:cons コンス]]で表現してみましょう。make-pointで座標を表現するオブジェクトを作り、point-xとpoint-yでオブジェクトのx座標とy座標にアクセスすることにします。point-xとpoint-yは計算の過程で何度も呼ばれることが予想されること、[[$$hs car]]と[[$$hs cdr]]を呼んでいるだけなことから、インライン化した方が良いでしょう。print-pointはpoint-xとpoint-yを利用して座標を表示する関数です。\n\n{{{\n> (defun make-point (x y) (cons x y))\nMAKE-POINT\n> (declaim (inline point-x point-y))\nNIL\n> (defun point-x (p) (car p))\nPOINT-X\n> (defun point-y (p) (cdr p))\nPOINT-Y\n> (defun print-point (p)\n    (format t \"~&(~a, ~a)~%\" (point-x p) (point-y p)))\nPRINT-POINT\n> (print-point (make-point 0 1))\n(0, 1)\nNIL\n}}}\n\nここで、内部で使っているデータ構造を[[$$hs g:vector ベクタ]]に変更します。この例では変更にあまり意味はありませんが、実際にプログラムを書くときは、性能を改善したりするために後から内部構造を変更する機会もあるでしょう。point-xとpoint-yはcarとcdrの代わりに[[$$hs elt]]を使うことにします。\n\n{{{\n> (defun make-point (x y) (vector x y)) ; 内部構造をベクタに変更\nMAKE-POINT\n> (defun point-x (p) (elt p 0))\nPOINT-X\n> (defun point-y (p) (elt p 1))\nPOINT-Y\n> (print-point (make-point 0 1))        ; carとcdrが呼ばれてエラーに\nERROR: value #(0 1) is not of the expected type LIST.\n}}}\n\nprint-pointはpoint-xとpoint-yを利用して座標を表示しますが、以前のcarとcdrを使った定義がインライン展開されているため、point-xとpoint-yの定義を変更しただけでは正しく動作しません。\n\n{{{\n> (defun print-point (p)\n    (format t \"~&(~a, ~a)~%\" (point-x p) (point-y p)))\nPRINT-POINT\n> (print-point (make-point 0 1))\n(0, 1)\nNIL\n}}}\n\nもう一度print-pointを定義し直すと正しく動作するようになります。\n\n----\n\n* ローカルな関数を定義しようとしてdefun内でdefunを使う\n\n[http://ja.wikipedia.org/wiki/Scheme Scheme]の流儀に慣れている人はやってしまいがちです。[[$$hs defun]]の中でもdefunを使うことはできますが、ローカルな関数にはなりません。\n\n関数aの中でだけ使う関数bを定義したいとします。\n\n{{{\n(defun a ()\n  (defun b () (print \"b\"))\n  (b))\n;=> A\n\n;; 一見期待通りに動いているように見えるが\n(a)\n;=> \"b\"\n;-> \"b\"\n\n;; bはaの外からも呼べてしまう\n(b)\n;=> \"b\"\n;-> \"b\"\n}}}\n\nローカルな関数を定義するときは[[$$hs flet]]か[[$$hs labels]]を使います。\n\n{{{\n;; ローカルな関数fはfletの中でだけ有効\n(flet ((f ()\n         (print \"local\")))\n  (f))\n;=> \"local\"\n;-> \"local\"\n\n;; 外からは見えない\n(f)\n;>> Undefined function F called with arguments () .\n}}}\n\n----\n\n* applyで関数を呼ぶときに引数として大きなリストを渡す\n\nリストの各要素を引数として関数に渡すときに[[$$hs apply]]は便利ですが、一定以上大きなリストを渡すと問題になります。\n\n{{{\n(apply #'append (make-list 5 :initial-element '(t)))\n;=> (T T T T T)\n\n(apply #'append (make-list (1+ call-arguments-limit) :initial-element '(t)))\n;>> Error: Too many arguments.\n}}}\n\n関数に渡すことのできる引数の数は[[$$hs call-arguments-limit]]までなので、それ以上の大きさのリストをapplyの最後の引数として渡すことはできません。\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/v_call_a.htm CLHS: Constant Variable CALL-ARGUMENTS-LIMIT]に\n\n<<<\nAn integer not smaller than 50 and at least as great as the ''[[$$hs g:value]]'' of '''[[$$hs lambda-parameters-limit]]''', the exact magnitude of which is ''[[$$hs g:implementation-dependent]]''.\n>>>\n\nと書かれているように、call-arguments-limitの値は処理系によって変わります。例えば、32ビットの[[Clozure CL]] 1.8では65536です。これが大きいかどうかは個人の感覚によって変わってくるでしょうが、移植性を考える場合、''規格では50より大きい値は保証されていない''ことに気をつけてください。\n\nなお、先ほどの例でcall-arguments-limitを超える大きさのリストを扱う場合は、\n\n{{{\n(reduce #'append list-of-lists :from-end t)\n(mapcan #'copy-list list-of-lists :initial-element '(t)))\n}}}\n\nといった書き方をすることで問題を回避できます。\n\n----\n\n* fixnum同士の計算結果をfixnumと仮定する\n\n[[$$hs fixnum]]同士の計算でもfixnumになるとは限りません。\n\n{{{\n(typep (+ most-positive-fixnum 1) 'fixnum)\n;=> NIL\n}}}\n\nを考えると分かりやすいのではないでしょうか。1は当然fixnumですが、most-positive-fixnumはfixnumが取り得る最大の値ですから、1を足してもfixnumの範囲を超えてしまいます。\n\n従って、\n\n{{{\n(+ (the fixnum x) (the fixnum y))\n}}}\n\nというコードも通常はfixnumを返すものとしてコンパイルされません。fixnumを返すことを保証してコンパイラに最適化を促す場合、\n\n{{{\n(the fixnum (+ (the fixnum x) (the fixnum y)))\n}}}\n\nとする必要があります。\n\n----\n\n* 大きなファイルを読み込むときに同じ大きさの配列や文字列を作る\n\nファイルを読み込むとき、([[$$hs unsigned-byte]] 8)の配列や文字列をバッファとしてデータを読み込むことは良くありますが、ファイルの大きさと同じ配列や文字列を作って一気にデータを読み込もうとした場合、大きさが[[$$hs array-total-size-limit]]以上になってしまい、配列や文字列を作ることができないことがあります。\n\nこれは32ビットの環境で主に問題になります。[http://www.lispworks.com/documentation/HyperSpec/Body/v_ar_tot.htm CLHS: Constant Variable ARRAY-TOTAL-SIZE-LIMIT]から引用しますが、array-total-size-limitは\n\n<<<\nA positive ''[[$$hs fixnum]]'', the exact magnitude of which is ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_i.htm#implementation-dependent implementation-dependent]'', but which is not less than 1024.\n>>>\n\nと決められているので、文字列を含むすべての配列はfixnum以上の大きさにはできません。\n\n32ビットの環境でのfixnumの上限は2^29 - 1のことが多いので、(unsigned-byte 8)の配列や文字列に単純にデータを読み込む場合、''多くの処理系では512MB以上の大きさのファイルは扱えません''。\n\nまた、array-total-size-limitは1024以上の正のfixnumであれば良く、fixnumの上限でなければいけないとは決められていないので、もっと小さいサイズの配列しか扱えない場合もあります。実際、32ビット環境の[[Clozure CL]]でのarray-total-size-limitは'''2^24'''で、'''工夫をしないと16MB以上の大きさのファイルを読み込めません'''。（制限を回避する方法はいくつかありますが、どれもデータの操作が難しくなります）\n\n----\n\n* 不要なオブジェクトのコピーをする\n\n例えば、[[$$hs subseq]]で部分文字列を取り出すとします。\n\n{{{\n(subseq \"abcdef\" 2 4)   ;=> \"cd\"\n}}}\n\nここで、返される文字列に破壊的な変更をしたくなったとき、元の文字列に影響することを恐れて、文字列を[[$$hs copy-seq]]でコピーしたくなるかもしれません。\n\nですが、それは不要な作業です。\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/f_subseq.htm CLHS: Accessor SUBSEQ]に書かれている通り、\n\n<<<\n'''[http://www.lispworks.com/documentation/HyperSpec/Body/f_subseq.htm#subseq subseq]''' always allocates a new ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#sequence sequence]'' for a result; it never shares storage with an old ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#sequence sequence]''. The result subsequence is always of the same ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_t.htm#type type]'' as ''sequence''.\n>>>\n\nsubseqから返される文字列は元の部分文字列のコピーだと決められていています。そのため、破壊的な変更をする場合でもコピーの必要はありません。\n\n{{{\n;; 二重にコピーすることになって効率的ではない\n(let* ((sub (copy-seq (subseq \"abcdef\" 2 4))))\n  (nstring-upcase sub))\n}}}\n\nCommon Lispの関数では、こういった、明確にコピーを返すように動作が決められていることがありますので、効率の良いプログラムを書くために知っておくと良いでしょう。\n\n----\n\n* maphashで戻り値を期待する\n\n'''[[$$hs maphash]]は常にnilを返します。'''map系の関数はどれも意味のある値を返すため、それを期待してはまる人が多いようです。\n\n{{{\n;; ((:X . 0) (:Y . 1) (:Z . 2))が返ってきたりはしない\n(let ((h (make-hash-table)))\n  (setf (gethash :x h) 0)\n  (setf (gethash :y h) 1)\n  (setf (gethash :z h) 2)\n  (maphash (lambda (k v)\n             (format t \"~a: ~a~%\" k v)\n             (cons k v))\n           h))\n;=> NIL\n;-> Z: 2\n;   Y: 1\n;   X: 0\n}}}\n\nハッシュテーブルの値を加工して返したい場合は、変数を介してmaphashの外に値を持ち出すか、[[$$hs loop]]を利用するのが定番です。\n\n{{{\n(let (r (h (make-hash-table)))\n  (setf (gethash :x h) 0)\n  (setf (gethash :y h) 1)\n  (setf (gethash :z h) 2)\n  (maphash (lambda (k v) (push (cons k v) r)) h)\n  r)\n;=> ((:X . 0) (:Y . 1) (:Z . 2))\n\n(let ((h (make-hash-table)))\n  (setf (gethash :x h) 0)\n  (setf (gethash :y h) 1)\n  (setf (gethash :z h) 2)\n  (loop for k being each hash-keys of h using (hash-value v) collect (cons k v)))\n;=> ((:Z . 2) (:Y . 1) (:X . 0))\n}}}\n\n----\n\n* inline宣言の位置\n\nグローバルな関数をインライン展開させたい場合、'''関数定義より前'''に[[$$hs inline]]宣言をしておかなければなりません。[http://www.lispworks.com/documentation/HyperSpec/Body/d_inline.htm#inline CLHS: Declaration INLINE, NOTINLINE]では\n\n<<<\nThe '''[[$$hs inline]]''' proclamation preceding the '''[[$$hs defun]]''' ''[[$$hs g:form]]'' ensures that the ''[[$$hs g:compiler]]'' has the opportunity save the information necessary for inline expansion, and the '''[[$$hs notinline]]''' proclamation following the '''[[$$hs defun]]''' ''[[$$hs g:form]]'' prevents f from being expanded inline everywhere.\n>>>\n\nと書かれていて、inline宣言が関数定義より前にある場合しかインライン展開を保証していません。[http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/clm.html Common Lisp the Language, 2nd Edition]の[http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node105.html 9.2. Declaration Specifiers]にも、\n\n<<<\nLooking at it the other way, the compiler is not required to save function definitions against the possibility of future expansions unless the functions have already been proclaimed to be inline.\n>>>\n\nと書かれています。同節に例があるので引用します。\n\n{{{\n(defun huey (x) (+ x 100))         ; コンパイラはこれを覚えておく必要はない\n(declaim (inline huey dewey))\n(defun dewey (y) (huey (sqrt y)))  ; おそらくhueyの呼び出しは展開されない\n(defun louie (z) (dewey (/ z)))    ; おそらくdeweyの呼び出しは展開される\n}}}\n\nローカルな関数をインライン展開させたい場合、'''[[$$hs flet]]や[[$$hs labels]]の本体部分の前'''でinline宣言をします。\n\n{{{\n(flet ((f (x y) (+ x y)))\n  (declare (inline f))\n  (f 1 2))\n}}}\n\nこの場合、他のグローバルな関数に影響を与えてしまうので、トップレベルでinline宣言をしてはいけません。\n\n----\n\n* ライブラリのトップレベルでの最適化宣言\n\nトップレベルに[[$$hs declaim]]や[[$$hs proclaim]]による最適化宣言があるファイルをロードすると、処理系の最適化フラグが変更されます。特定のファイルに対して最適化をかけようとして、そのファイルのトップレベルで最適化宣言をしてしまうと、利用者が知らないうちにシステム全体に対する最適化の設定が変わり、混乱させてしまうかもしれません。\n\n特定の関数だけ最適化フラグを変更したい場合には[[$$hs declare]]や[[$$hs locally]]を使います。\n\n単に関数ごとにdeclareを使って最適化フラグを設定すると、デバッグやテストのときに設定を変更する手間がかかります。そこで、あらかじめ最適化フラグをdefvarなどで定義しておき、それぞれの関数のdeclareではそれを使うようにすると便利です。\n\n{{{\n;; 最適化フラグを決めておき\n(defvar *optimize-flags* '(optimize speed (debug 0) (safety 0)))\n\n;; リードするときに置き換える\n(defun f ()\n  (declare #.*optimize-flags*)\n  ...)\n}}}\n\nこれは[[CL-PPCRE]]などで使われている手法です。実際に使われている様子を見たい場合は[https://github.com/edicl/cl-ppcre CL-PPCREのコード]を読んでみると良いでしょう。\n\nlocallyを使う場合はより単純です。locallyの内部のコードは指定した最適化フラグを使ってコンパイルされるようになります。\n\n{{{\n(locally (declare (optimize speed (debug 0) (safety 0)))\n  ...)\n}}}\n\n----\n\n* 参考資料\n\n- [http://www.aiai.ed.ac.uk/~jeff/lisp/cl-pitfalls Common Lisp Pitfalls]\n- [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm Common Lisp HyperSpec]\n- [http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/clm.html Common Lisp the Language, 2nd Edition]\n")
(" %Tag:net-telent-date'" . "(1638981582)")
("Ltk" . "(:ctime 1293001158 :cuser #f :mtime 1619742314 :muser #f)LtkはPeter Herth氏が作成したTkグラフィックツールキットのCommon Lispバインディングスです。tkが動くところならばほぼどこでも動作します。「Ltkを利用するのにtkの知識は不要である」というのが売り文句のようです。\n\n* 環境構築\n- [[ltkの環境構築]]\n\n* 「入門 Tcl/Tk」\n- [[Ltk:新規にウィンドウを表示する]]\n- [[Ltk:ボタンを表示する]]\n- [[Ltk:電卓アプリ(ボタン応用)]]\n- [[Ltk:チェックボタンを表示する]]\n- [[Ltk:ラジオボタンを表示する]]\n- [[Ltk:スケールを表示する]]\n- [[Ltk:pack後のオブジェクトのパラメータ設定をする]]\n- [[Ltk:ラベルを設定する]]\n- [[Ltk:複数行テキストを表示する]]\n- [[Ltk:メニューを表示する]]\n- [[Ltk:テキスト入力欄を表示する]]\n- [[Ltk:キーバインドを設定する]]\n- [[Ltk:メニューから他ウィンドウを表示する]]\n- [[Ltk:ウィジェットスタイルを変更する]]\n\n* 参考リンク\n- [http://www.peter-herth.de/ltk/ LTK - The Lisp Toolkit]\n- [http://lagendra.s.kanazawa-u.ac.jp/ogurisu/manuals/commonlisp/ltk/HTML/index.html LTkのサンプル集]\n- [https://en.wikibooks.org/wiki/Common_Lisp/External_libraries/Ltk Common Lisp/External libraries/Ltk(Wikibooks)]\n\n- [http://homepage3.nifty.com/kaku-chan/tcl_tk/ Tcl/TkでWindowsプログラミング](日本語、Tcl/Tkの解説、どのように動くかのイメージをつかみやすい)\n\n;; [http://phaendal.hatenablog.com/entry/2015/03/21/204723 SBCL / Linux Mint でGUI (Ltk, cells-gtk)]\n;; [http://d.hatena.ne.jp/masatoi/20110818/1313737503 LtkでGUIの練習―オセロ盤]\n")
(" %Tag:pXl[" . "(1342010430)")
(" %Tag:split-sequence'A=0" . "(1569931371)")
("Limp" . "(:ctime 1329736638 :cuser #f :mtime 1329736638 :muser #f)[[$$tag 【募集中】]]\n")
("日付と時刻" . "(:ctime 1227154105 :cuser #f :mtime 1336359656 :muser #f)- [[Universal Time]]\n- [[現在の時刻(Universal Time)を取得する]]\n- [[時刻の表現からUniversal Timeを作成する]]\n- [[Universal Timeを文字列に変換する]]\n- [[時刻に任意の時間を加減する]]\n- [[2つの時刻の差を求める]]\n- [[時刻中の曜日を日本語に変換する]]\n- [[現在の日付を求める]]\n- [[指定の日付が存在するかどうか調べる]]\n- [[何日後、何日前/何ヶ月後、何ヶ月前の日付を求める]]\n- [[うるう年かどうか判定する]]\n- [[文字列の日付をUniversal Timeに変換する]]\n- [[月の最後の日を調べる]]\n- [[日付が何曜日、何日、年初から何日め、年初から何週めになるかを求める]]\n- [[次の月を求める]]\n")
(" %Tag:portable-threads" . "(1668304199 (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f) (\"操作をタイムアウトにする\" :ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f) (\"スレッドに引数を渡す\" :ctime 1229082548 :cuser #f :mtime 1229092264 :muser #f))")
("Ltk:メニューから他ウィンドウを表示する" . "(:ctime 1619742343 :cuser #f :mtime 1619744908 :muser #f)* メニューからほかウィンドウの表示\n\n以下、３本のコードをファイル化し、REPLでkpr-main.lispをloadしてください。\n{{{\n> (load \"kpr-main.lisp\")\n}}}\n\n** kpr-main.lisp\n{{{\n;;; LTKのメニューから別のウィンドウを起動する\n\n(ql:quickload :ltk)\n\n;; 他画面ロード\n(load \"calc.lisp\")\n(load \"rgb.lisp\")\n\n;; パッケージの作成\n(defpackage :kpr-main\n  (:use :common-lisp\n        :ltk\n        :kpr-calc\n        :kpr-rgb)\n  (:export :main))\n\n(in-package :kpr-main)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"メニュー\")\n    (minsize *tk* 200 100)\n\n    (let* (\n           ;; メニューバー作成\n           (mb (make-menubar))\n           \n           ;;メニュー\"種類\"\n           (mshurui (make-menu mb \"アプリ\" ))\n\n           (mf-command (make-menubutton mshurui \"電卓\"\n                                        (lambda () ;(error \"asdf\")\n                                          (format t \"電卓メニュー pressed~&\")\n                                          (calc-main)                         ; 電卓アプリを開く\n                                          (finish-output))\n                                        :underline 1))\n\n           (sep2 (add-separator mshurui))\n\n           (mf-export (make-menu mshurui \"選択メニュー\"))\n\n           (mfe-jpg (make-menubutton mf-export \"電卓\" (lambda ()\n                                                              (format t \"電卓 pressed~&\")\n                                                              (calc-main)                         ; 電卓アプリを開く\n                                                              (finish-output))))\n           (mfe-gif (make-menubutton mf-export \"RGBテスト\" (lambda ()\n                                                              (format t \"RGBテスト pressed~&\")\n                                                              (rgb-main)                         ; RGBテストアプリを開く\n                                                              (finish-output))))\n\n           (sep3 (add-separator mshurui))\n\n\n           (mf-close (make-menubutton mshurui \"終了\"\n                                        (lambda () ;(error \"asdf\")\n                                          (format t \"終了 pressed~&\")\n                                          (setf *exit-mainloop* t)\n                                          (finish-output))\n                                        :underline 1))\n\n           (msg (make-instance 'message\n                               :text \"メニューから別画面を開くアプリです。\"\n                 :width 1000\n                 :background \"#FFFFFF\"))\n\n           (b1 (make-instance\n                'button\n                :text \"Close\"\n                :command (lambda ()\n                           (format t \"終了\")\n                           (setf *exit-mainloop* t)))))\n\n      (pack msg\n            :side :top\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n      (pack b1\n            :side :bottom\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n\n      ;; (configure msg\n      ;;            :anchor :w\n      ;;            )\n\n      )))\n\n(main)\n}}}\n\n** calc.lisp\n{{{\n;;; LTKでボタンを表示する\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :kpr-calc\n  (:use :common-lisp\n        :ltk)\n  (:export :calc-main))\n\n(in-package :kpr-calc)\n\n(defun calc-main ()\n  (with-ltk ()\n    (wm-title *tk* \"電卓アプリ\")\n    (let* (\n           ;; ベース用フレーム１(演算用ボタン配置用　√、÷、×、−)\n           (f-base1 (make-instance\n                     'frame))\n\n           ;; ベース用フレーム２(数字ボタン用配置用　０〜９、ドット、プラスマイナス、＋、＝)\n           (f-base2 (make-instance\n                     'frame))\n\n           ;; 電卓数字部用フレーム\n           (f-first1 (make-instance\n                      'frame\n                      :master f-base2))\n\n           ;; 電卓＋ボタンと＝ボタン用フレーム\n           (f-first2 (make-instance\n                      'frame\n                      :master f-base2))\n\n\n           ;; 電卓「０」「．」「±」用フレーム\n           (f-second1 (make-instance\n                      'frame\n                      :master f-first1))\n\n           ;; 電卓「１」「２」「３」用フレーム\n           (f-second2 (make-instance\n                      'frame\n                      :master f-first1))\n\n           ;; 電卓「４」「５」「６」用フレーム\n           (f-second3 (make-instance\n                      'frame\n                      :master f-first1))\n\n           ;; 電卓「７」「８」「９」用フレーム\n           (f-second4 (make-instance\n                      'frame\n                      :master f-first1))\n\n           \n           (b51 (make-instance\n                'button\n                :master f-base1\n                :text \"√\"\n                :command (lambda ()\n                           (format t \"ボタン√を押しました~%\"))))\n\n           (b52 (make-instance\n                'button\n                :master f-base1\n                :text \"÷\"\n                :command (lambda ()\n                           (format t \"ボタン÷を押しました~%\"))))\n\n           (b53 (make-instance\n                'button\n                :master f-base1\n                :text \"×\"\n                :command (lambda ()\n                           (format t \"ボタン×を押しました~%\"))))\n\n           (b54 (make-instance\n                'button\n                :master f-base1\n                :text \"ー\"\n                :command (lambda ()\n                           (format t \"ボタンーを押しました~%\"))))\n           \n           (b11 (make-instance\n                'button\n                :master f-second1\n                :text \"0\"\n                :command (lambda ()\n                           (format t \"ボタン0を押しました~%\"))))\n\n           (b12 (make-instance\n                'button\n                :master f-second1\n                :text \".\"\n                :command (lambda ()\n                           (format t \"ボタン.を押しました~%\"))))\n\n           (b13 (make-instance\n                'button\n                :master f-second1\n                :text \"+/-\"\n                :command (lambda ()\n                           (format t \"ボタン+/-を押しました~%\"))))\n\n           (b21 (make-instance\n                'button\n                :master f-second2\n                :text \"1\"\n                :command (lambda ()\n                           (format t \"ボタン1を押しました~%\"))))\n\n           (b22 (make-instance\n                'button\n                :master f-second2\n                :text \"2\"\n                :command (lambda ()\n                           (format t \"ボタン2を押しました~%\"))))\n\n           (b23 (make-instance\n                'button\n                :master f-second2\n                :text \"3\"\n                :command (lambda ()\n                           (format t \"ボタン3を押しました~%\"))))\n\n           (b31 (make-instance\n                'button\n                :master f-second3\n                :text \"4\"\n                :command (lambda ()\n                           (format t \"ボタン4を押しました~%\"))))\n\n           (b32 (make-instance\n                'button\n                :master f-second3\n                :text \"5\"\n                :command (lambda ()\n                           (format t \"ボタン5を押しました~%\"))))\n\n           (b33 (make-instance\n                'button\n                :master f-second3\n                :text \"6\"\n                :command (lambda ()\n                           (format t \"ボタン6を押しました~%\"))))\n\n\n           (b41 (make-instance\n                'button\n                :master f-second4\n                :text \"7\"\n                :command (lambda ()\n                           (format t \"ボタン7を押しました~%\"))))\n\n           (b42 (make-instance\n                'button\n                :master f-second4\n                :text \"8\"\n                :command (lambda ()\n                           (format t \"ボタン8を押しました~%\"))))\n\n           (b43 (make-instance\n                'button\n                :master f-second4\n                :text \"9\"\n                :command (lambda ()\n                           (format t \"ボタン9を押しました~%\"))))\n\n           (b44 (make-instance\n                'button\n                :master f-first2\n                :text \"+\"\n                :command (lambda ()\n                           (format t \"ボタン+を押しました~%\"))))\n\n           (b24 (make-instance\n                'button\n                :master f-first2\n                :text \"=\"\n                :command (lambda ()\n                           (format t \"ボタン=を押しました~%\"))))\n\n\n           (b3 (make-instance\n                'button\n                :text \"終了\"\n                :command (lambda ()\n                           (format t \"終了\")\n                           (setf *exit-mainloop* t))))\n           )\n\n      ;(pack (list b1 b2 b3) :side :top)         ; 通常の並び、順番に並ぶ。これがデフォルト\n      ;(pack (list b1 b2 b3) :side :left)        ; 指定されたオブジェクトを左から順番に並べる\n      ;(pack (list b1 b2 b3) :side :right)       ; 指定されたオブジェクトを右から順番に並べる\n      ;(pack (list b1 b2 b3) :side :bottom)      ; 指定されたオブジェクトを下から順番に並べる\n      ;(pack (list b1 b2 b3) :side :top :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n      \n      ;; フレームの配置\n      (pack (list f-base1 f-base2) :side :top :fill :both :expand :yes)\n      (pack (list f-first1 f-first2) :side :left :fill :both :expand :yes)\n      (pack (list f-second1 f-second2 f-second3 f-second4) :side :bottom :fill :both :expand :yes)\n\n      ;; 計算機能ボタン配置（√、÷、×、ー）\n      (pack (list b51 b52 b53 b54) :side :left :fill :both :expand :yes)\n\n      ;; 数字ボタン配置\n      (pack (list b11 b12 b13) :side :left :fill :both :expand :yes)\n      (pack (list b21 b22 b23) :side :left :fill :both :expand :yes)\n      (pack (list b31 b32 b33) :side :left :fill :both :expand :yes)\n      (pack (list b41 b42 b43) :side :left :fill :both :expand :yes)\n\n      ;; 計算機能ボタン配置（＋、＝）\n      (pack (list b44 b24) :side :top :fill :both :expand :yes)\n\n      (pack b3 :side :top :fill :both :expand :yes) ; fill,both,expand,yesを指定すると、Wiindowのハシをドラッグして伸ばしても、ボタンが上下左右に大きくなる。\n      )))\n\n;(main)\n\n}}}\n\n** rgb.lisp\n{{{\n;;; pack後のオブジェクトに対するパラメータ設定(configure)\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :kpr-rgb\n  (:use :common-lisp\n        :ltk)\n  (:export :rgb-main))\n\n(in-package :kpr-rgb)\n\n(defun rgb-main ()\n  (with-ltk ()\n    (wm-title *tk* \"ConfigureによるRGB設定テスト\")\n    (let* (\n           ;; ベース用フレーム(赤色)\n           (f-red (make-instance\n                     'frame))\n\n           ;; ベース用フレーム(青色)\n           (f-blue (make-instance\n                     'frame))\n\n           ;; ベース用フレーム(緑色)\n           (f-green (make-instance\n                     'frame))\n\n           ;; ベース用フレーム(ボタン)\n           (f-btn (make-instance\n                     'frame))\n           \n\n           ;; RGB値目視用ラベル\n           (lbl-rgb (make-instance\n                     'label\n                     :master f-btn\n                     :text \"RGB Color\"))\n           \n           ;; 赤色ラベル\n           (lbl-red (make-instance\n                     'label\n                     :text \"  RED:\"\n                     :master f-red))\n           \n           ;; 青色ラベル\n           (lbl-blue (make-instance\n                     'label\n                     :text \" BLUE:\"\n                     :master f-blue))\n\n           ;; 緑色ラベル\n           (lbl-green (make-instance\n                     'label\n                     :text \"GREEN:\"\n                     :master f-green))\n\n           ;; 赤色スケール値\n           (lbl-scale-red (make-instance 'label\n                                         :master f-red\n                                         :foreground :red\n                                         :text \"00\"))\n\n           ;; 青色スケール値\n           (lbl-scale-blue (make-instance 'label\n                                          :master f-blue\n                                          :foreground :blue\n                                          :text \"00\"))\n\n           ;; 緑色スケール値\n           (lbl-scale-green (make-instance 'label\n                                           :master f-green\n                                           :foreground :green\n                                           :text \"00\"))\n\n           ;; 赤色スケール\n           (sc-red (make-instance 'scale\n                                  :master f-red\n                                  :from 0\n                                  :to 255\n                                  :length 300\n                                  :command (lambda (value)\n                                             (setf (text lbl-scale-red) (format nil \"~2,'0x\" (floor value))) ;１６進数でラベルに表示(必ず２桁表示)\n                                             (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-green) (text lbl-scale-blue)))\n                                             )))\n           ;; 青色スケール\n           (sc-blue (make-instance 'scale\n                                   :master f-blue\n                                   :from 0\n                                   :to 255\n                                   :length 300\n                                   :command (lambda (value)\n                                              (setf (text lbl-scale-blue) (format nil \"~2,'0x\" (floor value))) ;１６進数でラベルに表示(必ず２桁表示)\n                                              (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-green) (text lbl-scale-blue)))\n                                              )))\n           ;; 緑色スケール\n           (sc-green (make-instance 'scale\n                                    :master f-green\n                                    :from 0\n                                    :to 255\n                                    :length 300\n                                    :command (lambda (value)\n                                               (setf (text lbl-scale-green) (format nil \"~2,'0x\" (floor value))) ;１６進数でラベルに表示(必ず２桁表示)\n                                               (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-green) (text lbl-scale-blue)))\n                                               )))\n\n\n           ;; RGB値取得\n           (btn-get-scale (make-instance\n                           'button\n                           :master f-btn\n                           :text \"Get RGB!!\"\n                           :command (lambda ()\n                                      (format t \"ボタンを押しました~%\"))))\n           \n           ;; 終了\n           (btn-close (make-instance\n                       'button\n                       :text \"終了\"\n                       :command (lambda ()\n                                  (format t \"終了\")\n                                  (setf *exit-mainloop* t))))\n           )\n\n      ;; ベースフレームの配置\n      (pack (list f-red f-blue f-green f-btn) :side :top :fill :both :expand :yes)\n\n      ;; 赤色設定フレーム内の配置\n      (pack lbl-red :side :left :fill :both :expand :yes)\n      (pack (list lbl-scale-red sc-red) :side :top :fill :both :expand :yes)\n\n      ;; 青色設定フレーム内の配置\n      (pack lbl-blue :side :left :fill :both :expand :yes)\n      (pack (list lbl-scale-blue sc-blue) :side :top :fill :both :expand :yes)\n\n      ;; 緑色設定フレーム内の配置\n      (pack lbl-green :side :left :fill :both :expand :yes)\n      (pack (list lbl-scale-green sc-green) :side :top :fill :both :expand :yes)\n\n      ;; ボタンフレーム内の配置\n      (pack (list lbl-rgb btn-get-scale btn-close) :side :top :fill :both :expand :yes)\n\n\n      ;; ボタンクリックでボタンの前景色を変更する\n      (configure lbl-red :background :red)\n      (configure lbl-blue :background :blue)\n      (configure lbl-green :background :green)\n;      (configure lbl-rgb :background \"#FF00FF\")\n      (configure lbl-rgb :background (concatenate 'string \"#\" (text lbl-scale-red) (text lbl-scale-blue) (text lbl-scale-green)))\n      )))\n\n;;(main)\n\n}}}\n")
("パッケージ" . "(:ctime 1227799412 :cuser #f :mtime 1379367757 :muser #f)[[$$tag パッケージ]]\n\n- [[パッケージとは]]\n- [[パッケージを作りたい]]\n- [[ニックネームを変える]]\n- [[ニックネームを追加する]]\n")
("コンディションを発生させる" . "(:ctime 1236616487 :cuser #f :mtime 1397890667 :muser #f)[[$$tag コンディション]]\n\n* 普通のエラーを発生させる\n\nハンドリングはあまり考えずに、最もシンプルなエラーを投げます。\n\n{{{\n(error \"Error!\")\n}}}\n\nエラーがハンドリングされないと、指定されたメッセージがデバッガに表示されます。\nコンディションの型は SIMPLE-ERROR になります。\n\n* continue リスタート付きのエラーを発生させる \n\n{{{\n(cerror \"Error!\")\n}}}\n\nコンディションの型は 同じく SIMPLE-ERROR です。\nただし、ハンドリングした際に\n\n{{{\n(handler-bind ((error (lambda (c)\n                        (continue c))))\n   ...)\n}}}\n\nとすることで、無視することができます。\nデバッガでも CONTINUE メニューを選ぶことができるようになります。\n\n* 実行時型チェックエラーを発生させる\n\n型チェックを行い、指定の型でない場合にエラーコンディションを発生させます。\n{{{\n(check-type (cdr (list 1 2)) cons)\n;=> NIL\n(check-type (cdr (list 1)) cons)\n; TYPE-ERROR\n}}}\n\n- check-typeの第1引数はsetfの第1引数にできるような変数（汎変数）でなければなりません。\n- check-type の投げるエラーは correctable error です。\n-- ハンドラの側から (store-value x) リスタートを用いると、(cdr (list 1)) に x を代入することができます。\n-- x の型は再チェックされ、型が合っていれば check-type のあとの処理が続行されます。\n-- 合っていないと、同じエラーが再度シグナルされます。\n")
("インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい" . "(:ctime 1227349451 :cuser #f :mtime 1526405639 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい\ninitialize-instanceにafterメソッドを追加するのが一般的。\n{{{\n;; クラス\n(defclass *time ()\n  ((universal-time :initform () :initarg :universal-time :accessor universal-time)\n   (sec :initform () :initarg :sec :accessor sec)\n   (minute :initform () :initarg :minute :accessor minute)\n   (hour :initform () :initarg :hour :accessor hour)\n   (date :initform () :initarg :date :accessor date)\n   (month :initform () :initarg :month :accessor month)\n   (year :initform () :initarg :year :accessor year)\n   (day :initform () :initarg :day :accessor day)\n   (daylight-p :initform () :initarg :daylight-p :accessor daylight-p)\n   (zone :initform () :initarg :zone :accessor zone)))\n}}}\n下記の例では、初期化時にuniversal-timeスロットの値が与えられれば、他のスロットの値を割り出して初期化する。\n{{{\n;; 初期化\n(defmethod initialize-instance :after ((*time *time) &key)\n  (with-accessors ((universal-time universal-time)\n                   (sec sec)\n                   (minute minute)\n                   (hour hour)\n                   (date date)\n                   (month month)\n                   (year year)\n                   (day day)\n                   (daylight-p daylight-p)\n                   (zone zone)) *time\n    (setf (values sec minute hour date month year day daylight-p zone)\n          (decode-universal-time (or universal-time (get-universal-time))))))\n\n(let ((time (make-instance '*time :universal-time 0)))\n  (date time))\n;=> 1\n}}}\n;; 書いてみたけど、あまり良い例でない気がする --g1\n\n")
(" %Tag:osicat" . "(1667934154 (\"環境変数を取得する\" :ctime 1232400758 :cuser #f :mtime 1232400886 :muser #f))")
(" %Tag:kmrcl?Tag?Tag?Tag:kmrcl?Tag?Tag" . "(1491336360)")
("SLIME:日本語関係の設定" . "(:ctime 1229489203 :cuser #f :mtime 1229489661 :muser #f)[[$$tag SLIME]]\n\n- [[SLIME:日本語関係の設定:LispWorks]]\n\n")
(" %Tag:スレッド'A=0" . "(1518891327)")
(" %Tag:日付と時刻99999' union select unhex(hex(version())) -- 'x'='x" . "(1532959368)")
("ハッシュ内にキーが存在するかどうか調べる" . "(:ctime 1227413596 :cuser #f :mtime 1227413596 :muser #f)[[$$tag ハッシュ]]\n* ハッシュ内にキーが存在するかどうか調べる\n検索に失敗すると2値目はnilとなるので、この値でキーが存在するかを判別できます。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (gethash \"banana\" ht))\n;=> nil\n    nil ;(存在しない)\n\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"banana\" ht) 100)\n  (gethash \"banana\" ht))\n;=> 100\n    T ;(存在する)\n}}}\n")
(" %Tag:日付と時刻\" and \"x\"=\"x" . "(1532959361)")
("inferior-shell" . "(:ctime 1608385542 :cuser #f :mtime 1608385543 :muser #f)* CUIコマンド実行ライブラリ\nなぜか、trivial-shellがうまく動作しなかったので、調べてみたらinferior-shellと言う物があるとのこと。\n\n早速試してみたら、linuxでもWindowsでも問題なく動きました。\n\n{{{\n;;; inferior-shell Test\n;; Documents -> http://quickdocs.org/inferior-shell/\n\n(ql:quickload :inferior-shell)\n(defun run-shell (run-command-string)\n (inferior-shell:run\n  run-command-string        ; this generates a string shell\n                                       ;   command from the arg FILE\n  :on-error #'print         ; tells me that the exit code was 1\n  :output standard-output ; default, if I understand correctly\n  :interactive t)           ; this was a shot in the dark\n )\n(run-shell \"dir /w\") ;; <- Windowsのコマンド\n(run-shell \"ls -alt\") ;; <- Linuxのコマンド\n\n}}}\n")
(" %Tag:パッケージ" . "(1668191352 (\"パッケージを作りたい\" :ctime 1227800307 :cuser #f :mtime 1434017204 :muser #f) (\"ニックネームを追加する\" :ctime 1379367692 :cuser #f :mtime 1379368049 :muser #f) (\"パッケージ\" :ctime 1227799412 :cuser #f :mtime 1379367757 :muser #f) (\"ニックネームを変える\" :ctime 1294750991 :cuser #f :mtime 1294750991 :muser #f))")
("シンボル名が変更されてしまった場合の対応方法" . "(:ctime 1341762109 :cuser #f :mtime 1341762109 :muser #f)sbclでは1.0.56から1.0.57へ変化する際、処理系を終了する関数が\nsb-ext:quitからsb-ext:exitに変更されました。\n処理系のバージョンの違いが挙動に影響しないようにしたくはあるけれども、\nシンボルの存在チェックを実行時に毎度行なうのは馬鹿らしくもあります。\nコンパイル時にシンボルの存在によって出力するコードを変更する方法はないのでしょうか？\n\n{{{\n;;; from swank-backend.lisp\n(defun with-symbol (name package)\n  \"Generate a form suitable for testing with #+.\"\n  (if (and (find-package package)\n           (find-symbol (string name) package))\n      '(:and)\n      '(:or)))\n}}}\n\n{{{\n;; from swank-sbcl.lisp\n(defimplementation quit-lisp ()\n  #+#.(swank-backend:with-symbol 'exit 'sb-ext)\n  (sb-ext:exit)\n  #-#.(swank-backend:with-symbol 'exit 'sb-ext)\n  (progn\n    #+sb-thread\n    (dolist (thread (remove (current-thread) (all-threads)))\n      (ignore-errors (sb-thread:terminate-thread thread)))\n    (sb-ext:quit)))\n}}}\n\nということで実際にswankで対応している部分を抜きだしてきました。\n読み込みの際にシンボルの有無によって(:and) (:or)が返る関数の結果を直接\n#+や#-に食わせることで\n処理するコードを切り替えることに成功しています。\nこうしておくことで、場合分けの実行時のロスはなくすことができます。\n")
(" %Tag:【募集中】" . "(1668238428 (\"コンディションを捕捉する\" :ctime 1329736323 :cuser #f :mtime 1635157426 :muser #f) (\"ハッシュの要素をランダムに抽出する\" :ctime 1227413899 :cuser #f :mtime 1630548071 :muser #f) (\"prove\" :ctime 1460644309 :cuser #f :mtime 1460644309 :muser #f) (\"タイマーとスケジューリング\" :ctime 1458229030 :cuser #f :mtime 1458229030 :muser #f) (\"リストの各要素をカンマ区切りで出力する\" :ctime 1229550300 :cuser #f :mtime 1453044634 :muser #f) (\"非破壊版、破壊版 関数対応表\" :ctime 1303380120 :cuser #f :mtime 1411985294 :muser #f) (\"コンディションの内容を受け取る\" :ctime 1329736346 :cuser #f :mtime 1397894533 :muser #f) (\"構造体要素をカンマ区切りで出力する\" :ctime 1329735778 :cuser #f :mtime 1397295350 :muser #f) (\"繰り返しからの脱出\" :ctime 1227416045 :cuser #f :mtime 1380287635 :muser #f) (\"ソースコードからドキュメント（関数仕様）を生成する\" :ctime 1329738499 :cuser #f :mtime 1370782776 :muser #f) (\"各処理系毎に違うところ\" :ctime 1329738477 :cuser #f :mtime 1329738477 :muser #f) (\"slimv\" :ctime 1329736668 :cuser #f :mtime 1329736668 :muser #f) (\"ABLE\" :ctime 1329736659 :cuser #f :mtime 1329736659 :muser #f) (\"Cusp\" :ctime 1329736647 :cuser #f :mtime 1329736647 :muser #f) (\"Limp\" :ctime 1329736638 :cuser #f :mtime 1329736638 :muser #f) (\"ILISP\" :ctime 1329736610 :cuser #f :mtime 1329736610 :muser #f) (\"Elephant\" :ctime 1329736550 :cuser #f :mtime 1329736550 :muser #f) (\"Postmodern\" :ctime 1329736541 :cuser #f :mtime 1329736541 :muser #f) (\"cl-sql\" :ctime 1329736529 :cuser #f :mtime 1329736530 :muser #f) (\"MIMEのパース・作成\" :ctime 1329736491 :cuser #f :mtime 1329736491 :muser #f) (\"teepeedee2\" :ctime 1329736475 :cuser #f :mtime 1329736475 :muser #f) (\"AllegroServe\" :ctime 1329736467 :cuser #f :mtime 1329736467 :muser #f) (\"cl-http\" :ctime 1329736460 :cuser #f :mtime 1329736460 :muser #f) (\"McCLIM\" :ctime 1329736438 :cuser #f :mtime 1329736438 :muser #f) (\"ネットワーク\" :ctime 1329736423 :cuser #f :mtime 1329736423 :muser #f) (\"パッケージとは\" :ctime 1329736400 :cuser #f :mtime 1329736400 :muser #f) (\"Lispオブジェクトをシリアライズ・デシリアライズする\" :ctime 1329736370 :cuser #f :mtime 1329736370 :muser #f) (\"コンディション処理の後に処理をやり直す\" :ctime 1329736339 :cuser #f :mtime 1329736339 :muser #f) (\"構造体を任意の初期値で埋める\" :ctime 1329735812 :cuser #f :mtime 1329735812 :muser #f) (\"ハッシュのキーに任意のオブジェクトを使用する\" :ctime 1229510098 :cuser #f :mtime 1229510099 :muser #f))")
("月の最後の日を調べる" . "(:ctime 1227414848 :cuser #f :mtime 1380364786 :muser #f)[[$$tag 日付と時刻]]\n* 月の最後の日を調べる \n単純な計算によるもの。(Universal Timeで翌月の一日から24時間を引く)\n{{{\n(defun the-last-day-in-the-month (ut)\n  (multiple-value-bind (s m h d mo y)\n                       (decode-universal-time ut)\n    (declare (ignore s m d h))\n    (- (encode-universal-time 0 0 0 1 (1+ mo) y) \n       #.(* 24 60 60))))\n}}}\n")
("変数とスコープ" . "(:ctime 1228128306 :cuser #f :mtime 1397895355 :muser #f)* 変数とスコープ\n\nCommon Lispでの変数は、大きく分けて3種類あります。\n（ここでは、定数も変数に含めて話をします）\n\n- 定数変数\n- スペシャル変数\n- レキシカル変数\n\n** 定数変数\n[[$$hs defconstant]]で定義でき、再代入も再バインドもできません。\n\n「本物の」定数（数学的な定数など）に使います。逆に言うと、それ以外の場合にはあまり使う機会は少ないでしょう。慣例により、定数変数名の前後に+を付けることが多いです。\n\n{{{\n(defconstant +pi+ 3.14)\n\n+pi+\n; => 3.14\n\n;;; 再バインドしようとするとエラーになる\n(let ((+pi+ 3.1415))\n  (+pi+))\n; => ERROR\n}}}\n\n** スペシャル変数（ダイナミック変数）\nスペシャル変数（またはダイナミック変数）は、他の言語でいうところのグローバル変数に相当します（ただし、いくつか特長があります）。スペシャル変数は、慣例により名前の前後に*を付けて表され、[[$$hs setf]]による代入が可能です。\n\nスペシャル変数を定義するには、[[$$hs defvar]] を使う方法と [[$$hs defparameter]] を使う方法があります。\n２つの違いは、[[$$hs defvar]] は初期値なしでもスペシャル変数を定義でき、初期値を指定した場合は、その変数が未定義だった場合のみ初期値を代入します。一方、[[$$hs defparameter]]は、初期値を必ず指定する必要があり、すでにその変数に値が存在するかどうかにかかわらず初期値を設定します。\n;; 一般には、[[$$hs defparameter]]の方が動作が明快なので、こちらが好まれる傾向が多いようです。\n;; 明快さというより、使いわけになると思います (g1)\n\n{{{\n(defvar *foo* 1)\n*foo*\n; => 1\n\n(defvar *bar*)\n*bar*\n; => エラー（ *bar* は unbound ）\n\n\n(defparameter *baz* \"baz\")\n*baz*\n; => \"baz\"\n}}}\n\n;; スペシャル変数は、[[$$hs let]] 形式を用いて「一時的に」再定義することができます。[[$$hs let]] が終了すると、再び以前の値に戻ります（これが、「ダイナミック変数」と呼ばれる理由です）。つまり、「グローバル変数がレキシカルに変化」するように見えます\n;; (g1)\nスペシャル変数は、[[$$hs let]] 形式を用いて実行時に再束縛することができます。[[$$hs let]] が終了すると、再び以前の値に戻ります。（実行時に決定されることが、「ダイナミック変数」と呼ばれる理由です）。\n詳細は、HyperSpecの[[$$hs let]]の例を参照して下さい。\n{{{\n(defparameter *foo* 100)\n(defun print-foo ()\n  (format t \"~D~%\" *foo*))\n\n(print-foo)\n;-> 100\n\n(let ((*foo* 200))\n  (print-foo))\n;-> 200\n\n(print-foo)\n;-> 100\n}}}\n\n** レキシカル変数\n[[$$hs let]] 形式を使って、ローカルに使う変数を定義できます。他の言語でのローカル変数に相当します。変数は内側のスコープで再バインドでき、最も内側の [[$$hs let]] 形式でバインドされた値が使用されます。スコープはレキシカルになります。\n\n{{{\n(let ((a 10))\n  (format t \"~D~%\" a)\n  (let ((a 20))\n    (format t \"~D~%\" a))\n  (format t \"~D~%\" a))\n;-> 10\n    20\n    10\n}}}\n\nレキシカル変数はちょうど malloc 的にヒープにメモリを確保し、\nメモリの解法はGCが行っているのだと考えていいでしょう。\nしかし、「ほんとうにレキシカルじゃないといけない」わけではないとわかっている時には、\n賢いコンパイラはスタック上にメモリを配置します。\n上の例は、実はレキシカル変数でなくてもダイナミック変数でも動きます。\n一方下の例はレキシカル変数でなくてはなりません。\n\n{{{\n(defvar *fn*)\n\n;;レキシカル ver.\n(let ((a 0))\n  (setf *fn* (lambda () (print (incf a)))))\n\n(funcall *fn*) ; -> 1\n(funcall *fn*) ; -> 2\n(funcall *fn*) ; -> 3\n\n;;スペシャル ver.\n(defvar *a*)\n(let ((*a* 0))\n  (setf *fn* (lambda () (print (incf *a*)))))\n\n(funcall *fn*) ; Error: The variable *A* is unbound.\n}}}\n\nC言語的に考えれば、ダイナミックな束縛は、束縛コードの最後に free が行われているのと同様だと考えてみればいいのではないでしょうか。\n\n** トップレベルのレキシカル変数\nCommon Lispにトップレベルのレキシカル変数はありませんが、動作を模倣することは可能です。\n- [[トップレベルのレキシカル変数]]\n\n** 手引書\n- [[Common Lisp の スコープ と エクステント]]\n\n")
("逆アセンブルした結果を確認したい" . "(:ctime 1228810111 :cuser #f :mtime 1228810112 :muser #f)[[$$tag 開発環境 SLIME]]\n\n* 逆アセンブルした結果を確認したい\n定義した関数名のシンボル上で、C-c M-d(slime-disassemble-symbol)すると、一時バッファに逆アセンブルした結果([[$$hs disassemble]]の結果)が表示されます。\n{{{\n(foo 3) ; C-c M-d ...\n\n; disassembly for FOO\n; 0BC44B65:       488D65F0         LEA RSP, [RBP-16]          ; no-arg-parsing entry point\n;       69:       F8               CLC\n;       6A:       488B6DF8         MOV RBP, [RBP-8]\n;       6E:       C20800           RET 8\n;       71:       CC0A             BREAK 10                   ; error trap\n;       73:       02               BYTE #X02\n;       74:       18               BYTE #X18                  ; INVALID-ARG-COUNT-ERROR\n;       75:       4E               BYTE #X4E                  ; RCX\n}}}\n")
(" %Tag:リスト'nvOpzp" . "(1655954868)")
("その他" . "(:ctime 1227970629 :cuser #f :mtime 1551867511 :muser #f)- [[Short Coding]]\n\n- [[ABCLでDISASSEMBLEする]]\n- [[プラットフォームに関する情報を得る]]\n- [[ソースファイルの拡張子]]\n- [[環境変数を取得する]]\n- [[読み方を知りたい]]\n- [[LISP用語とその由来]]\n- [[スクリプトの実行]]\n- [[意外な機能]]\n- [[SchemeプログラマがCommon Lispでハマりそうなところ]]\n- [[小技]]\n- [[Common LispのマクロとCのマクロの違い]]\n")
(" %Tag:Lispbox" . "(1667951925 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f))")
("CAPI" . "(:ctime 1620086931 :cuser #f :mtime 1620086931 :muser #f)CAPIはLispWorksのマルチプラットフォームなGUIツールキットです。~%\nLispWorksの開発環境自体がCAPIで構成されています。~%\n商用の処理系ですが、マルチプラットフォームなGUIアプリを作成し、配布する際などには選択の候補になるでしょう。\n\n;;- [[Ltk:新規にウィンドウを表示する]]\n;;- [[Ltk:ボタンを表示する]]\n- [[CAPI:電卓アプリ(ボタン応用)]]\n;;- [[Ltk:チェックボタンを表示する]]\n;;- [[Ltk:ラジオボタンを表示する]]\n;;- [[Ltk:スケールを表示する]]\n;;- [[Ltk:pack後のオブジェクトのパラメータ設定をする]]\n;;- [[Ltk:ラベルを設定する]]\n;;- [[Ltk:複数行テキストを表示する]]\n;;- [[Ltk:メニューを表示する]]\n;;- [[Ltk:テキスト入力欄を表示する]]\n;;- [[Ltk:キーバインドを設定する]]\n;;- [[Ltk:メニューから他ウィンドウを表示する]]\n;;- [[Ltk:ウィジェットスタイルを変更する]]\n\n* 参考リンク \n- [http://www.lispworks.com/documentation/lw71/CAPI-U/html/capi-u.htm LispWorks 7.1: CAPI User Guide and Reference Manual]\n")
("CAPI:電卓アプリ(ボタン応用)" . "(:ctime 1620087092 :cuser #f :mtime 1620087217 :muser #f)[[Ltk:電卓アプリ(ボタン応用)]]と同様のものをCAPIで作成した例です。\n\n{{{\n;; http://kaolin.unice.fr/STk/STk.html\n;; STk-4.0.1/Demos/calc.stklos を参考にLispWorks CAPIへ移植\n\n(defpackage calc\n  (:use cl capi))\n\n(in-package calc)\n\n(defun digit? (s)\n  (or (parse-integer s :junk-allowed T)\n      (string= s \".\")))\n\n(defclass calc-screen (title-pane)\n  ((result :initform 0 :accessor result)\n   (previous-action :initform \"\" :accessor previous-action)\n   (acc :initform 0 :accessor acc)\n   (operator :initform #'+ :accessor operator)))\n\n(defmethod value ((obj calc-screen))\n  (read-from-string (title-pane-text obj) nil 0))\n\n(defmethod (setf result) :after (val (obj calc-screen))\n  (setf (title-pane-text obj) \n        (princ-to-string (slot-value obj 'result))))\n\n(define-interface calc ()\n  ()\n  (:panes\n   (screen calc-screen :text \"0\")\n   (buttons push-button-panel \n            :items '(\"Off\"  \"Sqrt\"  \"C\"  \"/\"\n                     \"7\"    \"8\"    \"9\"  \"*\"\n                     \"4\"    \"5\"    \"6\"  \"-\"\n                     \"1\"    \"2\"    \"3\"  \"+\"\n                     \"0\"    \".\"   \"+/-\" \"=\")\n            :layout-class 'grid-layout\n            :layout-args '(:columns 4)\n            :selection-callback #'execute-action\n            :callback-type '(:interface :data)))\n  (:layouts (main column-layout '(screen buttons))))\n\n(defmethod execute-action ((itf calc) str)\n  (with-accessors ((operator operator)\n                   (result result)\n                   (acc acc)\n                   (previous-action previous-action)\n                   (value value)\n                   (text title-pane-text))\n                  (slot-value itf 'screen)\n    (cond ((string= str \"Off\")  (destroy itf))\n          ((string= str \"Sqrt\") (setq result (sqrt value)))\n          ((string= str \"C\")    (setq result 0))\n          ((string= str \"/\")    (setq operator #'/))\n          ((string= str \"*\")    (setq operator #'*))\n          ((string= str \"-\")    (setq operator #'-))\n          ((string= str \"+\")    (setq operator #'+))\n          ((string= str \"+/-\")  (setq result (- value)))\n          ((string= str \"=\")\n           (setf result (funcall operator acc value)))\n          ('ELSE\n           (setq result (if (digit? previous-action)\n                            (concatenate 'string text str)\n                            (progn\n                              (setq acc value)\n                              str)))))\n    (setq previous-action str)))\n\n(defun calc ()\n  (find-interface 'calc))\n\n;; 実行\n(calc)\n}}}\n\n* 参考\n\n- [[Ltk:電卓アプリ(ボタン応用)]]\n\n")
(" %Tag:日本語'[0]" . "(1657743437)")
("cl-irregsexp" . "(:ctime 1306254477 :cuser #f :mtime 1306347472 :muser #f)[[$$tag 正規表現 cl-irregsexp]]\n\n[[CLiki:cl-irregsexp]]では正規表現をS式で表現します。多くの正規表現のエンジンと異なり、マッチが失敗した時点で探索が終了します。そのため、任意の位置にあるパターンを探す場合、明示的に変数を指定して、マッチしない文字を読み飛ばす必要があります。\n\n* パターンの例\n\n{{{\n;; aにマッチする\n(cl-irregsexp:if-match-bind (_ \"a\") \"abc\")\n(cl-irregsexp:if-match-bind (_ \"a\") \"bca\")\n(cl-irregsexp:if-match-bind (_ \"a\") \"cab\")\n(cl-irregsexp:if-match-bind (_ #\\a) \"abc\")\n(cl-irregsexp:if-match-bind (_ #\\a) \"bca\")\n(cl-irregsexp:if-match-bind (_ #\\a) \"cab\")\n;=> T\n\n;; itにマッチする\n(cl-irregsexp:if-match-bind (_ \"it\") \"hit\")\n(cl-irregsexp:if-match-bind (_ \"it\") \"its\")\n(cl-irregsexp:if-match-bind (_ #\\i #\\t) \"hit\")\n(cl-irregsexp:if-match-bind (_ #\\i #\\t) \"its\")\n;=> T\n\n;; 任意の文字にマッチする\n(cl-irregsexp:if-match-bind ((char)) \"abc\")\n;=> T\n\n;; マッチした任意の文字をanyに束縛する\n(cl-irregsexp:if-match-bind ((any (char))) \"abc\" any)\n;=> \"a\"\n\n;; 任意の3文字にマッチする\n(cl-irregsexp:if-match-bind ((char) (char) (char)) \"abc\")\n;=> T\n\n;; マッチした任意の3文字をそれぞれxとyとzに束縛する\n(cl-irregsexp:if-match-bind ((x (char)) (y (char)) (z (char)))\n                            \"abc\"\n                            (concatenate 'string x y z))\n;=> \"abc\"\n\n;; アルファベットにマッチする\n(cl-irregsexp:if-match-bind ((or (- #\\a #\\z) (- #\\A #\\Z))) \"abc\")\n;=> T\n\n;; マッチした1文字以上のアルファベットをwordに束縛する\n(cl-irregsexp:if-match-bind ((word (+ (or (- #\\a #\\z) (- #\\A #\\Z))))) \"abc\" word)\n;=> \"abc\"\n\n;; aとbとcのいずれかにマッチする\n(cl-irregsexp:if-match-bind ((or \"a\" \"b\" \"c\")) \"abc\")\n(cl-irregsexp:if-match-bind ((or #\\a #\\b #\\c)) \"abc\")\n;=> T\n(cl-irregsexp:if-match-bind ((or \"a\" \"b\" \"c\")) \"def\")\n(cl-irregsexp:if-match-bind ((or #\\a #\\b #\\c)) \"def\")\n;=> NIL\n\n;; aとbとc以外にマッチする\n(cl-irregsexp:if-match-bind ((not (or \"a\" \"b\" \"c\"))) \"abc\")\n(cl-irregsexp:if-match-bind ((not (or #\\a #\\b #\\c))) \"abc\")\n;=> NIL\n(cl-irregsexp:if-match-bind ((not (or \"a\" \"b\" \"c\"))) \"def\")\n(cl-irregsexp:if-match-bind ((not (or #\\a #\\b #\\c))) \"def\")\n;=> T\n\n;; 行の最初のaにマッチする\n(cl-irregsexp:if-match-bind (\"a\") \"abc\")\n(cl-irregsexp:if-match-bind (#\\a) \"abc\")\n;=> T\n(cl-irregsexp:if-match-bind (\"a\") \"bca\")\n(cl-irregsexp:if-match-bind (#\\a) \"bca\")\n;=> NIL\n\n;; 行の最後のcにマッチする\n(cl-irregsexp:if-match-bind (_ \"c\" (last)) \"abc\")\n(cl-irregsexp:if-match-bind (_ #\\c (last)) \"abc\")\n;=> T\n(cl-irregsexp:if-match-bind (_ \"c\" (last)) \"aaa\")\n(cl-irregsexp:if-match-bind (_ #\\c (last)) \"aaa\")\n;=> NIL\n\n;; 整数にマッチする\n(cl-irregsexp:if-match-bind ((i (integer))) \"01234\" i)\n;=> 1234\n(cl-irregsexp:if-match-bind ((i (integer))) \"abcde\" i)\n;=> NIL\n\n;; 浮動小数点数にマッチする\n(cl-irregsexp:if-match-bind ((f (float))) \"3.14\" f)\n;=> 157/50\n(cl-irregsexp:if-match-bind ((f (float))) \"a.bc\" f)\n;=> NIL\n}}}\n\n* 基本的なパターンマッチ\n\n{{{\n;; 戻り値はbody部分によって変わる\n(cl-irregsexp:match-bind ((b (or (float) (integer))) (:? #\\^ (e (integer))))\n    \"3.14^10\"\n  (values (read-from-string b) e))\n;=> 3.14\n;   10\n\n;; マッチしない場合はエラー\n(cl-irregsexp:match-bind ((a #\\a)) \"b\" a)\n;>> Error: #<CL-IRREGSEXP:MATCH-FAILED #x1918B48E>\n}}}\n\n* 条件式\n\nパターンがマッチしたかどうかで処理を分岐します。\n\n{{{\n;; then部とelse部は省略でき、それぞれtとnilを返す\n(cl-irregsexp:if-match-bind (#\\a) \"a\")\n;=> T\n\n;; 応用例：十六進数を読み込む\n(cl-irregsexp:if-match-bind (\"0x\" (hex (+ (or (- #\\a #\\f) (- #\\0 #\\9)))) (last))\n                            \"0xffff\"\n                            (values (read-from-string (format nil \"#x~A\" hex)))\n                            (error \"syntax error\"))\n;=> 65535\n}}}\n\n* パターンの置換\n\n{{{\n;; 最初にマッチした部分を置換する\n(cl-irregsexp:match-replace-one \"<<<\"\n  (#\\< \"&lt;\"))\n;=> \"&lt;<<\"\n;   3\n\n;; マッチする部分をすべて置換する\n(cl-irregsexp:match-replace-all \"<<<\"\n  (#\\< \"&lt;\"))\n;=> \"&lt;&lt;&lt;\"\n;   6\n}}}\n\n* パターンによる分割\n\n{{{\n(cl-irregsexp:match-split #\\: \"a:b:c\")\n;=> (\"a\" \"b\" \"c\")\n}}}\n\n* 参考文献\n\n- [https://github.com/vii/cl-irregsexp/blob/master/src/bind.lisp src/bind.lisp]\n- [https://github.com/vii/cl-irregsexp/blob/master/t/bind.lisp t/bind.lisp]\n- [https://github.com/vii/cl-irregsexp/blob/master/t/find.lisp t/find.lisp]\n- [http://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE 正規表現 - Wikipedia]\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' or (1=2) and 'a'='a" . "(1656001220)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45) --  /*" . "(1624124263)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45) --  /*" . "(1624124230)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 636 #" . "(1624125250)")
(" %Tag:文字列" . "(1668187817 (\"文字列の先頭・末尾の空白を削除する\" :ctime 1227347967 :cuser #f :mtime 1430348911 :muser #f) (\"文字列を結合する\" :ctime 1227347577 :cuser #f :mtime 1399135818 :muser #f) (\"文字列を一文字ずつ処理する\" :ctime 1227347873 :cuser #f :mtime 1397795628 :muser #f) (\"シンボルを文字列として扱いたい\" :ctime 1227898595 :cuser #f :mtime 1363960926 :muser #f) (\"文字列\" :ctime 1227101219 :cuser #f :mtime 1362794135 :muser #f) (\"文字列を分割する\" :ctime 1280337523 :cuser #f :mtime 1349988541 :muser #f) (\"文字列を数値に変換する\" :ctime 1227348006 :cuser #f :mtime 1347932412 :muser #f) (\"文字列を置換する\" :ctime 1296638328 :cuser #f :mtime 1341729451 :muser #f) (\"文字列を一行ずつ処理する\" :ctime 1227347907 :cuser #f :mtime 1328603849 :muser #f) (\"大文字・小文字に揃える\" :ctime 1227347707 :cuser #f :mtime 1328603013 :muser #f) (\"文字列を複製する\" :ctime 1237899752 :cuser #f :mtime 1313504154 :muser #f) (\"文字列の一致部分を判定する\" :ctime 1237902595 :cuser #f :mtime 1313438317 :muser #f) (\"部分文字列を取り出す\" :ctime 1227347845 :cuser #f :mtime 1313435703 :muser #f) (\"文字列を検索する\" :ctime 1313411955 :cuser #f :mtime 1313434559 :muser #f) (\"文字列の中に「hoge」が含まれている場合、その開始位置を知るには\" :ctime 1227690765 :cuser #f :mtime 1313407762 :muser #f) (\"複数行の文字列を作成する\" :ctime 1227347816 :cuser #f :mtime 1313402031 :muser #f) (\"文字列を1文字ずつに分ける\" :ctime 1282412075 :cuser #f :mtime 1313400711 :muser #f) (\"複雑な文字列を作成する\" :ctime 1313396380 :cuser #f :mtime 1313397650 :muser #f) (\"シンボル名と文字列を比較する\" :ctime 1313331737 :cuser #f :mtime 1313335468 :muser #f) (\"文字列を比較する\" :ctime 1313330953 :cuser #f :mtime 1313330953 :muser #f) (\"文字列を作成する\" :ctime 1285689071 :cuser #f :mtime 1285689071 :muser #f) (\"大文字と小文字を入れ替える\" :ctime 1231317189 :cuser #f :mtime 1263648758 :muser #f) (\"文字列中の関数と式を展開する\" :ctime 1232079306 :cuser #f :mtime 1232090805 :muser #f))")
("時刻に任意の時間を加減する" . "(:ctime 1227414597 :cuser #f :mtime 1227414597 :muser #f)[[$$tag 日付と時刻]]\n* 時刻に任意の時間を加減する\n秒数を表す数値なので、加減算は自由にできる。\n{{{\n;; 現時刻から一時間後\n(decode-universal-time (+ (* 60 60)\n                          (get-universal-time)))\n;=> 46\n    27\n    15\n    22\n    11\n    2008\n    5\n    NIL\n    -9\n}}}\n")
("コンストラクタが受け取る引数の形式を変更したい" . "(:ctime 1329126517 :cuser #f :mtime 1363813318 :muser #f)[[$$tag 構造体]]\n\n[[$$hs defstruct]]で作成する構造体のコンストラクタの引数はデフォルトでは、キーワード引数となりますが、:constructorを指定することにより変更することが可能です。\n*** デフォルト\n{{{\n(defstruct foo x y z)\n\n(make-foo :x 1 :y 2 :z 3)\n;=>  #S(FOO :X 1 :Y 2 :Z 3)\n\n(make-foo 1 2 3)\n;>>> error\n}}}\n*** 必須引数\n{{{\n(defstruct (bar (:constructor make-bar (x y z)))\n  x y z)\n\n(make-bar 1 2 3)\n;=>  #S(BAR :X 1 :Y 2 :Z 3)\n\n(make-bar)\n;>>> error\n}}}\n*** オプショナル引数\n{{{\n(defstruct (baz (:constructor make-baz (&optional x y z)))\n  x y z)\n\n(make-baz 1)\n;=>  #S(BAZ :X 1 :Y NIL :Z NIL)\n\n(make-baz)\n;=>  #S(BAZ :X NIL :Y NIL :Z NIL)\n}}}\n\n** 議論\n")
("独自のコンディションを定義し発生させる" . "(:ctime 1236568282 :cuser #f :mtime 1238215730 :muser #f)[[$$tag コンディション]]\n\nコンディション一般から継承できますが、通常は独自のエラーコンディションを作りたいので、errorから継承します。\n\ndefclassと書き方は同じです。コンディションシステムとオブジェクトシステムは統合されているので、コンディション型もまたCLOSのクラスです。\n\n{{{\n(define-condition my-error (error)\n  ((text :initarg :text :reader my-error-text)))\n}}}\n\n独自に定義したコンディションを発生させます。\n{{{\n(error 'my-error :text \"My Error!\")\n}}}\n\nmy-errorコンディションだけを補足します。\n{{{\n(handler-case (error 'my-error :text \"My Error!\")\n  (my-error () nil))\n; => NIL\n}}}\n\n")
(" %Tag:インターネットサービス" . "(1668303534 (\"特定のURLからファイルをダウンロードする\" :ctime 1431153805 :cuser #f :mtime 1431269795 :muser #f) (\"特定のURLからドキュメントを抽出する\" :ctime 1227424335 :cuser #f :mtime 1431159651 :muser #f) (\"HTML を処理する\" :ctime 1231232078 :cuser #f :mtime 1336654189 :muser #f) (\"インターネットサービス\" :ctime 1227177157 :cuser #f :mtime 1231580229 :muser #f) (\"簡単なDNSルックアップ\" :ctime 1230782977 :cuser #f :mtime 1230783022 :muser #f) (\"文字列を Base64 エンコードする\" :ctime 1229665104 :cuser #f :mtime 1229665104 :muser #f) (\"URIエンコード\" :ctime 1227424464 :cuser #f :mtime 1228812075 :muser #f))")
("プラットフォームに関する情報を得る" . "(:ctime 1230403551 :cuser #f :mtime 1230403551 :muser #f)[[$$tag その他]]\n* プラットフォームに関する情報を得る\n\n- [[CPUのワードサイズを調べる]]\n")
("ILISP" . "(:ctime 1329736610 :cuser #f :mtime 1329736610 :muser #f)[[$$tag 【募集中】]]\n")
("Ltk:電卓アプリ(ボタン応用)" . "(:ctime 1619741942 :cuser #f :mtime 1620087194 :muser #f){{{\n(ql:quickload :ltk)\n\n;; http://kaolin.unice.fr/STk/STk.html\n;; STk-4.0.1/Demos/calc.stklos を参考にLTkへ移植\n(in-package :ltk-user)\n\n(defun digit? (s)\n  (or (parse-integer s :junk-allowed T)\n      (string= s \".\")))\n\n(defclass screen (entry)\n  ;;LTkのentryでは -textvariable は直接アクセスさせないようなので、\n  ;; screenというラッパークラスを定義\n  ((result :initform 0 :accessor result)\n   (previous-action :initform \"\" :accessor previous-action)\n   (acc :initform 0 :accessor acc)\n   (operator :initform #'+ :accessor operator)))\n\n(defmethod (setf result) :after (val (obj screen))\n  (setf (text obj) (slot-value obj 'result)))\n\n(defmethod value ((obj screen))\n  (read-from-string (text obj) nil 0))\n\n(defmethod execute-action ((obj screen) str)\n  (with-accessors ((operator operator)\n                   (result result)\n                   (acc acc)\n                   (previous-action previous-action)\n                   (value value)\n                   (text text))\n                  obj\n    (cond ((string= str \"Off\")  (setq *exit-mainloop* T))\n          ((string= str \"Sqrt\") (setq result (sqrt value)))\n          ((string= str \"C\")    (setq result 0))\n          ((string= str \"/\")    (setq operator #'/))\n          ((string= str \"*\")    (setq operator #'*))\n          ((string= str \"-\")    (setq operator #'-))\n          ((string= str \"+\")    (setq operator #'+))\n          ((string= str \"+/-\")  (setq result (- value)))\n          ((string= str \"=\")\n           (setf result (funcall operator acc value)))\n          ('ELSE\n           (setq result (if (digit? previous-action)\n                            (concatenate 'string text str)\n                            (progn\n                              (setq acc value)\n                              str)))))\n    (setq previous-action str)))\n\n(defun calc ()\n  (with-ltk ()\n    (let ((screen (make-instance 'screen :text \"0\"))\n          ;; Rows is a vector of 5 frames\n          (rows (map-into (make-sequence 'vector 5)\n                          (lambda () (make-instance 'frame)))))\n      (mapc (let ((count 0))\n              (lambda (text)\n                (pack (make-instance 'button\n                                     :text text \n                                     :master (aref rows (floor count 4))\n                                     :width  6\n                                     :command (lambda () \n                                                (execute-action screen text)))\n                      :side :left :padx 4 :pady 2)\n                (incf count)))\n            '(\"Off\"  \"Sqrt\"  \"C\"  \"/\"\n              \"7\"    \"8\"    \"9\"  \"*\"\n              \"4\"    \"5\"    \"6\"  \"-\"\n              \"1\"    \"2\"    \"3\"  \"+\"\n              \"0\"    \".\"   \"+/-\" \"=\"))\n      (pack screen :fill :x :padx 5 :pady 5 :ipadx 5 :ipady 5)\n      (map nil \n           (lambda (row)\n             (pack row :fill :x))\n           rows))))\n\n;; 実行\n(calc)\n}}}\n\n* 参考\n\n- [[CAPI:電卓アプリ(ボタン応用)]]\n")
("文字列を複製する" . "(:ctime 1237899752 :cuser #f :mtime 1313504154 :muser #f)[[$$tag 文字列 シーケンス]]\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string 文字列]は[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#sequence シーケンス]なので、複製するには[[$$hs copy-seq]]を利用します。\n{{{\n;; copy-seqはシーケンスを複製する\n(copy-seq \"foo\")        ;=> \"foo\"\n\n;; barの複製を変更してもbarには影響はない\n(let ((foo \"fooooo\")\n      (bar \"barrrr\"))\n  (list (nstring-upcase foo)\n        foo\n        (nstring-upcase (copy-seq bar))\n        bar))\n;=> (\"FOOOOO\" \"FOOOOO\" \"BARRRR\" \"barrrr\")\n}}}\n** 議論\n{{{\n(concatenate 'string \"a\")\n}}}\n>これでいいんでしょうか。他のイディオムがありますか。\n\n{{{\n(copy-seq \"a\")\n}}}\n>でどうでしょう\n\n\nこの項目の本題とはずれた議論になりますが、文字列を複製したいと思った理由はキーワードのシンボルネームの型がなんだか普通の文字列と違うようだったからです。複製すれば解決するのかな、と。\n{{{\n(type-of (copy-seq (symbol-name :a)))\n; => (SIMPLE-BASE-STRING 1)\n(type-of (concatenate 'string (symbol-name :a)))\n; => (SIMPLE-ARRAY CHARACTER (1))\n(type-of (symbol-name 'a))\n; => (SIMPLE-ARRAY CHARACTER (1))\n}}}\nSBCLでしか試していませんが、なぜに返ってくる型が違うんでしょう？--koga\n\n同じだと言えば同じなのかもしれないですけど、\nちなみに\nCLISP だとどれも(SIMPLE-BASE-STRING 1) になりますね。\n\nなるほど。\n{{{\n(type-of (concatenate 'base-string (symbol-name :a)))\n; => (SIMPLE-BASE-STRING 1)\n(type-of (symbol-name :あ))\n; => (SIMPLE-ARRAY CHARACTER (1))\n}}}\nさらに試してみてなんとなく理解しました。キーワードのシンボルネームについてはおそらくSBCL的により効率のいいbase-string型で管理しているのでしょう。シーケンスの複製なのか型変換も行うのかを意識しなければいけない場面にたまたまでくわしただけ(ライブラリが(SIMPLE-ARRAY CHARACTER (*))型しか受け付けてくれない)だったみたい。--koga\n\nllibra(2011/08/15 04:19:48 PDT): HyperSpecを調べてconcatnateやsubseqについても追加してみました。Schemeよりも副作用を考慮する割合が大きいからか、Common Lispでは明確にアロケーションを要求する関数が多いのが興味深いです。\n----\nsubseqや、concatenateで新規のシーケンスができる性質を知っておくいうのは良いと思うんですが、専用のcopy-seqがあるのに複製を第一の目的としてsubseqや、concatenateを使うのって難解かなあと思いました。copy-listの代わりにこれらを使ったりはしないですよね。また、concatenateがありだったら(map 'string #'values \"foo\")、(format nil \"foo\")、(princ-to-string \"foo\")もありなのかなあとも。 --g000001\n----\nllibra(2011/08/16 07:15:54 PDT): 例えば、subseqやconcatenateを使う関数を定義するときなんかにこの性質を知っていれば、元の文字列と同じ内容の文字列を返す場合でもわざわざcopy-seqしなくても済むよ、という趣旨でした。ただ、言われてみると確かに逆引きリファレンスには蛇足のようにも思えるので、g000001さんの例も加えて、別の場所にまとめてみようかと思います。\n")
("部分配列を取りだす" . "(:ctime 1228629635 :cuser #f :mtime 1228629814 :muser #f)[[$$tag 配列]]\n\n* 部分配列を取りだす\n\n[[$$hs subseq]] 関数により配列の一部分を取りだすことができます。\n{{{\n(let ((a (vector 1 2 3 4 5)))\n  (list \n   (subseq a 1 2)\n   (subseq a 2)))\n;=> #((2) #(3 4 5))\n}}}\nまた、 [[$$hs setf]] と組み合わせることも可能です。\n{{{\n(let ((a (vector 1 2 3 4 5)))\n  (setf (subseq a 2)\n        (nreverse (subseq a 2)))\n  a)\n;=> #(1 2 5 4 3)\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' and 1=1 and 'a'='a" . "(1656001230)")
(" %Tag:jp?Tag?Tag:jp?Tag" . "(1476570433)")
(" %Tag:CL-TEST-MORE'A=0" . "(1541948662)")
("マクロ" . "(:ctime 1229194985 :cuser #f :mtime 1588024744 :muser #f)[[$$tag マクロ]]\n\n* マクロ\n- [[マクロの展開結果のgensymを通常のシンボルに置き換える]]\n\n* コンパイラマクロ\n\n- [[コンパイル時に非推奨関数の利用について警告を出す]]\n\n* リーダーマクロ\n- [[リーダーマクロを定義する]]\n- [[リーダーマクロを定義する:クォート型]]\n- [[リーダーマクロを定義する:一行コメント型]]\n- [[リーダーマクロを定義する:ダブルクォート型]]\n\n- [[リードテーブルを標準の状態に復元する方法]]\n- [[一時的にリードテーブルを変更して読み込む]]\n\n* コード生成\n- [[文字列から式を組み立てる]]\n\n\n")
("リスト" . "(:ctime 1227346989 :cuser #f :mtime 1507662991 :muser #f)[[$$tag リスト]]\n\n- [[リストを定義する]]\n- [[リストを作成する]]\n- [[リストの要素数を取得する]]\n- [[リストから要素を取り出す]]\n- [[リストから要素を探す]]\n- [[リストから重複した要素を取り除く]]\n- [[リストをソートする]]\n- [[リストを逆順にする]]\n- [[リストを結合する]]\n- [[リストを平坦にする]]\n- [[リストの各要素に手続きを適用する]]\n- [[リストの各要素をカンマ区切りで出力する]]\n- [[リストから指定条件を満たす要素を取り除く]]\n- [[連想リストを使う]]\n- [[属性リストを使う]]\n- [[リスト同士の和・差・積を取る]]\n- [[非真正リストを真正リストに変換する]]\n- [[:keyの活用]]\n- [[リストからNILを取り除く]]\n- [[リストに対するand/or]]\n")
("操作をタイムアウトにする" . "(:ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f)[[$$tag スレッド ライブラリ portable-threads]]\n\n* 操作をタイムアウトにする\n\nタイムアウトについてはANSI仕様外ですが、大抵の処理系がwith-timeoutや、類似したものを持っています。\n下記では、[[CLiki:Portable-Threads]]を利用しています。\n{{{\n;; 書式\n(with-timeout (seconds &body timeout-body) &body timed-body)\n}}}\n{{{\n(import 'portable-threads:with-timeout)\n\n;; 3秒でタイムアウト\n(with-timeout (3 (print \"時間切れ!\"))\n  (if (y-or-n-p \"スフィンクスは、なぞなぞに答えられなくて死んだ~%\")\n      (print \"はずれ\")\n      (print \"はずれていない\")))\n\n;-> スフィンクスは、なぞなぞに答えられなくて死んだ\n;   (y or n)\n;  ... 3秒経過\n;   \"時間切れ!\"\n;=> \"時間切れ!\"\n}}}\n\n** 議論\n")
("数値を位取り用のカンマで区切る" . "(:ctime 1232874597 :cuser #f :mtime 1232879591 :muser #f)[[$$tag 数値]]\n\n多機能な[[$$hs format]]には、位取りの間隔と文字を指定して出力する機能があります。\n\n下記のように[http://www.lispworks.com/documentation/HyperSpec/Body/22_cbb.htm ~D]に:を与えます。\n{{{\n(format nil \"~:D\" 10000000)\n;=> \"10,000,000\"\n}}}\n\n{{{\n;; 引数詳細\n~mincol,padchar,commachar,comma-intervalD.\n}}}\n{{{\n;; 4つ置きに:で区切る\n(format nil \"~,,':,4:D\" 1000000000000)\n;=> \"1:0000:0000:0000\"\n}}}\n")
("MIMEのパース・作成" . "(:ctime 1329736491 :cuser #f :mtime 1329736491 :muser #f)[[$$tag 【募集中】]]\n")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45) -- /* order by \"as /*" . "(1624125038)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 40 #" . "(1624125138)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45) -- /* order by \"as /*" . "(1624124960)")
("EOFを取得したい" . "(:ctime 1393749461 :cuser #f :mtime 1393749462 :muser #f)テストケースの作成等でEOFの挙動をテストしたい場合、空のストリームが必要になりますが、空のストリームは、[[$$hs make-concatenated-stream]]で0個のストリームを連結したり、[[$$hs make-string-input-stream]]に空文字列を与えることで作ることができます。\n{{{\n(read (make-concatenated-stream))\n;!! end of file on #<CONCATENATED-STREAM :STREAMS NIL {10293A1523}>\n;!!    [Condition of type END-OF-FILE]\n\n\n(read (make-string-input-stream \"\"))\n;!! end of file on #<SB-IMPL::STRING-INPUT-STREAM {1027C414E3}>\n;!!   [Condition of type END-OF-FILE]\n\n\n(let ((stream (make-concatenated-stream)))\n  (list (handler-case (read stream)\n          (end-of-file () \"eof\"))\n        (handler-case (read-line stream)\n          (end-of-file () \"eof\"))\n        (handler-case (read-char stream)\n          (end-of-file () \"eof\"))))\n;=>  (\"eof\" \"eof\" \"eof\")\n}}}\n")
("ltkの環境構築" . "(:ctime 1454336086 :cuser #f :mtime 1454336086 :muser #f)* 環境構築手順\n# Tcl/Tk の環境をインストールする\n-- 参考 : [https://www.tcl.tk/software/tcltk/ Tcl/Tk Software] (Tcl Developer Site)\n-- 2016 年現在：ActiveTcl が有力\n# LTK を Lisp環境で使用できるようにする\n{{{\n(ql:quickload :ltk)\n}}}\n\n* Hello World !\n{{{\n(ltk:with-ltk ()\n    (let ((b (make-instance 'ltk:button\n                            :master nil\n                            :text \"Press Me\"\n                            :command (lambda () (format t \"Hello World!~%\")))))\n      (ltk:pack b)))\n}}}\n\n{{{\n(ltk:with-ltk ()\n  (let ((b (make-instance 'ltk:button\n                          :text \"Press Me!\"\n                          :command\n                            (lambda () \n                               (ltk:do-msg \"Hello, World !\"\n                                           :title \"Welcome !\")))))\n    (ltk:pack b)))\n}}}\n\n* その他情報\nWindows 環境では、コマンドラインのTk シェルである wish をコマンドライン経由で呼び出しています。ですので、PATH環境変数の設定が必須です。\n")
(" %Tag:drakma?Tag?Tag:drakma?Tag" . "(1476570090)")
("条件式を指定したソート" . "(:ctime 1228809412 :cuser #f :mtime 1228809413 :muser #f)[[$$tag 配列]]\n\n* 条件式を指定したソート\n\n[[$$hs sort]] は比較の為の関数を取りますので、比較条件を任意に指定することが可能です。\n{{{\n(let ((v (vector \"Hitoshi,045\" \"Sizuo,046\" \"Yoshi,0138\")))\n  (flet ((getn (x) (1+ (position #\\, x))))\n    (sort v (lambda (x y)\n              (string< x y :start1 (getn x) :start2 (getn y))))))\n;=> #(\"Yoshi,0138\" \"Hitoshi,045\" \"Sizuo,046\")\n}}}\n")
("CL-TEST-MORE" . "(:ctime 1294028420 :cuser #f :mtime 1460644076 :muser #f)[[$$tag CL-TEST-MORE テストフレームワーク]]\n\nhttps://github.com/fukamachi/cl-test-more\n\n* 特徴\n\n- TAPでの結果出力\n- テストのスクリプトとしての実行をサポート\n\n* 概要\n\n{{{\n(require 'cl-test-more)\n;; or\n(load \"cl-test-more.lisp\")\n\n(in-package :cl-test-more)\n\n(plan 9)\n\n;; check if first argument is true\n(ok (eq got expected) \"Description\")\n\n;; check if \"got\" equals \"expected\"\n(is got expected \"Description\")\n(isnt got expected \"Description\")\n;; with :test function\n(is got expected \"Description\" :test #'string=)\n\n;; rather than print *standard-output* \"# This is just a comment\\n\"\n(diag \"This is just a comment\")\n\n;; macro expansion\n(is-expand (got macro) (expected :like \"this\") \"Description\")\n\n;; output\n(is-print (write-line \"aiueo\") \"aiueo\\n\" \"Description\")\n\n;; error\n(is-error (error \"hoge\") 'simple-error \"Description\")\n\n;; type\n(is-type 10 'number \"Description\")\n\n;; regular expression\n(like \"aiueo\" \"[iu]e\" \"Description\")\n\n;; functions always pass or fail\n(pass \"Description\")\n(fail \"Description\")\n\n;; grouping tests\n(deftest test-a\n  (is \"A\" (symbol-name :a))\n  (isnt \"b\" (symbol-name :b)))\n\n(run-test :test-a)\n(run-test-all)\n}}}\n\n* インストール\n\nQuicklisp([[Quicklispを使う]])でインストールできます。\n\n{{{\n(ql:quickload :cl-test-more)\n}}}\n\n* テストの書き方\n\n- ok\n- is\n- isnt\n- is-expand\n- is-print\n- is-error\n- is-type\n- like\n- diag\n- pass\n- fail\n- plan\n- run-test\n- run-test-all\n\n* スクリプトとしての実行\n\n[http://tips.lisp-users.org/common-lisp/index.cgi?%e3%82%b9%e3%82%af%e3%83%aa%e3%83%97%e3%83%88%e3%81%ae%e5%ae%9f%e8%a1%8c スクリプトとして実行]する場合、通常の実行と以下の点で異なります。\n\n- 終了時に自動で結果を集計、表示\n- 途中でエラーが出たときにデバッガを表示せず終了\n- planでテストの数を指定しておけば、テストが正常通りにすべて実行されたかを確認できる\n\nこの実行形式の場合、run-test-allは必要ありません。Allegro CL, SBCL, CMUCL, Clozure CL, ECL, CLISPでサポートされています(他の処理系の場合はrun-test-allが必要です)。\n\n* その他\n\n** デフォルトのテスト関数を指定する\n\nテスト関数はデフォルトで\"equal\"を使ってテストします。このデフォルトの比較関数は*default-test-function*で定義されており、自由に設定することができます。\n")
("指定id属性の値をもつ要素を探す:plexippus-xpath" . "(:ctime 1336648193 :cuser #f :mtime 1336648193 :muser #f)下記の例では、属性idの値が'x'の要素を探します。~%\n\nライブラリの導入方法\n{{{\n(ql:quickload :xpath)\n}}}\nXML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"<a xmlns='http://tips.lisp-users.org/common-lisp'><b>1</b><b id='x'>1</b><b id='y'>9</b><c>2</c></a>\"\n   (stp:make-builder)))\n}}}\n{{{\n(xpath:with-namespaces ((\"x\" (stp:namespace-uri (stp:document-element *doc*))))\n  (dolist (e (xpath:all-nodes (xpath:evaluate \"//x:b[@id='x']\" *doc*)))\n    (format t\n            \"~A[@id='~A'] => ~A~%\"\n            (stp:local-name e)\n            (stp:attribute-value e \"id\")\n            (stp:string-value e))))\n;->  b[@id='x'] => 1\n;\n;=>  NIL\n}}}\n")
(" %Tag:日付と時刻2121121121212.1" . "(1532959354)")
(" %Tag:cl-interpol?Tag?Tag:cl-interpol?Tag" . "(1476570451)")
("XMLハンドリング" . "(:ctime 1336639162 :cuser #f :mtime 1363449148 :muser #f)[[$$include XML]]\n")
("関数に別名をつけたい" . "(:ctime 1228257394 :cuser #f :mtime 1418666222 :muser #f)プログラミングをするなかで、問題領域にあわせた語彙を使った方がコードが読みやすい場合があります。そういうときは、関数を別名で呼ぶことができると便利です。\n\n例えば、find-all-ifという語彙を使いたいとします。ただし機能的には、ANSIの[[$$hs remove-if-not]]という関数と同等だとしましょう。そんなときは、シンボル間で関数定義をコピーすればOKです。\n\n{{{\n(remove-if-not #'evenp '(1 2 3 4 5))\n;=> (2 4)\n\n(setf (symbol-function 'find-all-if) #'remove-if-not)\n;=> #<Function REMOVE-IF-NOT>\n\n(find-all-if #'evenp '(1 2 3 4 5))\n;=> (2 4)\n}}}\n\n")
(" %Tag:cl-cron'[0]" . "(1665785550)")
("コメント" . "(:ctime 1227971104 :cuser #f :mtime 1227971659 :muser #f)[[$$tag コーディングスタイル]]\n\n* コメント\n大体の慣習は下記の様なスタイルです。\n{{{\n;;;; 4つはタイトルや\n;;;; セクションヘッダに対して使用\n\n;;; 3つは、関数や、ブロックに使用\n(cond ((atom x) \"atom!\")\t\t; アトムか? (1つは、インラインコメントに使用)\n      ((listp x) \"list!\")\t\t; リストか?\n      ;; 上記以外のすべて (2つはインデントを合せてフォームに使用)\n      (t (cons x)))\n}}}\n\n* 参考文献\n- [http://www.lispworks.com/documentation/HyperSpec/Body/02_ddb.htm HyperSpec/Notes about Style for Semicolon]\n- [[COMMON LISP 第2版]] P464\n\n")
(" %Tag:テストフレームワーク'[0]" . "(1666819061)")
("処理時間の計測" . "(:ctime 1460646274 :cuser #f :mtime 1460646274 :muser #f)* 実行時間の測定\ntime 関数によって、フォームの評価が完了するまでのに要した時間を計測することができます\n\n{{{\n(defun tarai (x y z)\n  (if (<= x y)\n      y\n      (tarai\n        (tarai (1- x) y z)\n        (tarai (1- y) z x)\n        (tarai (1- z) x y))))\n\n* (time (tarai 12 6 0))\n\nEvaluation took:\n  0.087 seconds of real time\n  0.078125 seconds of total run time (0.078125 user, 0.000000 system)\n  89.66% CPU\n  312,811,374 processor cycles\n  0 bytes consed\n\n12\n}}}\n\n\n* 参考リンク\n- [https://sites.google.com/site/shidoinfo/Home/programing-lang/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E/lisp/common-lisp/common-lisp-%E5%87%A6%E7%90%86%E7%B3%BB Common Lisp 処理系]\n- [https://ja.wikipedia.org/wiki/%E7%AB%B9%E5%86%85%E9%96%A2%E6%95%B0 竹内関数(たらいまわし関数)]\n- [http://www.geocities.jp/m_hiroi/clisp/ 実行環境ごとの所要時間例]\n")
(" %Tag:????\" and \"x\"=\"y" . "(1587484320)")
("2進数・8進数・16進数で数値を扱うには" . "(:ctime 1227836450 :cuser #f :mtime 1227836450 :muser #f)[[$$tag 数値]]\n* 2進数・8進数・16進数で数値を扱うには\n2進数、8進数、16進数は以下のように記述します。\n{{{\n#b10000 ;=> 16\n#o20    ;=> 16\n#x10    ;=> 16\n}}}\n")
("ハッシュを値で降順、値が等しい場合キーで昇順にソートする" . "(:ctime 1227413847 :cuser #f :mtime 1380443347 :muser #f)[[$$tag ハッシュ]]\n* ハッシュを値で降順、値が等しい場合キーで昇順にソートする\nCommon Lispのハッシュテーブルは順番付きハッシュテーブルではありませんので、ハッシュテーブルの要素がソート可能である必要がありません。~%\n「ソートされたハッシュ」は存在しませんが、plistなどの形で出力することは可能です。~%\n※[[ライブラリ:Alexandria]]を利用\n{{{\n(defun hash-table-top-n-values (table predicate &key (key #'car))\n  \"Returns sorted entries from hash table TABLE.\"\n  (sort (alexandria:hash-table-alist table) predicate :key key))\n}}}\n実行\n{{{\n(hash-table-top-n-values (alexandria:alist-hash-table\n                          (pairlis '(1 2 3 4 5 6) '(b a b d e c)))\n                         #'<\n                         :key #'car)\n;=>  ((1 . B) (2 . A) (3 . B) (4 . D) (5 . E) (6 . C))\n}}}\n標準のsortには比較値が等しかった場合の挙動の規定はなく値が等しいときにキーで昇順にソートはライブラリを利用するか自作することになるでしょう。\n{{{\n;;; Perl/Rubyの<=>演算子風。等しい場合は、0\n;;;  第一引数の方が小さい場合には負値、大きい場合は正値を返す\n\n(defmethod <=> ((x string) (y string) &optional (factor 1))\n  (* (cond ((string= x y) 0)\n           ((string< x y) -1)\n           (T 1))\n     factor))\n\n\n(defmethod <=> ((x symbol) (y symbol) &optional (factor 1))\n  (* (cond ((string= x y) 0)\n           ((string< x y) -1)\n           (T 1))\n     factor))\n\n\n(defmethod <=> ((x number) (y number) &optional (factor 1))\n  (* (cond ((= x y) 0)\n           ((< x y) -1)\n           (T 1))\n     factor))\n\n\n(defun <=>sort (sequence predicate &key (key #'values))\n  (sort sequence (lambda (x y)\n                   (<= 0 (funcall predicate \n                                  (funcall key x)\n                                  (funcall key y))))\n        :key key))\n}}}\n実行\n{{{\n(defvar *table* (alexandria:alist-hash-table \n                 '((6 . C) (5 . E) (4 . D) (3 . B) (2 . A) (1 . B))))\n\n\n;;; 値は降順、キーは昇順 ((キー . 値) ...)\n(<=>sort (alexandria:hash-table-alist *table*)\n         (lambda (X Y) \n           (+ (<=> (cdr X) (cdr Y) 2) ;キーを優先(降順)\n              (<=> (car Y) (car X)))))\n;=>  ((5 . E) (4 . D) (6 . C) (1 . B) (3 . B) (2 . A))\n\n\n;;; 値、キーともに降順 \n(<=>sort (alexandria:hash-table-alist *table*)\n         (lambda (x y) \n           (+ (<=> (cdr x) (cdr y) 2) ;キーを優先(降順)\n              (<=> (car x) (car y)))))\n;=>  ((5 . E) (4 . D) (6 . C) (3 . B) (1 . B) (2 . A))\n}}}\n")
(" %Tag:SBCL" . "(1668286764 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f) (\"処理系:日本語の扱い\" :ctime 1529826517 :cuser #f :mtime 1529826517 :muser #f))")
("ネットワーク" . "(:ctime 1329736423 :cuser #f :mtime 1329736423 :muser #f)[[$$tag 【募集中】]]\n")
("CLISP" . "(:ctime 1553196191 :cuser #f :mtime 1553196191 :muser #f)+ 2 3\n")
(" %Tag:local-time'nvOpzp" . "(1666810856)")
(" %Tag:weblocks" . "(1521643064)")
(" %Tag:url-rewrite'" . "(1490531391)")
(" %Tag:正規表現'[0]" . "(1590369020)")
(" %Tag:CL-TEST-MORE999999.1 union select unhex(hex(version())) -- and 1=1" . "(1582882545)")
(" %Tag:CMUCL" . "(1668163697 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f) (\"処理系:日本語の扱い\" :ctime 1529826517 :cuser #f :mtime 1529826517 :muser #f))")
(" %Tag:配列'/**/AND/**/SlEEp(3)/**/AND/**/'1" . "(1624125092)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 80 #" . "(1624125151)")
("何日後、何日前/何ヶ月後、何ヶ月前の日付を求める" . "(:ctime 1227414763 :cuser #f :mtime 1370595615 :muser #f)[[$$tag 日付と時刻]]\n* 何日後、何日前/何ヶ月後、何ヶ月前の日付を求める\nUniversal Timeは秒数を表す数値なので、加減算は自由にできます。\n{{{\n;; 2000/1/1の100日後を求める\n(+ (encode-universal-time 0 0 0 1 1 2000)\n   (* 100 24 60 60))\n;=> 3164281200\n\n(metatilities:date-string-brief 3164281200)\n\"4-10-2000\"\n}}}\n")
("読み取り時のデフォルトの浮動小数点の精度を指定する" . "(:ctime 1328578994 :cuser #f :mtime 1328579022 :muser #f)[[$$tag 数値]]\n\n[[$$hs *read-default-float-format*]] に型を指定することにより可能です\n{{{\n(let ((*read-default-float-format* 'double-float))\n  (read-from-string \"(1.0 1.0s0)\"))\n;=>  (1.0d0 1.0)\n;    11\n\n\n(let ((*read-default-float-format* 'single-float))\n  (read-from-string \"(1.0 1.0d0)\"))\n;=>  (1.0 1.0d0)\n;    11\n}}}\n")
("ハッシュの全エントリに対して処理を実行する" . "(:ctime 1227413710 :cuser #f :mtime 1229517972 :muser #f)[[$$tag ハッシュ]]\n* ハッシュの全エントリに対して処理を実行する\n専用の構文maphashがあります。他loop等でも処理が可能です。\nまた、このような処理の構文を自作したい場合には、with-hash-table-iteratorを利用します。\n{{{\n(let ((ht (make-hash-table :test #'equal))\n      (default 100))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (maphash (lambda (key val)\n             (format t \"key => ~A, val => ~A~%\" key val))\n           ht))\n\n;-> key => apple, val => 150\n    key => banana, val => 300\n    key => lemon, val => 300\n;=> nil\n}}}\n\n{{{\n;; ht は上の例のハッシュテーブルと同じもの。\n(loop for key being the hash-keys in ht\n      using (hash-value val)\n      do (format t \"key => ~A, val => ~A~%\" key val))\n}}}\n")
(" %Tag:local-time' or (1=2) and 'a'='a" . "(1660041623)")
(" %Tag:パッケージ'" . "(1587554412)")
(" %Tag:テスト" . "(1668216747 (\"FiveAM\" :ctime 1460645375 :cuser #f :mtime 1660192441 :muser #f))")
("オブジェクトシステム(CLOS)" . "(:ctime 1227412906 :cuser #f :mtime 1546121842 :muser #f)* 定義・作成・削除\n- [[クラスを定義する]]\n- [[メソッドを定義するには]]\n- [[オブジェクトの初期化を行う]]\n- [[定義したメソッドを削除するには]]\n- [[インスタンス初期化時に複数のスロットを同じ値で埋めたい]]\n- [[インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい]]\n- [[ディスパッチ目的のインスタンスを都度生成しない]]\n\n* インスタンス変数・スロット\n- [[クラスに必須スロットを設定する]]\n- [[同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい]]\n- [[オブジェクトのスロットの値をまとめて変更する]]\n- [[インスタンス変数・クラス変数を定義する]]\n- [[インスタンス変数へアクセスするメソッドを簡単に定義する]]\n- [[インスタンスからスロット名を取得する]]\n\n* メソッド\n- [[メソッドの可視性を定義する]]\n- [[メソッド引数のクラス判定の順番を通常の逆向きにする]]\n\n* 継承\n- [[スーパークラスのメソッドを呼び出す]]\n- [[定義されていないスーパクラスメソッドの呼び出しを防ぎたい]]\n- [[サブクラス関係かどうか判定する]]\n\n\n* 高度な話題\n- [[インスタンス生成を記録しておき後で条件を満すものを抽出したい]]\n- [[匿名クラスをつくりたい]]\n- [[オブジェクトの印字方法をカスタマイズする]]\n- [[初回の起動でしか実行されないフックを作成したい]]\n\n* その他\n- [[CLOSの読みはシーロスとクロスどちらが正しいか]]\n- [[CLIMの読みはシーリムとクリムどちらが正しいか]]\n")
(" %Tag:puri" . "(1667934175 (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
(" %Tag:cl-json" . "(1668200452 (\"JSONのパース・生成\" :ctime 1346850276 :cuser #f :mtime 1346932427 :muser #f))")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45) --  /*" . "(1624124475)")
(" %Tag:【募集中】'" . "(1572020291)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 641 #" . "(1624125305)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45),CHAR(45,120,50,53,45,81,45) --  /*" . "(1624124497)")
("FiveAM" . "(:ctime 1460645375 :cuser #f :mtime 1660192441 :muser #f)[[$$tag ライブラリ テスト FiveAM]]\n\n[https://fiveam.common-lisp.dev/ FiveAM]はシンプルな[http://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%83%86%E3%82%B9%E3%83%88#.E5.8D.98.E4.BD.93.E3.83.86.E3.82.B9.E3.83.88.E3.81.A8.E7.B5.90.E5.90.88.E3.83.86.E3.82.B9.E3.83.88 ユニットテスト]フレームワークです。\n\n- テストスイートによるテストの階層化\n- テスト同士の依存関係を定義できる\n- 対話的なインターフェイスのサポート\n- [http://www.cse.chalmers.se/~rjmh/QuickCheck/ QuickCheck]式のSpecification-based testingへの対応\n\nといった特徴があります。\n\n----\n\n[[$$toc]]\n\n----\n\n* 導入方法\nQuicklispに登録されています ([[Quicklispを使う]])\n\n{{{\n(ql:quickload 'fiveam)\n}}}\n\n\n\n* 利用例\n\n{{{\n> (5am:test add-2\n    \"ADD-2関数のテスト\"   ; 短かい説明\n    ;; チェックする内容\n    (5am:is (= 2 (add-2 0)))\n    (5am:is (= 0 (add-2 -2))))\nADD-2\n> (5am:run! 'add-2)\n..\n Did 2 checks.\n    Pass: 2 (100%)\n    Skip: 0 ( 0%)\n    Fail: 0 ( 0%)\n\nNIL\n>\n}}}\n\n----\n\n* テストの定義\n\n[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003ATEST.html 5am:test]マクロによってテストを定義できます。\n\n{{{\n(5am:test identity\n  \"Test for cl:identity.\"\n  (5am:is (zerop (identity 0))))\n}}}\n\n最初の引数はテストに付ける名前で、それ以降はテストの処理の本体です。また、[[$$hs defun]]などと同じで、処理の前にテストの説明を書くことができます。この説明はテストが失敗されたときに表示されます。\n\n{{{\n> (5am:test with-description \"Description\" (5am:fail \"Failed\"))\nWITH-DESCRIPTION\n> (5am:test without-description (5am:fail \"Failed\"))\nWITHOUT-DESCRIPTION\n> (5am:run! '(with-description without-description))\nff\n Did 2 checks.\n    Pass: 0 ( 0%)\n    Skip: 0 ( 0%)\n    Fail: 2 (100%)\n\n Failure Details:\n --------------------------------\n WITHOUT-DESCRIPTION []: \n      Failed.\n --------------------------------\n --------------------------------\n WITH-DESCRIPTION [Description]: \n      Failed.\n --------------------------------\n\nNIL\n>\n}}}\n\n** アサーション\n\n以下のようなアサーションが定義されています。\n\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003AIS.html 5am:is]:\n渡された式が真になるときに成功する\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003ASKIP.html 5am:skip]:\nスキップする\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003AIS-TRUE.html 5am:is-true]:\n渡された式が真になるときに成功する。失敗した場合のメッセージに5am:isと差がある\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003AIS-FALSE.html 5am:is-false]:\n渡された式が偽になるときに成功する\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003ASIGNALS.html 5am:signals]:\n指定されたコンディションが発生すると成功する\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003AFINISHES.html 5am:finishes]:\n渡された式が最後まで実行できた場合に成功する\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003APASS.html 5am:pass]:\n常に成功する\n:[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003AFAIL.html 5am:fail]:\n常に失敗する\n\n具体的な使用例です。\n\n;; TODO: もっと例を増やす\n\n{{{\n;; symbolがキーワードのときに成功する\n(5am:is-true (keywordp symbol))\n(5am:is (equal \"KEYWORD\" (package-name (symbol-package symbol))))\n\n;; does-not-existというファイルが存在しない場合に成功する\n(5am:is-false (probe-file #p\"does-not-exist\"))\n(5am:signals file-error (close (open #p\"does-not-exist\")))\n}}}\n\n** コンパイルのタイミング\n\n特に指定しない限り、テストの処理の本体は、テストを実行するときに初めてコンパイルされますが、テストを定義する時点でコンパイルしてしまうこともできます。ローカルな変数や関数を利用するときに便利です。\n\n{{{\n;; ローカルな関数を利用する例\n(flet ((ref (fn)\n         (5am:is (eql #\\b (funcall fn \"abc\" 1)))))\n  (5am:test (char :compile-at :definition-time)\n    (ref #'char))\n  (5am:test (elt :compile-at :definition-time)\n    (ref #'elt)))\n}}}\n\nこのように、テストの名前を「(名前 :compile-at :definition-time)」という形にすることで、コンパイルのタイミングを指定できます。\n\n----\n\n* テストの階層化\n\nテストスイートを定義することでテストを階層化できます。スイートの仕組みはパッケージに良く似ていて、[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003ADEF-SUITE.html 5am:def-suite]マクロでスイートを定義して、[http://common-lisp.net/project/bese/docs/fiveam/api/macro_005FIT.BESE.FIVEAM_003A_003AIN-SUITE.html 5am:in-suite]マクロで現在のスイートを切り替えるようになっています。\n\n{{{\n;; すべてのテストが属するallというスイートを定義する\n(5am:def-suite all)\n\n;; allに属するsuite-aとsuite-bというスイートを定義する\n(5am:def-suite suite-a :in all)\n(5am:def-suite suite-b :in all)\n\n;; suite-aに属するaというテストを定義する\n(5am:in-suite suite-a)\n(5am:test a \"Test A\" (5am:pass))\n\n;; suite-bに属するbというテストを定義する\n(5am:in-suite suite-b)\n(5am:test b \"Test B\" (5am:fail))\n}}}\n\n5am:def-suiteと5am:in-suiteの組み合わせは良く使われるので、同じ処理をする5am:def-suite*というマクロが定義されています。\n\n{{{\n;;; 上と同等の例をdef-suite*で\n\n(5am:def-suite all)\n\n(5am:def-suite* suite-a :in all)\n(5am:test a \"Test A\" (5am:pass))\n\n(5am:def-suite* suite-b :in all)\n(5am:test b \"Test B\" (5am:fail))\n}}}\n\n----\n\n* テストの実行\n\n定義したテストやスイートを実行する場合、基本的に[http://common-lisp.net/project/bese/docs/fiveam/api/function_005FIT.BESE.FIVEAM_003A_003ARUN_0021.html 5am:run!]という関数を利用します。これは、指定に従ってテストを実行し、テストの結果をわかりやすく表示するという、ユニットテストで幾度となく繰り返される処理を組み合わせたものです。\n\n{{{\n> (5am:run!)\n..\n Did 2 checks.\n    Pass: 2 (100%)\n    Skip: 0 ( 0%)\n    Fail: 0 ( 0%)\n\nNIL\n>\n}}}\n\n標準では、検査が成功するごとにドット（.）が表示され、失敗するごとにfが表示されます。テストコードでエラーが発生した場合はXが表示されます。すべてのテストが終了するか、途中でテストが中断されるまでこれは繰り返され、それが終わるとテスト結果の集計が表示されます。\n\n5am:run!で何を実行するかは引数を渡すことで指定できます。テストやスイートに関連付けられたシンボル、テストやスイートのオブジェクト、それらのシンボルやオブジェクトを要素とするリストがサポートされています。\n\n{{{\n;; xというシンボルに関連付けられたテストあるいはスイートを実行する\n(5am:run! 'x)\n\n;; xとyというシンボルに関連付けられたテストあるいはスイートを実行する\n(5am:run! '(x y))\n}}}\n\n引数が省略された場合、現在のスイートに属するテストが実行されます。\n\n** 対話的なインターフェイス\n\n*** デバッガとの連携\n\nテストを実行するとき、標準ではテストが失敗したりテストコードでエラーが発生した場合でも、デバッガに入ることはありません。この動作を変えたい場合、[http://common-lisp.net/project/bese/docs/fiveam/api/variable_005FIT.BESE.FIVEAM_003A_003A_002ADEBUG-ON-FAILURE_002A.html 5am:*debug-on-failure*]と[http://common-lisp.net/project/bese/docs/fiveam/api/variable_005FIT.BESE.FIVEAM_003A_003A_002ADEBUG-ON-ERROR_002A.html 5am:*debug-on-error*]というスペシャル変数の値を変更します。\n\n{{{\n> (5am:run!)\nf\n Did 1 check.\n    Pass: 0 ( 0%)\n    Skip: 0 ( 0%)\n    Fail: 1 (100%)\n\n Failure Details:\n --------------------------------\n B [Test B]: \n      no reason given.\n --------------------------------\n\nNIL\n> (let ((5am:*debug-on-failure* t)) (5am:run!))\nThe following check failed: NIL\nno reason given.\n   [Condition of type IT.BESE.FIVEAM::CHECK-FAILURE]\n\nRestarts:\n 0: [IGNORE-FAILURE] Continue the test run.\n 1: [RETEST] Rerun the test #<TEST-CASE B #x30200132055D>\n 2: [IGNORE] Signal an exceptional test failure and abort the test #<TEST-CASE B #x30200132055D>.\n 3: [EXPLAIN] Ignore the rest of the tests and explain current results\n 4: [RETRY] Retry SLIME REPL evaluation request.\n 5: [*ABORT] Return to SLIME's top level.\n...\n}}}\n\nなお、この機能を簡単に利用できるように、5am:*debug-on-error*と5am:*debug-on-failure*をtにした状態で5am:run!を呼ぶ5am:debug!という関数が定義されています。\n\n*** 再実行\n\n直前三回分のテストの実行を、[http://common-lisp.net/project/bese/docs/fiveam/api/function_005FIT.BESE.FIVEAM_003A_003A_0021.html 5am:!]、[http://common-lisp.net/project/bese/docs/fiveam/api/function_005FIT.BESE.FIVEAM_003A_003A_0021_0021.html 5am:!!]、[http://common-lisp.net/project/bese/docs/fiveam/api/function_005FIT.BESE.FIVEAM_003A_003A_0021_0021_0021.html 5am:!!!]という関数で繰り返すことができます。5am:!が一番新しく、5am:!!!が一番古いものです。\n\n----\n\n* Specification-based testing\n\nテストするデータを自動的に生成できます。ユーザ定義のジェネレータを使うこともできます。\n\n{{{\n> (defun plus (a b) (+ a b))\nPLUS\n> (5am:test plus\n    (5am:for-all ((a (5am:gen-integer))\n                  (b (5am:gen-integer)))\n      (5am:is (= (+ a b) (plus a b)))\n      (5am:is (= (plus a b) (plus b a)))\n      (5am:is (= a (plus a 0)))\n      (5am:is (= 0 (plus a (- a))))\n      (5am:is (< a (plus a 1)))\n      (5am:is (= (* 2 a) (plus a a)))))\nPLUS\n> (5am:run! 'plus)\n...............................................................................\n...............................................................................\n...............................................................................\n...............................................................................\n...............................................................................\n...............................................................................\n...............................................................................\n................................................\n Did 1 check.\n    Pass: 1 (100%)\n    Skip: 0 ( 0%)\n    Fail: 0 ( 0%)\n\nNIL\n}}}\n\n----\n\n* 参考資料\n\n* 参考リンク\n- [https://common-lisp.net/project/fiveam/ FiveAM] : 公式\n- [http://qiita.com/g000001/items/c02a549eb80b7d9c30a7 fiveam] : ASDFとの連携\n- [http://www.cliki.net/fiveam CLiki:FiveAM]\n")
(" %Tag:配列" . "(1668191481 (\"多次元配列の要素をランダムに抽出する\" :ctime 1612437944 :cuser #f :mtime 1612437979 :muser #f) (\"配列\" :ctime 1228095119 :cuser #f :mtime 1612437813 :muser #f) (\"一致する要素を全て取り除く\" :ctime 1228100675 :cuser #f :mtime 1370593874 :muser #f) (\"配列から重複した要素を取り除く\" :ctime 1228889087 :cuser #f :mtime 1363964743 :muser #f) (\"複数の要素を変更する\" :ctime 1228748252 :cuser #f :mtime 1362976185 :muser #f) (\"配列要素をカンマ区切りで出力する\" :ctime 1228099965 :cuser #f :mtime 1362956728 :muser #f) (\"配列を縮小したい\" :ctime 1336360974 :cuser #f :mtime 1336360989 :muser #f) (\"指定した長さの配列を作成する\" :ctime 1284803879 :cuser #f :mtime 1284804196 :muser #f) (\"配列をリストに変換する\" :ctime 1234352506 :cuser #f :mtime 1234352916 :muser #f) (\"多次元の配列を1つのインデックスで扱う\" :ctime 1233973763 :cuser #f :mtime 1234161455 :muser #f) (\"指定した位置の要素を取り除く\" :ctime 1229191528 :cuser #f :mtime 1229256880 :muser #f) (\"プログラムで配列を定義する\" :ctime 1229189109 :cuser #f :mtime 1229232047 :muser #f) (\"配列の配列をフラットな配列にする\" :ctime 1228982740 :cuser #f :mtime 1228982771 :muser #f) (\"配列の配列を検索する\" :ctime 1228981495 :cuser #f :mtime 1228981573 :muser #f) (\"配列から指定条件を満たす要素を取り除く\" :ctime 1228980663 :cuser #f :mtime 1228980664 :muser #f) (\"配列中の要素を探す\" :ctime 1228889710 :cuser #f :mtime 1228889710 :muser #f) (\"条件式を指定したソート\" :ctime 1228809412 :cuser #f :mtime 1228809413 :muser #f) (\"配列の要素をランダムに抽出する\" :ctime 1228749208 :cuser #f :mtime 1228749208 :muser #f) (\"配列を空にする\" :ctime 1228630645 :cuser #f :mtime 1228630645 :muser #f) (\"部分配列を取りだす\" :ctime 1228629635 :cuser #f :mtime 1228629814 :muser #f) (\"配列の先頭または末尾から要素を取りだす\" :ctime 1228558271 :cuser #f :mtime 1228558271 :muser #f) (\"配列に要素を追加する\" :ctime 1228549816 :cuser #f :mtime 1228549869 :muser #f) (\"配列の要素数を取得する\" :ctime 1228547522 :cuser #f :mtime 1228547523 :muser #f) (\"配列を逆順にする\" :ctime 1228464721 :cuser #f :mtime 1228464722 :muser #f) (\"配列同士の和・差・積を取る\" :ctime 1228453798 :cuser #f :mtime 1228453798 :muser #f) (\"配列同士を結合する\" :ctime 1228193096 :cuser #f :mtime 1228193097 :muser #f) (\"配列を任意の値で埋める\" :ctime 1228105446 :cuser #f :mtime 1228112194 :muser #f) (\"配列をソートする\" :ctime 1228095583 :cuser #f :mtime 1228112150 :muser #f) (\"配列の各要素に関数を適用し配列を作成する\" :ctime 1228101170 :cuser #f :mtime 1228112053 :muser #f) (\"配列の各要素に対して関数を適用する\" :ctime 1228103803 :cuser #f :mtime 1228111982 :muser #f))")
("ファイルに書き込む" . "(:ctime 1227946735 :cuser #f :mtime 1363819506 :muser #f)[[$$tag 入出力]]\n* ファイルに書き込む\n[[$$hs with-open-file]] マクロで :direction :output を指定してファイルをオープンします。既にあるファイルを上書きする場合は :if-exists :supersede を指定します。ファイルをオープンしたら [[$$hs write-line]] や [[$$hs format]] でファイルに出力します。\n{{{\n(with-open-file (out \"/tmp/a.txt\" :direction :output :if-exists :supersede)\n  (write-line \"Hello\" out)\n  (format out \"~:d\" 1000))\n}}}\n")
(" %Tag:Alexandria" . "(1668278263 (\"ハッシュをシーケンス(alist、plist、その他)に変換する\" :ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f))")
("基本的構成を確立する" . "(:ctime 1252242002 :cuser #f :mtime 1252324555 :muser #f)[[$$tag eli]]\n* 基本的構成を確立する\n- eli は the Emacs-Lisp Interface の略で、Franz社が提供するLisp統合開発環境です。\n- 処理系は Allegro Common Lisp のみに対応しています。\n- Emacs は GNU Emacs (18 以降) と XEmacs に対応しているようです。\n- このエントリでは eli の基本的な構成を確立する手順を説明します。\n- [http://www.franz.com/support/documentation/8.1/doc/eli.htm 公式マニュアル] も提供されていますので、このエントリの主な価値は日本語で書いてあるということです。\n** 取得と配置\n- Allegro Common Lisp の配布に同梱されています。EmacsWiki等での提供は、このエントリ執筆時点では存在しません。\n- Allegro Common Lisp をインストールしたディレクトリの中に、eliディレクトリとxeliディレクトリがあり、ここにフラットにelispファイルが存在します。xeliディレクトリの中身は、ほとんどがeliディレクトリの中のファイルへのシンボリックリンクです。\n- 結局、Allegro Common Lisp の取得と配置以外は何もしなくてもOKです。\n** 設定\n- .emacs などの Emacs 初期化ファイルに次の行を加えます。\n{{{\n;; Allegro Common Lisp を配置した位置を/usr/local/acl181とします。\n;; Emacs の場合\n(load \"/usr/local/acl81/eli/fi-site-init\")\n;; XEmacs の場合\n(load \"/usr/local/acl81/xeli/fi-site-init\")\n}}}\n\n** REPLの起動と終了\n- REPL の起動は、M-x fi:common-lisp でOKです。REPL 起動時に Lisp image ファイル等を聞かれますので、入力します。入力のデフォルト値を指定しておくには、.emacs等で、\n{{{\n  (setq fi:common-lisp-image-name \"/usr/local/acl81/alisp\")\n  (setq fi:common-lisp-image-file \"/usr/local/acl81/alisp.dxl\")\n  (setq fi:common-lisp-directory \"~/tmp/\")\n}}}\nなどと指定しておきます。いつも同じならば、「もうちょっと整備するときは」のところのexamplesにあるように run-common-lisp を定義してしまうのがよいでしょう。\n- この手順の場合、Common Lisp は Emacs のサブプロセスとして起動されます。\n\n- REPLの終了は、REPL 上で :exit と入力します。\n- REPL 起動時の引数指定は、Emacs を再起動するかしない限り、残りつづけます。なので、M-x fi:common-lisp とすると対話なしに、以前指定した指定で Lisp が起動します。例えば、mlisp に切り替えるためなど起動時引数を変更することがREPL再起動の目的である場合は、C-u M-x fi:common-lisp としてください。再度対話的に起動できます。\n\n** モードについて\n- fi:common-lisp で起動したREPL（バッファ）のメジャーモードは、Inferior Common Lisp モードになります。\n- eli にはたくさんのモードが用意されています。一覧は次のとおりです。\n{{{\nfi:inferior-common-lisp-mode\nfi:lisp-listener-mode\nfi:common-lisp-mode\nfi:definition-mode\nfi:inverse-definition-mode\nfi:scan-stack-mode\nfi:shell-mode\nfi:su-mode\nfi:remote-su-mode\nfi:telnet-mode\nfi:rlogin-mode\n}}}\n- この中でもっとも利用頻度が高いのは、fi:common-lisp-mode でしょう。Lisp のソースファイルを編集するためのメジャーモードです。\n** fi:common-lisp-mode について\n- 編集対象である Common Lisp ソースファイルの解釈について EmacsとLispが間違いなくコミュニケーションするために、package と readtable を指定することが可能です。\n- 特段指定しなくとも、package については、Emacs が Common Lisp ソースファイルをパースして、(in-package ...) というマクロの存在を関知して自動的に設定してくれますので、問題なく動作します。\n- 指定には Emacs の mode specification (別名 file mode line) を使います。フルに指定する例は次のとおりです。\n{{{\n;; -*- mode: fi:common-lisp-mode; package: mypack; readtable: myrt -*-\n(in-package :mypack)\n(eval-when (compile \n            load\n            eval)\n  (setq *readtable* (named-readtable :myrt)))\n}}}\n** 各種マイナーモードとの相性\n- Paredit、Show-Paren、Yas/Minor、Auto-Complete 等と一緒に使ったところ、気になる衝突はありませんでした。\n- Redshank は、C-c C-s が衝突しているので調整が必要です。\n\n - Inferior Common Lisp mode : C-c C-s fi:re-search-forward-input\n - Common Lisp mode : C-c C-s fi:lisp-eval-or-compile-last-sexp\n - Redshank mode : C-c C-s redshank-complete-form\n\n** もうちょっと整備するときは\n- eli/examples/emacs.el misc/dot-emacs.elに .emacs のちょっと便利な設定例があり、参考になります。\n")
("指定パスの要素だけ取り出したい:cxml-stp" . "(:ctime 1336734222 :cuser #f :mtime 1336734222 :muser #f)このページでは、[[CLiki:plexippus-xpath]]を組み合せる例を紹介しています~%\n** ライブラリの導入方法\n{{{\n(ql:quickload :xpath)\n}}}\nXML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"<a><b><c>1</c></b></a>\"\n   (stp:make-builder)))\n}}}\nxpathで/a/b/cを探す\n{{{\n(stp:string-value (xpath:first-node (xpath:evaluate \"/a/b/c\" *doc*)))\n;=>  \"1\"\n}}}\nxpathは使わず、cxml-stpパッケージの関数のみでの実現\n{{{\n(flet ((fc (name parent)\n         (stp:find-child name parent :key #'stp:local-name :test #'string=)))\n  (stp:string-value (fc \"c\" (fc \"b\" (fc \"a\" *doc*)))))\n;=>  \"1\"\n}}}\n")
(" %Tag:シーケンス" . "(1668305982 (\"文字列の先頭・末尾の空白を削除する\" :ctime 1227347967 :cuser #f :mtime 1430348911 :muser #f) (\"文字列を結合する\" :ctime 1227347577 :cuser #f :mtime 1399135818 :muser #f) (\"文字列を一文字ずつ処理する\" :ctime 1227347873 :cuser #f :mtime 1397795628 :muser #f) (\"文字列\" :ctime 1227101219 :cuser #f :mtime 1362794135 :muser #f) (\"文字列を分割する\" :ctime 1280337523 :cuser #f :mtime 1349988541 :muser #f) (\"文字列を数値に変換する\" :ctime 1227348006 :cuser #f :mtime 1347932412 :muser #f) (\"文字列を一行ずつ処理する\" :ctime 1227347907 :cuser #f :mtime 1328603849 :muser #f) (\"大文字・小文字に揃える\" :ctime 1227347707 :cuser #f :mtime 1328603013 :muser #f) (\"文字列を複製する\" :ctime 1237899752 :cuser #f :mtime 1313504154 :muser #f) (\"文字列の一致部分を判定する\" :ctime 1237902595 :cuser #f :mtime 1313438317 :muser #f) (\"部分文字列を取り出す\" :ctime 1227347845 :cuser #f :mtime 1313435703 :muser #f) (\"文字列を1文字ずつに分ける\" :ctime 1282412075 :cuser #f :mtime 1313400711 :muser #f))")
("文字列" . "(:ctime 1227101219 :cuser #f :mtime 1362794135 :muser #f);; -*- outline -*-\n[[$$tag 文字列 シーケンス]]\n- [[文字列を作成する]]\n- [[文字列を複製する]]\n- [[文字列を比較する]]\n- [[文字列を結合する]]\n- [[文字列を分割する]]\n- [[部分文字列を取り出す]]\n- [[文字列の一致部分を判定する]]\n- [[文字列を検索する]]\n- [[文字列を置換する]]\n- [[大文字・小文字に揃える]]\n- [[大文字と小文字を入れ替える]]\n- [[文字列を数値に変換する]]\n- [[文字列を1文字ずつに分ける]]\n- [[文字列を一文字ずつ処理する]]\n- [[文字列を一行ずつ処理する]]\n- [[複数行の文字列を作成する]]\n- [[複雑な文字列を作成する]]\n- [[文字列の先頭・末尾の空白を削除する]]\n- [[シンボルを文字列として扱いたい]]\n- [[シンボル名と文字列を比較する]]\n- [[文字列中の関数と式を展開する]]\n- [[文字列の末端の改行を削除する]]\n")
("テストフレームワーク" . "(:ctime 1448036430 :cuser #f :mtime 1460645382 :muser #f)- [[prove]] (旧： [[CL-TEST-MORE]])\n- [[FiveAM]]\n")
("Ltk:ボタンを表示する" . "(:ctime 1619741892 :cuser #f :mtime 1619744645 :muser #f)* ボタン\n\n{{{\n;;; LTKでボタンを表示する\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-01\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-01)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"Button TEST\")\n    (let* ((b (make-instance\n              'button\n                :text \"ボタン\"\n                :command (lambda ()\n                           (format t \"ボタンを押しました\")\n                           (setf *exit-mainloop* t)))))\n      (pack b))))\n\n(main)\n\n}}}\n\n* ボタン その②\n\n{{{\n;;; LTKでボタンを表示する\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-02\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-02)\n\n(defun main ()\n  (with-ltk ()\n    (let* ((b1 (make-instance\n                'button\n                :text \"ボタン１\"\n                :command (lambda ()\n                           (format t \"ボタン１を押しました\"))))\n           (b2 (make-instance\n                'button\n                :text \"ボタン２\"\n                :command (lambda ()\n                           (format t \"ボタン２を押しました\"))))\n           (b3 (make-instance\n                'button\n                :text \"終了\"\n                :command (lambda ()\n                           (format t \"終了\")\n                           (setf *exit-mainloop* t)))))\n      ;(pack (list b1 b2 b3) :side :top)         ; 通常の並び、順番に並ぶ。これがデフォルト\n      ;(pack (list b1 b2 b3) :side :left)        ; 指定されたオブジェクトを左から順番に並べる\n      ;(pack (list b1 b2 b3) :side :right)       ; 指定されたオブジェクトを右から順番に並べる\n      ;(pack (list b1 b2 b3) :side :bottom)      ; 指定されたオブジェクトを下から順番に並べる\n      ;(pack (list b1 b2 b3) :side :top :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n      (pack (list b1 b2 b3) :side :top :fill :both :expand :yes) ; fill,both,expand,yesを指定すると、Wiindowのハシをドラッグして伸ばしても、ボタンが上下左右に大きくなる。\n      )))\n\n(main)\n\n}}}\n")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45) -- /* order by \"as /*" . "(1624124892)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45) -- /* order by \"as /*" . "(1624124926)")
(" %Tag:local-time'" . "(1660041616)")
("配列中の要素を探す" . "(:ctime 1228889710 :cuser #f :mtime 1228889710 :muser #f)[[$$tag 配列]]\n\n* 配列中の要素を探す\n\n[[$$hs position]] もしくは、 [[$$hs find]] を利用することにより配列から要素を検索することができます。\n\n[[$$hs position]] は指定された要素が見つかればその位置を、見つからなければnilを返します。\n\n[[$$hs find]] は指定された要素が見つかればその要素を、見つからなければnilを返します。\n\n両者とも :test キーワードに比較用関数を指定することが可能です。\n\n{{{\n(let ((a #(\"apple\" 10 \"orange\" #(\"lemon\" \"vine\")))\n      (test  #'equal))\n  (list\n   (position \"apple\" a :test test)\n   (position 10 a :test test)\n   (position #(\"lemon\" \"vine\") a :test test)\n   (position #(\"fruit\") a :test test)))\n;=> (0 1 NIL NIL)\n}}}\n{{{\n(let ((a #(\"apple\" 10 \"orange\" #(\"lemon\" \"vine\")))\n      (test  #'equalp))                 ;equalpに変更\n  (list\n   (position \"apple\" a :test test)\n   (position 10 a :test test)\n   (position #(\"lemon\" \"vine\") a :test test)\n   (position #(\"fruit\") a :test test)))\n;=> (0 1 3 NIL)\n}}}\n{{{\n(let ((a #(\"apple\" 10 \"orange\" #(\"lemon\" \"vine\")))\n      (test  #'equalp))                \n  (list\n   (find \"apple\" a :test test)\n   (find 10 a :test test)\n   (find #(\"lemon\" \"vine\") a :test test)\n   (find #(\"fruit\") a :test test)))\n;=> (\"apple\" 10 #(\"lemon\" \"vine\") NIL)\n}}}\n")
(" %Tag:???? and 1>1" . "(1587484317)")
(" %Tag:XML" . "(1331441915)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 320 #" . "(1624125174)")
(" %Tag:split-sequence'[0]" . "(1617569727)")
("ARRAY-TOTAL-SIZE-LIMIT" . "(:ctime 1529821655 :cuser #f :mtime 1529821655 :muser #f)[[$$tag 定数 制限]]\n\n[[$$hs array-total-size-limit]]は配列に入れることができる要素の最大数より1大きい数です。すべての配列に共通する制限で、変更はできません。具体的な値は処理系によって異なりますが、少なくとも1024より大きい数にするように決められています。\n\nあまり関わりがないと思いがちですが、([[$$hs unsigned-byte]] 8)の配列に大きめのデータを読み込んだり、長い文字列を作ったりすると（文字列は文字の配列なので）、主に32ビットの環境で、この制限にかかる場合があります。\n\n||プラットフォーム||リミット||\n||CLISP 2.49 32-bit||2^24 - 1 = 16777215||\n||CLISP 2.49 64-bit||2^32 - 1 = 4294967295||\n||[[Clozure CL]] 1.7 64-bit||2^56 = 72057594037927936||\n||[[Clozure CL]] 1.7 32-bit||2^24 = 16777216||\n||[[LispWorks]] 6.0.1 32-bit||67108337 (≒ 2^26)||\n||[[LispWorks]] 7.1 64-bit||2^29 - 1 = 536870911||\n||[[Steel Bank Common Lisp]] 1.0.53 64-bit||4611686018427387901 (≒ 2^62)||\n||[[Allegro CL]] 32-bit||2^29 - 1 = 536870911||\n||[[Allegro CL]] 64-bit||2^60 - 1 = 1152921504606846975||\n||XCL 64-bit||2^61 - 1 = 2305843009213693951||\n||CMUCL 20c 32-bit||2^29 - 1 = 536870911||\n||ABCL 1.0.0||2^31 - 1 = 2147483647||\n||Scieneer CL 1.3.9 64-bit||2^60 - 1 = 1152921504606846975||\n||GCL 2.6.7 CLtL1 64-bit||2^31 - 1 = 2147483647||\n----\n\n* [[Clozure CL]]\n\n64ビットの環境で2^56（72057594037927936）、32ビットの環境で2^24（16777216）に設定されています。\n\n[http://ccl.clozure.com/manual/chapter17.2.html#Register-usage-and-tagging 17.2. Register usage and tagging]の\"17.2.4. Tagging scheme\"で詳しく説明されていますが、即値（環境ごとに何が即値かは異なります）とコンスセル以外のLispオブジェクトは、Clozure CLではuvectorというデータ構造で表現されています。\n\nuvectorでは、データ構造の最初の1[[$$wp ワード]]に内容の型を表す情報（8ビット）と要素の数（1ワード - 8ビット）が入るように決まっています。そして、配列は即値でもコンスセルでもありませんから、uvectorとして扱われます。そのため、配列の要素の数も1ワード - 8ビットの領域に記録されることになり、64ビットの環境では56ビット（0～2^56 - 1）、32ビットの環境では24ビット（0～2^24 - 1）の範囲に要素の数も制限されます。\n\n{{{\n■32ビット環境でのuvectorの構造\n\n 0  1  2  3  4  5  6  7  8  9 10  ... 28 29 30 31 32 33 34 35 36 ...\n┏━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━\n┃       型情報         ┃       要素の数         ┃  実際のデータ\n┗━━━━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━\n}}}\n\n----\n\n* 参考文献\n\n- [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm Common Lisp HyperSpec]\n- [http://www.clisp.org/impnotes/ Implementation Notes for GNU CLISP]\n- [http://ccl.clozure.com/manual/index.html Clozure CL Documentation]\n- [http://www.lispworks.com/documentation/lw60/LW/html/lw.htm LispWorks User Guide and Reference Manual]\n")
(" %Tag:配列' and 'x'='y" . "(1624124174)")
("インターネットサービス" . "(:ctime 1227177157 :cuser #f :mtime 1231580229 :muser #f)[[$$tag インターネットサービス]]\n\n* インターネットサービス\n\n- [[簡単なDNSルックアップ]]\n")
(" %Tag:ライブラリ" . "(1668290431 (\"FiveAM\" :ctime 1460645375 :cuser #f :mtime 1660192441 :muser #f) (\"インスタンス生成を記録しておき後で条件を満すものを抽出したい\" :ctime 1227530644 :cuser #f :mtime 1551866854 :muser #f) (\"ディスパッチ目的のインスタンスを都度生成しない\" :ctime 1546122245 :cuser #f :mtime 1546122245 :muser #f) (\"オブジェクトのスロットの値をまとめて変更する\" :ctime 1336347630 :cuser #f :mtime 1526495292 :muser #f) (\"CL-FAD\" :ctime 1432468963 :cuser #f :mtime 1432468963 :muser #f) (\"trivial-shell\" :ctime 1432435430 :cuser #f :mtime 1432435430 :muser #f) (\"特定のURLからファイルをダウンロードする\" :ctime 1431153805 :cuser #f :mtime 1431269795 :muser #f) (\"特定のURLからドキュメントを抽出する\" :ctime 1227424335 :cuser #f :mtime 1431159651 :muser #f) (\"文字列を分割する\" :ctime 1280337523 :cuser #f :mtime 1349988541 :muser #f) (\"文字列を検索する\" :ctime 1313411955 :cuser #f :mtime 1313434559 :muser #f) (\"文字列の中に「hoge」が含まれている場合、その開始位置を知るには\" :ctime 1227690765 :cuser #f :mtime 1313407762 :muser #f) (\"複数行の文字列を作成する\" :ctime 1227347816 :cuser #f :mtime 1313402031 :muser #f) (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1302577221 :muser #f) (\"リストを平坦にする\" :ctime 1302448675 :cuser #f :mtime 1302448825 :muser #f) (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f) (\"環境変数を取得する\" :ctime 1232400758 :cuser #f :mtime 1232400886 :muser #f) (\"操作をタイムアウトにする\" :ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f) (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f) (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f) (\"簡単なDNSルックアップ\" :ctime 1230782977 :cuser #f :mtime 1230783022 :muser #f) (\"別のプログラムを起動する\" :ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f) (\"スレッドに引数を渡す\" :ctime 1229082548 :cuser #f :mtime 1229092264 :muser #f) (\"URIエンコード\" :ctime 1227424464 :cuser #f :mtime 1228812075 :muser #f) (\"ストリームを扱うように出力先としてシーケンスを指定したい\" :ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f) (\"ベクタをバイナリのストリームとして扱いたい\" :ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f) (\"新規ページ作成の手順\" :ctime 1227422988 :cuser #f :mtime 1228111845 :muser #f) (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f) (\"ハッシュをシーケンス(alist、plist、その他)に変換する\" :ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f))")
("文字列を数値に変換する" . "(:ctime 1227348006 :cuser #f :mtime 1347932412 :muser #f)[[$$tag 文字列 シーケンス]]\n* 文字列を数値に変換する\n整数の場合は[[$$hs parse-integer]]が使えます。その他の場合は[[$$hs read-from-string]] を使用します。\n{{{\n(parse-integer \"1\")                     ;=> 1\n(read-from-string \"1/10\")               ;=> 1/10\n(read-from-string \"1.2\")                ;=> 1.2\n(read-from-string \"#c(1 1)\")            ;=> #C(1 1)\n}}}\n[[$$hs read-from-string]]は整数の場合でも利用できます。\n\n整数については基数を指定することもできます。\n{{{\n(parse-integer \"11\" :radix 2)           ;=> 3\n(parse-integer \"11\" :radix 8)           ;=> 9\n(parse-integer \"11\" :radix 10)          ;=> 11\n(parse-integer \"11\" :radix 16)          ;=> 17\n}}}\n;; この基数指定は文字列の方に基数接頭辞をつけることで上書きすることができる。\n;; {{{\n;; ;;(import (rnrs))\n;; ;;\n;; ;;(string->number \"#d11\" 16) ; => 11\n;; }}}\n;; \n;; * 文字と Unicode スカラー値を相互変換する\n;; {{{\n;; ;;(import (rnrs))\n;; ;;\n;; ;;(char->integer (string-ref \"a\" 0)) ; => 97\n;; ;;(string (integer->char 97)) ; => \"a\"\n;; }}}\n*** :junk-allowed引数の活用\n;; [出典] 実践 Common Lisp, p24\n;; 原文ママではないですが、問題があるようなら削除お願いします\n:junk-allowed を指定すれば数値として認識されたものより先のゴミ文字を無視できます。\nこのとき、数値が読み取れないと nil を返します。~%\n{{{\n(defvar *data*\n  '(\"174円\" \"103円\" \"190円\" \"121円\" \"139円\" \"157円\" \"192円\" \"197円\" \"110円\" \"129円\"\n    \"105円\" \"131円\" \"139円\" \"123円\" \"179円\" \"195円\" \"110円\" \"122円\" \"140円\" \"151円\"))\n\n\n(mapcar (lambda (x) (parse-integer x :junk-allowed T))\n        *data*)\n;=>  (174 103 190 121 139 157 192 197 110 129 105 131 139 123 179 195 110 122 140\n;     151)\n}}}\n{{{\n(defvar *data2*\n  '(\"単価189円\" \"単価134円\" \"単価114円\" \"単価125円\" \"単価199円\" \"単価123円\" \"単価107円\"\n    \"単価162円\" \"単価177円\" \"単価122円\" \"単価172円\" \"単価121円\" \"単価131円\" \"単価197円\"\n    \"単価108円\" \"単価152円\" \"単価102円\" \"単価197円\" \"単価168円\" \"単価102円\"))\n\n\n(mapcar (lambda (x) \n          (parse-integer x\n                         :junk-allowed T\n                         :start (position-if #'digit-char-p x)))\n        *data2*)\n;=>  (189 134 114 125 199 123 107 162 177 122 172 121 131 197 108 152 102 197 168\n;     102)\n}}}\n{{{\n(defvar *data3*\n  '(\"十六進表記でFCという数\" \"十六進表記でDBという数\" \"十六進表記で81という数\"\n    \"十六進表記で60という数\" \"十六進表記で2Bという数\" \"十六進表記で8という数\"\n    \"十六進表記で1Dという数\" \"十六進表記で8Dという数\" \"十六進表記で6Cという数\"\n    \"十六進表記で4Eという数\" \"十六進表記でF6という数\" \"十六進表記でF0という数\" \n    \"十六進表記で48という数\" \"十六進表記で14という数\" \"十六進表記で4Dという数\"\n    \"十六進表記で30という数\" \"十六進表記でFBという数\" \"十六進表記でDCという数\" \n    \"十六進表記で73という数\" \"十六進表記でEという数\"))\n\n\n(mapcar (lambda (s) \n          (parse-integer s\n                         :junk-allowed T\n                         :start (position-if (lambda (c)\n                                               (digit-char-p c 16.))\n                                             s)\n                         :radix 16.))\n        *data3*)\n;=>  (252 219 129 96 43 8 29 141 108 78 246 240 72 20 77 48 251 220 115 14)\n}}}\n必ず数値が欲しい場合は次のようにすれば良いでしょう。\n{{{\n(or (parse-integer \"no integer\" :junk-allowed t) 0)\n;=> 0\n}}}\n")
(" %Tag:cl-interpol?Tag?Tag?Tag:cl-interpol?Tag?Tag" . "(1476583643)")
("複数行の文字列を作成する" . "(:ctime 1227347816 :cuser #f :mtime 1313402031 :muser #f)[[$$tag 文字列 cl-interpol ライブラリ]]\n* 複数行の文字列を作成する\n[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string 文字列][http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_l.htm#literal リテラル]には改行を含めることができます。\n{{{\n\"abc\ndef\nghi\"\n}}}\n[[$$hs format]]を使うと一行にまとめられます。\n{{{\n(format nil \"abc~%def~%ghi\")\n;=> \"abc\n;   def\n;   ghi\"\n}}}\n[[CLiki:CL-INTERPOL]]を使えば、Cなどの文字列で使える[http://ja.wikipedia.org/wiki/%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9 エスケープシーケンス]を利用できます。\n{{{\nCL-USER> (cl-interpol:enable-interpol-syntax)\n; No value\nCL-USER> #?\"abc\\ndef\\nghi\"\n\"abc\ndef\nghi\"\n}}}\n")
("配列の配列を検索する" . "(:ctime 1228981495 :cuser #f :mtime 1228981573 :muser #f)[[$$tag 配列]]\n\n* 配列の配列を検索する\n\nベクタの入れ子による連想リスト(alist)のようなものがあり、これに適用できるベクタ版の [[$$hs assoc]] のようなものは、 [[$$hs find]] や [[$$hs find-if]] で実現できるでしょう。\n{{{\n(let ((a #(#(\"apple\" 100)\n           #(\"vine\" 500)\n           #(\"orange\" 300))))\n  (find \"apple\" a \n        :key (lambda (x) (aref x 0))\n        :test #'equal))\n;=> #(\"apple\" 100)\n}}}\n{{{\n(let ((a #(#(\"apple\" 100)\n           #(\"vine\" 500)\n           #(\"orange\" 300))))\n  (find-if (lambda (x) (equal \"apple\" (aref x 0)))  \n           a))\n;=> #(\"apple\" 100)\n}}}\n")
("文字列を置換する" . "(:ctime 1296638328 :cuser #f :mtime 1341729451 :muser #f)[[$$tag 文字列 cl-ppcre]]\n\n文字列中の文字を、別の文字に置換するには [[$$hs substitute]]が利用出来ます。~%\n{{{\n(substitute #\\H #\\h \"hello, World. hello hehehe\")\n;⇒ \"Hello, World. Hello HeHeHe\"\n}}}\n\nまた、文字ではなく \"文字列\" を置換したい場合には [[CLiki:cl-ppcre]] の regex-replace, および regex-replace-all を使うことで可能です。~%\n{{{\n(cl-ppcre:regex-replace \"abcde\"\n                        \"abcde, World. abcde abcde\"\n                        \"Hello\")\n;⇒ \"Hello, World. abcde abcde\"\n;   T\n\n(cl-ppcre:regex-replace-all \"abcde\"\n                            \"abcde, World. abcde abcde\"\n                            \"Hello\")\n;⇒ \"Hello, World. Hello Hello\"\n;   T\n}}}\n")
("ブロックからの脱出" . "(:ctime 1229520442 :cuser #f :mtime 1229549658 :muser #f)[[$$tag 制御構造]]\n* ブロックからの脱出\n\nブロックを定義するとその中から return-from を使って脱出できます。\n{{{\n(block foo\n  (print 1)\n  (return-from foo 2)\n  (print 3))\n}}}\n\nreturn-from には脱出するブロックの名前と戻り値となる値を指定します。\n指定した値がブロック全体の値になります。\n\n暗黙のブロック名 nil から脱出する return もあります。\n{{{\n(block nil\n  (print 1)\n  (return 2)\n  (print 3))\n}}}\n\ndefun による関数定義は関数名を名前とするブロックで自動的につつまれます。\nですから、 return-from で脱出できます。\n{{{\n(defun foo ()\n  (print 1)\n  (return-from foo 2)\n  (print 3))\n}}}\n\nloop は名前 nil のブロックで自動的につつまれます。\nですから、 return で脱出できます。\n{{{\n(loop for i in '(1 2 3 4 5)\n      if (= i 3)\n      do (return i))\n}}}\n\nnamed キーワードでブロックの名前を明示することもできます。\n入れ子の loop から脱出する場合に便利です。\n{{{\n(loop named a\n      for i in '((1) (2 3) (4 5 6 7))\n      do (loop for j in i\n               do (print (cons i j))\n               if (= j 3)\n               do (return-from a)))\n;-> ((1) . 1) \n    ((2 3) . 2) \n    ((2 3) . 3) \n;=> NIL\n}}}\n")
(" %Tag:【募集中】/administrator/help/en-GB/toc.json" . "(1585999573)")
(" %Tag:配列\" and \"x\"=\"x" . "(1624124186)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' and 1=2 and 'a'='a" . "(1656001229)")
(" %Tag:local-time' or(1=1)#" . "(1660041663)")
("Hunchentootを起動する" . "(:ctime 1292947409 :cuser #f :mtime 1292947883 :muser #f)[[$$tag Hunchentoot Webサーバ]]\n\nacceptorクラスのインスタンスを作り、startを呼ぶことで、ウェブサーバとしての動作を開始します。\n\n{{{\n;; ポート80のacceptor\n(defvar *port80-acceptor* (make-instance 'hunchentoot:acceptor))\n\n;; ポート8080のacceptor\n(defvar *port8080-acceptor* (make-instance 'hunchentoot:acceptor :port 8080))\n\n;; ポート80への接続の受付を開始する\n(hunchentoot:start *port80-acceptor*)\n\n;; ポート8080への接続の受付を開始する\n(hunchentoot:start *port8080-acceptor*)\n}}}\n\nこのように、複数のポートへの接続を、同時に受け持たせることもできます。\n")
(" %Tag:local-time) or(1=1)-- -" . "(1660041689)")
(" %Tag:構造体'[0]" . "(1664907687)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45) --  /*" . "(1624124385)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae and 1=1-- -" . "(1656001225)")
(" %Tag:jp" . "(1668304901 (\"外部からの入力バイト列を文字列にしたい(文字コード変換含む)\" :ctime 1229261302 :cuser #f :mtime 1236779813 :muser #f))")
(" %Tag:ハッシュテーブル" . "(1611570464 (\"2つのハッシュの両方にあるキー、または一方にしかないキーを見つける\" :ctime 1231752347 :cuser #f :mtime 1231752347 :muser #f) (\"ハッシュのキーと値を反転する\" :ctime 1231474598 :cuser #f :mtime 1231474872 :muser #f))")
("処理系を表すfeature一覧" . "(:ctime 1227968264 :cuser #f :mtime 1606312122 :muser #f)* 処理系を表すfeature一覧\n\n現役のものから古いものまでの一覧です。\n||キーワード||処理系名||||\n||sbcl||Steel Bank Common Lisp||ANSI||\n||clisp||CLISP||ANSI||\n||ecl||Embeddable Common Lisp||ANSI||\n||mcl||Macintosh Common LISP||ANSI||\n||ccl||Clozure CL||ANSI||\n||openmcl||Open MCL||ANSI||\n||allegro||Allegro Common Lisp||ANSI||\n||lispworks||LispWorks||ANSI||\n||scl||Scieneer Common Lisp||ANSI||\n||cmu||CMUCL||ANSI||\n||abcl||Armed Bear Common Lisp||ANSI||\n||xcl||XCL||ANSI||\n||cormanlisp||Corman lisp||ANSI||\n||gclisp||Golden Common LISP||ANSI||\n||???||Eclipse||ANSI||\n||???||Tachyon Common Lisp||CLtL2/ANSI||\n||symbolics/scl/genera/||Symbolics Common lisp||CLtL2/ANSI||\n||||HiLisp||CLtL2/ANSI||\n||movitz||Movitz||???||\n||liquid||Liquid Common Lisp||CLtL2?||\n||||NX-LISP||CLtL2+MOP||\n||gcl||GNU Common Lisp||CLtL2||\n||powerlisp||PowerLisp||CLtL2||\n||poplog||Poplog Common Lisp||CLtL2||\n||sapphire||Star Sapphire Common Lisp||CLtL1+CLOS ?||\n||||Fujitsu LISP||CLtL2||\n||lucid/lcl||Lucid Common Lisp||???||\n||harlequin-common-lisp||Harlequin Common Lisp||???||\n||Xerox||XEROX Common LISP(XEROX 1100)||CLtL1||\n||TI||TI Common LISP||CLtL1/2||\n||vaxlisp|| VaxLisp||CLtL1||\n||spice||Spice Lisp||CLtL1||\n||kcl||Kyoto Common Lisp||CLtL1||\n||ExCL||ExCL (Franz)||???||\n||hp||H.P. Common Lisp||CLtL1||\n||akcl||Austin Kyoto Common Lisp||???||\n||ibcl||IBUKI Common Lisp||???||\n;;||PRIME||???||???||\n;;||pyramid||???||???||\n||macl||Macintosh Allegro Common Lisp||CLtL1||\n||coral||Coral Common Lisp||CLtL1||\n||???l||Data General Common Lisp||CLtL1||\n||elis||ELIS Common Lisp||CLtL1||\n||Butterfly||BBN Butterfly Common Lisp||CLtL1||\n||||Concurrent Common LISP||CLtL1||\n||???||ECoLisp||CLtL1||\n||???||WCL||CLtL1||\n||tops-20||TOPS-20 Common Lisp||CLtL1||\n||lmi||Lambda Common Lisp||CLtL1||\n||???||Hokkaido Common Lisp||CLtL1||\n||???||It's CL||CLtL1||\n")
(" %Tag:開発環境'" . "(1593483617)")
("ディレクトリのリスト表現からパスを生成する" . "(:ctime 1337330938 :cuser #f :mtime 1337330938 :muser #f)[[$$tag 入出力]]\n\n[[$$hs make-pathname]] は:directory引数等で、リスト表現も受け付けますので工夫すれば簡単に書くことが可能です\n\n{{{\n(defun gen-dirs (dirs subdirs)\n  (mapcan (lambda (d)\n            (mapcar (lambda (b)\n                      (make-pathname :directory `(:absolute ,@(mapcar #'string d) ,(string b))\n                                     :case :common))\n                    subdirs))\n          dirs))\n}}}\n{{{\n(gen-dirs '((usr local) (usr2 local) (usr) () )\n          '(bin sbin))\n;=>  (#P\"/usr/local/bin/\" #P\"/usr/local/sbin/\" #P\"/usr2/local/bin/\"\n;     #P\"/usr2/local/sbin/\" #P\"/usr/bin/\" #P\"/usr/sbin/\" #P\"/bin/\" #P\"/sbin/\")\n}}}\n")
(" %Tag:その他" . "(1668187723 (\"ABCLでDISASSEMBLEする\" :ctime 1230125046 :cuser #f :mtime 1365504930 :muser #f) (\"読み方を知りたい\" :ctime 1237824999 :cuser #f :mtime 1294119593 :muser #f) (\"プラットフォームに関する情報を得る\" :ctime 1230403551 :cuser #f :mtime 1230403551 :muser #f))")
("ホームディレクトリを取得する" . "(:ctime 1237730376 :cuser #f :mtime 1238226847 :muser #f)[[$$tag 入出力]]\n\n* ホームディレクトリを取得する\n\nホームディレクトリを取得するには、[[$$hs user-homedir-pathname]] が利用できます。\n{{{\n;; ユーザ foo の場合\n(user-homedir-pathname)\n;=> #P\"/home/foo/\"\n}}}\n\n")
(" %Tag:cl-cron?p=Tag?Tag:cl-cron?p=Tag" . "(1467037342)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45) -- /* order by \"as /*" . "(1624124869)")
(" %Tag:����'" . "(1577118414)")
("多値を変数に代入する" . "(:ctime 1229603159 :cuser #f :mtime 1363963273 :muser #f)[[$$tag 制御構造]]\n\n多値（複数の値）を返す関数があります。\n単純に[[$$hs let]]で変数に束縛しただけでは最初の値しか得られません。\n多値のそれぞれを変数に束縛するには[[$$hs multiple-value-bind]]を使います。\n{{{\n(multiple-value-bind (q r)\n    (truncate 11 3)\n  (format t \"~A ~A~%\" q r))\n;-> 3 2\n;=> NIL\n}}}\n\n多値をリストに格納して返してくれる[[$$hs multiple-value-list]]もあります。\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/m_setf_.htm setf] と [http://www.lispworks.com/documentation/HyperSpec/Body/f_values.htm values] を使って代入することもできます。\n{{{\n(let (q r)\n  (setf (values q r) (truncate 11 3))\n  (format t \"~A ~A~%\" q r))\n;-> 3 2\n;=> NIL\n}}}\n")
(" %Tag:リスト" . "(1668213236 (\"リスト\" :ctime 1227346989 :cuser #f :mtime 1507662991 :muser #f) (\"リストに対するand/or\" :ctime 1507662958 :cuser #f :mtime 1507662958 :muser #f) (\"リストの各要素をカンマ区切りで出力する\" :ctime 1229550300 :cuser #f :mtime 1453044634 :muser #f) (\"リストを結合する\" :ctime 1227520956 :cuser #f :mtime 1333387606 :muser #f) (\"連想リストを使う\" :ctime 1227518778 :cuser #f :mtime 1328668221 :muser #f) (\"リストを逆順にする\" :ctime 1227519902 :cuser #f :mtime 1328667971 :muser #f) (\"リストをソートする\" :ctime 1227975489 :cuser #f :mtime 1328667915 :muser #f) (\"リストから重複した要素を取り除く\" :ctime 1227610615 :cuser #f :mtime 1328667883 :muser #f) (\"リストから要素を探す\" :ctime 1228221887 :cuser #f :mtime 1328667713 :muser #f) (\"リストから要素を取り出す\" :ctime 1227519371 :cuser #f :mtime 1328667648 :muser #f) (\"リストの要素数を取得する\" :ctime 1227517615 :cuser #f :mtime 1328667572 :muser #f) (\"リストを定義する\" :ctime 1228807123 :cuser #f :mtime 1328667397 :muser #f) (\"リストを平坦にする\" :ctime 1302448675 :cuser #f :mtime 1302448825 :muser #f) (\"属性リストを使う\" :ctime 1238173062 :cuser #f :mtime 1238173062 :muser #f) (\"交代リストを使う\" :ctime 1237823129 :cuser #f :mtime 1238167665 :muser #f) (\"非真正リストを真正リストに変換する\" :ctime 1231231029 :cuser #f :mtime 1231316965 :muser #f) (\"リストの各要素に手続きを適用する\" :ctime 1229558079 :cuser #f :mtime 1229600569 :muser #f) (\"リストから指定条件を満たす要素を取り除く\" :ctime 1228980905 :cuser #f :mtime 1229557393 :muser #f) (\"リストを作成する\" :ctime 1229551584 :cuser #f :mtime 1229551944 :muser #f) (\"リスト同士の和・差・積を取る\" :ctime 1228451910 :cuser #f :mtime 1228451910 :muser #f))")
("シンボル名と文字列を比較する" . "(:ctime 1313331737 :cuser #f :mtime 1313335468 :muser #f)[[$$tag シンボル 文字列]]\n\nシンボル名と文字列を比較するには、([[$$hs symbol-name]] シンボル)を文字列と比較するか、[[$$hs string=]]を使います。\n\n{{{\n(equal (symbol-name 'a) \"A\")    ;=> T\n(equal (symbol-name '#:_) \"_\")  ;=> T\n(string= (intern \"A\") \"A\")      ;=> T\n(string= :_ \"_\")                ;=> T\n}}}\n\n参照: [[シンボルを文字列として扱いたい]]\n")
("初回の起動でしか実行されないフックを作成したい" . "(:ctime 1318391632 :cuser #f :mtime 1370597684 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n初回の起動時に、自分自身を削除するbeforeメソッドを作成することにより可能です。\n{{{\n(defmethod foo ()\n  (write-line \"foo\")\n  (values))\n\n(defmethod foo :before (&aux (me #'foo))\n  ;; フック\n  (write-line \"***only once***\")\n  ;; 自身を削除\n  (remove-method me (find-method me '(:before) '() )))\n\n(foo)\n;->  ***only once***\n;    foo\n;  \n;=>  No value\n(foo)\n;->  foo\n;\n;=>  No value\n(foo)\n;->  foo\n;\n;=>  No value\n}}}\n")
(" %Tag:ファイル" . "(1668244622 (\"ファイル\" :ctime 1237730203 :cuser #f :mtime 1237816525 :muser #f))")
("teepeedee2" . "(:ctime 1329736475 :cuser #f :mtime 1329736475 :muser #f)[[$$tag 【募集中】]]\n")
("文字列を分割する" . "(:ctime 1280337523 :cuser #f :mtime 1349988541 :muser #f)[[$$tag 文字列 シーケンス ライブラリ cl-ppcre split-sequence]]\n* 文字列を分割する\n[[CLiki:CL-PPCRE]]のsplitを使うことで、正規表現にマッチした部分で文字列を分割することができます。\n{{{\n(ppcre:split \":\" \"a:b:c\")\n;=> (\"a\" \"b\" \"c\")\n}}}\nまた、[[CLiki:SPLIT-SEQUENCE]]のsplit-sequenceを使うことでも、文字列を分割できます。\n{{{\n(split-sequence:split-sequence #\\: \"a:b:c\")\n;=> (\"a\" \"b\" \"c\")\n;   5\n}}}\nこちらは正規表現ではなく、区切りとなる文字によって、文字列を分割します。\n\nライブラリを使うまでも無い簡易的な場面では、search と subseq を使っても分割できます。~%\n（再帰なので、長い文字列を処理するとスタックを使い尽くす場合があります。）\n{{{\n(defun split (x str)\n  (let ((pos (search x str))\n        (size (length x)))\n    (if pos\n      (cons (subseq str 0 pos)\n            (split x (subseq str (+ pos size))))\n      (list str))))\n\n(format t \"~S\" (split \":\" \"a:b:c\"))\n;=> (\"a\" \"b\" \"c\")\n}}}\n")
("同じランダムステートを使い回したい" . "(:ctime 1345200986 :cuser #f :mtime 1345379739 :muser #f)* ランダムステートの生成と利用\n\n[[$$hs random]]で乱数を得ることができますが、デフォルトの[[$$hs *random-state*]]とは別個にランダムステートを指定して利用することが可能です。~%\nランダムステートの生成には、[[$$hs make-random-state]]を利用し、全く新規に作成、コピー等の使い分けが可能です。~%\n同じランダムステートからは同じ結果が生じます。\n\n{{{\n;;; 新規にrandom-stateを生成\n(defvar *my-random-state* (make-random-state t))\n}}}\n{{{\n(defun foo ()\n  (with-output-to-string (out)\n    (dotimes (i 20) \n      (write (random 36 (make-random-state *my-random-state*))\n             :stream out\n             :base 36) )))\n\n\n;;; ループ内で都度オリジナルをコピーするので同じ結果が繰り返される\n(foo)\n;=>  \"YYYYYYYYYYYYYYYYYYYY\"\n\n\n(foo)\n;=>  \"YYYYYYYYYYYYYYYYYYYY\"\n}}}\n{{{\n(defun bar ()\n  (with-output-to-string (out) \n    (let ((rs (make-random-state *my-random-state*)))\n      (dotimes (i 20) \n        (write (random 36 rs)           ;randomは実行の度にrsを副作用的に変更する\n               :stream out\n               :base 36) ))))\n\n\n;; ループの外でオリジナルをコピー。繰り返しの度に結果は変わるが同じ種からは、\n;; 同じ結果が生じる\n\n(bar)\n;=>  \"YNEPQBIY7UZGNJFG3E2X\"\n\n(bar)\n;=>  \"YNEPQBIY7UZGNJFG3E2X\"\n}}}\n\n* ランダムステートのシリアライズ\n\n[[$$hs random-state]]型のオブジェクトが具体的にどのようなオブジェクトかは規格上決められていませんが、random-state型のオブジェクトを[[$$hs write]]などで書き出したものは、'''同じ処理系で'''[[$$hs read]]することで同じ状態のオブジェクトとして復元できることが保証されています。\n\n{{{\n(let ((state (make-random-state)))\n  (values state (read-from-string (write-to-string (make-random-state)))))\n;=> #.(CCL::INITIALIZE-MRG31K3P-STATE 314159 42 1776 271828 6021023 1066),\n;   #.(CCL::INITIALIZE-MRG31K3P-STATE 314159 42 1776 271828 6021023 1066)\n}}}\n\n別の処理系で書き出したものをreadできるかは保証されていません。注意してください。\n")
(" %Tag:例外処理" . "(1668204983 (\"確実に後処理を行なう\" :ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f))")
("|comments:リクエスト::003" . "(:ctime 1457273038 :cuser #f :mtime 1457273039 :muser #f)* 西之園萌絵 (2016/03/06 23:03:59):\n<<<\n時間をカウントアップするにはどうすれば良いでしょうか？\n１年、２年、３年、4年…とカウントアップし、○年経ったら■する。という命令をしたいです。\n宜しくお願いします。\n>>>\n")
(" %Tag:fare-utils?Tag?Tag:fare-utils?Tag" . "(1491322215)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45) --  /*" . "(1624124431)")
(" %Tag:【募集中】/administrator/language/en-GB/install.xml" . "(1585999575)")
("編集に関する基本方針" . "(:ctime 1227343206 :cuser #f :mtime 1227542061 :muser #f)[[$$toc]]\n* 編集に関する基本方針\nこのコンテンツははWiLiKiというWikiエンジンで構築されており、以下の基本方針に同意していただける方であれば、どなたでもコンテンツの追加、修正をすることが可能です。\n** 引用先でのクレジット表示不要の確認\n引用先でのクレジット表示が必要な投稿はご遠慮下さい。\n** 著作権を侵害しない\n他者の著作権を侵害する内容を書き込むことはご遠慮ください。\n** 改変・削除される可能性があることに同意してください\n自分が書き込んだ内容が改変、もしくは削除される可能性があることに同意してください。\n")
("環境変数を取得する" . "(:ctime 1232400758 :cuser #f :mtime 1232400886 :muser #f)[[$$tag ライブラリ arnesi osicat]]\n\n環境変数の取得に関しては、処理系依存ですが、大抵の処理系には存在しています。\nまた、統一的に扱えるようなポータビリティレイヤのパッケージも存在しています。\n\n処理系ごとに\n{{{\n;; SBCL\n(posix-getenv \"HOME\")\n;=> \"/u/mc/prog-ubuntu\"\n}}}\n\n[[CLiki:ARNESI]]のgetenvを利用\n{{{\n(arnesi:getenv \"HOME\")\n;=> /home/CLer\n}}}\n\n[[CLiki:OSICAT]]のenvironment-variableを利用。[[$$hs setf]]も可能\n{{{\n(setf (osicat:environment-variable \"FOOBARBAZ\")\n      \"foobarbaz\")\n\n(osicat:environment-variable \"FOOBARBAZ\")\n;=> \"foobarbaz\"\n}}}\n\n*** 参考:\n[http://cl-cookbook.sourceforge.net/os.html#env Accessing Environment Variables]\n\n** 議論\n")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45) --  /*" . "(1624124352)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45) -- /* order by 'as /*" . "(1624124698)")
("マクロ展開を確認したい" . "(:ctime 1229603579 :cuser #f :mtime 1229603942 :muser #f)[[$$tag SLIME 開発環境]]\n* マクロ展開を確認したい\n\nslime-macroexpand-1 (C-c C-m) を使います。\n\n展開したいフォームの先頭の括弧にカーソルを置いて、C-c C-mで展開形があたらしいバッファに表示されます。そのバッファで slime-popup-buffer-quit-function (q) を入力すればバッファは閉じます。\n")
("構造体を作成する" . "(:ctime 1229600738 :cuser #f :mtime 1336244558 :muser #f)[[$$tag 構造体]]\n\n* 構造体を作成する\n\n構造体を定義するには、 [[$$hs defstruct]] を利用します。\n[[$$hs defstruct]] には多様なオプションがありますが、最も簡単な定義は下記の様になるでしょう。\n{{{\n(defstruct person\n  name age tall)\n\n;; 中身を観察する\n(describe (make-person))\n;-> #S(PERSON :NAME NIL :AGE NIL :TALL NIL)\n;   Type: PERSON\n;   Class: #<STRUCTURE-CLASS PERSON>\n;   NAME: NIL\n;   AGE: NIL\n;   TALL: NIL\n}}}\n[[$$hs defstruct]] で上記の様に定義するとコンストラクタとして make-person 、アクセサとしてperson-name、person-age、person-tallも定義されます。アクセサは [[$$hs setf]] 可能です。(この振舞いは定義時のオプションで変更できます。)\nコンストラクタにはスロットの名前がキーワードで指定でき、指定した値が初期値となります。\n{{{\n(make-person :name \"春夫\" :age 20 :tall 172.5)\n;=> #S(PERSON :NAME \"春夫\" :AGE 20 :TALL 172.5)\n}}}\n\n** アクセサ使用例\n{{{\n(let ((p (make-person :name \"春夫\" :age 20 :tall 172.5)))\n  (format t \"~Aさんは~D歳で、身長は~Fセンチあります。~%\" (person-name p) (person-age p) (person-tall p)))\n;-> 春夫さんは20歳で、身長は172.5センチあります。\n;=> NIL\n\n ;; 初期値は指定せず後で設定\n(let ((p (make-person)))\n  (setf (person-name p) \"春夫\"\n        (person-age p) 20\n        (person-tall p) 172.5)\n  (format t \"~Aさんは~D歳で、身長は~Fセンチあります。~%\" (person-name p) (person-age p) (person-tall p)))\n;-> 春夫さんは20歳で、身長は172.5センチあります。\n;=> NIL\n}}}\n尚、ANSIの仕様では [[$$hs slot-value]] が構造体で使えるかどうかは、処理系の判断に任せていますが、大抵の処理系では [[$$hs slot-value]] 、 [[$$hs with-slots]] が構造体でも使えるようです。(Allegro CL、SBCL、LispWorks等々)\n{{{\n(let ((p (make-person :name \"春夫\" :age 20 :tall 172.5)))\n  (with-slots (name age tall) p\n    (format t \"~Aさんは~D歳で、身長は~Fセンチあります。~%\" name age tall)))\n;-> 春夫さんは20歳で、身長は172.5センチあります。\n;=> NIL\n}}}\n")
(" %Tag:日本語" . "(1668281290 (\"外部からの入力バイト列を文字列にしたい(文字コード変換含む)\" :ctime 1229261302 :cuser #f :mtime 1236779813 :muser #f))")
("|comments:リクエスト::002" . "(:ctime 1321070362 :cuser #f :mtime 1321070362 :muser #f)* 負け犬君 (2011/11/11 19:59:22):\n<<<\n    右のストリームから左のストリームへデータを受け流すにはどうしたらよいのでしょう？\n\n    ファイルを開いて全部をネットワークに出すなどの場合は、ちょびちょび read-line write-line をくりかえすほかないのでしょうか？ \n>>>\n")
(" %Tag:????99999' union select unhex(hex(version())) -- 'x'='x" . "(1587484325)")
("コンディションの内容を受け取る" . "(:ctime 1329736346 :cuser #f :mtime 1397894533 :muser #f)[[$$tag 【募集中】]]\n\n\nhandler-bind でハンドリングコードに入ったところを考えてください。\n\n\n  (handler-bind ((something-happened #'my-handler)\n     (do-something))\n\n  (defun my-handler (c)\n     ...)\n\n\n自ら定義したコンディションである something-happened の定義を見てみましょう。\n\n  (define-condition something-happened (simple-error)\n    ((foo :initarg :foo :reader foo)))\n\nコンディションオブジェクトは普通のCLOSオブジェクトですので、\nもし slot foo に何らかのデータが格納されていれば、\n\n\n  (defun my-handler (c)\n     (format *error-output*\n             \"~&error value is ~a.\" (foo c))\n\nで読み出すことができます。\nもちろん、readerを使わずとも普通に\n\n\n\n  (defun my-handler (c)\n     (format *error-output*\n             \"~&error value is ~a.\" (slot-value 'foo c))\n\nでも構いません。ただ、slot-value は基本的に bad practice だということは心に止めておいてください。(コンパイラが最適化してくれない、API化したときにオブジェクトを隠蔽できない)\n\n")
(" %Tag:配列' and 'x'='x" . "(1624124163)")
(" %Tag:制御構造?p=Tag?Tag?Tag:制御構造?p=Tag?Tag" . "(1476573666)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45) -- /* order by \"as /*" . "(1624125005)")
("正規表現" . "(:ctime 1236781854 :cuser #f :mtime 1430357064 :muser #f)[[$$tag 正規表現 cl-ppcre]]\n\n- [[CL-PPCRE]]\n- [[cl-irregsexp]]\n;; - [[CLiki:cl-peg]]\n\n- [[正規表現機能別一覧]]\n")
(" %Tag:日付と時刻' and 'x'='x" . "(1532959358)")
("引数のリストに関数を適用する" . "(:ctime 1230115720 :cuser #f :mtime 1244308774 :muser #f)[[$$tag 関数]]\n\n* 引数のリストに関数を適用する\n\n引数のリストに手続きを適用するには [[$$hs apply]] 手続きを使います。\n\n{{{\n(apply #'+ '(1 2 3 4)) ; => 10\n\n(apply #'list 'a 'b '(c d e)) ; => (A B C D E) \n}}}\n\n[[$$hs setf]]と組み合わせた例\n{{{\n(let ((a (make-array '(3 3) :initial-contents '((1 2 3) (4 5 6) (7 8 9))))\n      (pos '(1 1)))\n  (setf (apply #'aref a pos) 'foo)\n  a)\n;=> #2A((1 2 3) (4 FOO 6) (7 8 9))\n}}}\n{{{\n(let ((a (make-array '(3 3) :initial-contents '((1 2 3) (4 5 6) (7 8 9))))\n      (pos '(1 1)))\n  (apply #'(setf aref) 'foo a pos)\n  a)\n;=> #2A((1 2 3) (4 FOO 6) (7 8 9))\n}}}\n")
(" %Tag:closure-html'nvOpzp" . "(1659485599)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae and 1=2" . "(1656001219)")
(" %Tag:alexandria?Tag:alexandria" . "(1491321689)")
(" %Tag:local-time' and 1=2 and 'a'='a" . "(1660041666)")
(" %Tag:closure-html'" . "(1653250913)")
(" %Tag:local-time) and 1=1 and (2=2" . "(1660041711)")
(" %Tag:kmrcl" . "(1668261330 (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1302577221 :muser #f) (\"リストを平坦にする\" :ctime 1302448675 :cuser #f :mtime 1302448825 :muser #f) (\"別のプログラムを起動する\" :ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f))")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45) --  /*" . "(1624124329)")
("リストをソートする" . "(:ctime 1227975489 :cuser #f :mtime 1328667915 :muser #f)[[$$tag リスト]]\n\nリストを並べ替えるには、[[$$hs sort]] 関数を使います。sort 関数は引数のリストを破壊的に変更します。よって、新たなリストを得るには [[$$hs copy-list]] を使います。第１引数に並べ替えたいリスト、第２引数に比較に使う関数( #'< など)を指定します。\n\n{{{\n(let ((my-list '(2 3 1 5 4)))\n  (sort (copy-list my-list) #'<))\n;=> (1 2 3 4 5)\n}}}\n\n比較に使う関数を変えれば、逆順に並べ替えたり、特殊な並べ替えをすることもできます。\n\n{{{\n;; 逆順に並び替える\n(let ((my-list '(2 3 1 5 4)))\n             (sort (copy-list my-list) #'>))\n;=> (5 4 3 2 1)\n\n;; 各要素の絶対値で並び替える\n(let ((my-list '(-2 3 5 1 -7 -4)))\n  (sort (copy-list my-list) \n        #'(lambda (a b) (< (abs a) (abs b)))))\n;=> (1 -2 3 -4 5 -7)\n\n}}}\n\nまた、:key キーワードを使うと、比較関数に渡される前に要素に対して適用される関数を指定できます。上記の絶対値の例は、以下のように書いても同等です\n\n{{{\n(let ((my-list '(-2 3 5 1 -7 -4)))\n  (sort (copy-list my-list) #'< :key #'abs))\n;=> (1 -2 3 -4 5 -7)\n}}}\n\nこのように、第２引数の比較関数と :key キーワードパラメーターを用いることで、複雑なソートを簡潔に書くことができます。\n")
("配列の要素をランダムに抽出する" . "(:ctime 1228749208 :cuser #f :mtime 1228749208 :muser #f)[[$$tag 配列]]\n\n* 配列の要素をランダムに抽出する\n\n[[$$hs aref]] と [[$$hs random]] と [[$$hs length]] を組み合わせることで実現できます。\n{{{\n(let* ((a #(a b c d e))\n       (len (length a)))\n  (aref a (random len)))\n;=> B ;実行ごとにランダム\n}}}\n")
("文字を数値に変換する" . "(:ctime 1313336891 :cuser #f :mtime 1313336892 :muser #f)[[$$hs digit-char-p]]を用いて数値を表わす文字を数値に変換することが可能です。\n\n{{{\n(digit-char-p #\\1)\n;=> 1\n\n(map 'list #'digit-char-p \"01234567890\")\n;=> (1 2 3 4 5 6 7 8 9 0)\n}}}\n\n[[$$hs digit-char-p]]は基数を設定することにより2〜36進数までの範囲で変換条件を指定可能です。\n{{{\n(map 'list (lambda (x) (digit-char-p x 16)) \"123456789abcdef\")\n;=> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)\n}}}\n")
(" %Tag:スレッド" . "(1668285357 (\"スレッド\" :ctime 1229079964 :cuser #f :mtime 1337154190 :muser #f) (\"複数 Listener を使う\" :ctime 1252504504 :cuser #f :mtime 1252507229 :muser #f) (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f) (\"操作をタイムアウトにする\" :ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f) (\"スレッドを生成する:ScineerCL\" :ctime 1230694363 :cuser #f :mtime 1230694363 :muser #f) (\"スレッドに引数を渡す\" :ctime 1229082548 :cuser #f :mtime 1229092264 :muser #f))")
("Ltk:新規にウィンドウを表示する" . "(:ctime 1619741803 :cuser #f :mtime 1619741803 :muser #f)* 新規ウィンドウ作成\n\n{{{\n;;;; 新しいウィンドウを作成する\n(ql:quickload :ltk)\n\n(in-package :ltk)\n\n(with-ltk ()\n  (wm-title *tk* \"新しいウィンドウを作る\")\n  (minsize *tk* 300 300)                ; 300px X 300px\n\n  (let* ((b (make-instance 'button \n                          :master nil\n                          :text \"Press Me\"\n                          :command (lambda () (format t \"Hello World!~%\")))))\n    (pack b)))\n\n}}}\n")
(" %Tag:シンボル" . "(1668283107 (\"シンボル\" :ctime 1227906107 :cuser #f :mtime 1616467986 :muser #f) (\"キーワードを生成したい\" :ctime 1227906421 :cuser #f :mtime 1328609558 :muser #f) (\"シンボル名と文字列を比較する\" :ctime 1313331737 :cuser #f :mtime 1313335468 :muser #f) (\"既存のシンボルに文字列を追加して新しいシンボルを生成する\" :ctime 1236523298 :cuser #f :mtime 1236523298 :muser #f) (\"同一のインターンされないシンボルを複数個所で使う\" :ctime 1233607862 :cuser #f :mtime 1233794032 :muser #f))")
(" %Tag:配列\"" . "(1624124107)")
("無名関数をなんらかの方法で選別したい" . "(:ctime 1340979780 :cuser #f :mtime 1364489967 :muser #f)[[$$tag MOP ]]\n\n** 無名の総称関数に名前を付ける方法\n\nANSI標準ではありませんが、MOPの定義によれば総称関数には、 [[$$mop generic-function-name]] を使って名前を付けることができますので、これを利用して選別することができるでしょう。\n\nMOPの互換性のため[[CLiki:Closer to MOP]]を利用しています。 \n\n{{{\n(defparameter *objs*\n  (list (annotated-function \"x\" () 0)\n        (annotated-function \"q\" () 1)\n        (annotated-function \"r\" () 2)\n        (annotated-function \"i\" () 3)\n        (annotated-function \"a\" (a b c) (list a b c))\n        (annotated-function \"e\" () 4)\n        (annotated-function \"l\" () 5)\n        (annotated-function \"h\" () 6)\n        (annotated-function \"b\" () 7)\n        (annotated-function \"a\" (a b c) (* a b c))\n        (annotated-function \"l\" () 9)\n        (lambda (x) \"foo\")\n        #'list\n        1 2 3 4\n        '(foo)))\n\n\n(mapcar #'apply \n        (remove-if-not (lambda (x)\n                         (and (typep x 'standard-generic-function)\n                              (string= \"a\" (c2mop:generic-function-name x))) )\n                       *objs*)\n        '((1 2 3) (1 2 3) (1 2 3)))\n;=>  ((1 2 3) 6)\n}}}\n*** annotated-functionの定義例\n{{{\n(defmacro annotated-function (annot (&rest args) &body body)\n  (flet ((make-specializers-form ()\n           (let ((pos (position-if (lambda (x)\n                                     (member x lambda-list-keywords))\n                                   args)))\n             `(list ,@(mapcar (constantly '(find-class t))\n                              (subseq args 0 pos))))))\n    (let ((gf (gensym \"gf-\"))\n          (meth (gensym \"meth-\"))\n          (margs (gensym \"args-\"))\n          (ignore (gensym \"ignore-\")))\n      `(let* ((,gf (make-instance 'standard-generic-function))\n              (,meth (make-instance 'standard-method\n                                    :function (lambda (,margs ,ignore)\n                                                (declare (ignore ,ignore))\n                                                (apply (lambda (,@args) ,@body) ,margs))\n                                    :lambda-list ',args\n                                    :specializers ,(make-specializers-form))))\n         (add-method ,gf ,meth)\n         (setf (c2mop:generic-function-name ,gf) ,annot)\n         ,gf))))\n}}}\nマクロ展開\n{{{\n(LET* ((#:|gf-11467| (MAKE-INSTANCE 'STANDARD-GENERIC-FUNCTION))\n       (#:|meth-11468|\n        (MAKE-INSTANCE 'STANDARD-METHOD :FUNCTION\n                       (LAMBDA (#:|args-11469| #:|ignore-11470|)\n                         (DECLARE (IGNORE #:|ignore-11470|))\n                         (APPLY (LAMBDA () 8) #:|args-11469|))\n                       :LAMBDA-LIST 'NIL :SPECIALIZERS (LIST))))\n  (ADD-METHOD #:|gf-11467| #:|meth-11468|)\n  (SETF (SB-MOP:GENERIC-FUNCTION-NAME #:|gf-11467|) \"foo\")\n  #:|gf-11467|)\n}}}\n\n** ドキュメンテーション文字列を使う場合\n\nドキュメンテーション文字列は、処理系依存かつ、処理系が任意の理由で捨てることができますので、ドキュメンテーション文字列が常にあることを期待することはできませんが、無名関数もドキュメンテーション文字列を持つことができますので、この文字列を [[$$hs documentation]] で取得/利用することにより選別できなくもありません。もちろんできないかもしれませんので、できなくても問題ない場合には使えるかもしれません~%\n(他の方法募集)\n{{{\n(defparameter *funs*\n  (list (lambda () \"d\" 90) (lambda () \"v\" 39) \n        (lambda () \"z\" 92) (lambda () \"b\" 10)\n        (lambda () \"f\" 31) (lambda () \"h\" 23)\n        (lambda () \"p\" 95) (lambda () \"k\" 22)\n        (lambda () \"i\" 51) (lambda () \"z\" 66)\n        (lambda () \"r\" 80) (lambda () \"a\" 68)\n        (lambda () \"b\" 35) (lambda () \"t\" 95)\n        (lambda () \"q\" 30) (lambda () \"v\" 66)\n        (lambda () \"q\" 58) (lambda () \"g\" 65)\n        (lambda () \"l\" 48) (lambda () \"e\" 89)\n        #'list))\n}}}\n{{{\n;;; \"a\"というドキュメントが付いている無名関数を選ぶ\n(mapcar #'funcall\n        (remove-if-not (lambda (x)\n                         (string= \"a\" (documentation x 'function)) )\n                       *funs*))\n;=>  (68)\n}}}\n\n")
("|comments:リクエスト::000" . "(:ctime 1232205586 :cuser #f :mtime 1551867911 :muser #f)* 匿名希望 (2009/01/17 07:19:46):\n<<<\nLISPのマクロと、Cのマクロの違いを教えて\n>>>\n\n書きました\n[[Common LispのマクロとCのマクロの違い]]\n")
(" %Tag:listener" . "(1668039737 (\"複数 Listener を使う\" :ctime 1252504504 :cuser #f :mtime 1252507229 :muser #f))")
(" %Tag:trivial-shell" . "(1668290821 (\"trivial-shell\" :ctime 1432435430 :cuser #f :mtime 1432435430 :muser #f))")
("基本的なビット演算をする" . "(:ctime 1455556508 :cuser #f :mtime 1455556508 :muser #f)* log*系関数\n\n整数値を２進数として扱い、ビット演算をする関数には[[$$hs logand]] などがあります。\n\n{{{\n(logand #b0110 #b1101) ;=>   4 = #b0100\n(logior #b0110 #b1101) ;=>  15 = #b1111\n(logxor #b0110 #b1101) ;=>  11 = #b1011\n}}}\n\nlog*系の関数には次のようなものがあります\n||logand  ||AND演算||\n||logandc1||(logandc1 n1 n2) == (logand (lognot n1) n2)||\n||logandc2||(logandc2 n1 n2) == (logand n1 (lognot n2))||\n||logeqv  ||Exclusive NOR演算||\n||logior  ||OR演算||\n||lognand ||NAND演算||\n||lognor  ||NOR演算||\n||lognot  ||NOT演算||\n||logorc1 ||(logorc1 n1 n2) == (logior (lognot n1) n2)||\n||logorc2 ||(logorc2 n1 n2) == (logior n1 (lognot n2))||\n||logxor  ||XOR演算||\n\n\n* boole 関数\nlog*系関数によってできるビット演算を、[[$$hs boole]]関数から呼び出すことができます。\n第二引数に演算を指定し、引数となる２つの整数を用いた論理演算を行います。\n\n{{{\n(boole boole-and #b0110 #b1101) ;=>   4 = #b0100\n(boole boole-ior #b0110 #b1101) ;=>  15 = #b1111\n(boole boole-xor #b0110 #b1101) ;=>  11 = #b1011\n}}}\n\n演算には次のような種類があります\n\n||演算        ||結果||\n||boole-1     ||引数１を返します||\n||boole-2     ||引数２を返します||\n||boole-and   ||AND演算||\n||boole-andc1 ||logandc1 と同じ||\n||boole-andc2 ||logandc2 と同じ||\n||boole-c1    ||引数１の補数を返します||\n||boole-c2    ||引数２の補数を返します||\n||boole-clr   ||常に０を返します（すべてのビットが０である）||\n||boole-eqv   ||Exclusive NOR演算||\n||boole-ior   ||OR演算||\n||boole-nand  ||NAND演算||\n||boole-nor   ||NOR演算||\n||boole-orc1  ||logorc1 と同じ||\n||boole-orc2  ||logorc2 と同じ||\n||boole-set   ||常に-1を返します(すべてのビットが１である)||\n||boole-xor   ||XOR演算||\n")
("配列を縮小したい" . "(:ctime 1336360974 :cuser #f :mtime 1336360989 :muser #f)[[$$tag 配列]]\n\nCommon Lispの配列にはfill-pointerが設定でき、決められた範囲内で終端を設定することが可能です。但し、fill-pointerの有無は配列生成時に指定する必要があります。\n{{{\n(let ((vec (make-array 10 :fill-pointer t)))\n  (setf (fill-pointer vec) 3)\n  vec)\n;=>  #(0 0 0)\n}}}\n\nまた、単に[[$$hs subseq]]でコピーすることでも目的は達成できることもあるでしょう。\n{{{\n(subseq #(1 2 3 4 5) 0 3)\n;=>  #(1 2 3)\n}}}\n")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45) --  /*" . "(1624124318)")
(" %Tag:closer-mop" . "(1668146360 (\"ディスパッチ目的のインスタンスを都度生成しない\" :ctime 1546122245 :cuser #f :mtime 1546122245 :muser #f) (\"オブジェクトのスロットの値をまとめて変更する\" :ctime 1336347630 :cuser #f :mtime 1526495292 :muser #f))")
("配列の配列をフラットな配列にする" . "(:ctime 1228982740 :cuser #f :mtime 1228982771 :muser #f)[[$$tag 配列]]\n\n* 配列の配列をフラットな配列にする\n\nflatten はLISP系言語で良く使われるユーティリティ(ANSI CLには含まれていません)ですが、殆どがリストにしか対応していません。\nベクタ版のものが必要な場合は、下記のように書けるでしょう。 \n{{{\n(defun vector-flatten (vec)\n  (cond ((not (vectorp vec)) vec)\n        ((zerop (length vec)) #())\n        ((vectorp (aref vec 0))\n         (concatenate 'vector \n                      (vector-flatten (aref vec 0)) \n                      (vector-flatten (subseq vec 1))))\n        (T (concatenate 'vector \n                        (vector (aref vec 0)) \n                        (vector-flatten (subseq vec 1))))))\n\n(vector-flatten #(1 2 3 #(4 #(5) 6 '(7 8) 9)))\n;=> #(1 2 3 4 5 6 '(7 8) 9)\n}}}\n\n\n\n\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae or(1=2)-- -" . "(1656001226)")
(" %Tag:local-time%' and 1=2 and '%'='" . "(1660041669)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45) -- /* order by \"as /*" . "(1624125049)")
(" %Tag:配列' or (1,2)=(select*from(select name_const(CHAR(120,102,89,74,111,86,118,78,69,101),1),name_const(CHAR(120,102,89,74,111,86,118,78,69,101),1))a) -- 'x'='x" . "(1624125351)")
("除算の商と余りを求める" . "(:ctime 1227870704 :cuser #f :mtime 1328663291 :muser #f)[[$$tag 数値]]\n* 除算の商と余りを求める\n余りを求めるには [[$$hs mod]] 関数もしくは [[$$hs rem]] 関数を使用します。\n商も同時に求めるには [[$$hs floor]] 関数もしくは [[$$hs truncate]] 関数を使用します。\n商と余りを多値で返します。\n{{{\n(mod 10 3)        ;=> 1\n(rem 10 3)        ;=> 1\n\n(mod -10 3)       ;=> 2\n(rem -10 3)       ;=> -1\n\n(floor 10 3)\n;=> 3\n;   1\n(truncate 10 3)\n;=> 3\n;   1\n(floor -10 3)\n;=> -4\n;    2\n(truncate -10 3)\n;=> -3\n;   -1\n}}}\n")
(" %Tag:ライブラリ管理" . "(1668087484 (\"Quicklispを使う\" :ctime 1292893400 :cuser #f :mtime 1299547197 :muser #f) (\"clbuildを使う\" :ctime 1238075435 :cuser #f :mtime 1257333862 :muser #f))")
(" %Tag:local-time') and 1=1#" . "(1660041697)")
(" %Tag:flexi-streams" . "(1668159560 (\"ストリームを扱うように出力先としてシーケンスを指定したい\" :ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f) (\"ベクタをバイナリのストリームとして扱いたい\" :ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f))")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45) --  /*" . "(1624124374)")
("ファイル" . "(:ctime 1237730203 :cuser #f :mtime 1237816525 :muser #f)[[$$tag ファイル]]\n\n- [[ホームディレクトリを取得する]]\n\n\n** 議論\n現在、ファイル関係も[[入出力]]にまとめているという感じなのですが、[[入出力]]という名前は、やはり判りづらかったでしょうか？ --g000001\n\nI/O一般とは別にファイル操作に特化した逆引きがあるといいなと思い追加してしまいました。\nサイズやパーミッションなどです。 --\nでもって、[[入出力]]のほうをよく見てみるとすでにファイル操作のエントリもありました。ごめんなさい。[[入出力]]に統合してください。--\n")
(" %Tag:日付と時刻 or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- and 1=1" . "(1532959370)")
("各処理系毎に違うところ" . "(:ctime 1329738477 :cuser #f :mtime 1329738477 :muser #f)[[$$tag 【募集中】]]\n----\n処理系毎に違うことを調べるのは難しいので、移植等で挙動が問題となった場合、まずANSI CL等の仕様にあたることになるでしょう。~%\n簡単な目安としては、common-lisp、common-lisp-user以外のパッケージで定義されている関数、マクロ、変数は処理系依存のことが殆どですので、これらのパッケージに依存したアプリケーションを作成した場合は処理系依存となります。\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45) -- /* order by 'as /*" . "(1624124531)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45) -- /* order by \"as /*" . "(1624124835)")
(" %Tag:����'A=0" . "(1577131344)")
(" %Tag:SLIME" . "(1668195208 (\"SLIME:slime-indentation\" :ctime 1529825505 :cuser #f :mtime 1573371720 :muser #f) (\"SLIME:インスペクタ\" :ctime 1529825608 :cuser #f :mtime 1529825608 :muser #f) (\"SLIME:SLDB\" :ctime 1529824426 :cuser #f :mtime 1529824426 :muser #f) (\"SLIME\" :ctime 1229489124 :cuser #f :mtime 1529824240 :muser #f) (\"マクロ展開を確認したい\" :ctime 1229603579 :cuser #f :mtime 1229603942 :muser #f) (\"SLIME:日本語関係の設定:LispWorks\" :ctime 1229489628 :cuser #f :mtime 1229489727 :muser #f) (\"SLIME:日本語関係の設定\" :ctime 1229489203 :cuser #f :mtime 1229489661 :muser #f) (\"逆アセンブルした結果を確認したい\" :ctime 1228810111 :cuser #f :mtime 1228810112 :muser #f) (\"マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい\" :ctime 1228627796 :cuser #f :mtime 1228627796 :muser #f))")
("時刻の表現からUniversal Timeを作成する" . "(:ctime 1227414501 :cuser #f :mtime 1227414501 :muser #f)[[$$tag 日付と時刻]]\n* 時刻の表現からUniversal Timeを作成する\nencode-universal-timeを使用する。\n(encode-universal-time second minute hour date month year [time-zone])\nという形式で呼び出すとUniversal Timeが取得できる\n{{{\n;; 2008/11/20 13:10:23\n(encode-universal-time 23 10 13 20 11 2008 -9)\n;=> 3436143023\n}}}\n")
("format:リスト内の値をCSV形式で一行に出力したい" . "(:ctime 1452526131 :cuser #f :mtime 1453044662 :muser #f)See : [[リストの各要素をカンマ区切りで出力する]]\n\n{{{\n(format t \"~{~a~^,~}\" '(1 2 3))\n;-> 1,2,3\n}}}\n")
("sequenceの最適化" . "(:ctime 1338947371 :cuser #f :mtime 1338952560 :muser #f)最適化とは、一般的なものを限定化することにより特定の局面での効率を上げることですが、CLの場合、最適化で調整できるパラメータは最も一般的な設定がデフォルトになっていることが殆どです。~%\nこれらの項目を制限したり、特定化することによって最適化します。\n\n** リストかベクタか\n[[$$hs sequence]]には主なところでは、[[$$hs list]]、[[$$hs vector]]、[[$$hs string]]があります。リストは要素にアクセスするのに最悪の場合O(n)(nはリストの長さ)のコストがかかりますが、ベクタは、長さによらずO(1)です。~%\nランダムアクセスや要素をシャッフルするような場合は、劇的にパフォーマンスが違ってきますが、配列を使うべきところにリストを使ってしまうのは、lispプログラマの古典的な問題として知られています。~%\n- [http://www.kt.rim.or.jp/~hisashim/gabriel/WIB.ja.html 2.2 良いLispプログラミングは難しい]\n\n||     ||要素の型指定||サイズの動的な変更||ランダムアクセス||シーケンシャルアクセス||任意の場所への要素の挿入||\n||リスト||不可能(ポインタが指すものの型は指定できない)||可||不向き||可||可||\n||ベクタ||可能||可変長(固定の方が効率は良い)||可||可||不向き||\n\n** ベクタの最適化(要素の型を指定する)\nベクタの型を指定しての最適化で最適化される点には2つあります。\n# 処理速度の向上(主にアクセサとの連携で)\n# データ容量の縮小\n\n配列のデータのサイズは、(+ 基本データ領域のサイズ (* 長さ 要素が確保するビット))となります。~%\n\nベクタの型の最適化において特定化するポイントは主に下記の通りです\n# フィルポインタを付けない\n# 伸縮可能にしない\n# 要素の型をできるだけ限定する\n\n[[$$hs string]]は、文字を要素とする特化した[[$$hs vector]]で、他に要素が0か1に特化した[[$$hs bit-vector]]があります。~%\nデフォルトで用意されている要素の型が限定されたベクタの型には下記のようなものがあります~%\n||型||フィルポインタ||伸縮可能||要素の型の限定||displacedか||専用のアクセサ||\n||t(=指定していない)||あっても良い||あっても良い||T(されていない)||そうでも良い||なし(elt)||\n||vector||あっても良い||あっても良い||T(されていない)||そうでも良い||aref||\n||simple-array||なし||なし||T(されていない)||違う||aref||\n||simple-vector||なし||なし||T(されていない)||違う||svref||\n||string||あっても良い||あっても良い||character||そうでも良い||char||\n||simple-string||なし||なし||character||違う||schar||\n||bit-vector||あっても良い||あっても良い||bit||そうでも良い||bit||\n||simple-bit-vector||なし||なし||bit||違う||sbit||\nなお、simple-vectorのように、fill-pointerなし、固定長、displacedでないベクタでありつつ、要素の型は指定したvectorを作成する場合は、simple-arrayのサブタイプを指定します。\n{{{\n;; (unsigned-byte 8)を要素に持つベクタの型\n(simple-array (unsigned-byte 8) (*))\n}}}\nなど\n** 型を指定した例\n{{{\n;; 要素数\n(defconstant 100_000_000 (expt 10 8))\n}}}\n**** vectorを指定 (fill-pointerあり、adjustable)\n{{{\n(declaim (vector *big-vector-vector*))\n(defvar *big-vector-vector* (make-array 100_000_000\n                                        :adjustable T :fill-pointer 100_000_000))\n\n(reduce (lambda (x y) (+ x y)) *big-vector-vector*)\n;⇒ 0\n#|------------------------------------------------------------|\nEvaluation took:\n  5.927 seconds of real time\n  5.904369 seconds of total run time (5.888368 user, 0.016001 system)\n  99.61% CPU\n  14,188,101,966 processor cycles\n  66,208 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n\n**** simple-vectorを指定(make-arrayでパラメータを指定しない場合のデフォルト)\n{{{\n(declaim (simple-vector *big-vector-simple-vector*))\n(defvar *big-vector-simple-vector* (make-array 100_000_000))\n\n(reduce (lambda (x y) (+ x y)) *big-vector-simple-vector*)\n;⇒ 0\n#|------------------------------------------------------------|\nEvaluation took:\n  4.537 seconds of real time\n  4.532283 seconds of total run time (4.516282 user, 0.016001 system)\n  99.89% CPU\n  10,862,211,222 processor cycles\n  100,080 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n\n**** 要素を(unsigned-byte 8)にしたベクタ (simple-array (unsigned-byte 8) (*))\n{{{\n(declaim ((simple-array (unsigned-byte 8) (*))\n          *big-vector-u8*))\n\n(defvar *big-vector-u8*\n  (make-array 100_000_000 :element-type '(unsigned-byte 8)))\n\n(reduce (lambda (x y) (+ x y)) *big-vector-u8*)\n;⇒ 0\n#|------------------------------------------------------------|\nEvaluation took:\n  4.647 seconds of real time\n  4.636290 seconds of total run time (4.572286 user, 0.064004 system)\n  99.76% CPU\n  11,124,966,564 processor cycles\n  98,896 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n\n**** bit-vectorを指定\n{{{\n(declaim ((bit-vector 100000000) *big-vector-bit-vector*))\n(defvar *big-vector-bit-vector*\n  (make-array 100_000_000 :element-type 'bit))\n\n(reduce (lambda (x y) (+ x y)) *big-vector-bit-vector*)\n;⇒ 0\n#|------------------------------------------------------------|\nEvaluation took:\n  4.867 seconds of real time\n  4.852303 seconds of total run time (4.844303 user, 0.008000 system)\n  99.69% CPU\n  11,651,081,796 processor cycles\n  33,456 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n*** アクセサで扱う型を指定しての最適化\n上記のベクタの型を指定しての最適化と併せ、アクセサで扱う型も特定化することで高速化します\n{{{\n(reduce (lambda (x y)\n          (declare (bit x y))\n          (+ x y))\n        *big-vector-bit-vector*)\n;⇒ 0\n#|------------------------------------------------------------|\nEvaluation took:\n  4.682 seconds of real time\n  4.688293 seconds of total run time (4.688293 user, 0.000000 system)\n  100.13% CPU\n  11,208,257,712 processor cycles\n  107,792 bytes consed\n\nIntel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz\n |------------------------------------------------------------|#\n}}}\n")
("xのn乗（べき乗・累乗）を計算する" . "(:ctime 1457056251 :cuser #f :mtime 1457278229 :muser #f)[[$$tag 数値]]\n\n* x の n 乗の計算\n[[$$hs expt]] 関数を使います。[[$$hs exp]] 関数の関連関数で，''b^x = e^x log b'' という定義に基づいています。そのため整数乗だけではなく実数乗の計算も対応しています。なので n乗根も求められます。\n\n{{{\n(expt 3 2) ;=> 9\n(expt 3 1/2) ;=> 1.7320508\n(expt 10 2.5) ;=> 316.22775 ; = 10^2 * 10^(0.5)\n}}}\n\n\n* 2 の n 乗の整数値\n求めたい値が 2のn乗の整数値であれば，[[$$hs ash]] 関数によるビットシフト計算が使用できます。\n\n{{{\n(ash 1 10) ;=> 1024 ; = 2^10\n}}}\n\n* e の n 乗\n[[$$hs exp]] 関数で e^n が計算可能です。\n\n{{{\n(exp 1) ;=> 2.7182817\n(exp 2) ;=> 7.389056\n}}}\n\n[[対数を計算する]] も参照してください。\n")
("最適化指針" . "(:ctime 1529823480 :cuser #f :mtime 1529823481 :muser #f)[[$$tag 最適化]]\n\nコードの最適化についてです。\n\nLisp方言の中でも特に実用性を重視しているCommon Lispでは、プログラムの比較的低い層まで触れるようになっています。型宣言によってオブジェクトコードから型チェックのコードをなくしたり、変数を動的エクステントとして宣言することでスタックにオブジェクトを作ったり、コンパイルしたコードを逆アセンブルして調整の参考にしたり、といったことは、Common Lispでは普通のことです。\n\nプログラマが積極的に関与できるCommon Lispの最適化の仕組みは、ほかの多くの言語と比べたときに有利な点のひとつであり、コードの性能を確保したいときの助けになってくれるでしょう。\n\n----\n\n[[$$toc]]\n\n----\n\n* 最適化宣言\n\nコードを書いてデバッグもした。しかし、コンパイルしたコードを実行してみたらどうも遅い。こういうことは、プログラミングをしているとよくあることです。そういうときは、まず最適化宣言をして、コンパイラに最適化をさせてみましょう。\n\n最適化宣言は[[$$hs optimize]]宣言で行います。[http://www.lispworks.com/documentation/HyperSpec/Body/d_optimi.htm CLHS: Declaration OPTIMIZE]から文法を引用します。\n\n<<<\n(optimize {''quality'' | (''quality'' ''value'')}*)\n>>>\n\nqualityは最適化の方向性を表すシンボルです。\n\n:compilation-speed:コンパイル速度\n:debug:デバッグのしやすさ\n:safety:実行時エラーの検査\n:space:オブジェクトコードと実行時のメモリの大きさ\n:speed:オブジェクトコードの速さ\n\n規格で決められているのはこの五種類ですが、処理系がこれ以外のシンボルについて定義しても良いことになっています。実際、[[Steel Bank Common Lisp]]や[[CMU Common Lisp]]、[http://www.lispworks.com/ LispWorks]では処理系独自のシンボルを使えます。\n\nvalueは重要性です。0から3までの整数を指定することができ、大きいほど重要になっていきます。\n\n:0:重要でない\n:1:普通\n:2:1と3の中間\n:3:とても重要\n\nvalueを省略した場合は3と同じ意味です。valueの値をもとにコンパイラはオブジェクトコードを作りますが、具体的にどんな最適化をどのようにするかは、処理系に任されています。\n\n{{{\n;; 高速だが実行時の検査を省略していてデバッグもしづらい\n;; 最終的なリリース向け\n(declaim (optimize (speed 3) (debug 0) (safety 0)))\n\n;; 実行時に検査をしてデバッグもしやすいが遅い\n;; 開発途中のデバッグ向け\n(declaim (optimize (speed 0) (debug 3) (safety 3)))\n}}}\n\noptimize宣言をどこですれば良いかは、場合によって変わります。ライブラリを最適化したい場合は、最適化する関数ごとにdeclareを使うか、locallyを使うと良いでしょう。'''トップレベルでdeclaimを使ってはいけません。'''ライブラリをロードするとき、システム全体に影響を与えてしまいます。アプリケーションを最適化したい場合は、システム全体についての宣言をしてからコードをコンパイルすると良いでしょう。\n\n{{{\n;;; ライブラリ\n\n(defun fact (n)\n  ;; 関数についての宣言\n  (declare (optimize speed))\n  (labels ((rec (n r)\n             (if (zerop n) r (rec (1- n) (* n r)))))\n    (rec n 1)))\n\n;; locallyの中の式についての宣言\n(locally (declare (optimize speed))\n  (defun fact (n)\n    (labels ((rec (n r)\n               (if (zerop n) r (rec (1- n) (* n r)))))\n      (rec n 1))))\n\n;; コンパイル時だけシステム全体についての宣言をする\n(eval-when (:compile-toplevel)\n  (proclaim '(optimize speed)))\n\n;; 上と同じだが紛らわしい\n;; 使い方を間違っているのか意図通りなのか分かりにくい\n(eval-when (:compile-toplevel)\n  (declaim (optimize speed)))\n\n;;; アプリケーション\n\n;; システム全体についての宣言\n(declaim (optimize speed))\n\n(compile-file \"code.lisp\")\n(load \"code\")\n(save-application \"application\"\n                  :toplevel-function #'main\n                  :prepend-kernel t)\n}}}\n\n----\n\n* 先に進む前に\n\n最適化宣言をしてコンパイラに最適化をさせると、効果の差はありますが、大体は性能が良くなります。おそらく、高速になったり、メモリの消費が少なくなることでしょう。ですが、それでもまだ必要な性能に届かないこともあります。そんなときは、プログラマがコードに手を加えることで、コンパイラにより効果的なオブジェクトコードを作らせることができるかもしれません。いわゆる、手動での最適化です。\n\nしかし、性能が悪いからといって、闇雲にいろいろと手を加えるのはおすすめしません。[http://ja.wikipedia.org/wiki/%E3%83%89%E3%83%8A%E3%83%AB%E3%83%89%E3%83%BB%E3%82%AF%E3%83%8C%E3%83%BC%E3%82%B9 Donald Knuth]の[http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf 論文]から、手動での最適化についてのとても有名な言葉を引用します。\n\n<<<\nWe ''should'' forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. \n>>>\n\nこれは、\n\n- 些細な効率を追求しても意味がない\n- 最適化のための変更にはデメリットがある\n\nことを伝えています。\n\nひとつ目は単純な話です。10秒かかる部分を二倍速くしたら5秒も速くなりますが、1秒かかる部分を二倍速くしても0.5秒です。性能に大きく影響する部分は限られるので、大きな効果を期待するには、それがどこなのか見つけなければなりません。\n\nふたつ目は、以降の節を読めば理解できるでしょう。手動での最適化は幅広い知識が必要なために難しく、時間もかかります。また、最適化をすると、読みにくく、変更しにくく、デバッグしにくいコードになります。僅かに性能が上がるくらいでは割に合いませんし、コードへの変更がまだ多い段階では作業の邪魔にしかなりません。\n\n手動での最適化は、ある程度コードが完成に近づいてから、''最小限の変更で最大限の効果を得る''ことを考えながらしてください。薬も過ぎれば毒です。\n\n----\n\n* プロファイリング\n\n（書きかけ）\n\n- イベントベース\n- 統計的\n\n----\n\n* 型宣言\n\n[[$$hs type]]宣言や[[$$hs ftype]]宣言をすることで、変数や関数の型をコンパイラに知らせることができます。また、[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#special_form 特殊形式]の[[$$hs the]]を使うことで、式の結果の型をコンパイラに知らせることができます。''型宣言と実際のオブジェクトの型が一致しなかったときにどうなるかは決められていません。''\n\nコンパイラは[http://ja.wikipedia.org/wiki/%E5%9E%8B%E6%8E%A8%E8%AB%96 型推論]で変数や関数の型を決め、自動的に型に合わせた効果的なオブジェクトコードを作りますが、決められた型からは効果的なオブジェクトコードが作れないことがあります。そんなとき、型宣言でコンパイラに型を知らせることで、効果的なオブジェクトコードを作れるようになります。\n\nオブジェクトコードの性能に大きな差が出るため、性能が必要な部分では型宣言をすると良いでしょう。適切な型が選ばれているかどうかは、逆アセンブルの結果を見て判断したり、処理系独自の拡張（例えば[[Steel Bank Common Lisp]]では[[$$hs describe]]で関数の型を見れます）を使って知ることができます。\n\n{{{\n(defun plus-vanilla (x y) (+ x y))\n(disassemble 'plus-vanilla)\n;=> NIL\n;->   [0]     (recover-fn)\n;     [5]     (cmpl ($ 8) (% temp1))\n;     [8]     (jne L66)\n;     [10]    (pushl (% ebp))\n;     [11]    (movl (% esp) (% ebp))\n;     [13]    (pushl (% arg_y))\n;     [14]    (pushl (% arg_z))\n;   \n;   ;;; (+ x y)\n;     [15]    (movl (% arg_y) (% imm0))\n;     [17]    (orl (% arg_z) (% imm0))\n;     [19]    (testb ($ 3) (% imm0.b))\n;     [21]    (jne L46)\n;     [23]    (addl (% arg_y) (% arg_z))\n;     [25]    (jno L60)\n;     [27]    (nop)\n;     [28]    (leal (@ 0 (% arg_y)) (% arg_y))\n;     [32]    (calll (@ .SPFIX-OVERFLOW))\n;     [39]    (recover-fn)\n;     [44]    (jmp L60)\n;   L46\n;     [46]    (movl (% arg_y) (% arg_y))\n;     [48]    (calll (@ .SPBUILTIN-PLUS))\n;     [55]    (recover-fn)\n;   L60\n;     [60]    (leavel)\n;     [61]    (retl)\n;   \n;   ;;; #<no source text>\n;   L66\n;     [66]    (uuo-error-wrong-number-of-args)\n\n(defun plus-typed (x y)\n  (declare (type fixnum x y))\n  (the fixnum (+ x y)))\n(disassemble 'plus-typed)\n;=> NIL\n;->   [0]     (recover-fn)\n;     [5]     (cmpl ($ 8) (% temp1))\n;     [8]     (jne L26)\n;     [10]    (pushl (% ebp))\n;     [11]    (movl (% esp) (% ebp))\n;     [13]    (pushl (% arg_y))\n;     [14]    (pushl (% arg_z))\n;   \n;   ;;; (the fixnum (+ x y))\n;     [15]    (addl (% arg_y) (% arg_z))\n;     [17]    (leavel)\n;     [18]    (retl)\n;   \n;   ;;; #<no source text>\n;   L26\n;     [26]    (uuo-error-wrong-number-of-args)\n}}}\n\nまず、[http://www.lispworks.com/documentation/HyperSpec/Body/d_type.htm CLHS: Declaration TYPE]からtype宣言の文法を引用します。\n\n<<<\n(type ''typespec'' ''var''*)\n>>>\n\nvarを束縛するオブジェクトの型がtypespecだとコンパイラに知らせます。また、typeの部分は省略できます。\n\n{{{\n;; xとyの型はfixnum\n(defun plus (x y)\n  (declare (type fixnum x y))\n  (+ x y))\n\n;; 上の省略形\n(defun plus (x y)\n  (declare (fixnum x y))\n  (+ x y))\n}}}\n\n次に、[http://www.lispworks.com/documentation/HyperSpec/Body/d_ftype.htm#ftype CLHS: Declaration FTYPE]からftype宣言の文法を引用します。\n\n<<<\n(ftype ''type'' ''function-name''*)\n>>>\n\ntypeをfunction-nameの型としてコンパイラに知らせます。typeには[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#compound_type_specifier 複合型指定子]で特殊化した[[$$hs function]]型を指定します。\n\n{{{\n;; plusはふたつのfixnumを受け取り整数を返す\n(declaim (ftype (function (fixnum fixnum) integer) plus))\n(defun plus (x y) (+ x y))\n\n;; ローカル関数についての型宣言\n(defun outside (x y)\n  (flet ((inside (x y) (+ x y)))\n    (declare (ftype (function (fixnum fixnum) integer) inside))\n    (inside x y)))\n}}}\n\n最後に、[http://www.lispworks.com/documentation/HyperSpec/Body/s_the.htm CLHS: Special Operator THE]からtheの文法を引用します。\n\n<<<\n'''the''' ''value-type'' ''form'' => ''result''*\n>>>\n\nvalue-typeを、formの戻り値のresultの型としてコンパイラに伝えます。\n\n{{{\n;; 結果はfixnum\n(the fixnum (+ 4 5))\n;=> 9\n\n;; 結果は符号なし16ビット整数\n(the (integer 0 #.(1- (expt 2 16))) (+ 256 128))\n(the (unsigned-byte 16) (+ 256 128))\n;=> 384\n\n;; 結果は整数と浮動小数点数\n(the (values integer float) (truncate 3.2d0))\n;=> 3, 0.20000000000000018D0\n}}}\n\n処理系によってコンパイラの型推論の性能には差があり、どのように型宣言をすれば効果があるのかもそれぞれ違います。詳しいことはそれぞれのマニュアルを読んでください。型宣言（特にthe）はコードを'''非常に読みにくくします'''ので、必要以上に宣言するのは避けたほうが良いでしょう。\n\n----\n\n* インライン展開\n\n[[$$hs inline]]宣言によって、関数を[http://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E5%B1%95%E9%96%8B インライン展開]するようコンパイラに指示できます。\n\n関数の呼び出しを節約できるので、呼び出しのオーバヘッドがなくなりますが、オブジェクトコードが大きくなります。インライン展開されたコードが実行されればされるほど効果的です。[http://en.wikipedia.org/wiki/Inner_loop インナーループ]で使われる関数についてinline宣言すると良いでしょう。実行される回数が少ないとあまり効果はありません。\n\n{{{\n(defun sum (a b c d e f) (+ a b c d e f))\n(declaim (inline sum-inline))\n(defun sum-inline (a b c d e f) (+ a b c d e f))\n\n(progn\n  (time (dotimes (n 100000000) (sum n n n n n n)))\n  (time (dotimes (n 100000000) (sum-inline n n n n n n))))\n;=> NIL\n;-> (DOTIMES (N 100000000) (SUM N N N N N N)) took 1,640 milliseconds (1.640 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 1,640 milliseconds (1.640 seconds) were spent in user mode\n;                       0 milliseconds (0.000 seconds) were spent in system mode\n;   125 milliseconds (0.125 seconds) was spent in GC.\n;    84,172,160 bytes of memory allocated.\n;   (DOTIMES (N 100000000) (SUM-INLINE N N N N N N)) took 844 milliseconds (0.844 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 844 milliseconds (0.844 seconds) were spent in user mode\n;                       0 milliseconds (0.000 seconds) were spent in system mode\n;    48 bytes of memory allocated.\n}}}\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/d_inline.htm CLHS: Declaration INLINE, NOTINLINE]から文法を引用します。\n\n<<<\n(inline ''function-name''*)\n>>>\n\nfunction-nameを'''定義する前'''にinline宣言をすると、function-nameがインライン展開されるようになります。''ただし、コンパイラはinline宣言を無視して良いことになっているので、確実にインライン展開されるかは保証されません。''\n\nマクロやコンパイラマクロでも似たようなことができますが、それぞれ違いがあります。\n\n{{{\n;;; インライン関数\n\n;; inline宣言はコンパイラに無視されるかもしれない\n(declaim (inline stream-car))\n(defun stream-car (stream) (car stream))\n\n;; 関数なので高階関数に渡せる\n(apply #'stream-car '((0 1 2))) ;=> 0\n\n;; インライン展開を宣言で制御できる\n(defun stream-car-caller (stream)\n  (if stream\n      (stream-car stream)       ; インライン展開される\n      (locally (declare (notinline stream-car))\n        (stream-car stream))))  ; インライン展開されない\n\n;; 逆アセンブルして確認\n(disassemble 'stream-car-caller)\n;=> NIL\n;->   [0]     (recover-fn)\n;     [5]     (pushl (% ebp))\n;     [6]     (movl (% esp) (% ebp))\n;     [8]     (pushl (% arg_z))\n;   \n;   ;;; (if stream (stream-car stream) ; インライン展開される (locally (declare (notinline stream-car)) (stream-car st\n;     [9]     (cmpl ($ #x13001) (@ -4 (% ebp)))\n;     [16]    (je L24)\n;   \n;   ;;; (stream-car stream)\n;     [18]    (pushl (% arg_z))\n;     [19]    (movl (@ 3 (% arg_z)) (% arg_z))\n;     [22]    (leavel)\n;     [23]    (retl)\n;   \n;   ;;; (locally (declare (notinline stream-car)) (stream-car stream))\n;   L24\n;     [24]    (movl (@ -4 (% ebp)) (% arg_z))\n;     [27]    (movl ($ 4) (% temp1))\n;     [32]    (movl (@ 'STREAM-CAR (% fn)) (% temp0))\n;     [38]    (leavel)\n;     [39]    (jmpl (@ 6 (% temp0)))\n\n;;; マクロ\n\n;; 常にインライン展開される\n(defmacro stream-car (stream) `(car ,stream))\n\n;; マクロなので高階関数には直接渡せない\n(apply #'(lambda (x) (stream-car x)) '((0 1 2)))        ;=> 0\n\n;;; コンパイラマクロ\n\n(defun stream-car (stream) (car stream))\n\n;; 常にインライン展開される\n(define-compiler-macro stream-car (stream) `(car ,stream))\n\n;; 関数なので高階関数に渡せる\n(apply #'stream-car '((0 1 2))) ;=> 0\n}}}\n\ninline宣言された関数は、高階関数に渡すことができ、インライン展開するかどうかを柔軟に切り替えられ、よりコードの意図が分かりやすくなります。特に問題がなければ、inline宣言をする方が良いでしょう。\n\n気をつけなければいけないことがひとつあります。inline宣言された関数に変更があった場合、マクロと同じで、それを利用しているコードはすべて''再コンパイルしないと変更が反映されません''。これを忘れると、見えないバグに悩まされることになります。\n\n{{{\n(defun make-point (x y) (cons x y))\n(declaim (inline point-x point-y))\n(defun point-x (p) (car p))\n(defun point-y (p) (cdr p))\n\n(defun print-coordinate (p)\n  (format t \"(~a, ~a)~%\" (point-x p) (point-y p)))\n\n(print-coordinate (make-point 0 1))\n;=> NIL\n;-> (0, 1)\n\n(defun make-point (x y) (vector x y))\n(defun point-x (p) (aref p 0))\n(defun point-y (p) (aref p 1))\n\n(print-coordinate (make-point 0 1))\n;>> Error: value #(0 1) is not of the expected type LIST.\n}}}\n\n----\n\n* 動的エクステント\n\n変数や関数について[[$$hs dynamic-extent]]宣言をすると、束縛するオブジェクトの[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_e.htm#extent エクステント]を[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_d.htm#dynamic_extent 動的エクステント]にできます。\n\n規格では決められていませんが、動的エクステントのオブジェクトは[http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF スタック]のメモリを割り当てられるのが一般的なので、[http://ja.wikipedia.org/wiki/%E3%83%92%E3%83%BC%E3%83%97%E9%A0%98%E5%9F%9F ヒープ]のメモリを割り当てられる[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_i.htm#indefinite_extent 無限エクステント]のオブジェクトよりも高速に扱えます。一時的に使うオブジェクトを作るコストが気になるときにdynamic-extent宣言をすると良いでしょう。\n\n{{{\n(time (dotimes (n 10000)\n        (let ((l (make-list n)))\n          (length l))))\n;=> NIL\n;-> (DOTIMES (N 10000) (LET ((L (MAKE-LIST N))) (LENGTH L))) took 2,875 milliseconds (2.875 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 2,687 milliseconds (2.687 seconds) were spent in user mode\n;                       78 milliseconds (0.078 seconds) were spent in system mode\n;   2,172 milliseconds (2.172 seconds) was spent in GC.\n;    399,960,048 bytes of memory allocated.\n\n(time (dotimes (n 10000)\n        (let ((l (make-list n)))\n          (declare (dynamic-extent l))\n          (length l))))\n;=> NIL\n;-> (DOTIMES (N 10000) (LET ((L (MAKE-LIST N))) (DECLARE (DYNAMIC-EXTENT L)) (LENGTH L))) took 1,172 milliseconds (1.172 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 1,078 milliseconds (1.078 seconds) were spent in user mode\n;                       0 milliseconds (0.000 seconds) were spent in system mode\n;   812 milliseconds (0.812 seconds) was spent in GC.\n;    131,557,360 bytes of memory allocated.\n}}}\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/d_dynami.htm#dynamic-extent CLHS: Declaration DYNAMIC-EXTENT]から文法を引用します。\n\n<<<\n(dynamic-extent [[''var''* | (function ''fn'')*]])\n>>>\n\nvarあるいはfnを束縛するオブジェクトが動的エクステントになります。''ただし、コンパイラはdynamic-extent宣言を無視して良いことになっているので、確実に動的エクステントになるかは保証されません。''\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#scope スコープ]を抜けると、動的エクステントのオブジェクトは捨てられてしまうので気をつけてください。また、スタックの大きさは限られているので、大きなオブジェクトは置けません。その場合はヒープのメモリを割り当てられるため、大きなオブジェクトについてdynamic-extent宣言しても効果はありません。（コードを読む人へのヒントにはなるかもしれませんが）\n\n{{{\n(print (let ((l (list 0 1 2)))\n         l))\n;=> (0 1 2)\n;-> (0 1 2)\n\n;; 参照できるが、すでにオブジェクトは捨てられている\n(print (let ((l (list 0 1 2)))\n         (declare (dynamic-extent l))\n         l))\n;>> Error: Stack overflow on temp stack.\n;-> (((((...\n\n;; スタックに置かれる\n(time (let ((l (make-list (1- (* 8 1024)))))\n        (declare (dynamic-extent l))\n        (car l)))\n;=> NIL\n;-> (LET ((L (MAKE-LIST (1- (* 8 1024))))) (DECLARE (DYNAMIC-EXTENT L)) (CAR L)) took 0 milliseconds (0.000 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 0 milliseconds (0.000 seconds) were spent in user mode\n;                       0 milliseconds (0.000 seconds) were spent in system mode\n;    32 bytes of memory allocated.\n\n;; この環境では64KB以上のオブジェクトはヒープに置かれる\n(time (let ((l (make-list (* 8 1024))))\n        (declare (dynamic-extent l))\n        (car l)))\n;=> NIL\n;-> (LET ((L (MAKE-LIST (* 8 1024)))) (DECLARE (DYNAMIC-EXTENT L)) (CAR L)) took 0 milliseconds (0.000 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 0 milliseconds (0.000 seconds) were spent in user mode\n;                       0 milliseconds (0.000 seconds) were spent in system mode\n;    65,568 bytes of memory allocated.\n}}}\n\n----\n\n* コンパイラマクロ\n\n（書きかけ）\n\n- 特定のコードを効果的なコードに変換する\n- 定数であれば実行時に計算して置き換えることすら可能\n- 最適化に非常に有効だが保守性が著しく悪くなる\n\n----\n\n* 逆アセンブル\n\n[[$$hs disassemble]]でコンパイルした関数を逆アセンブルできます。\n\n結果は[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#standard_output 標準出力]に出力されます。規格で決められているので、きちんと準拠している処理系では使えますが、逆アセンブルした結果をどのような形式で出力するかは処理系に任されています。\n\n{{{\n;; Clozure CL 1.6：LAP（Lisp Assembly Program）\n(disassemble 'car)\n;=> NIL\n;-> ;; \"ccl:lib;level-2.lisp.newest\":13317-13338\n;     [0]     (recover-fn)\n;     [5]     (cmpl ($ 4) (% temp1))\n;     [8]     (jne L34)\n;     [10]    (pushl (% ebp))\n;     [11]    (movl (% esp) (% ebp))\n;     [13]    (pushl (% arg_z))\n;     [14]    (movl (% arg_z) (% imm0))\n;     [16]    (andl ($ 7) (% imm0))\n;     [19]    (cmpl ($ 1) (% imm0))\n;     [22]    (jne L42)\n;     [24]    (movl (@ 3 (% arg_z)) (% arg_z))\n;     [27]    (leavel)\n;     [28]    (retl)\n;   L34\n;     [34]    (uuo-error-wrong-number-of-args)\n;   L42\n;     [42]    (uuo-error-reg-not-list (% arg_z))\n\n;; Steel Bank Common Lisp 1.0.45：アセンブリ言語\n(disassemble 'car)\n;=> NIL\n;-> ; disassembly for CAR\n;   ; 008D4A30:       488B51F9         MOV RDX, [RCX-7]           ; no-arg-parsing entry point\n;   ;       34:       488BE5           MOV RSP, RBP\n;   ;       37:       F8               CLC\n;   ;       38:       5D               POP RBP\n;   ;       39:       C3               RET\n;   ;       3A:       CC0A             BREAK 10                   ; error trap\n;   ;       3C:       02               BYTE #X02\n;   ;       3D:       18               BYTE #X18                  ; INVALID-ARG-COUNT-ERROR\n;   ;       3E:       54               BYTE #X54                  ; RCX\n;   ;       3F:       CC0A             BREAK 10                   ; error trap\n;   ;       41:       02               BYTE #X02\n;   ;       42:       02               BYTE #X02                  ; OBJECT-NOT-LIST-ERROR\n;   ;       43:       95               BYTE #X95                  ; RDX\n\n;; CLISP 2.48：S式で表現したバイトコード\n(disassemble (lambda (x y) (+ x y)))\n;=> NIL\n;-> \n;   Disassembly of function :LAMBDA\n;   2 required arguments\n;   0 optional arguments\n;   No rest parameter\n;   No keyword parameters\n;   4 byte-code instructions:\n;   0     (LOAD&PUSH 2)\n;   1     (LOAD&PUSH 2)\n;   2     (CALLSR 2 55)                       ; +\n;   5     (SKIP&RET 3)\n}}}\n\n逆アセンブルの結果をもとに、きちんと最適化されたオブジェクトコードが作られているか確認したり、より効率的なオブジェクトコードが作られるコードを探したりと、最適化の強力な武器になります。\n\n----\n\n* 参考文献\n\n- [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm Common Lisp HyperSpec]\n- [http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html Common Lisp the Language, 2nd Edition]\n- [http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf Structured Programming with Goto Statements]\n- [http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/aced55aeed5f6ef2 DECLARE, DECLAIM and PROCLAIM that I'm not sure I understand the difference!]\n- [http://john.freml.in/lisp-declaim-myths John Fremlin's blog: Common Common Lisp myths about declaim]\n- [http://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E5%B1%95%E9%96%8B インライン展開 - Wikipedia]\n- [http://cl-www.msi.co.jp/solutions/knowledge/lisp-world/tutorial/scope-and-extent.pdf Common Lispのスコープとエクステント]\n\n----\n\n- プロファイリング\n- コンパイラマクロ\n- TCO(tail call optimization)\n- displaced array（高速化とか作ってそっちでやると思う）\n- FFI + C（リーサルウェポン）\n- http://www.pentaside.org/paper/compilermacro-lemmens/compiler-macros-for-publication.txt\n- http://cl-www.msi.co.jp/solutions/knowledge/lisp-world/tutorial/compiler-eval-b.pdf\n- http://www.psg.com/~dlamkins/sl/chapter20.html\n")
(" %Tag:jp?Tag:jp" . "(1491322168)")
(" %Tag:drakma?Tag:drakma" . "(1476570030)")
("COMMON LISP 第2版" . "(:ctime 1227971790 :cuser #f :mtime 1228812722 :muser #f)[[$$tag 参考文献]]\n\n* COMMON LISP 第2版\n\nGuy L. Steele Jr.著 井田昌之翻訳監修\n[[isbn:4320025881]]\n")
("絶対値を求める" . "(:ctime 1229676067 :cuser #f :mtime 1229676067 :muser #f)[[$$tag 数値]]\n\n絶対値を求めるには [[$$hs abs]] を使用します。\n{{{\n(abs -0.234)\n;=> 0.234\n}}}\n")
(" %Tag:CL-TEST-MORE'\"" . "(1582882529)")
(" %Tag:Hunchentoot?Tag:Hunchentoot" . "(1476574344)")
("Ltk:スケールを表示する" . "(:ctime 1619742073 :cuser #f :mtime 1619744709 :muser #f)* スケール\n\n{{{\n;;; LTKでスケール\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-07\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-07)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"Scale TEST\")\n    (let* (\n           (value-label (make-instance 'label\n                                       :text \"Start!\"))\n\n           (scale (make-instance 'scale\n                                 :from 0\n                                 :to 100\n                                 :length 300\n                                 :command (lambda (value)\n                                            (setf (text value-label) value))))\n\n           (btn-get-label (make-instance 'button\n                                         :text \"GetScaleValue\"\n                                         :command (lambda ()\n                                                    (format t \"ScaleValue is ~a~%\" (text value-label)))))\n           \n           (btn-close (make-instance 'button\n                                     :text \"Close\"\n                                     :command (lambda ()\n                                                (format t \"ボタンを押しました\")\n                                                (setf *exit-mainloop* t))))\n           )\n      (pack value-label)\n      (pack scale)\n      (pack btn-get-label)\n      (pack btn-close)\n      )))\n\n(main)\n}}}\n")
(" %Tag:日付と時刻 and 1>1" . "(1532959357)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45) -- /* order by \"as /*" . "(1624125027)")
("文字列のCRC32チェックサムを計算する" . "(:ctime 1357998885 :cuser #f :mtime 1357998885 :muser #f)下記では、ライブラリのironcladを利用しています。\n* ライブラリの導入方法\n{{{\n(ql:quickload :ironclad)\n}}}\n* 文字列のCRC-32を計算\n{{{\n;;; 16進数で表示するためのユーティリティ\n(defun write-seq-base-16 (seq &key ((:stream *standard-output*)\n                                    *standard-output*)\n                              &aux (*print-base* 16))\n  (map nil (lambda (e) (write e)) seq))\n}}}\n\n{{{\n(write-seq-base-16 \n (crypto:digest-sequence 'ironclad:crc32 \n                         (crypto:ascii-string-to-byte-array \n                          \"The quick brown fox jumps over the lazy dog\")))\n;>>  8C736521\n;=>  NIL\n}}}\n")
("意外な機能" . "(:ctime 1313335782 :cuser #f :mtime 1313335902 :muser #f)**** string=系は、シンボルを扱える\nシンボルは、文字列指示子([http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_designator string designator])として扱えますが、string=系はこれを扱えます\n{{{\n(string-equal :foo \"FOO\")\n;=> T\n\n(string= :foo \"FOO\")\n;=> T\n}}}\n**** string<系は、述語が成立した場合に不一致の位置を返す\n{{{\n(string< \"111\" \"112\")\n;=> 2\n\n(string-lessp \"111\" \"112\")\n;=> 2\n}}}\n**** [[$$hs ensure-directories-exist]]は mkdir -p 相当の動作をする\n{{{\n(probe-file \"/tmp/foo\")\n;=> NIL\n\n(ensure-directories-exist \"/tmp/foo/bar/baz\")\n;=> \"/tmp/foo/bar/baz\"\n}}}\n")
("選択的に属性を追加する:cxml-stp" . "(:ctime 1336737377 :cuser #f :mtime 1336737378 :muser #f)このページでは、[[CLiki:plexippus-xpath]]を組み合せる例を紹介しています~%\n** ライブラリの導入方法\n{{{\n(ql:quickload :xpath)\n}}}\n\nXML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"\n<a>\n  <b name='トド松'>6</b>\n  <b name='チョロ松'>3</b>\n  <b name='一松'>4</b>\n  <b name='カラ松'>2</b>\n  <b name='十四松'>5</b>\n  <b name='おそ松'>1</b>\n</a>\n\"\n   (stp:make-builder)))\n}}}\n下記の例では、属性nameが「おそ松」の時のみ、「長男」という値を持つ属性aliasを追加しています。\n{{{\n(let* ((doc (stp:copy *doc*)) ;破壊的に変更するのでコピー\n       (cs (xpath:all-nodes (xpath:evaluate \"/a/b\" doc))))\n  (dolist (c cs)\n    (when (string= \"おそ松\" (stp:attribute-value c \"name\"))\n      (stp:add-attribute c (stp:make-attribute \"長男\" \"alias\"))))\n  (stp:serialize doc (cxml:make-string-sink)))   ; XML文字列へ\n;=>  \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n;    <a>\n;      <b name=\\\"トド松\\\">6</b>\n;      <b name=\\\"チョロ松\\\">3</b>\n;      <b name=\\\"一松\\\">4</b>\n;      <b name=\\\"カラ松\\\">2</b>\n;      <b name=\\\"十四松\\\">5</b>\n;      <b alias=\\\"長男\\\" name=\\\"おそ松\\\">1</b>\n;    </a>\"\n}}}\n")
("リストを逆順にする" . "(:ctime 1227519902 :cuser #f :mtime 1328667971 :muser #f)[[$$tag リスト]]\n\nリストを逆順にするには [[$$hs reverse]] 関数を使います。\n\n{{{\n(reverse '(1 2 3 4)) ; => (4 3 2 1)\n(reverse '()) ; => ()\n}}}\n\nLisp系言語 では計算結果をリストの先頭に逐次 [[$$hs cons]] して行き、逆となっているものを最後に [[$$hs reverse]] するというイディオムがよく使われます。Lispのリスト構造の性質上、リストの末尾への追加とちがい先頭への追加は高速に処理できるためです。\n{{{\n(defun map1 (fn xs)\n  (do ((xs xs (cdr xs))\n       (rs () (cons (funcall fn (car xs)) rs)))\n      ((endp xs) (nreverse rs)))) ; nreverse はreverseの破壊版\n\n(map1 #'1+ '(1 2 3 4))\n;=> (2 3 4 5)\n}}}\n")
("要素名で探して処理する:plexippus-xpath" . "(:ctime 1336642678 :cuser #f :mtime 1336642678 :muser #f)ライブラリ導入\n{{{\n(ql:quickload :xpath)\n}}}\n\nXML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"<a xmlns='http://tips.lisp-users.org/common-lisp'><b>1</b><b>1</b><b>9</b><c>2</c></a>\"\n   (stp:make-builder)))\n}}}\n\n{{{\n(xpath:with-namespaces ((\"x\" (stp:namespace-uri (stp:document-element *doc*))))\n  (dolist (e (xpath:all-nodes (xpath:evaluate \"//x:b\" *doc*)))\n    (format t\n            \"~A => ~A~%\"\n            (xpath-protocol:local-name e) (xpath:string-value e))))\n;>>  b => 1\n;>>  b => 1\n;>>  b => 9\n;>>\n;=>  NIL\n}}}\n")
("多値を連結する" . "(:ctime 1319129611 :cuser #f :mtime 1319129611 :muser #f){{{\n(multiple-value-call #'values (values 1 2 3) (values 4 5 6) (values 7 8 9))\n;=>  1\n;    2\n;    3\n;    4\n;    5\n;    6\n;    7\n;    8\n;    9\n\n(multiple-value-call #'list (values 1 2 3) (values 4 5 6) (values 7 8 9))\n;=>  (1 2 3 4 5 6 7 8 9)\n\n\n(multiple-value-call #'+ (values 1 2 3) (values 4 5 6) (values 7 8 9))\n;=>  45\n}}}\n")
("Common Lisp の スコープ と エクステント" . "(:ctime 1228170031 :cuser #f :mtime 1228170119 :muser #f)[[$$tag 参考文献]]\n\n* Common Lisp の スコープ と エクステント\n株式会社数理システム 黒田 寿男氏による、ANSI Common Lispの変数のスコープ、エクステント仕様を正しく理解できるようになるための手引書\n- [http://cl-www.msi.co.jp/solutions/knowledge/lisp-world/tutorial/scope-and-extent.pdf Common Lisp の スコープ と エクステント(PDF)]\n")
(" %Tag:net-telent-date'A=0" . "(1566862008)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45) -- /* order by \"as /*" . "(1624124949)")
("定義されていないスーパクラスメソッドの呼び出しを防ぎたい" . "(:ctime 1228017976 :cuser #f :mtime 1228017977 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* 定義されていないスーパクラスメソッドの呼び出しを防ぎたい\n\nnext-method-pを使用するとスーパクラスにメソッドが定義されているかを確認してから呼び出せます。\n{{{\n(defclass one () ())\n(defclass two (one) ())\n\n(defmethod meth1 ((c two))\n  (print \"2!\")\n  (and (next-method-p)\n       (call-next-method)))\n\n(defmethod meth1 ((c one))\n  (print \"1!\")\n  (and (next-method-p)\n       (call-next-method)))\n\n;=> nil\n(meth1 (make-instance 'two))\n;-> \"2!\" \n;   \"1!\" \n;=> nil\n}}}\nもしくは、定義されていないスーパクラスメソッドを呼び出した場合に呼ばれる no-next-method の動作を定義することでも対処できます。\n{{{\n(defclass one () ())\n(defclass two (one) ())\n\n(defmethod meth2 ((c two))\n  (print \"2!\")\n  (call-next-method))\n\n(defmethod meth2 ((c one))\n  (print \"1!\")\n  (call-next-method))\n\n(defmethod no-next-method ((gf (eql #'meth2)) (meth T) &rest args)\n  (declare (ignore args))\n  nil)\n\n(meth2 (make-instance 'two))\n;-> \"2!\" \n;   \"1!\" \n;=> nil\n}}}\n")
("ページの最終更新日を調べる" . "(:ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f)[[$$tag Webオートメーション ライブラリ drakma net-telent-date]]\n\n* ページの最終更新日を調べる\n\n下記の例では、Webクライアントに[[CLiki:DRAKMA]]、日付文字のパーズに[[CLiki:net-telent-date]]を利用しています。\n{{{\n;; 素朴な実装\n(defun sort-url (urls &key (test #'<))\n  (flet ((ut-date-url (urls)\n           (MAPCAR (lambda (url &aux (lastmod (last-modified url)))\n                     (list (if lastmod (date:parse-time lastmod) 0)\n                           (or lastmod \"<NONE SPECIFIED>\")\n                           url))\n                   URLS)))\n    (format T \"~:{~*~&~29A: ~A~%~}\" \n            (sort (ut-date-url urls) test :key #'first))))\n\n(defun last-modified (url)\n  (macrolet ((%header (req) `(nth-value 2 ,req)))\n    (drakma:header-value :last-modified\n      (%header (drakma:http-request url :method :head)))))\n}}}\n{{{\n;; 実行例\n(sort-url '(\"http://tips.lisp-users.org\"\n            \"http://tips.lisp-users.org/common-lisp/\"\n            \"http://tips.lisp-users.org/scheme\"\n            \"http://shibuya.lisp-users.org/\"))\n;-> <NONE SPECIFIED>             : http://tips.lisp-users.org/common-lisp/\n;   <NONE SPECIFIED>             : http://tips.lisp-users.org/scheme\n;   <NONE SPECIFIED>             : http://shibuya.lisp-users.org/\n;   Thu, 20 Nov 2008 02:33:58 GMT: http://tips.lisp-users.org\n;=> NIL\n}}}\n\n** 議論\n")
(" %Tag:Metatilities" . "(1227414987 (\"現在の日付を求める\" :ctime 1227414677 :cuser #f :mtime 1227414949 :muser #f) (\"うるう年かどうか判定する\" :ctime 1227414804 :cuser #f :mtime 1227414922 :muser #f) (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1227414906 :muser #f) (\"月の最後の日を調べる\" :ctime 1227414848 :cuser #f :mtime 1227414871 :muser #f))")
(" %Tag:drakma?Tag?Tag?Tag:drakma?Tag?Tag" . "(1476570303)")
(" %Tag:portable-threads'" . "(1667340008)")
(" %Tag:????' and 'x'='x" . "(1587484318)")
("Hunchentoot" . "(:ctime 1292946216 :cuser #f :mtime 1292947854 :muser #f)[[$$tag Hunchentoot Webサーバ]]\n- [[Hunchentootを起動する]]\n- [[Hunchentootでリクエストハンドラを定義する]]\n- [[Hunchentootでディスパッチャを定義する]]\n- [[Hunchentootでセッションを管理する]]\n")
("CLIMの読みはシーリムとクリムどちらが正しいか" . "(:ctime 1318391551 :cuser #f :mtime 1318391551 :muser #f)[[CLOSの読みはシーロスとクロスどちらが正しいか]]と同様に、CLIMにもシーリム派とクリム派があるようです。~%\nCLIMの開発者(Scott Mckay氏等)は、シーリムといっているようですが色々あるようです~%\n")
(" %Tag:CL-TEST-MORE and 1=1" . "(1582882533)")
("非真正リストを真正リストに変換する" . "(:ctime 1231231029 :cuser #f :mtime 1231316965 :muser #f)[[$$tag リスト]]\n\n* 非真正リストを真正リストに変換する\n\n最後の cdr が '() でないリストを普通の（真正）リスト([http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#proper_list proper_list])と区別して非真正リスト([http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_i.htm#improper_list improper_list])と呼びます。\n循環リスト、点対リストは、非真正リストです。\n\nこのコード例だと、(foo . #0=(bar baz . #0#)) のように途中で循環しているリストを与えたら無限ループに入りますので「うさぎと亀」アルゴリズムなどを使った方が良いでしょう。\n{{{\n;; 非真正リストを真正リストに変換\n(defun improper-list->proper-list (list)\n  (check-type list list)\n  (do ((again? nil)\n       (x list (cdr x))\n       (ans () (cons (car x) ans)))\n      (nil)\n    (typecase x\n      (null (return (nreverse ans)))\n      (atom (return (nreconc ans (list x))))\n      (T (when (and (eq x list)\n                    (prog1 again? (setq again? T)))\n           (return (nreverse ans)))))))\n\n;; 試してみる\n\n;; 真正リスト\n(improper-list->proper-list '(foo bar baz))\n;=> (FOO BAR BAZ)\n\n;; 点対リスト\n(improper-list->proper-list '(foo bar . baz))\n;=> (FOO BAR BAZ)\n\n;; 循環リスト\n(let ((circl (list 'foo 'bar 'baz)))\n  (setf (cdr (last circl)) circl)\n  (improper-list->proper-list circl))\n;=> (FOO BAR BAZ)\n}}}\n\n* 議論\n\n- このコードだと、(foo #0=(bar baz . #0#)) のように途中で循環しているリストを与えたら無限ループに入っちゃいます。「うさぎと亀」アルゴリズムなどを使った方が良いでしょう。(直したらこのコメントは消しちゃって構いません)\n- (foo #0=(bar baz . #0#)) だと proper list なので (foo . #0=(bar baz . #0#)) ですよね。お手軽にチェックするならlist-lengthを使ってこういうのとかでしょうか。\n{{{\n(defun check-list (list)\n  (handler-case \n      (typecase (list-length list)\n        (null 'circular-list)\n        (number 'proper-list))\n    (type-error (c) 'dotted-list)))\n}}}\n")
("指定した長さの配列を作成する" . "(:ctime 1284803879 :cuser #f :mtime 1284804196 :muser #f)[[$$tag 配列]]\n\n[[$$hs make-array]]に長さを指定することで任意の長さの配列を生成することが可能です。~%\n{{{\n(make-array 10 :initial-element 'e)\n}}}\nまた、[http://www.lispworks.com/documentation/HyperSpec/Body/02_dhc.htm #(]リーダーマクロによりREAD時に生成することも可能です。\n{{{\n;; #10(e) ≡ #.(make-array 10 :initial-element 'e)\n#10(e)\n;⇒ #(E E E E E E E E E E)\n}}}\nなお、生成されるタイミングにより生成されるオブジェクトも変ってきます。\n{{{\n(defun mkvector ()\n  (let ((w #(e e e e e e e e e e))     ;READ時に生成\n        (x #10(e))                     ;READ時に生成\n        (y #.(make-array 10 :initial-element 'e)) ;READ時に生成\n        (z (make-array 10 :initial-element 'e)))  ;実行時に生成\n    (list w x y z)))\n\n(mapcar #'eq\n        (mkvector)\n        (mkvector))\n;⇒ (T T T NIL)\n\n(mapcar #'equalp\n        (mkvector)\n        (mkvector))\n;⇒ (T T T T)\n}}}\n")
("ハッシュの要素数を取得する" . "(:ctime 1227413641 :cuser #f :mtime 1227413641 :muser #f)[[$$tag ハッシュ]]\n* ハッシュの要素数を取得する\nhash-table-countで要素数を取得することができます。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  (hash-table-count ht))\n;=> 3\n}}}\n")
("QUOTEとFUNCTIONを使い分ける" . "(:ctime 1230117851 :cuser #f :mtime 1230190336 :muser #f)[[$$hs 関数]]\n\n* QUOTEとFUNCTIONを使い分ける\n\n関数を引数として渡す書法では、[[$$hs function]](#')や[[$$hs quote]](')が使われますが、使われる状況によって意味合いが変ってくることがあります。\n\n*** 局所関数と大域関数\n[[$$hs quote]]では、大域の関数を参照([[$$hs symbol-function]]の値と同じ)しますが、[[$$hs function]]ではもっとも内側のスコープの関数を参照します。\n{{{\n(defun foo (&rest args)\n  (format nil \"global foo!!! => ~{~A~^ ~}\" args))\n\n(defun bar ()\n  (flet ((foo (&rest args)\n           (format nil \"local foo!!! => ~{~A~^ ~}\" args)))\n    (list \n     (apply #'foo '(1 2 3))\n     (apply 'foo '(1 2 3)))))\n\n(bar)\n;=> (\"local foo!!! => 1 2 3\" \"global foo!!! => 1 2 3\")\n}}}\n\n*** もう少し詳しい説明\n- [[QUOTEとFUNCTIONを使い分ける:もう少し詳しい説明]]\n")
("CLOSの読みはシーロスとクロスどちらが正しいか" . "(:ctime 1227899666 :cuser #f :mtime 1227899678 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* CLOSの読みはシーロスとクロスどちらが正しいか\n\nCLOSを策定の中心人物の一人、Daniel G. Bobrow氏によれば、どちらでも良いとのことで、また、CL FAQにも\"See-Loss\" or \"Closs\"とあり実際にどちらも良く耳にします。\n\n\n\n")
(" %Tag:最適化?p=Tag:最適化" . "(1491322133)")
(" %Tag:drakma'[0]" . "(1666190264)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 601 #" . "(1624125217)")
("繰り返しからの脱出" . "(:ctime 1227416045 :cuser #f :mtime 1380287635 :muser #f)[[$$tag 制御構造 【募集中】]]\n\n** loopの場合\n通常の終了は [[$$hs loop-finish]] を使います。\n{{{\n(loop for i in '(1 2 3 4 5)\n      do (print i)\n         (loop-finish))\n}}}\n\nreturnキーワードでも脱出できます。\n{{{\n(loop for i in '(1 2 3 4 5)\n      do (print i)\n      return i)\n}}}\nreturn による脱出は finally キーワードで指定されたフォームが実行されないので、脱出というより中断的な意味合いになると思います。([[繰り返しの前処理・後処理]])\n\n無条件に脱出するのはあまり役に立たないので、普通は条件指定します。\n{{{\n(loop for i in '(1 2 3 4 5)\n      if (evenp i)\n      do (print i)\n         (loop-finish))\n}}}\nネストしたループから抜けるには namedと[[$$hs return-from]]を組み合わせて使います\n{{{\n(loop named outer\n      for i from 1 to 10 do\n      (loop for j from 1 to 10\n            if (= (+ i j) 10)\n            do (return-from outer (cons i j))))\n}}}\n")
(" %Tag:Hunchentoot" . "(1668302430 (\"Hunchentootを起動する\" :ctime 1292947409 :cuser #f :mtime 1292947883 :muser #f) (\"Hunchentoot\" :ctime 1292946216 :cuser #f :mtime 1292947854 :muser #f))")
(" %Tag:c2mop" . "(1668243603 (\"インスタンス生成を記録しておき後で条件を満すものを抽出したい\" :ctime 1227530644 :cuser #f :mtime 1551866854 :muser #f) (\"クラスに必須スロットを設定する\" :ctime 1338974638 :cuser #f :mtime 1339113652 :muser #f))")
(" %Tag:????999999.1 union select unhex(hex(version())) -- and 1=1" . "(1587484324)")
(" %Tag:jp'" . "(1581825622)")
("配列を任意の値で埋める" . "(:ctime 1228105446 :cuser #f :mtime 1228112194 :muser #f)[[$$tag 配列]]\n\n* 配列を任意の値で埋める\n\n[[$$hs fill]] はシークエンス全般に適用できます。:start と :end で範囲を指定できます。省略すればすべての要素が指定したアイテムで埋まります。\nまた、 [[$$hs fill]] は破壊的に変更された元の配列を返します。\n{{{\n(let ((v (vector 0 1 2 3 4 5 6 7 8 9)))\n  (fill v 88 :start 1 :end 4)\n  v)\n;=> #(0 88 88 88 4 5 6 7 8 9)\n}}}\n")
("初期化ファイル" . "(:ctime 1329665428 :cuser #f :mtime 1379676279 :muser #f)||処理系||ファイル名(断わりがなければホームディレクトリ直下に設置)||\n||SBCL||.sbclrc||\n||Clozure CL||ccl-init.fasl, ccl-init.lisp .ccl-init.lisp||\n||LispWorks||.lispworks||\n||Allegro CL||.clinit.cl, clinit.cl||\n||ABCL||.abclrc||\n||Scieneer CL||.scl-init.lisp||\n||CLISP||.clisprc, .clisprc.lisp||\n||CMUCL||init.lisp, .cmucl-init.lisp||\n||ECL||.ecl, .eclrc||\n")
("変数の型宣言" . "(:ctime 1292909932 :cuser #f :mtime 1363965608 :muser #f)　最適化の一環として変数の型を宣言しておくという方法があります。\n[[$$hs declare]]と[http://www.lispworks.com/documentation/HyperSpec/Body/d_type.htm type]を使用すると、以下のように変数の型を宣言することが可能です。\n{{{\n(let ((i 100))\n    (declare (type fixnum i));;iはfixnumであるという宣言\n;;ここで何か処理を実行するときはiはfixnumとして扱われます。\n    i)\n}}}\nまた、typeは省略可能で\n{{{\n(let ((i 100))\n    (declare (fixnum i));;iはfixnumであるという宣言\n;;ここで何か処理を実行するときはiはfixnumとして扱われます。\n    i)\n}}}\nのように宣言することも可能です。\n\n　そもそも宣言した型が誤っている場合や、この型宣言が有効なスコープ内で、宣言した型とは違う値を代入したり、違う型になる演算をした場合は、結果は不確定なものとなります。\n\n;; 直交という表現が難しかったので代替表現を考えましたが保留\n;;　また、この型宣言が多重にネストする場合は、内側で宣言する型は外側で宣言している型すべてとandの関係になることが可能でなければなりません\n;;{{{\n;;(let ((foo 3))\n;;  (declare (integer foo))\n;;  (let ((foo 4.0))\n;;    (declare (float foo))\n;;    foo))\n;;;=> error ; (and integer float)は不正\n;; とおもったけど処理系依存？\n;;(let ((foo 3))\n;;  (declare (integer foo))\n;;  (let ((foo 4))\n;;    (declare (integer foo))\n;;    foo))\n;;;=> 4\n;;\n;;(let ((foo 3))\n;;  (declare (fixnum foo))\n;;  (let ((foo 4))\n;;    (declare (integer foo)) ; (declare ((and fixnum integer) foo))と同じになる。この例の場合はつまりfixnum\n;;    foo))\n;;;=> 4\n;;}}}\n\n　多くの静的型言語では型宣言はプログラムの意味に制約をつけるもので、\nその制約に違反している場合はコンパイラがエラーを出してくれます。\n一方、Common Lispにおける型宣言はコンパイラに対するヒントであって、\n「コンパイラにはわからないだろうけど、俺(プログラマ)はここはfixnumってわかってるんで、\n最適化よろしく」という感じで使うものです。コンパイラよりプログラマの方が\n多くを知っている、という前提があります。\n\n　したがって、型宣言と矛盾するデータを渡したとしてもコンパイラは何も警告\nしてくれないどころか、実行してみるとSEGVで落ちるようなコードになることも良くあります。\n不正なデータが渡らないように型をチェックするコードなどは陽に書かなければなりません。\nコンパイラは、型宣言に関してはプログラマを全面的に信頼します。\n宣言が守られることを保証するのはプログラマの役割なのです。\n\n\n** 議論\n\n")
(" %Tag:url-rewrite?Tag:url-rewrite" . "(1476570613)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') as tempxtestxtable where 1=2-- -" . "(1656001239)")
(" %recent-changes" . "((\"FiveAM\" . 1660192441) (\"ワイルドカードを展開したパスにする\" . 1631079351) (\"入出力\" . 1631078775) (\"落とし穴\" . 1630548541) (\"最もよく現れるデータを見つけたい\" . 1630548155) (\"ハッシュの要素をランダムに抽出する\" . 1630548071) (\"loop\" . 1630548022) (\"format:NIL を () として印字したい\" . 1626990240) (\"format\" . 1620277851) (\"CAPI:電卓アプリ(ボタン応用)\" . 1620087217) (\"Ltk:電卓アプリ(ボタン応用)\" . 1620087194) (\"CAPI\" . 1620086931) (\"GUI\" . 1620086563) (\"Ltk:ウィジェットスタイルを変更する\" . 1619790387) (\"Ltk:メニューから他ウィンドウを表示する\" . 1619744908) (\"Ltk:テキスト入力欄を表示する\" . 1619744822) (\"Ltk:メニューを表示する\" . 1619744771) (\"Ltk:複数行テキストを表示する\" . 1619744757) (\"Ltk:ラベルを設定する\" . 1619744739) (\"Ltk:pack後のオブジェクトのパラメータ設定をする\" . 1619744725) (\"Ltk:スケールを表示する\" . 1619744709) (\"Ltk:ラジオボタンを表示する\" . 1619744698) (\"Ltk:チェックボタンを表示する\" . 1619744686) (\"Ltk:ボタンを表示する\" . 1619744645) (\"Ltk:キーバインドを設定する\" . 1619744395) (\"Ltk\" . 1619742314) (\"Ltk:新規にウィンドウを表示する\" . 1619741803) (\"ANSI-CL/CLtL2/CLtL1シンボル比較表\" . 1619714066) (\"シンボル\" . 1616467986) (\"多次元配列の要素をランダムに抽出する\" . 1612437979) (\"配列\" . 1612437813) (\"inferior-shell\" . 1608385543) (\"コマンドライン\" . 1608385391) (\"CL-PPCRE\" . 1607226708) (\"リンク集\" . 1606361804) (\"逆引きCommon Lisp書式\" . 1606312296) (\"処理系を表すfeature一覧\" . 1606312122) (\"処理系:選び方の目安\" . 1606311892) (\"go to\" . 1605275555) (\"標準組み込みのシンボルを上書きしたい\" . 1600090070) (\"仮引数で宣言されていないキーワードを渡す\" . 1599529753) (\"関数\" . 1599528850) (\"文字列から式を組み立てる\" . 1588025170) (\"マクロ\" . 1588024744) (\"Linuxのディストリビューションを判定する\" . 1586447198) (\"OS\" . 1586446166) (\"逆引きCommon Lisp\" . 1586446118) (\"処理系を起動したディレクトリのパスネームを返す\" . 1579751086) (\"SLIME:slime-indentation\" . 1573371720) (\"Clozure CL\" . 1566555078))")
(" %Tag:local-time') and 1=2 and ('1'='1" . "(1660041685)")
("ニックネームを変える" . "(:ctime 1294750991 :cuser #f :mtime 1294750991 :muser #f)[[$$tag パッケージ]]\n* ニックネームを変える\n\n既存パッケージのニックネームは rename-package で変更することができます。\n\n{{{\n(defpackage :foo\n  (:nicknames :bar))\n;=> #<PACKAGE \"FOO\">\n\n(package-nicknames :foo)\n;=> (\"BAR\")\n\n(rename-package :foo (package-name :foo) '(:baz :baha))\n;=> #<PACKAGE \"FOO\">\n\n(package-nicknames :foo)\n;=> (\"BAHA\" \"BAZ\")\n\n(rename-package :foo (package-name :foo) nil)\n;=> #<PACKAGE \"FOO\">\n\n(package-nicknames :foo)\n;=> NIL\n}}}\n")
(" %Tag:trivial-shell/.env" . "(1659722101)")
("インスタンス変数・クラス変数を定義する" . "(:ctime 1230290536 :cuser #f :mtime 1230290689 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* インスタンス変数・クラス変数を定義する\n\nインスタンス変数・クラス変数の違いは、[[$$hs defclass]]でのスロットの定義で :allocation に:classか:instanceを指定することにより定義します。 :allocation の指定が省略された場合は、:instanceの指定となります。\n{{{\n(defclass foo ()\n  ((class-var :initform () \n              :allocation :class\n              :accessor class-var)\n   (instance-var :initform () \n                 :allocation :instance\n                 :accessor instance-var)))\n\n(let ((foo-1 (make-instance 'foo))\n      (foo-2 (make-instance 'foo)))\n\n  ;; foo-1の値を変更\n  (setf (class-var foo-1) 100\n        (instance-var foo-1) 50)\n\n  ;; foo-2の値を確認\n  (list (class-var foo-2)\n        (instance-var foo-2)))\n;=> (100 NIL)\n}}}\nクラス変数とした場合、継承した子クラスの同名スロットを変更すると親クラスのスロットまで変更されるので、これを意図しない場合注意が必要です。\n{{{\n(defclass bar (foo) ())\n\n(let ((foo-1 (make-instance 'foo))      \n      (bar-1 (make-instance 'bar)))\n\n  ;; foo-1のclass-varに100を設定\n  (setf (class-var foo-1) 100)\n\n  ;; bar-1の値を変更\n  (setf (class-var bar-1) 'bar\n        (instance-var bar-1) 50)\n\n  ;; foo-1の値を確認\n  (list (class-var foo-1)\n        (instance-var foo-1)))\n;=> (BAR NIL)\n}}}\n上記を回避するには、子クラスで再度スロットの定義をし、インスタンス変数であることを明記する必要があります。\n{{{\n(defclass baz (foo) \n  (;; allocation指定を省略するとデフォルトは:instance\n   (class-var :accessor class-var))) \n\n(let ((foo-1 (make-instance 'foo))      \n      (baz-1 (make-instance 'baz)))\n\n  ;; foo-1のclass-varに100を設定\n  (setf (class-var foo-1) 100)\n\n  ;; baz-1の値を変更\n  (setf (class-var baz-1) 'baz\n        (instance-var baz-1) 50)\n\n  ;; foo-1の値を確認\n  (list (class-var foo-1)\n        (instance-var foo-1)))\n;=> (100 NIL)\n}}}\n")
("format:文字列を生成する" . "(:ctime 1297574995 :cuser #f :mtime 1297574995 :muser #f)第2引数にNILを与えることにより、出力を文字列として取り出すことが可能です。\n{{{\n(format nil \"~A\" \"こんにちは\")\n;=> \"こんにちは\"\n}}}\n上記は大体下記のように書いたことと同じになります\n{{{\n(with-output-to-string (out)\n  (format out \"~A\" \"こんにちは\"))\n;=> \"こんにちは\"\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' or(1=2)#" . "(1656001228)")
(" %Tag:ECL" . "(1667933901 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f))")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45) --  /*" . "(1624124486)")
("小技" . "(:ctime 1337413896 :cuser #f :mtime 1337413896 :muser #f)** macroletの展開を確認したい\n{{{\n(macrolet ((def ()\n               `(progn\n                  ,@(mapcar (lambda (c)\n                              (let ((class-name (class-name (find-class c))))\n                                `(defmethod zot ((obj ,class-name))\n                                   (format nil\n                                           ,(format nil\n                                                    \"~~A => ~:(~A~)\"\n                                                    class-name)\n                                           obj ))))\n                            *classes* ))))\n  (def) )\n}}}\nのようなローカルマクロの展開を確認したいとします。場合によっては、SLIMEなどで展開を確認できたりもしますが、うまく展開されないこともあります。~%\nこういう場合先頭に[[$$hs quote]]を付けリストとして出力してみるのも一つの手です。\n{{{\n(macrolet ((def ()\n               '`(progn ;<- 先頭にquoteをつける\n                   ,@(mapcar (lambda (c)\n                               (let ((class-name (class-name (find-class c))))\n                                 `(defmethod zot ((obj ,class-name))\n                                    (format nil\n                                            ,(format nil\n                                                     \"~~A => ~:(~A~)\"\n                                                     class-name )\n                                            obj ))))\n                             *classes* ))))\n  (def) )\n;=>  (PROGN\n;      (DEFMETHOD ZOT ((OBJ CONS)) (FORMAT NIL \"~A => Cons\" OBJ))\n;      (DEFMETHOD ZOT ((OBJ NUMBER)) (FORMAT NIL \"~A => Number\" OBJ))\n;      (DEFMETHOD ZOT ((OBJ INTEGER)) (FORMAT NIL \"~A => Integer\" OBJ))\n;      (DEFMETHOD ZOT ((OBJ LIST)) (FORMAT NIL \"~A => List\" OBJ))\n;      (DEFMETHOD ZOT ((OBJ NULL)) (FORMAT NIL \"~A => Null\" OBJ))\n;      (DEFMETHOD ZOT ((OBJ STRING)) (FORMAT NIL \"~A => String\" OBJ))\n;      (DEFMETHOD ZOT ((OBJ SYMBOL)) (FORMAT NIL \"~A => Symbol\" OBJ))\n;      (DEFMETHOD ZOT ((OBJ VECTOR)) (FORMAT NIL \"~A => Vector\" OBJ)))\n}}}\n")
("ハッシュのキーと値を反転する" . "(:ctime 1231474598 :cuser #f :mtime 1231474872 :muser #f)[[$$tag ハッシュテーブル]]\n\n* ハッシュのキーと値を反転する\n\n値からキーを検索したいことがありますが、キーと値の逆転は下記のように書けるでしょう。(FIXME)\n\nキーと値の両方から検索する場合、[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#association_list alist]と[[$$hs assoc]]/[[$$hs rassoc]]の組み合わせも検討できるでしょう。\n{{{\n;; 逆転に際してキーの重複は後のものが有効\n(defun invert (table &key (test #'eql))\n  (let ((newtab (make-hash-table :test test)))\n    (maphash (lambda (k v)\n               (setf (gethash v newtab) k))\n             table)\n    newtab))\n\n;; 実行例\n(let ((turtles (alexandria:plist-hash-table\n                '(Howard-Kaylan (Musician Lead-Singer)\n                  John-Barbata  (Musician Drummer)\n                  Leonardo      (Ninja Leader Blue)\n                  Donatello     (Ninja Machines Purple)\n                  Al-Nichol     (Musician Guitarist)\n                  Mark-Volman   (Musician Great-Hair)\n                  Raphael       (Ninja Cool Rude Red)\n                  Michaelangelo (Ninja Party-Dude Orange)\n                  Jim-Pons      (Musician Bassist)))))\n\n  (gethash '(musician bassist) (invert turtles :test #'equal)))\n;=> JIM-PONS\n;   T\n}}}\n\n** 議論\n")
(" %Tag:日付と時刻'\"" . "(1532959352)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45) -- /* order by 'as /*" . "(1624124665)")
("MOST-POSITIVE-FIXNUM" . "(:ctime 1529822476 :cuser #f :mtime 1529822476 :muser #f)[[$$tag 定数 制限]]\n\n[[$$hs most-positive-fixnum]]は[[$$hs g:fixnum]]の中で一番大きな値です。2^15 - 1と[[$$hs array-dimension-limit]]以上でなければならず、定数なので変更することもできません。\n\n||プラットフォーム||リミット||\n||[[LispWorks]] 6.0.1 32-bit||2^29 - 1 = 536870911||\n||[[Clozure CL]] 1.7 64-bit||2^60 - 1 = 1152921504606846975||\n")
("複雑な文字列を作成する" . "(:ctime 1313396380 :cuser #f :mtime 1313397650 :muser #f)[[$$tag 文字列]]\n\n複雑な文字列を作るときは[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_stream 文字列ストリーム]が便利です。\n\n{{{\n;; 「, 」で区切られた0から9までの数\n(with-output-to-string (s)\n  (dotimes (n 10)\n    (unless (zerop n)\n      (princ \", \" s))\n    (princ n s)))\n;=> \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9\"\n}}}\n\nまた、[[$$hs format]]はとても高機能なので、formatだけでもかなり複雑な文字列を作れます。\n\n{{{\n;; 空白で区切られた1から10までの数に対応する英単語\n(format nil \"~{~R~^ ~}\" (loop :for i :from 1 :to 10 :collect i))\n;=> \"one two three four five six seven eight nine ten\"\n}}}\n")
(" %Tag:c2mop'[0]" . "(1662877675)")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 321 #" . "(1624125184)")
("多次元の配列を1つのインデックスで扱う" . "(:ctime 1233973763 :cuser #f :mtime 1234161455 :muser #f)[[$$tag 配列]]\n\n[[$$hs row-major-aref]]を利用すれば、多次元の配列を1つのインデックスで扱うことができます。\n{{{\n(let ((a10x10 (make-array '(10 10))))\n  (dotimes (i (floor (array-total-size a10x10) 2))\n    (setf (row-major-aref a10x10 i) 1))\n  a10x10)\n;=> #2A((1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0))\n}}}\n\n上記は、[[$$hs make-array]]のオプションである:displaced-toを利用し、元の多次元配列をベクタにマッピングしたものと同様の効果を持ちます。\n{{{\n(let* ((a10x10 (make-array '(10 10)))\n       (a100 (make-array 100 :displaced-to a10x10)))\n  (dotimes (i 50)\n    (setf (aref a100 i) 1))\n  a10x10)\n}}}\n** 議論\n")
("グローバル変数シンボル一覧" . "(:ctime 1305621129 :cuser #f :mtime 1363965437 :muser #f)Common Lispの標準で定められたグローバル変数には大別してスペシャル変数と定数があります。~%\nこれらは、正確にはCLパッケージのシンボルの値になりますので、下記のシンボルは、正確には、cl:*print-case*のことになり、foo:*print-case*は別のもの、ということになります。(fooパッケージがCLパッケージのシンボルをインポートしていなければ)~%\nまた、:fooのようなキーワードシンボルは、自己評価シンボルで自分自身のシンボルを値として返すことに決まっており、これはグローバルな定数で変更することはできません。\n* スペシャル変数\n- [[$$hs *]]\n- [[$$hs **]]\n- [[$$hs ***]]\n- [[$$hs *break-on-signals*]]\n- [[$$hs *compile-file-pathname*]]\n- [[$$hs *compile-file-truename*]]\n- [[$$hs *compile-print*]]\n- [[$$hs *compile-verbose*]]\n- [[$$hs *debug-io*]]\n- [[$$hs *debugger-hook*]]\n- [[$$hs *default-pathname-defaults*]]\n- [[$$hs *error-output*]]\n- [[$$hs *features*]]\n- [[$$hs *gensym-counter*]]\n- [[$$hs *load-pathname*]]\n- [[$$hs *load-print*]]\n- [[$$hs *load-truename*]]\n- [[$$hs *load-verbose*]]\n- [[$$hs *macroexpand-hook*]]\n- [[$$hs *modules*]]\n- [[$$hs *package*]]\n- [[$$hs *print-array*]]\n- [[$$hs *print-base*]]\n- [[$$hs *print-case*]]\n- [[$$hs *print-circle*]]\n- [[$$hs *print-escape*]]\n- [[$$hs *print-gensym*]]\n- [[$$hs *print-length*]]\n- [[$$hs *print-level*]]\n- [[$$hs *print-lines*]]\n- [[$$hs *print-miser-width*]]\n- [[$$hs *print-pprint-dispatch*]]\n- [[$$hs *print-pretty*]]\n- [[$$hs *print-radix*]]\n- [[$$hs *print-readably*]]\n- [[$$hs *print-right-margin*]]\n- [[$$hs *query-io*]]\n- [[$$hs *random-state*]]\n- [[$$hs *read-base*]]\n- [[$$hs *read-default-float-format*]]\n- [[$$hs *read-eval*]]\n- [[$$hs *read-suppress*]]\n- [[$$hs *readtable*]]\n- [[$$hs *standard-input*]]\n- [[$$hs *standard-output*]]\n- [[$$hs *terminal-io*]]\n- [[$$hs *trace-output*]]\n- [http://l1sp.org/cl/%2B +]\n- [http://l1sp.org/cl/%2B%2B ++]\n- [http://l1sp.org/cl/%2B%2B%2B +++]\n- [[$$hs -]]\n- [[$$hs /]]\n- [[$$hs //]]\n- [[$$hs ///]]\n* グローバルな定数\n- [[$$hs array-dimension-limit]]\n- [[$$hs array-rank-limit]]\n- [[$$hs array-total-size-limit]]\n- [[$$hs boole-1]]\n- [[$$hs boole-2]]\n- [[$$hs boole-and]]\n- [[$$hs boole-andc1]]\n- [[$$hs boole-andc2]]\n- [[$$hs boole-c1]]\n- [[$$hs boole-c2]]\n- [[$$hs boole-clr]]\n- [[$$hs boole-eqv]]\n- [[$$hs boole-ior]]\n- [[$$hs boole-nand]]\n- [[$$hs boole-nor]]\n- [[$$hs boole-orc1]]\n- [[$$hs boole-orc2]]\n- [[$$hs boole-set]]\n- [[$$hs boole-xor]]\n- [[$$hs call-arguments-limit]]\n- [[$$hs char-code-limit]]\n- [[$$hs double-float-epsilon]]\n- [[$$hs double-float-negative-epsilon]]\n- [[$$hs internal-time-units-per-second]]\n- [[$$hs lambda-list-keywords]]\n- [[$$hs lambda-parameters-limit]]\n- [[$$hs least-negative-double-float]]\n- [[$$hs least-negative-long-float]]\n- [[$$hs least-negative-normalized-double-float]]\n- [[$$hs least-negative-normalized-long-float]]\n- [[$$hs least-negative-normalized-short-float]]\n- [[$$hs least-negative-normalized-single-float]]\n- [[$$hs least-negative-short-float]]\n- [[$$hs least-negative-single-float]]\n- [[$$hs least-positive-double-float]]\n- [[$$hs least-positive-long-float]]\n- [[$$hs least-positive-normalized-double-float]]\n- [[$$hs least-positive-normalized-long-float]]\n- [[$$hs least-positive-normalized-short-float]]\n- [[$$hs least-positive-normalized-single-float]]\n- [[$$hs least-positive-short-float]]\n- [[$$hs least-positive-single-float]]\n- [[$$hs long-float-epsilon]]\n- [[$$hs long-float-negative-epsilon]]\n- [[$$hs most-negative-double-float]]\n- [[$$hs most-negative-fixnum]]\n- [[$$hs most-negative-long-float]]\n- [[$$hs most-negative-short-float]]\n- [[$$hs most-negative-single-float]]\n- [[$$hs most-positive-double-float]]\n- [[$$hs most-positive-fixnum]]\n- [[$$hs most-positive-long-float]]\n- [[$$hs most-positive-short-float]]\n- [[$$hs most-positive-single-float]]\n- [[$$hs multiple-values-limit]]\n- [[$$hs nil]]\n- [[$$hs pi]]\n- [[$$hs short-float-epsilon]]\n- [[$$hs short-float-negative-epsilon]]\n- [[$$hs single-float-epsilon]]\n- [[$$hs single-float-negative-epsilon]]\n- [[$$hs t]]\n")
(" %Tag:最適化'" . "(1331698906)")
(" %Tag:CLISP" . "(1667933885 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f) (\"処理系:日本語の扱い\" :ctime 1529826517 :cuser #f :mtime 1529826517 :muser #f))")
(" %Tag:ベクタ" . "(1668191422 (\"配列をソートする\" :ctime 1228095583 :cuser #f :mtime 1228112150 :muser #f))")
("ライブラリ" . "(:ctime 1227239160 :cuser #f :mtime 1458559719 :muser #f)[[$$toc]]\n* 総合ユーティリティ系\n- [[Tag:kmrcl]]\n- [[Tag:fare-utils]]\n- [[Tag:arnesi]]\n- [[Tag:metatilities]]\n- [[Tag:alexandria]]\n* 文字列操作\n- [[Tag:cl-ppcre]]\n- [[Tag:cl-interpol]]\n- [[Tag:jp]]\n- [[CLiki:fare-csv]]\n* インターネットサービス\n- [[Tag:drakma]]\n- [[Tag:url-rewrite]]\n* テストフレームワーク\n- [[Tag:CL-TEST-MORE]]\n* Webサーバー\n- [[Tag:Hunchentoot]]\n- [[Tag:Weblocks]]\n")
(" %Tag:JSON" . "(1668131496 (\"JSONのパース・生成\" :ctime 1346850276 :cuser #f :mtime 1346932427 :muser #f))")
(" %Tag:t@C" . "(1497416855)")
(" %Tag:【募集中】/administrator/" . "(1585999578)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae and 1=2#" . "(1656001221)")
(" %Tag:local-time' and 1=2-- -" . "(1660041656)")
("逆引きCommon Lisp書式" . "(:ctime 1365407015 :cuser #f :mtime 1606312296 :muser #f)書式の指針を以下に示します。\n絶対に従わなければならないというものではありません。\n多少間違っていても、他の人が直してくれるので大丈夫です。\n\n* 文体\nですます調で書きましょう。文章の終わりを気をつければ十分です。\n* 戻り値の書き方\n次の行に「;=> 」に続けて書きます。\nもしくは一覧性を考慮しS式と同一行に書きます。~%\n例)\n{{{\n(+ 1 1)\n;=> 2\n\n(+ 1 1)  ;=> 2\n}}}\n* 多値の書き方\n一つ目の戻り値を次の行に「;=> 」に続けて書きます。\n以降の戻り値は一つ目の戻り値と桁を揃えて書きます。~%\n例)\n{{{\n(values 1 2)\n;=> 1\n;   2\n}}}\n* 戻り値無しの書き方\n「;=> 」に続けて斜体で「''No value''」と書きます。~%\n例)\n{{{\n(values)\n;=> ''No value''\n}}}\n* 標準出力の書き方\n「;-> 」に続けて書きます。\n複数行の場合は一行目に桁を揃えます。\n戻り値よりも先に書きます。~%\n例)\n{{{\n(format t \"~@{~D~%~}\" 1 2 3)\n;-> 1\n;   2\n;   3\n;=> NIL\n}}}\n")
("ジェネレータ" . "(:ctime 1336352895 :cuser #f :mtime 1336352994 :muser #f)Common Lispにジェネレータは標準では存在しませんので似たようなものを自作するか、ライブラリを利用することになります。~%\n下記では、クロージャを用いて似たようなものを作成しています。\n{{{\n(defun gen (from below)\n  (let ((i from))\n    (lambda ()\n      (and (< i below)\n           (let ((j i))\n             (incf i)\n             j)))))\n\n(let ((g (gen 0 10)))\n  (dotimes (i 11)\n    (princ (funcall g))))\n;>>  0123456789NIL\n;=>  NIL\n}}}\n** seriesを利用した例\n{{{\n;; series の導入\n(ql:quickload :series)\n}}}\n{{{\n(let ((g (generator (scan-range :from 0 :below 10))))\n  (dotimes (i 11)\n    (princ (next-in g))))\n;->  0123456789NIL\n;=>  NIL\n}}}\n** 参照\n- [[状態を持った手続きを作る]]\n")
("部分文字列を取り出す" . "(:ctime 1227347845 :cuser #f :mtime 1313435703 :muser #f)[[$$tag 文字列 シーケンス]]\n\n部分文字列の取り出しには[[$$hs subseq]]関数を使います。\n\n{{{\n;; 2文字目から最後までを取り出す\n(subseq \"0123456\" 1)    ;=> \"123456\"\n\n;; 3文字目から4文字目までを取り出す\n(subseq \"0123456\" 2 4)  ; => \"23\"\n}}}\n\n取り出す部分の複製が返されるので、変更しても元の文字列への影響はありません。\n\n{{{\n;; s2を変更してもs1には影響しない\n(let* ((s1 \"0123456\")\n       (s2 (subseq s1 1)))\n  (setf (elt s2 0) #\\!)\n  (list s1 s2))\n;=> (\"0123456\" \"!23456\")\n}}}\n")
("format:条件分岐:文字列セットのn番目を選択する" . "(:ctime 1298373281 :cuser #f :mtime 1298373454 :muser #f)~~[ ~]で囲んだ文字列は、先頭を0番目として、引数に与えられた数値に応じて指された文字列を選択することが可能です。~%\nセパレータは、~;になります。\n{{{\n(dotimes (i 5)\n  (format t \"~[foo~;bar~;baz~]~%\" (random 3)))\n;-> foo\n;   baz\n;   foo\n;   bar\n;   foo\n;   \n;=> NIL\n}}}\n上記は動作としては、\n{{{\n(dotimes (i 5)\n  (format t \"~A~%\" (nth (random 3) '(\"foo\" \"bar\" \"baz\"))))\n}}}\nと同じように考えられます。~%\n\n馬鹿馬鹿しい例~%\n{{{\n(dotimes (i 100)\n  (format t\n          \"~[~;1~;2~;Fizz~;4~;Buzz~;Fizz~;7~;8~;Fizz~;Buzz~;11~;Fizz~;13~;14~;FizzBuzz~;16~;17~;Fizz~;19~;Buzz~;Fizz~;22~;23~;Fizz~;Buzz~;26~;Fizz~;28~;29~;FizzBuzz~;31~;32~;Fizz~;34~;Buzz~;Fizz~;37~;38~;Fizz~;Buzz~;41~;Fizz~;43~;44~;FizzBuzz~;46~;47~;Fizz~;49~;Buzz~;Fizz~;52~;53~;Fizz~;Buzz~;56~;Fizz~;58~;59~;FizzBuzz~;61~;62~;Fizz~;64~;Buzz~;Fizz~;67~;68~;Fizz~;Buzz~;71~;Fizz~;73~;74~;FizzBuzz~;76~;77~;Fizz~;79~;Buzz~;Fizz~;82~;83~;Fizz~;Buzz~;86~;Fizz~;88~;89~;FizzBuzz~;91~;92~;Fizz~;94~;Buzz~;Fizz~;97~;98~;Fizz~;Buzz~]~%\" i))\n;-> \n;   1\n;   2\n;   Fizz\n;   4\n;   Buzz\n;   Fizz\n;   7\n;   8\n;   Fizz\n;   Buzz\n;   11\n;   Fizz\n;   13\n;   14\n;   FizzBuzz\n;   16\n;   17\n;   Fizz\n;   19\n;   Buzz\n;   Fizz\n;   22\n;   23\n;   Fizz\n;   Buzz\n;   26\n;   Fizz\n;   28\n;   29\n;   FizzBuzz\n;   31\n;   32\n;   Fizz\n;   34\n;   Buzz\n;   Fizz\n;   37\n;   38\n;   Fizz\n;   Buzz\n;   41\n;   Fizz\n;   43\n;   44\n;   FizzBuzz\n;   46\n;   47\n;   Fizz\n;   49\n;   Buzz\n;   Fizz\n;   52\n;   53\n;   Fizz\n;   Buzz\n;   56\n;   Fizz\n;   58\n;   59\n;   FizzBuzz\n;   61\n;   62\n;   Fizz\n;   64\n;   Buzz\n;   Fizz\n;   67\n;   68\n;   Fizz\n;   Buzz\n;   71\n;   Fizz\n;   73\n;   74\n;   FizzBuzz\n;   76\n;   77\n;   Fizz\n;   79\n;   Buzz\n;   Fizz\n;   82\n;   83\n;   Fizz\n;   Buzz\n;   86\n;   Fizz\n;   88\n;   89\n;   FizzBuzz\n;   91\n;   92\n;   Fizz\n;   94\n;   Buzz\n;   Fizz\n;   97\n;   98\n;   Fizz\n;   \n;=> NIL\n}}}\n")
(" %Tag:ファイル処理" . "(1668194772 (\"CL-FAD\" :ctime 1432468963 :cuser #f :mtime 1432468963 :muser #f))")
("リーダーマクロを定義する:クォート型" . "(:ctime 1335982898 :cuser #f :mtime 1335982898 :muser #f)標準のリーダーマクロである「'」と同じタイプの例です。~%\n{{{\n(defun read-quote (stream ignore)\n  (declare (ignore ignore))\n  (list 'quote (read stream t nil t)))\n}}}\nリーダーがマクロ文字に遭遇すると、その文字は読み捨て、代わりに、(quote 次の一つの式)というフォームに展開します。\n{{{\n(let ((*readtable* (copy-readtable nil))) ;新しい標準のリードテーブル\n\n  (set-macro-character #\\% #'read-quote) ;%をquoteに展開\n\n  (with-input-from-string (in \"%(foo bar baz)\")\n    (read in)))\n;=>  '(FOO BAR BAZ)\n}}}\n")
("リーダーマクロを定義する:ダブルクォート型" . "(:ctime 1335984250 :cuser #f :mtime 1335984250 :muser #f)標準のリーダーマクロである「\"」と同じタイプの例です。\n{{{\n(defun read-string (stream close-char)\n  (with-output-to-string (out)\n    (do ((char (read-char stream nil :eof) (read-char stream nil :eof)))\n        ((or (eq char :eof) (char= char close-char))\n         (if (eq char :eof)\n             (error 'end-of-file :stream stream)))\n      (when (char= #\\\\ char)\n        (setq char (read-char stream nil :eof))\n        (if (eq char :eof)\n            (error 'end-of-file :stream stream)))\n      (princ char out))))\n}}}\nリーダーがマクロ文字に遭遇すると、指定した終端の文字までを読み込み文字列として返します。~%\n上記では、終端文字を文字列に含めるには、\\でエスケープすることにしています。~%\n{{{\n;;; %〜%を文字列として読む\n(let ((*readtable* (copy-readtable nil)))\n\n  (set-macro-character #\\% #'read-string)\n\n  (with-input-from-string (in \"%foo bar \\\\%baz%\") (read in)))\n;=>  \"foo bar %baz\"\n\n;;; 「〜」を文字列として読む\n(let ((*readtable* (copy-readtable nil)))\n\n  (set-macro-character #\\「 (lambda (s c) (read-string s #\\」)))\n\n  (with-input-from-string (in \"「あいうえお かきくけこ「さしすせそ\\\\」」\")\n    (read in)))\n;=>  \"あいうえお かきくけこ「さしすせそ」\"\n}}}\n")
("同じストリームをバイトストリームやキャラクタストリームとして扱いたい" . "(:ctime 1399292321 :cuser #f :mtime 1399297628 :muser #f)ストリームの要素を、[[$$hs character]]でも、[[$$hs unsigned-byte]]でも扱えるようなストリームを、Bivalent Streamと呼びます。\n\nCommon LispでBivalent Streamは、 [[CLiki:flexi-streams]] を使用することによって実現可能です。\n\n** 利用例\n\n{{{\nおはよう𠀋一郎!\n}}}\nというUTF-8のファイルが、/tmp/foo として存在するとします。\n\n{{{\n(defun utf-8-char-bytes (byte)\n  \"最初のバイトから一文字のバイト数を算出する\"\n  (let ((n (- 8 (integer-length (logxor byte #xff)))))\n    (case n\n      (0 1)\n      (1 nil)\n      (otherwise n))))\n\n(defun read-utf-8-char-octets (stream)\n  \"UTF-8の一文字分のバイトを読む\"\n  (let* ((1stoct (read-byte stream))\n         (chars (utf-8-char-bytes 1stoct))\n         (ans (make-array chars :element-type '(unsigned-byte 8))))\n    (declare ((vector (unsigned-byte 8)) ans))\n    (setf (elt ans 0) 1stoct)\n    (loop :for idx :from 1 :below chars\n          :do (setf (elt ans idx) (read-byte stream)))\n    ans))\n\n\n(with-open-file (in \"/tmp/foo\" :element-type '(unsigned-byte 8))\n  (let ((in (flex:make-flexi-stream in :external-format :utf-8)))\n    (princ\n     (list (read-utf-8-char-octets in)\n           (read-char in)\n           (read-utf-8-char-octets in)\n           (read-char in)\n           (read-utf-8-char-octets in)\n           (read-char in)\n           (read-utf-8-char-octets in)\n           (read-char in)))\n    (terpri)\n    (file-position in 0)\n    (princ\n     (list (read-char in)\n           (read-utf-8-char-octets in)\n           (read-char in)\n           (read-utf-8-char-octets in)\n           (read-char in)\n           (read-utf-8-char-octets in)\n           (read-char in)\n           (read-utf-8-char-octets in)))\n    nil))\n;>>  (#(227 129 138) は #(227 130 136) う #(240 160 128 139) 一 #(233 131 142) !)\n;>>  (お #(227 129 175) よ #(227 129 134) 𠀋 #(228 184 128) 郎 #(33))\n;=>  NIL\n}}}\n\n** 処理系ごとの対応状況\n*** SBCL\nSBCLでは、標準でBivalent Streamが利用可能です。利用する為には、[[$$hs open]]に:element-type :defaultを指定します。\n{{{\n(with-open-file (in \"/tmp/foo\" :element-type :default)\n  (princ\n   (list (read-utf-8-char-octets in)\n         (read-char in)\n         (read-utf-8-char-octets in)\n         (read-char in)\n         (read-utf-8-char-octets in)\n         (read-char in)\n         (read-utf-8-char-octets in)\n         (read-char in)))\n  (terpri)\n  (file-position in 0)\n  (princ\n   (list (read-char in)\n         (read-utf-8-char-octets in)\n         (read-char in)\n         (read-utf-8-char-octets in)\n         (read-char in)\n         (read-utf-8-char-octets in)\n         (read-char in)\n         (read-utf-8-char-octets in)))\n  nil)\n;>>  (#(227 129 138) は #(227 130 136) う #(240 160 128 139) 一 #(233 131 142) !)\n;>>  (お #(227 129 175) よ #(227 129 134) 𠀋 #(228 184 128) 郎 #(33))\n;=>  NIL\n}}}\n\n*** Allegro CL\nAllegro CLは標準状態で、Bivalent Streamが利用可能になっています。\n\n** 参考\n\n- http://www.sbcl.org/manual/index.html#Bivalent-Streams\n")
("条件判断(case)" . "(:ctime 1227415897 :cuser #f :mtime 1350654802 :muser #f)[[$$tag 制御構造]]\n* 条件判断(case文)\nC言語やJavaの switch-case に似た機能です。\n\n{{{\n(case 値\n  (条件値1\n     処理1\n     処理2 ...)\n  (条件値2\n     処理3 ...))\n}}}\n\n条件値と値が eql となる場合のみ後続の処理が順に評価されます。\n条件値に T 又は OTHERWISE を指定すると、他の全ての条件値に一致しなかった場合に評価されます。\nまた、条件値には括弧で囲った複数の値を配置することも出来ます。この場合は、括弧内のどれか１つの値と一致すれば後続の処理が評価されます。\nT と一致する値の場合の処理を記述したい場合、(T) として括弧で囲む必要があります。\n\n最後に評価された処理の値が caseの値として返ります。どの条件値とも一致しなかった場合には NILが返ります。\n")
("プログラム中でハッシュを定義する" . "(:ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f)[[$$tag ハッシュ ライブラリ fare-utils alexandria arnesi]]\n* プログラム中でハッシュを定義する\n以下のようにするとプログラム中でハッシュを定義することができます。\n検索用のテスト関数も:testで指定することが可能です。(デフォルトでは、eql)\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300))\n}}}\n見ての通りやや面倒なので、便利にするライブラリも様々提供されています。\n{{{\n;; alexandria\n(alexandria:plist-hash-table '(\"apple\" 150\n                               \"banana\" 300\n                               \"lemon\" 300)\n                             :test #'equal)\n\n;; fare-utils\n(fare-utils:alist->hash-table '((\"apple\" 150)\n                                (\"banana\" 300)\n                                (\"lemon\" 300))\n                              :test #'equal)\n\n;; arnesi\n(arnesi:build-hash-table (list :test #'equal)\n                         '((\"apple\" 150)\n                           (\"banana\" 300)\n                           (\"lemon\" 300)))\n}}}\n")
(" %Tag:%e3%83%91%e3%83%83%e3%82%b1%e3%83%bc%e3%82%b8" . "(1290635296)")
("スレッドを生成する" . "(:ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f)[[$$tag スレッド ライブラリ portable-threads bordeaux-threads]]\n\n* スレッドを生成する\n\n** portable-threadsでの例\n\nportable-threadsは主にネイティブスレッドを提供している処理系のコンパチブルレイヤです。\nスレッドの生成には、 spawn-thread スレッドの生存の確認には、 thread-alive-p を利用します。\n{{{\n(defpackage :thread-test\n  (:use :cl :portable-threads))\n(in-package :thread-test)\n\n(progn\n  (print \"Test start\")\n  (print \"Create thread\")\n\n  (let ((th (spawn-thread \"foo\" (lambda ()\n                                  (let ((*standard-output* #.*standard-output*)) ;printの出力を一箇所に纏めるため\n                                    (print \"Start thread\")\n                                    (sleep 3)\n                                    (print \"End thread\"))))))\n    (loop :while (thread-alive-p th) \n          :do (sleep 0.005)) ;wait FIXME(joinとかないのだろうか。)\n    (print \"Test compleated\")))\n;-> \"Test start\" \n;   \"Create thread\" \n;   \"Start thread\" \n;   \"End thread\" \n;   \"Test compleated\" \n;=> \"Test compleated\"\n}}}\n** bordeaux-threadsでの例\n\n{{{\n(defpackage :thread-test\n  (:use :cl :bordeaux-threads))\n(in-package :thread-test)\n\n(progn\n  (print \"Test start\")\n  (print \"Create thread\")\n\n  (let ((th (make-thread (lambda ()\n                           (let ((*standard-output* #.*standard-output*)) ;printの出力を一箇所に纏めるため\n                             (print \"Start thread\")\n                             (sleep 3)\n                             (print \"End thread\")))\n                         :name \"foo\")))\n    #+sbcl (join-thread th)\n    #-sbcl (loop :while (thread-alive-p th) :do (sleep 0.005))\n    (print \"Test compleated\")))\n;-> \"Test start\" \n;   \"Create thread\" \n;   \"Start thread\" \n;   \"End thread\" \n;   \"Test compleated\" \n;=> \"Test compleated\"\n}}}\n\n- [[スレッドを生成する:AllegroCL]]\n- [[スレッドを生成する:ScineerCL]]\n")
(" %Tag:scl" . "(1668039741 (\"スレッドを生成する:ScineerCL\" :ctime 1230694363 :cuser #f :mtime 1230694363 :muser #f))")
("ファイル内の特定の行を読み込む" . "(:ctime 1231655622 :cuser #f :mtime 1231655622 :muser #f)[[$$tag 入出力]]\n\n* ファイル内の特定の行を読み込む\n\n標準にファイルの読み込みで行を指定する方法ははありませんので、ライブラリを利用するか、自作することになるでしょう。\n\n[[CLiki:Series]] を利用した例\n{{{\n(in-package :series)\n\n(defun read-nth-line (pos file)\n  (collect-nth pos\n    (scan-file file #'read-line)))\n}}}\n{{{\n;; 実行例\n(read-nth-line 666 \"/usr/share/dict/words\")\n;=> \"Andrianampoinimerina's\"\n}}}\n\n[[$$hs file-position]]を利用した例\n{{{\n(defun read-nth-line (pos file)\n  (with-open-file (in file)\n    (let ((pos (nth-beginning-of-line-position pos file)))\n      (when pos\n        (file-position in pos)\n        (read-line in)))))\n\n(defun nth-beginning-of-line-position (n file &optional (newline-char #\\Newline))\n  (with-open-file (in file)\n    (loop :with newline := newline-char\n          :for char := (read-char in nil nil) :while char\n          :when (eql newline char) :count :it :into cnt\n          :when (>= cnt n) :return (file-position in)\n          :finally (return NIL))))\n}}}\n** 議論\n\n")
(" %Tag:募集中" . "(1458228653)")
(" %Tag:数値?p=Tag:数値" . "(1476570604)")
(" %Tag:シーケンス'A=0" . "(1550220169)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45) -- /* order by \"as /*" . "(1624124790)")
("一致する要素を全て取り除く" . "(:ctime 1228100675 :cuser #f :mtime 1370593874 :muser #f)[[$$tag 配列]]\n\n* 一致する要素を全て取り除く\n\n[[$$hs remove]] や [[$$hs delete]] はシークエンス全般に適用できますのでベクタにも利用可能です。\n{{{\n(let ((v (vector \"はちべえ\" \"やしち\" \"うっかりはちべえ\" \n\t\t \"かくさん\" \"うっかりはちべえ\" \"すけさん\"\n\t\t \"うっかりはちべえ\")))\n  (remove \"うっかりはちべえ\" v :test #'string=))\n;=> #(\"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")\n}}}\n")
("文字列の一致部分を判定する" . "(:ctime 1237902595 :cuser #f :mtime 1313438317 :muser #f)[[$$tag 文字列 シーケンス]]\n\n[[$$hs mismatch]]はふたつのシーケンスを比較して、最初から比較するときは一致しない最初の要素の位置を、最後から比較するときは一致した最後の要素の位置を返します。これを利用して、文字列がどこまで一致しているかを調べられます。\n\n{{{\n;; すべて一致するとnilを返す\n(mismatch \"foo\" \"foo\")  ;=> NIL\n\n;; 2文字目以前は一致する（3文字目以降が一致しない）\n(mismatch \"bar\" \"baz\")  ;=> 2\n\n;; 2文字目以前は一致しない（3文字目以降は一致する）\n(mismatch \"cddr\" \"cadr\" :from-end t)    ;=> 2\n}}}\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 160 #" . "(1624125162)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') and 1=1 and ('1'='1" . "(1656001232)")
("数値を2進数・8進数・16進数表現の文字列に変換するには" . "(:ctime 1227837042 :cuser #f :mtime 1328663527 :muser #f)[[$$tag 数値]]\n* 数値を2進数・8進数・16進数表現の文字列に変換するには\n[[$$hs *print-base*]] で基数を指定するか、[[$$hs format]] で ~b, ~o, ~x, ~r を使います。\n{{{\n(let ((*print-base* 2))\n  (prin1-to-string 255)) ;=> \"11111111\"\n\n(format nil \"~b\" 255)    ;=> \"11111111\"\n(format nil \"~o\" 255)    ;=> \"377\"\n(format nil \"~x\" 255)    ;=> \"FF\"\n(format nil \"~8x\" 255)   ;=> \"      FF\"\n(format nil \"~8,'0x\" 255);=> \"000000FF\"\n\n(format nil \"~vr\" 2 255)    ;=> \"11111111\"\n(format nil \"~vr\" 8 255)    ;=> \"377\"\n(format nil \"~vr\" 16 255)   ;=> \"FF\"\n}}}\n\n** リーダで読み戻せる文字列にするには\n[[$$hs *print-radix*]] に [[$$hs nil]]以外を指定すると、基数を示す文字列も印字されます。\n{{{\n(let ((*print-base* 16)\n      (*print-radix* t))\n  (format nil \"~S ~S\" #(16) 255))\n;=>\"#(#x10) #xFF\"\n}}}\n")
("コンディション" . "(:ctime 1229668291 :cuser #f :mtime 1397872707 :muser #f)[[$$tag コンディション]]\n\n- [[コンディションを発生させる]]\n- [[コンディションを捕捉する]]\n- [[特定のコンディションだけを捕捉する]]\n- [[発生したコンディションからの回復手段（再起動）を提供する]]\n- [[SBCL:定数の上書きエラーで上書きを選択する]]\n- [[コンディション処理の後に処理をやり直す]]\n- [[コンディションの内容を受け取る]]\n- [[独自のコンディションを定義し発生させる]]\n- [[隠蔽されたコンディションの発生を活性化する]]\n")
("Webサーバ" . "(:ctime 1292927796 :cuser #f :mtime 1292927979 :muser #f)[[$$tag Webサーバ]]\n\n- [[cl-http]]\n- [[Hunchentoot]]\n- [[AllegroServe]]\n- [[teepeedee2]]\n\n:その他:\n[[CLiki:HTTP server]]\n")
("構造体の要素数を取得する" . "(:ctime 1329735802 :cuser #f :mtime 1335997733 :muser #f)Common Lispの構造体は、ベクタをそのまま利用しているわけではありませんので、単純にインスタンスに[[$$hs length]]を適用すれば要素数が求められるわけではありません。~%\n但し、オプションで、[[$$hs defstruct]]が利用する内部の構造に、[[$$hs vector]]か、[[$$hs list]]を利用することが可能ですので、この場合は、[[$$hs length]]で要素数を求めることが可能です。\n{{{\n(defstruct (va (:type vector))\n  x y)\n\n(defstruct (vb (:type vector)\n               (:include va))\n  z)\n\n(length (make-vb :x 1 :y 2 :z 3))\n;=>  3\n}}}\n\n{{{\n(defstruct (la (:type list))\n  x y)\n\n(defstruct (lb (:type list)\n               (:include la))\n  z)\n\n(length (make-lb :x 1 :y 2 :z 3))\n;=>  3\n}}}\n")
(" %Tag:?????\" and \"x\"=\"x" . "(1584214739)")
(" %Tag:" . "(1667942099 (\"loop\" :ctime 1336291276 :cuser #f :mtime 1630548022 :muser #f) (\"無名関数をなんらかの方法で選別したい\" :ctime 1340979780 :cuser #f :mtime 1364489967 :muser #f) (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1302577221 :muser #f) (\"オブジェクトの初期化を行う\" :ctime 1229748239 :cuser #f :mtime 1229748296 :muser #f))")
("ハッシュに要素を追加する" . "(:ctime 1227413572 :cuser #f :mtime 1227413572 :muser #f)[[$$tag ハッシュ]]\n* ハッシュに要素を追加する\n以下のようにするとハッシュへ要素を追加することができます。~%\nCLでは空のハッシュテーブルを作成して追加という手順となるので、初期化/追加は同じ流れです。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  ;; 追加\n  (setf (gethash \"apple\" ht) 150)\n  ;; 検索 => 表示\n  (print (gethash \"apple\" ht)))\n;-> 150\n;=> 150\n}}}\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45) -- /* order by 'as /*" . "(1624124687)")
("シンボルを文字列として扱いたい" . "(:ctime 1227898595 :cuser #f :mtime 1363960926 :muser #f)[[$$tag 文字列]]\n* シンボルを文字列として扱いたい\n\nCommon Lispでは、シンボルのシンボル名が文字列で格納されているため、シンボルも文字列のように扱うことが可能な場合が多くあります。\nCLでは、これを[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_designator string designator]と呼び規定しています。\n\n{{{\n■利用例\n(defpackage :foo ...)\n(defpackage #:foo ...)\n(in-package :foo)\n...\n}}}\nシンボルからシンボル名を取り出すには、[[$$hs symbol-name]]か[http://www.lispworks.com/documentation/HyperSpec/Body/f_string.htm string]を利用します。\n{{{\n\"FOO\"\n;=> \"FOO\"\n\n(symbol-name '#:foo)\n;=> \"FOO\"\n\n(symbol-name :foo)\t\t\t;':foo, 'keyword:fooでも同じ。\n;=> \"FOO\"\n\n(symbol-name 'foo)\n;=> \"FOO\"\n\n\"foo bar baz\"\n;=> \"foo bar baz\"\n\n(symbol-name '|foo bar baz|)\n;=> \"foo bar baz\"\n\n(symbol-name :|foo bar baz|)\n;=> \"foo bar baz\"\n\n(symbol-name '#:|foo bar baz|)\n;=> \"foo bar baz\"\n\n(symbol-name '#:\\f\\o\\o\\ \\b\\a\\r\\ \\b\\a\\z)\n;=> \"foo bar baz\"\n\n(string '#:\\f\\o\\o\\ \\b\\a\\r\\ \\b\\a\\z)\n;=> \"foo bar baz\"\n\n(string= \"FOO\" 'foo)\n;=> T\n\n(equalp \"FOO\" 'FOO)\n;=> nil\n}}}\n\n[[$$hs defpackage]]等で、#:fooや、:fooが利用される理由ですが、fooとするとfooシンボルがインターンされてしまい、意図しない名前の競合が発生することがあるためで、#:fooならば、どのパッケージにもインターンされず、:fooならば、キーワードパッケージにインターンされるのみとなります。この場合(defpackage \"FOO\" ..)と直接大文字で書いてしまえば良いのですが、主に大文字をタイプするのが面倒等の理由で最近では、#:fooや、:fooと書かれる傾向が強いようです。\n")
(" %Tag:????' or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- 'x'='x" . "(1587484328)")
(" %Tag:local-time or(1=1)-- -" . "(1660041660)")
("&optionalや&keyで引数が指定されて呼び出されたか調べる" . "(:ctime 1291650200 :cuser #f :mtime 1291650200 :muser #f)[[$$tag 関数]]\n\n* &optionalや&keyで引数が指定されて呼び出されたか調べる\n\nlambda-listでは以下のようにして調べることができます\n\n{{{\n(defun hoge (&key (keyword nil keyword-specified-p)) \n  (print (list keyword keyword-specified-p)))\n(hoge) ; => (NIL NIL)\n(hoge :aaa nil) ; => (NIL T)\n\n(defun fuga (&optional (arg nil arg-specified-p)\n  (print (list arg arg-specified-p)))\n(fuga) ; => (NIL NIL)\n(fuga nil) ; => (NIL T)\n}}}\n")
("format:条件分岐" . "(:ctime 1297853071 :cuser #f :mtime 1297853071 :muser #f)~~:[XXX~;YYY~] を使うことにより出力に条件分岐を利用することが可能です。~%\n引数が nil ならば XXX が、それ以外ならば YYY が出力されます。\n\n{{{\n(format nil \"Toggle ~:[OFF~;ON~]\" nil)\n;=> \"Toggle OFF\"\n\n(format nil \"Toggle ~:[OFF~;ON~]\" t)\n;=> \"Toggle ON\"\n}}}\n")
(" %Tag:???? AND 1=1" . "(1587484321)")
("状態を持った手続きを作る" . "(:ctime 1228173536 :cuser #f :mtime 1228173569 :muser #f)[[$$tag 関数]]\n\n* 状態を持った手続きを作る\n\n関数にレキシカルな環境を閉じ込むことで状態を持った手続きを作ることができます。\n\n下記の例では、GoFデザインパターンのIteratorパターンをクロージャで真似ています。\n{{{\n(defun make-iterator (sequence)\n  (let ((idx 0)\n\t(len (length sequence)))\n    (values (lambda () (setq idx 0))\n\t    (lambda () (incf idx))\n\t    (lambda () (elt sequence idx))\n\t    (lambda () (<= len idx)))))\n\n(multiple-value-bind (first! next! current-item done?)\n    (make-iterator '(1 2 3 4))\n  (do ()\n      ((funcall done?))\n    (print (funcall current-item))\n    (funcall next!))\n  (print \"Reset!\")\n  (funcall first!)\n  (print (funcall current-item)))\n;-> 1 \n;   2 \n;   3 \n;   4 \n;   Reset!\n;   1 \n;=> 1\n}}}\nこうすることで大域的な名前空間を汚染せずに関数に状態を持たせることができます。\n\n** 参考\n- [http://homepage1.nifty.com/bmonkey/lisp/sacla/html/lisp/sequence.lisp.html Yuji Minejimaさんのmake-iterator]\n")
(" %Tag:参考文献'" . "(1656001218)")
("文字列を検索する" . "(:ctime 1313411955 :cuser #f :mtime 1313434559 :muser #f)[[$$tag 文字列 正規表現 cl-ppcre ライブラリ]]\n\n* 文字で検索する\n\n文字列の中にその文字があるか調べるには[[$$hs find]]、最初にその文字が見つかった位置を調べるには[[$$hs position]]を使います。\n\n{{{\n;; dが文字列の中に存在するときはdを返す\n(find #\\d \"abcdef\")     ;=> #\\d\n\n;; 存在しなければnilを返す\n(find #\\g \"abcdef\")     ;=> NIL\n\n;; 最初にcが見つかった位置を返す\n(position #\\c \"abcdef\") ;=> 2\n\n;; 見つからなければnilを返す\n(position #\\h \"abcdef\") ;=> NIL\n}}}\n\n* 文字列で検索する\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string 文字列]は[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#sequence シーケンス]ですので、[[$$hs search]]が利用できます。\n\n{{{\n;; 最初に\"8\"が見つかった位置を返す\n(search \"8\" \"1 3 2 3 8 6 4 7 1 5\")\n;=> 8\n\n;; 見つからなければnilを返す\n(search \"0\" \"1 3 2 3 8 6 4 7 1 5\")\n;=> NIL\n\n;; 文字列の最初から\"1\"を探す\n(search \"1\" \"1 3 2 3 8 6 4 7 1 5\")\n;=> 0\n\n;; 文字列の最後から\"1\"を探す\n(search \"1\" \"1 3 2 3 8 6 4 7 1 5\" :from-end t)\n;=> 16\n\n;; 4文字目から最後の文字までの範囲で\"3\"を探す\n(search \"3\" \"1 3 2 3 8 6 4 7 1 5\" :start2 3)\n;=> 6\n\n;; 2文字目から5文字目までの範囲で\"1\"を探す\n(search \"1\" \"1 3 2 3 8 6 4 7 1 5\" :start2 1 :end2 4)\n;=> NIL\n}}}\n\n* 正規表現で検索する\n\n正規表現はどちらかというと、文字列の中から複雑な条件に一致する部分を見つけるために使われますが、単純に特定の文字列を探すためにも使えます。\n\n[[CLiki:CL-PPCRE]]を使うと、\n\n{{{\n(ppcre:scan \"はちべえ\" \"すけさんかくさんはちべえやしち\")\n;=> 8   ; パターンに一致する部分の開始位置\n;   12  ; パターンに一致する部分の終了位置+1\n;   #() ; グループ化されたパターンに一致する部分の開始位置の配列\n;   #() ; グループ化されたパターンに一致する部分の終了位置+1の配列\n}}}\n\nこんな風に文字列を探せます。\n\n詳しくは[[正規表現]]と[[CL-PPCRE]]を見てください。\n")
(" %Tag:処理系" . "(1668290466 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f) (\"処理系\" :ctime 1227545106 :cuser #f :mtime 1529826720 :muser #f) (\"処理系:日本語の扱い\" :ctime 1529826517 :cuser #f :mtime 1529826517 :muser #f))")
(" %Tag:????' and 'x'='y" . "(1587484319)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45) -- /* order by 'as /*" . "(1624124553)")
("SLIME:日本語関係の設定:LispWorks" . "(:ctime 1229489628 :cuser #f :mtime 1229489727 :muser #f)[[$$tag SLIME]]\n\n* SLIME:日本語関係の設定:LispWorks\n\n最新のCVS版SLIMEでは、UTF-8に設定することによりSLIMEでも日本語を扱うことが可能です。\n- [[CLiki:flexi-streams]]\nが必要です。\n\n*** 処理系側(SWANK側)の設定\n\n{{{\n(lw:set-default-character-element-type 'lw:simple-char)\n(setq STREAM::*DEFAULT-EXTERNAL-FORMAT* '(:utf-8 :eol-style :lf))\n}}}\n\n*** SLIME側の設定\n{{{\n(setq slime-net-coding-system 'utf-8-unix)\n}}}\n\n*** 注意点\nLispWorksの試用版では、Emacs内から起動できないので、SWANKを別起動して、slime-connectで接続する利用形態になります。\n\n** 参考\n- [http://common-lisp.net/pipermail/slime-devel/2008-September/015580.html slime-devel:UTF-8 support for slime in Lispworks back end]\n\n\n")
(" %Tag:html" . "(1392039473)")
("ハッシュを空にする" . "(:ctime 1227413762 :cuser #f :mtime 1227413763 :muser #f)[[$$tag ハッシュ]]\n* ハッシュを空にする\n[http://www.lispworks.com/documentation/HyperSpec/Body/f_clrhas.htm clrhash]を利用します。\nclrhashの返却値は、内容がクリアされたハッシュテーブルです。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (clrhash ht))\n;=> #<HASH-TABLE :TEST EQUAL :COUNT 0 {100AF5A1E1}>\n}}}\n")
("ファイルをリネームする" . "(:ctime 1231087938 :cuser #f :mtime 1231087938 :muser #f)[[$$tag 入出力]]\n\n* ファイルをリネームする\n\nファイルのリネームには、[[$$hs rename-file]]が利用できます。\n[[$$hs rename-file]]は、返り値として3つの値を返し、(デフォルトの新ファイル名 変更前のファイル名 新ファイルの[[$$hs truename]]を返します。\n{{{\n;; foo.lispからbar.lispへ\n(rename-file \"/tmp/foo.lisp\" \"/tmp/bar.lisp\")\n;=> #P\"/tmp/bar.lisp\"\n;   #P\"/tmp/foo.lisp\"\n;   #P\"/tmp/bar.lisp\"\n}}}\n\n\n\n\n")
(":keyの活用" . "(:ctime 1336366186 :cuser #f :mtime 1336392187 :muser #f)Common Lispのシークエンスを扱う関数には:keyに関数を指定することで、読み出し方法を指定することが可能なことがあります。~%\n:keyを活用すれば、オブジェクトのスロットの値によってソートする等のことが可能です。~%\nまた、標準以外のライブラリなどでも、この規約に沿ったものが多くあります。~%\n:key が利用できるCL標準の関数は下記の通りです~%\n[[$$hs adjoin]], [[$$hs assoc]], [[$$hs assoc-if]], [[$$hs assoc-if-not]], [[$$hs find]], [[$$hs find-if]], [[$$hs find-if-not]], [[$$hs intersection]], [[$$hs member]], [[$$hs member-if]], [[$$hs member-if-not]], [[$$hs merge]], [[$$hs nintersection]], [[$$hs nset-difference]], [[$$hs nset-exclusive-or]], [[$$hs nsublis]], [[$$hs nsubst]], [[$$hs nsubst-if]], [[$$hs nsubst-if-not]], [[$$hs nunion]], [[$$hs position]], [[$$hs position-if]], [[$$hs position-if-not]], [[$$hs pushnew]], [[$$hs rassoc]], [[$$hs rassoc-if]], [[$$hs rassoc-if-not]], [[$$hs set-difference]], [[$$hs set-exclusive-or]], [[$$hs sort]], [[$$hs stable-sort]], [[$$hs sublis]], [[$$hs subsetp]], [[$$hs subst]], [[$$hs subst-if]], [[$$hs subst-if-not]], [[$$hs union]]\n\n** コード例\n下記の例では、オブジェクトのプロパティを:keyで拾うことにより、抽出、ソート、グループ化をしています。~%\n(ユーザー定義の関数の例として、com.informatimago.common-lisp.list:equivalence-classesを利用しています。)\n{{{\n(import 'com.informatimago.common-lisp.list:equivalence-classes)\n\n;;; データ(購入者名 商品名 購入日時(universal time))\n(defclass item ()\n  ((purchase-date :accessor purchase-date :initarg :purchase-date)\n   (purchaser :accessor purchaser :initarg :purchaser)\n   (product-name :accessor product-name :initarg :product-name)))\n\n(defvar *items*\n  (mapcar (lambda (p n d)\n            (make-instance 'item\n                           :purchaser p\n                           :product-name n\n                           :purchase-date d))\n        '(\"おそ松\" \"カラ松\" \"チョロ松\" \"一松\" \"十四松\" \"トド松\")\n        '(\"テレビ\" \"テレビ\" \"エアコン\" \"ノートPC\" \"扇風機\" \"掃除機\")\n        '(3512674686 3556829851 3543518696 3526561150 3514854835 3529844173)))\n}}}\n{{{\n;;; 期間でしぼりこみ\n(defun between (fn start-ut end-ut items)\n  (remove-if-not (lambda (i)\n                   (<= start-ut i end-ut ))\n                 items\n                 :key fn))\n\n\n;;; オブジェクトのスロットでソート\n(defun order-by (fn items)\n  (sort items #'< :key fn))\n\n\n;;; オブジェクトのスロットでグループ化\n(defun group-by (fn items)\n  (equivalence-classes items :test #'string= :key fn))\n\n\n;;; アイテムをプリント\n(defun print-item (item)\n  (let ((item (if (consp item) item (list item))))\n    (format t \"商品 = ~A~%\" (product-name (car item)))\n    (dolist (e item)\n      (format t \"~4T購入者は、~Aさん~%\" (purchaser e)) )))\n\n\n\n;;; 実行\n(dolist (item (group-by #'product-name\n                        (order-by #'purchase-date\n                                  (between #'purchase-date\n                                           (encode-universal-time 0 0 0 1 1 2011)\n                                           (encode-universal-time 0 0 0 31 12 2013)\n                                           *items*))))\n  (print-item item))\n;->  商品 = エアコン\n;        購入者は、チョロ松さん\n;    商品 = 掃除機\n;        購入者は、トド松さん\n;    商品 = ノートPC\n;        購入者は、一松さん\n;    商品 = 扇風機\n;        購入者は、十四松さん\n;    商品 = テレビ\n;        購入者は、カラ松さん\n;        購入者は、おそ松さん\n;\n;=>  NIL\n}}}\n")
(" %Tag:【参考文献】" . "(1227971135 (\"Tutorial on Good Lisp Programming Style\" :ctime 1227969021 :cuser #f :mtime 1227971111 :muser #f))")
(" %Tag:jp?Tag?Tag?Tag:jp?Tag?Tag" . "(1476573577)")
(" %Tag:CuǗ" . "(1461645516)")
(" %Tag:Lispbox'A=0" . "(1570630423)")
("文字列から式を組み立てる" . "(:ctime 1588024845 :cuser #f :mtime 1588025170 :muser #f)多くはありませんが、リスト等から式を組み立てるより、文字列表現から式を組み立てる方が手軽な場合があります。~%\n但し余計な中間データが発生しますので、リード時読み取りと組み合わせて定数の設定に使う等、使う場所を選ぶ必要があるでしょう。\n\n{{{\n(defvar *bit-vectors*\n  `#(,@(loop :for i :from #b00000 :to #b11111\n             :collect (read-from-string (format nil \"#*~5,'0B\" i)))))\n\n*bit-vectors*\n;=> #(#*00000 #*00001 #*00010 #*00011 #*00100 #*00101 #*00110\n      #*00111 #*01000 #*01001 #*01010 #*01011 #*01100 #*01101\n      #*01110 #*01111 #*10000 #*10001 #*10010 #*10011 #*10100\n      #*10101 #*10110 #*10111 #*11000 #*11001 #*11010 #*11011\n      #*11100 #*11101 #*11110 #*11111)\n}}}\n\n* 参考: 文字列を経由しない場合\n\n{{{\n(defun integer->bit-vector (n fig)\n  (let* ((bv (make-sequence 'bit-vector fig))\n         (len (length bv)))\n    (dotimes (i len)\n      (setf (aref bv (- len i 1))\n            (ldb (byte 1 i) n)))\n    bv))\n\n`#(,@(loop :for i :from #b00000 :to #b11111 :collect (integer->bit-vector i 5)))\n;=> #(#*00000 #*00001 #*00010 #*00011 #*00100 #*00101 #*00110\n      #*00111 #*01000 #*01001 #*01010 #*01011 #*01100 #*01101\n      #*01110 #*01111 #*10000 #*10001 #*10010 #*10011 #*10100\n      #*10101 #*10110 #*10111 #*11000 #*11001 #*11010 #*11011\n      #*11100 #*11101 #*11110 #*11111)\n}}}\n")
("最もよく現れるデータを見つけたい" . "(:ctime 1231407996 :cuser #f :mtime 1630548155 :muser #f)[[$$tag ハッシュ]]\n\n* 最もよく現れるデータを見つけたい\n\nアイテムの出現数を記録し、最大のものを見付けるにはハッシュテーブルを利用する方法等が考えられるでしょう。FIXME\n{{{\n(defgeneric most-common (container &key test)\n  (:method (container &key (test #'equal))\n    (let ((count (count-item (make-hash-table :test test) \n                             container))\n          (max 0) \n          max-var)\n      (loop :for val :being :each :hash-values :of count \n                                  :using (:hash-key key)\n            :do (when (< max val) \n                  (setq max val\n                        max-var key)))\n      (values max-var max)))))\n(defmethod most-common ((table null) &key test) \n  (values nil nil))\n\n(defgeneric count-item (table container))\n(defmethod count-item (table (list list))\n  (symbol-macrolet ((hv (gethash elt table)))\n    (loop :for elt :in list\n          :do (multiple-value-bind (val win) hv\n                (if win (incf hv) (setf hv 1)))))\n  table)\n\n;; 実行例\n(let ((list '(1 2 3 1 2 3 1 2 3 4 5 4 2 1 2 3 3 2 5 8)))\n  (most-common list :test #'eql))\n;=> 2 ;値\n;   6 ;回数\n}}}\n\n** 議論\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45) -- /* order by 'as /*" . "(1624124676)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae) or(1=1)-- -" . "(1656001233)")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae) and 1=1-- -" . "(1656001236)")
(" %Tag:数値'[0]" . "(1666763954)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45) --  /*" . "(1624124252)")
("指定の日付が存在するかどうか調べる" . "(:ctime 1227414725 :cuser #f :mtime 1335998832 :muser #f)[[$$tag 日付と時刻]]\n\nCommon Lispの標準に該当する関数はありませんので自作するかライブラリを利用することになるでしょう。~%\n{{{\n(defun date-exist-p (y m d)\n  (let ((ut (encode-universal-time 0 0 0 d m y)))\n   (multiple-value-bind (ig no re d2 m2 y2)\n                        (decode-universal-time ut)\n     (declare (ignore ig no re))\n     (and (= y y2)\n          (= d d2)\n          (= m m2)\n          ut))))\n}}}\n上記の例では、一度universal timeにエンコードし、再度デコードした結果が、与えられたものと一致した場合、真(universal time)を返します。\n{{{\n(date-exist-p 1900 2 29)\n;=>  NIL\n\n(date-exist-p 2000 2 29)\n;=>  3160738800\n\n(date-exist-p 2012 2 29)\n;=>  3539430000\n\n(date-exist-p 2013 2 29)\n;=>  NIL\n}}}\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 638 #" . "(1624125261)")
("ABLE" . "(:ctime 1329736659 :cuser #f :mtime 1329736659 :muser #f)[[$$tag 【募集中】]]\n")
(" %Tag:定数" . "(1668297017 (\"MOST-POSITIVE-FIXNUM\" :ctime 1529822476 :cuser #f :mtime 1529822476 :muser #f) (\"ARRAY-TOTAL-SIZE-LIMIT\" :ctime 1529821655 :cuser #f :mtime 1529821655 :muser #f))")
("リストから要素を探す" . "(:ctime 1228221887 :cuser #f :mtime 1328667713 :muser #f)[[$$tag リスト]]\nリストから要素を探すには [[$$hs find]] または [[$$hs member]] を使います。find は見つけた要素を、member は見つけた要素以降のリストを返します。見つからない場合はいずれも nil を返します。\n\n{{{\n(find 1 '(0 1 2 3 4))\n; => 1\n\n(member 1 '(0 1 2 3 4))\n; => (1 2 3 4)\n\n(find nil '(t nil t nil))\n; => nil\n\n(member nil '(t nil t nil))\n; => (nil t nil)\n}}}\n\nfind, member はデフォルトでは比較に [[$$hs eql]] を使います。文字列を探す場合など、eql 以外の比較関数を使いたい場合は :test, :test-not を指定します。\n\n{{{\n(find \"bar\" '(\"foo\" \"bar\" \"baz\"))\n; => nil\n\n(find \"bar\" '(\"foo\" \"bar\" \"baz\") :test #'string=)\n; => \"bar\"\n\n(find \"bar\" '(\"foo\" \"bar\" \"baz\") :test-not #'string=)\n; => \"foo\"\n}}}\n\n要素ではなく述語を満たす(あるいは満たさない)ものを探す場合は [[$$hs find-if]], [[$$hs find-if-not]], [[$$hs member-if]], [[$$hs member-if-not]] を使います。\n\n{{{\n(find-if #'oddp '(0 1 2 3 4))\n; => 1\n\n(find-if-not #'minusp '(-2 -1 0 1 2))\n; => 0\n}}}\n")
("スレッドを生成する:ScineerCL" . "(:ctime 1230694363 :cuser #f :mtime 1230694363 :muser #f)[[$$tag スレッド scl]]\n\n* スレッドを生成する:ScineerCL\n\n** Scineer CLでの例\n\nScineer CLでは主にMPパッケージにまとめられています。\n{{{\n(defpackage :thread-test\n  (:use :cl :portable-threads))\n(in-package :thread-test)\n\n(progn\n  (print \"Test start\")\n  \n  (let ((p (mp:make-process \n            (lambda ()\n              (print \"Start thread\" #.*standard-output*)\n              (sleep 3)\n              (print \"End thread\" #.*standard-output*))\n            :name \"test\")))\n\n    (print \"Waiting for the thread to complete\")\n    (mp:process-wait \"wait\" (lambda () (not (mp:process-alive-p p))))\n\n    (print \"Test compleated\")))\n\n;-> \"Test start\" \n;   \"Start thread\" \n;   \"Waiting for the thread to complete\" \n;   \"End thread\" \n;   \"Test compleated\"\n;=> \"Test compleated\"\n\n}}}\n")
("構造体要素をカンマ区切りで出力する" . "(:ctime 1329735778 :cuser #f :mtime 1397295350 :muser #f)[[$$tag 【募集中】]]\n\n構造体というかオブジェクト全般。\n\nオブジェクトの文字列プリントを司るのは print-object。\nCLOSの理解を必要としますが、見ていればわかるでしょう。\n\n\n (defstruct my-struct ....)\n\n (defmethod print-object (s (o my-struct))\n   ...)\n\n\ns は出力先のストリーム。\nprint-object を直に呼ぶことは推奨されていません。[http://www.lispworks.com/documentation/HyperSpec/Body/f_pr_obj.htm ANSI CL]\nそのため、こうなります。\n\n\n- NG: (print-object *standard-output* (make-instance 'my-struct ...))\n- OK: (print *standard-output* (make-instance 'my-struct ...))\n\n\n実際には print の中で print-object が呼ばれます。\nこのときには、*standard-output* が s に代入されて実行されます。\n\nさて、次は要素をカンマ区切りで出力する方法です。\nこれには MOP (metaobject protocol) を使います。\nクラスの内部情報を見るためのプロトコルです。\n(quicklispインストール済みを前提)\n\n\n (require :closer-mop)\n\n (defmethod print-object ((o my-struct) s)\n   (let ((names (mapcar #'slot-definition-name (class-slots (class-of o)))))\n     (let ((first t))\n       (dolist (name names)\n         (if first\n             (setf first nil)\n             (write-char #\\, s))\n         (princ name s)))))\n\n\n大事なのはこの部分ですね:\n\n (mapcar #'slot-definition-name (class-slots (class-of o)))\n\nslot-definition-name と class-slots の\nふたつの関数は、ANSIでは定義されていません。\n[http://www.alu.org/mop/index.html AMOP] に載っています。\n\n\n動くコードをまとめると:\n\n\n (in-package :cl-user)\n\n (require :closer-mop)\n (use-package :closer-mop)\n\n (defstruct my-struct\n   (x 1)\n   (y 0)\n   (z 0))\n\n (defmethod print-object ((o my-struct) s)\n   (let ((names (mapcar #'slot-definition-name (class-slots (class-of o)))))\n     (let ((first t))\n       (dolist (name names)\n         (if first\n             (setf first nil)\n             (write-char #\\, s))\n         (princ name s)))))\n\n\n (print (make-instance 'my-struct))\n\n\n")
("連想リストを使う" . "(:ctime 1227518778 :cuser #f :mtime 1328668221 :muser #f)[[$$tag リスト]]\n\n対をリストにしたものを連想リスト（association list）([[alist]]とも呼ばれる)と呼びます。 Lisp では簡単なテーブルが必要な場合に[[ハッシュテーブル]]の代わりに、リストの要素である対の car をキーとし cdr を値とする連想リストをテーブルとして使うことがあります。要素が少ない場合にはハッシュ値の計算などのオーバーヘッドもあり、ハッシュテーブルの方が低速になることもあります。\n\n連想リストを生成する場合には単純に [[$$hs quote]] や [[$$hs list]] を使ったり、必要に応じて バッククォート を使ったりします。\n\n{{{\n(defparameter *alist*\n  '((one . 1)\n    (two . 2)\n    (three . 3)))\n}}}\n\n要素を追加するには [[$$hs cons]] を使います。\n\n{{{\n(cons (cons 'four 4) *alist*) \n;=> ((FOUR . 4) (ONE . 1) (TWO . 2) (THREE . 3))\n}}}\n\n便利な専用の関数として、[[$$hs acons]] があります。\n\n{{{\n(acons 'four 4 alist) \n;=> ((FOUR . 4) (ONE . 1) (TWO . 2) (THREE . 3))\n}}}\n\n連想リストの参照には [[$$hs assoc]] 関数を使います。与えられたオブジェクトとキーの一致をテストする為の関数は、:testキーワードで指定でき省略するとデフォルトの [[$$hs eql]]が使用されます。\nまた、[[$$hs assoc-if]]は、テストする関数を引数にとり結果が真となるものを返します。\n{{{\n(assoc 'one *alist*) \n;=> (ONE . 1)\n(assoc 'five *alist* :test #'eq) \n;=> nil\n(assoc-if (lambda (x) (eq x 'one)) *alist*) \n;=> (ONE . 1)\n}}}\nキーではなく、値の方で検索する場合には、rassocを利用します。\n{{{\n(rassoc 1 *alist*) \n;=> (ONE . 1)\n(rassoc-if (lambda (x) (eq x 1)) *alist*) \n;=> (ONE . 1)\n}}}\n\n;;値だけを取り出したい場合には\n;;\n;;{{{\n;;(import (rnrs) (srfi :2))\n;;\n;;(cond ((assq 'one alist) => cdr)\n;;      (else #f)) ; => 1\n;;\n;;(cond ((assq 'six alist) => cdr)\n;;      (else #f)) ; => #f\n;;\n;;(and-let* ((p (assq 'three alist)))\n;;  (cdr p)) ; => 3\n;;}}}\n\n")
(" %Tag:IuWFNgVXe(CLOS)" . "(1294328713)")
("リストを結合する" . "(:ctime 1227520956 :cuser #f :mtime 1333387606 :muser #f)[[$$tag リスト]]\n* リストを結合する\nリストを結合するには様々な方法があり、それぞれ性質が異なります。\n\n:[[$$hs append]]:新規のリストが作成されますが、最後の要素はコピーされたものではなく連結されたものになります。\n{{{\n(append '(1 2 3) '(a b c))\n;=> (1 2 3 A B C)\n\n(let* ((a (list 1 2 3))\n       (b (list 'a 'b 'c))\n       (c (list 'i 'ii 'iii))\n       (a+b (append a b)))\n  (nconc b c) ; bとcを破壊的に連結\n  a+b)\n;=> (1 2 3 A B C I II III)\n}}}\n:[[$$hs concatenate]]:すべての要素が連結された新規のリストを返します。\n{{{\n(concatenate 'list '(1 2 3) '(a b c))\n;=> (1 2 3 A B C)\n\n(let* ((a (list 1 2 3))\n       (b (list 'a 'b 'c))\n       (c (list 'i 'ii 'iii))\n       (a+b (concatenate 'list a b)))\n  (nconc b c) ; bとcを破壊的に連結\n  a+b)\n;=> (1 2 3 A B C)\n}}}\n:[[$$hs nconc]]:先頭のリストと後のリストを破壊的に結合します。結果としてリストは破壊的に修正されます。\n{{{\n(nconc (list 1 2 3) (list 4 5 6))\n;=> (1 2 3 4 5 6)\n\n(let ((a (list 1 2 3))\n      (b (list 'a 'b 'c)))\n  (nconc a b)\n  (list a b))\n;=> ((1 2 3 A B C) (A B C))\n}}}\n\n少々トリッキーですが、以下のようにしてもリストの連結を実現できます。\n{{{\n`(,@(list 1 2 3) ,@(list 'a 'b 'c))\n;=> (1 2 3 A B C)\n}}}\n`（バッククオート）の中では,@は評価された上でその場にリストを展開されるので、`(,@(list 1 2 3))は(1 2 3)と書いてあるのと同じになります。これを利用すると、\n{{{\n(let ((ls '(a b c)))\n  `(1 2 3 ,@ls i ii iii))\n; => (1 2 3 A B C I II III)\n}}}\nのように、リストの一部に変数のリストを挿入する場合も簡単に書けます。\n\nFIXME\n{{{\n`(,.(list 1 2 3) ,.(list 4 5 6))\n;=> (1 2 3 4 5 6)\n}}}\n")
("属性リストを使う" . "(:ctime 1238173062 :cuser #f :mtime 1238173062 :muser #f)[[$$tag リスト]]\n\n属性リストはキーと値が順番にならんだリストで、連想リストと同様にキーと値を手軽に扱う方法として使用されてきたようです。\nplist(Property list)とも呼ばれます。\n\n{{{\n'(foo 1 bar 2 baz 3)\n}}}\n\n消費するコンスセルの数は連想リストと全く同じです。\n\nplistを操作するための関数には[[$$hs getf]]が用意されています。\n{{{\n(let ((plist '(foo 1 bar 2 baz 3)))\n  (list (getf plist 'foo)\n        (getf plist 'bar)))\n;=> (1 2)\n\n(let ((plist (list 'foo 1 'bar 2 'baz 3)))\n  (setf (getf plist 'foo) 100\n        (getf plist 'bar) 200)\n  plist)\n;=> (FOO 100 BAR 200 BAZ 3)\n}}}\n** 議論\n属性リスト(Property list/plist)という名前に比べ交代リストというのは、それ程聞かないのですが、竹内先生の著作等から来ているのでしょうか。\n検索エンジンから来る人は多分、属性リストで検索してくると思うので、属性リストの項目も同内容で作成してみてはどうでしょうか。 --g000001\n\nご指摘のとおりです。竹内先生の「はじめての人のためのLisp」を読んで交代リストと頭から信じ込んでいました。普段はplistと呼んでいたので深く意識しませんでしたがあらためて日本語で言うならば今だと属性リストが一般的ですね。--koga\n\n")
("繰り返し(while)" . "(:ctime 1329736276 :cuser #f :mtime 1329736295 :muser #f)Common LispにはEmacs Lispの様なwhileは存在しませんが、[[$$hs loop]]を使うか、必要ならば、簡単なマクロを書くことで実現できます。~%\nまた、ユーティリティ系のライブラリにも良く含まれています。\n*** [[$$hs loop]]マクロで\n{{{\n(loop :while (not (zerop (random 10)))\n      :do (princ \".\"))\n;-> .....\n;=> NIL\n}}}\n*** 自作\n{{{\n(defmacro while (test &body body)\n  `(do ()\n       ((not ,test))\n     ,@body))\n\n(while (not (zerop (random 10)))\n  (princ \".\"))\n;-> ............\n;=> NIL\n}}}\n")
(" %Tag:'[0]" . "(1608829501)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45) --  /*" . "(1624124442)")
("配列の先頭または末尾から要素を取りだす" . "(:ctime 1228558271 :cuser #f :mtime 1228558271 :muser #f)[[$$tag 配列]]\n\n* 配列の先頭または末尾から要素を取りだす\n\nフィルポインタ付きのベクタは [[$$hs vector-pop]] で末尾から要素を取り出すことができ、取り出した要素の分ベクタは縮みます。\n{{{\n(let ((v (make-array 5 :adjustable T\n                       :fill-pointer 5\n                       :initial-contents '(1 2 3 4 5))))\n  (list (vector-pop v)\n        (vector-pop v)\n        (vector-pop v)\n        v))\n;=> (5 4 3 #(1 2))\n}}}\n先頭から取り出したい場合は、自作することになるでしょう。FIXME\n{{{\n(defun vector-pop-front (vec)\n  (prog1 (aref vec 0)\n         (replace vec vec :start2 1)\n         (decf (fill-pointer vec))))\n\n(let ((v (make-array 5 :adjustable T\n                       :fill-pointer 5\n                       :initial-contents '(1 2 3 4 5))))\n  (vector-pop-front v) ;=> 1\n  v)\n;=> #(2 3 4 5)\n}}}\n")
(" %Tag:【募集中】?p=Tag?Tag:【募集中】?p=Tag" . "(1476573598)")
("インスタンスからスロット名を取得する" . "(:ctime 1526400878 :cuser #f :mtime 1526401054 :muser #f)ポータブルなMOPライブラリであるcloser-mopを使うことで、インスタンスからクラスのスロット名を取得できる。\n\n{{{\n(ql:quickload :closer-mop)\n\n(defclass person () ((name  :initarg :name)\n                     (email :initarg :email)\n                     (age   :initarg :age)))\n\n(defparameter person1 (make-instance 'person))\n\n(mapcar #'c2mop:slot-definition-name\n        (c2mop:class-slots (class-of person1)))\n; => (NAME EMAIL AGE)\n}}}\n\nまた、closer-mopを使ったユーティリティ集であるfare-mopを使っても同じことができる。\n\n{{{\n(ql:quickload :fare-mop)\n\n(fare-mop:collect-slots person1)\n; => nil 束縛されてないスロットは無視される\n\n(defparameter person2 (make-instance 'person :name \"foo\" :email \"foo@bar.com\" :age 30))\n\n(fare-mop:collect-slots person2)\n; => (:NAME \"foo\" :EMAIL \"foo@bar.com\" :AGE 30)\n}}}\n")
("対数を計算する" . "(:ctime 1230695185 :cuser #f :mtime 1230695227 :muser #f)[[$$tag 数値]]\n\n* 対数を計算する\n\n対数を計算するための関数には、[[$$hs exp]]、[[$$hs log]]等々が提供されています。FIXME\n\n([[$$hs log]] number &optional base)はbaseを底とするnumberの対数を返します。\n{{{\n(log 10 10)\n;=> 1.0\n}}}\n([[$$hs exp]] number)はeのn乗を返します。\n{{{\n(exp 0) ;=> 1.0\n}}}\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 642 #" . "(1624125316)")
("Universal Timeを文字列に変換する" . "(:ctime 1227414526 :cuser #f :mtime 1227414526 :muser #f)[[$$tag 日付と時刻]]\n* Universal Timeを文字列に変換する\nライブラリで提供されていることも多い。[[ライブラリ:KMRCL]]等\n{{{\n(multiple-value-bind (sec min hr day mon year dow daylight-p zone)\n    (decode-universal-time 3436143023)\n  (declare (ignore daylight-p zone))\n  (format nil \"~[Mon~;Tue~;Wed~;Thu~;Fri~;Sat~;Sun~] ~d ~[Jan~;Feb~;Mar~;Apr~;May~;Jun~;Jul~;Aug~;Sep~;Oct~;Nov~;Dec~] ~d ~2,'0d:~2,'0d:~2,'0d\"\n          dow\n          day\n          (1- mon)\n          year\n          hr min sec))\n;=> \"Thu 20 Nov 2008 13:10:23\"\n}}}\n{{{\n(format nil \"~{~A~^-~}\" (reverse \n                       (butlast \n                        (multiple-value-list \n                            (decode-universal-time 3436143023))\n                        3)))\n;=> \"2008-11-20-13-10-23\"\n}}}\n")
(" %Tag:構造体" . "(1668087700 (\"コンストラクタが受け取る引数の形式を変更したい\" :ctime 1329126517 :cuser #f :mtime 1363813318 :muser #f) (\"構造体を作成する\" :ctime 1229600738 :cuser #f :mtime 1336244558 :muser #f) (\"構造体\" :ctime 1229599940 :cuser #f :mtime 1329126153 :muser #f))")
("オブジェクトの初期化を行う" . "(:ctime 1229748239 :cuser #f :mtime 1229748296 :muser #f)[[$$tag オブジェクトシステム(CLOS) ]]\n\n* オブジェクトの初期化を行う\n\n[[$$hs defclass]] で定義する際に初期値を設定することが可能です。\n初期値の指定には、:initform、:initarg、:default-initargs等を状況に応じて使い分けます。\n# :initform で指定した値はインスタンスが作成された時や、クラスを変更して新しく追加されたスロットの初期値となります。\n# :initargは [[$$hs make-instance]] でのインスタンス作成時に指定するキーワードを指定します。\n# :default-initargs は、インスタンス作成時にキーワードでの初期値設定が省略された場合のデフォルト値をplist形式で設定します。\n{{{\n(defclass foo ()\n  ((x :initform 0)\n   (y :initform 10\n      :initarg :y)\n   (z :initarg :z))\n  (:default-initargs :z 100))\n\n(describe (make-instance 'foo))\n;-> #<FOO 20095F07> is a FOO\n;   X      0\n;   Y      10\n;   Z      100\n\n;; キーワードにより初期値を与える。\n;; (xスロットは:initargを設定していないため、この方法では初期値を設定できない)\n(describe (make-instance 'foo :y 20 :z 30))\n;-> #<FOO 232B438B> is a FOO\n;   X      0\n;   Y      20\n;   Z      30\n\n(defclass bar ()\n  ((x :initform 1)\n   (y :initform 2)\n   (z :initform 3)\n   (a :initarg :a))\n  (:default-initargs :a 4))\n\n(describe (change-class (make-instance 'foo) 'bar))\n\n;-> #<BAR 232FA22B> is a BAR\n;   X      0\n;   Y      10\n;   Z      100\n;   A      #<unbound slot>\n}}}\nまた、オブジェクトの生成は[[$$hs make-instance]]メソッドで行いますが、[[$$hs make-instance]]メソッドは、初期化のために [[$$hs initialize-instance]] を呼び出しますのでカスタマイズしたい場合には、[[$$hs initialize-instance]]に:afterメソッドを追加することが一般的に行なわれています。\n\n** 関連\n[[インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい]]\n")
(" %Tag:local-time') or(1=2)#" . "(1660041691)")
(" %Tag:スレッド'[0]" . "(1656061457)")
("シンボル" . "(:ctime 1227906107 :cuser #f :mtime 1616467986 :muser #f)[[$$tag シンボル]]\n\n- [[シンボルを生成する]]\n- [[キーワードを生成したい]]\n- [[シンボル名と文字列を比較する]]\n- [[既存のシンボルに文字列を追加して新しいシンボルを生成する]]\n- [[シンボルの一覧を表示したい]]\n- [[関数に別名をつけたい]]\n- [[同一のインターンされないシンボルを複数個所で使う]]\n- [[シンボルを探す]]\n- [[シンボルが外部シンボルか内部シンボルか継承されているかを調べる]]\n- [[グローバル変数シンボル一覧]]\n- [[シンボル名が変更されてしまった場合の対応方法]]\n- [[標準組み込みのシンボルを上書きしたい]]\n- [[Common Lisp標準が利用するキーワードシンボル一覧]]\n- [[ANSI-CL/CLtL2/CLtL1シンボル比較表]]\n")
(" %Tag:開発環境" . "(1668189992 (\"SLIME:インスペクタ\" :ctime 1529825608 :cuser #f :mtime 1529825608 :muser #f) (\"SLIME:SLDB\" :ctime 1529824426 :cuser #f :mtime 1529824426 :muser #f) (\"SLIME\" :ctime 1229489124 :cuser #f :mtime 1529824240 :muser #f) (\"マクロ展開を確認したい\" :ctime 1229603579 :cuser #f :mtime 1229603942 :muser #f) (\"逆アセンブルした結果を確認したい\" :ctime 1228810111 :cuser #f :mtime 1228810112 :muser #f) (\"マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい\" :ctime 1228627796 :cuser #f :mtime 1228627796 :muser #f))")
("四捨五入する" . "(:ctime 1228831221 :cuser #f :mtime 1328665576 :muser #f)[[$$tag 数値]]\n\n* 四捨五入する\n\nCommon Lisp の [[$$hs round]] 関数は偶数丸めで四捨五入ではありません。\nよって四捨五入をしたい場合は自作する必要があります。\n\n簡単な実装例を示します。\n{{{\n;; その1\n(defun nearest-1 (number)\n  (values (floor (+ 0.5 number))))\n\n;; その2\n;; number や divisor が負の時のことは考えていません\n(defun nearest-2 (number &optional (divisor 1))\n  (if (>= (- number (* (floor number divisor) divisor)) (/ divisor 2))\n      (ceiling number divisor)\n      (floor number divisor)))\n\n;; roundは以下のように 偶数方向へ丸められる\n(round 10.5)\n; => 10\n;    0.5\n\n(round 11.5)\n; => 12\n;    -0.5\n}}}\n")
("開発環境" . "(:ctime 1228626894 :cuser #f :mtime 1458610465 :muser #f)* 開発環境\n\nEmacsをインターフェースとするSLIME等、現在主流となっているものには、Emacs系が多いようです。\n\n* Emacs Lisp系\n- [[SLIME]]\n-- [[マクロ展開を確認したい]]\n-- [[マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい]]\n-- [[逆アセンブルした結果を確認したい]]\n- [[ELI]]\n- [[ILISP]]\n\n* Vi系\n- [[Limp]]\n\n* IDEプラグイン系\n- [[Cusp]]\n\n* 独自系\n\n- [[ABLE]]\n- [[slimv]]\n\n* 処理系付属\n- LispWorksのエディタ\n- Allegro CLのIDE\n- Hemlock(MCL、Clozure CL)\n")
("条件を満すノードを探したい:cxml-stp" . "(:ctime 1336640609 :cuser #f :mtime 1336640609 :muser #f)このページでは、[[CLiki:plexippus-xpath]]を組み合せる例を紹介しています~%\n** ライブラリの導入方法\n{{{\n(ql:quickload :xpath)\n}}}\n** 動作\nXML文章構築\n{{{\n(defparameter *doc*\n  (cxml:parse\n   \"<a xmlns='http://tips.lisp-users.org/common-lisp'><b>1</b><b>1</b><b>9</b><c>2</c></a>\"\n   (stp:make-builder)))\n}}}\nxpathで内容が1である要素bを探し、個数をカウントする\n{{{\n(xpath:with-namespaces ((\"x\" \"http://tips.lisp-users.org/common-lisp\"))\n  (length (xpath:all-nodes (xpath:evaluate \"//x:b[.=1]\" *doc*))))\n;=>  2\n}}}\nxpathは使わず、cxml-stpパッケージの関数のみでの実現\n{{{\n(length\n (stp:filter-recursively (lambda (c)\n                           (and (typep c 'stp:element)\n                                (string= \"b\" (stp:local-name c))\n                                (string= (stp:string-value c) \"1\") ))\n                         *doc* ))\n;=>  2\n}}}\n")
("一時変数を使わずに値を交換する" . "(:ctime 1230918931 :cuser #f :mtime 1230918931 :muser #f)[[$$tag 制御構造]]\n\n* 一時変数を使わずに値を交換する\n\n様々な方法がありますが、主に[[$$hs rotatef]]を使う方法が一般的でしょう。\n下記はそれぞれマクロで結果は大体同じようなものに展開されます。\n{{{\n(let ((x 10) (y 20))\n  (rotatef x y)\n  (list x y))\n;=> (20 10)\n\n(let ((x 10) (y 20))\n  (psetq x y y x)\n  (list x y))\n;=> (20 10)\n\n(let ((x 10) (y 20))\n  (setf (values x y) (values y x))\n  (list x y))\n;=> (20 10)\n\n(let ((x 10) (y 20))\n  (multiple-value-setq (x y) (values y x))\n  (list x y))\n;=> (20 10)\n}}}\nまれに[[$$hs prog2]]を利用したコードに遭遇することがありますが、Common Lisp以前のイディオムです。\n{{{\n;; 太古のイディオム\n(let ((x 10) (y 20))\n  ;; 太古にはprog1が存在しなかったためprog2\n  (setq x (prog2 nil y (setq y x))) \n  (list x y))\n;=> (20 10)\n}}}\n\n")
(" %Tag:fare-utils?Tag:fare-utils" . "(1491321985)")
(" %Tag:����" . "(1577118413)")
("仕様/ドキュメント" . "(:ctime 1227970340 :cuser #f :mtime 1237821656 :muser #f)[[$$tag 仕様/ドキュメント]]\n\n- [[Tag:参考文献]]\n- [[ドキュメンテーション]]\n- [[ソースコードからドキュメント（関数仕様）を生成する]]\n")
(" %Tag:多値" . "(1668087629 (\"多値\" :ctime 1319129540 :cuser #f :mtime 1319129540 :muser #f))")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45) -- /* order by \"as /*" . "(1624124846)")
(" %Tag:local-time' and 1=2#" . "(1660041632)")
(" %Tag:local-time) and 1=2-- -" . "(1660041694)")
(" %Tag:scl'[0]" . "(1664180519)")
("リストの各要素に手続きを適用する" . "(:ctime 1229558079 :cuser #f :mtime 1229600569 :muser #f)[[$$tag リスト]]\n\n[[$$hs map]]を使う方法です。\n{{{\n(map 'list '1+ '(1 2 3))   ;=> (2 3 4)\n(map 'vector '1+ '(1 2 3)) ;=> #(2 3 4)\n\n(map 'list 'cons '(1 2 3) '(4 5 6))\n;=> ((1 . 4) (2 . 5) (3 . 6))\n}}}\n\n[[$$hs mapcar]]を使う方法です。\n{{{\n(mapcar #'1+ '(1 2 3))   ;=> (2 3 4)\n;#'1+ は、'1+ でもいいです。\n(mapcar #'cons '(1 2 3) '(4 5 6))\n;=> ((1 . 4) (2 . 5) (3 . 6))\n}}}\n\n[[$$hs loop]]を使う方法です。\n{{{\n(loop for i in '(1 2 3) collect (1+ i)) ;=> (2 3 4)\n\n(loop for i in '(1 2 3)\n      for j in '(4 5 6)\n      collect (cons i j))\n;=> ((1 . 4) (2 . 5) (3 . 6))\n}}}\n")
("次の月を求める" . "(:ctime 1336359907 :cuser #f :mtime 1336359966 :muser #f)Common Lispの標準には universal time のような秒単位のものしかありませんので、自作するか、ライブラリを利用することになるでしょう\n{{{\n(defun next-month (y m)\n  (multiple-value-bind (ig no re d m y)\n                       (decode-universal-time\n                        (1+ (encode-universal-time 59 59 23 31 m y)))\n    (declare (ignore ig no re d))\n    (list y m)))\n\n(next-month 2012 12)\n;=>  (2013 1)\n}}}\n\n** local-time を利用\n{{{\n(ql:quickload :local-time)\n}}}\n{{{\n(defun next-month (y m)\n  (let ((ts (local-time:timestamp+ (local-time:encode-timestamp 0 0 0 0 1 m y)\n                                   1 :month)))\n    (list (local-time:timestamp-year ts)\n          (local-time:timestamp-month ts))))\n\n(next-month 2012 12)\n;=>  (2013 1)\n}}}\n")
("SLIME:インスペクタ" . "(:ctime 1529825608 :cuser #f :mtime 1529825608 :muser #f)[[$$tag 開発環境 SLIME]]\n\nインスペクタを使うと、オブジェクトの内容を詳しく調べることができます。[[SLIME:SLDB]]などから起動できるほかに、C-c Iで手動で起動させることもできます。C-c Iでは、ミニバッファから入力したオブジェクトをインスペクタで表示します。\n\n{{{\nInspect value (evaluated): #'+\n}}}\n\nこのように、ミニバッファで入力すると、\n\n{{{\n#<FUNCTION #x1011EF8E>\n--------------------\nName: +\nIts argument list is: (&LEXPR NUMBERS)\nDocumentation: \"Return the sum of its arguments. With no args, returns 0.\"\nSource note: #<SOURCE-NOTE *\"ccl:l1;l1-numbers.lisp\":8585-9043 NIL>\n\nUnderlying UVECTOR\n}}}\n\nインスペクタが+の情報を表示します。NameやDocumentationの値の部分はリンクになっていて、再帰的に内容を調べることができます。\n\n----\n\n* 操作方法\n\n:RET:インスペクタで調べられる値の上にカーソルがある場合、再帰的にインスペクタを呼び出します。動作の上にカーソルがある場合、その動作を実行します。\n:d:スロットの情報を表示します。\n:v:簡易表示と詳細な表示を切り替えます。\n:l:ひとつ前のオブジェクトに戻ります。（RETから戻ります）\n:n, SPC:lと逆の動作をします。\n:g:再読込します。\n:q:インスペクタを終了します。\n:p:新しいバッファにオブジェクトをpretty printします。\n:.:オブジェクトのソースコードを探します。 \n:>:インスペクタの最後の行に移動します。\n:M-RET:オブジェクトの値を*にコピーします。\n:TAB:インスペクタで調べられる次のオブジェクトに移動します。\n:S-TAB:インスペクタで調べられるひとつ前のオブジェクトに移動します。\n")
("小数点を切り上げ・切り捨て" . "(:ctime 1236786098 :cuser #f :mtime 1237111566 :muser #f)[[$$tag 数値]]\n\n小数点の切り上げ・切り捨てを行うには、[[$$hs floor]]、[[$$hs ffloor]]、[[$$hs ceiling]]、[[$$hs fceiling]]を使います。この4つの関数は、(整数部分,小数部分) の多値を返します。\n\nそれぞれ、\n:floor:実数を -∞方向に切り下げて、結果を整数で返す\n:ffloor:実数を -∞方向に切り下げて、結果を浮動小数点で返す\n:ceiling:実数を +∞方向に切り上げて、結果を整数で返す\n:fceiling:実数を +∞方向に切り上げて、結果を浮動小数点数で返す\n\n{{{\n(floor 3.33)\n; => 3\n;    0.32999992\n\n(ffloor 3.33)\n; => 3.0\n;    0.32999992\n\n(floor -9.23)\n; => -10\n;    0.77000046\n\n(ceiling 3.248)\n; => 4\n;    -0.7520001\n\n(ceiling -3.333)\n; => -3\n;    -0.33299994\n\n}}}\n")
("SLIME:SLDB" . "(:ctime 1529824426 :cuser #f :mtime 1529824426 :muser #f)[[$$tag 開発環境 SLIME]]\n\n処理系によって、サポートされている機能や、[http://en.wikipedia.org/wiki/Stack_trace バックトレース]のフォーマットなどに違いがあります。\n\n{{{\n> (error \"error\")\n}}}\n\n[[SLIME]]では、処理系がデバッガを起動する場面で、自動的にSLDBが起動します。\n\n{{{\nerror\n   [Condition of type SIMPLE-ERROR]\n\nRestarts:\n 0: [RETRY] Retry SLIME REPL evaluation request.\n 1: [*ABORT] Return to SLIME's top level.\n 2: [ABORT-BREAK] Reset this thread\n 3: [ABORT] Kill this thread\n\nBacktrace:\n  0: (CCL::CALL-CHECK-REGS ERROR \"error\")\n  1: (CCL::CHEAP-EVAL (ERROR \"error\"))\n --more--\n}}}\n\n----\n\n[[$$toc]]\n\n----\n\n* ブレークポイント\n\nANSIで定義されている[http://www.lispworks.com/documentation/HyperSpec/Body/f_break.htm#break break]を、停止したい位置で呼び出します。\n\n{{{\n> (defun fact (n)\n    (break)\n    (if (zerop n)\n        1\n        (* n (fact (1- n)))))\nFACT\n> (fact 5)\n}}}\n\nというコードを実行すると、\n\n{{{\n\n\n   [Condition of type SIMPLE-CONDITION]\n\nRestarts:\n 0: [CONTINUE] Return from BREAK.\n 1: [RETRY] Retry SLIME REPL evaluation request.\n 2: [*ABORT] Return to SLIME's top level.\n 3: [ABORT-BREAK] Reset this thread\n 4: [ABORT] Kill this thread\n\nBacktrace:\n  0: (FACT 5)\n  1: (CCL::CALL-CHECK-REGS FACT 5)\n  2: (CCL::CHEAP-EVAL (FACT 5))\n --more--\n}}}\n\nといった感じで、SLDBが起動します。\n\n----\n\n* リスタート\n\nSLDBを抜けるには、表示されているリスタートの一覧の中から、どれかひとつを選んで実行しなければなりません。上のブレークポイントの例では、\n\n{{{\nRestarts:\n 0: [CONTINUE] Return from BREAK.\n 1: [RETRY] Retry SLIME REPL evaluation request.\n 2: [*ABORT] Return to SLIME's top level.\n 3: [ABORT-BREAK] Reset this thread\n 4: [ABORT] Kill this thread\n}}}\n\nがリスタートの一覧です。番号が振ってある行の上にカーソルを移動させ、RETキーで実行できます。また、ショートカットのために、以下のキーバインドが定義されています。\n\n:a:ABORTする。\n:q:トップレベルへ抜ける。\n:c:CONTINUEする。\n:0～9:対応する番号のリスタートを実行する。\n\n----\n\n* スタックフレーム\n\nバックトレースに表示されているスタックフレームに対して、操作や、環境の中での評価ができます。\n\n{{{\nBacktrace:\n  0: (FACT 5)\n  1: (CCL::CALL-CHECK-REGS FACT 5)\n  2: (CCL::CHEAP-EVAL (FACT 5))\n --more--\n}}}\n\n番号が振ってある行が各フレームです。対象にしたいフレームの上にカーソルを移動させてから、以下のコマンドを実行します。\n\n:t:ローカル変数を表示するかしないかを切り替えます。\n:v:フレームに対応するコードを表示します。\n:e:フレームの環境の中で式を評価します。結果はミニバッファに表示されます。\n:d:フレームの環境の中で式を評価します。結果は新しいバッファに表示されます。\n:D:フレームに対応する関数を逆アセンブルします。\n:i:\nフレームの環境の中で式を評価して、結果を[[SLIME:インスペクタ]]で表示します。\n:C-c C-c:フレームに対応するコードを再コンパイルします。\n\nまた、対象のフレームを楽に切り替えられるように、以下のキーバインドが定義されています。\n\n:n:ひとつ下のフレームに移動します。\n:p:ひとつ上のフレームに移動します。\n:M-n:現在のフレームの詳細を隠してから、ひとつ下のフレームに移動し、詳細とコードを表示します。\n:M-p:現在のフレームの詳細を隠してから、ひとつ上のフレームに移動し、詳細とコードを表示します。\n:>:一番下のフレームに移動します。\n:<:一番上のフレームに移動します。\n\n----\n\n* ステップ実行\n\n一部の処理系ではステップ実行ができます。\n\n:s:ステップインします。\n:x:ステップオーバーします。\n:o:ステップアウトします。\n\n----\n\n* その他の機能\n\n:r:同じ引数でフレームの実行を再開します。\n:R:ミニバッファから入力する値でフレームから戻ります。\n:B:SLDBを終了し、処理系のデバッガを起動します。\n:C:\nデバッグ中のコンディションを[[SLIME:インスペクタ]]で表示します。\n:::ミニバッファから入力する式をトップレベルで評価します。\n\n----\n\n* 参考文献\n\n- [http://lispuser.net/emacs/lisphacking.html Emacs による Lisp Hacking]\n- [http://common-lisp.net/project/slime/doc/html/ SLIME User Manual]\n")
("文字列の中に「hoge」が含まれている場合、その開始位置を知るには" . "(:ctime 1227690765 :cuser #f :mtime 1313407762 :muser #f)[[$$tag 文字列 cl-ppcre ライブラリ]]\n* 文字列の中に「hoge」が含まれている場合、その開始位置を知るには\n文字列はシーケンスですので、[[$$hs search]]が利用できます。\n{{{\n(search seq-s seq)\n以下の指定ができます。\n:from-end bool\n:test function\n:test-not function\n:start1 position\n:start2 position\n:end1 position\n:end2 position\n:key function\n}}}\n{{{\n(search \"hoge\" \"foo bar hoge hage huge hege\")\n;=>8\n}}}\n[[CLiki:CL-PPCRE]]を利用した例\n{{{\nscan書式\n(scan regex target-string &key start end)\n => match-start, match-end, reg-starts, reg-ends\n}}}\n{{{\n(ppcre:scan \"(はちべえ)\" \"すけさんかくさんはちべえやしち\")\n;=> 8    ;マッチ開始位置\n;   12   ;マッチ終了位置\n;   #(8) ;マッチレジスタ開始位置 FIXME\n;   #(12);マッチレジスタ終了位置 \n}}}\n\n")
("末尾呼び出しの最適化" . "(:ctime 1228171120 :cuser #f :mtime 1228812122 :muser #f)[[$$tag 最適化]]\n\n* 末尾呼び出しの最適化\n\nSchemeと異なり、ANSI Common Lispでは、末尾呼び出しの最適化は仕様で要求されていないため、処理系により最適化の条件/状況が異なります。\n下記のClikiのまとめを参照して下さい。\n- [[CLiki:Tail Recursion]]\n")
("テキストファイルをオープンして内容を出力する" . "(:ctime 1227871186 :cuser #f :mtime 1362891077 :muser #f)[[$$tag 入出力]]\n* テキストファイルをオープンして内容を出力する\n[[$$hs with-open-file]] マクロでファイルをオープンし、[[$$hs loop]] マクロの中で [[$$hs read-line]] 関数を使って一行ずつ読み込んで出力します。\n{{{\n(with-open-file (in \"abc.txt\")\n  (loop for line = (read-line in nil)\n        while line\n        do (write-line line)))\n}}}\n")
("条件判断(if スペシャルフォーム)" . "(:ctime 1228888390 :cuser #f :mtime 1228888391 :muser #f)[[$$tag 制御構造]]\n* 条件判断(if :スペシャルフォーム)\nif文は条件式を評価し結果が真であればthen部を実行し、真でなければelseで指定した式を実行します。構文と例を以下に示します。\n{{{\n■構文\n(if 条件式 [then] [else])\n}}}\n{{{\n■例\n(if (= a 0)\n    (format t \"a is zero.\")\n    (if (< a 0)\n        (format t \"a is negative.\")\n        (format t \"a = ~A\" a)))\n}}}\n")
(" %Tag:CL-FAD" . "(1668198564 (\"CL-FAD\" :ctime 1432468963 :cuser #f :mtime 1432468963 :muser #f))")
(" %Tag:split-sequence'" . "(1638284992)")
(" %Tag:日付と時刻999999.1 union select unhex(hex(version())) -- and 1=1" . "(1532959367)")
("2つの時刻の差を求める" . "(:ctime 1227414623 :cuser #f :mtime 1227414623 :muser #f)[[$$tag 日付と時刻]]\n* 2つの時刻の差を求める\n秒数を表す数値なので、加減算は自由にできる。\n{{{\n;; 2000/1/1から現時刻までの秒数\n(- (get-universal-time)\n   (encode-universal-time 0 0 0 1 1 2000))\n;=> 280679398\n}}}\n")
("ライセンスについて" . "(:ctime 1227334285 :cuser #f :mtime 1227542200 :muser #f)[[$$toc]]\n* 逆引きCommon Lispのライセンスについて\nクリエイティブコモンズライセンス [http://creativecommons.org/licenses/by/2.1/jp/ 表示2.1] とします。\nコード/説明文中のクレジットについては、投稿者はクレジット表示の必要なしと意思表示した上で書き込んでいますので表示の必要はありません。\n\n")
(" %Tag:関数" . "(1668302646 (\"関数\" :ctime 1228173344 :cuser #f :mtime 1599528850 :muser #f) (\"関数が定義されているか調べる\" :ctime 1292770800 :cuser #f :mtime 1292770830 :muser #f) (\"&optionalや&keyで引数が指定されて呼び出されたか調べる\" :ctime 1291650200 :cuser #f :mtime 1291650200 :muser #f) (\"引数のリストに関数を適用する\" :ctime 1230115720 :cuser #f :mtime 1244308774 :muser #f) (\"SETF関数を取り出す\" :ctime 1233974927 :cuser #f :mtime 1233975138 :muser #f) (\"一定の値を返す関数を得る\" :ctime 1229257495 :cuser #f :mtime 1229257495 :muser #f) (\"状態を持った手続きを作る\" :ctime 1228173536 :cuser #f :mtime 1228173569 :muser #f))")
("複数 Listener を使う" . "(:ctime 1252504504 :cuser #f :mtime 1252507229 :muser #f)[[$$tag eli listener スレッド]]\n* 複数 Listener を使う\n- 簡単にいうと、ひとつの Lisp 上にマルチプロセスでREPLをたくさん持てるという機能です。\n\n- eli ではひとつの Lisp に複数の Listener を持たせることができます。\n- それぞれの Listener は、Lisp 内の別プロセスとして動作します。OSのプロセスとしては Lisp 単体です。\n- それぞれの Listener は、Emacs 上の別々のバッファに紐付けられます。\n- このエントリでは、複数 Listener の起動と終了手順を紹介します。\n- 前提として、M-x fi:common-lisp にて Emacs のサブプロセスとしてLisp を起動したものとします。\n{{{\nCL-USER(2): :processes\n:processes\nP Bix Dis Sec   dSec Pri State    Process Name, Whostate, Arrest\n*   2   3   3    2.5   0 runnable Initial Lisp Listener\n*   3   6   0    0.0   0 waiting  Connect to Emacs daemon, waiting for input\n*   4   2   0    0.0   0 inactive Run Bar Process\n*   5   5   0    0.0   0 waiting  Editor Server, waiting for input\nCL-USER(3):\n}}}\nこれは、M-x fi:common-lisp を実行した直後のプロセス状態です。Listener がひとつあります。\n** Listener 起動\n- (fi:open-lisp-listener -1 \"my-lisp-listener\") を Emacs 上で elisp として評価します。(M-: または scratch バッファにて C-x C-e を実施するなど)\n- \"*my-lisp-listener*\" というバッファ名で REPL が現れます。これで完了です。\n- :processes でプロセス状態を確認してみます。\n{{{\nCL-USER(3): :processes\n:processes\nP Bix Dis Sec   dSec Pri State    Process Name, Whostate, Arrest\n*   6   3   0    0.0   0 waiting  *my-lisp-listener*, waiting for input\n*   2   2   3    0.0   0 runnable Initial Lisp Listener\n*   3   6   0    0.0   0 waiting  Connect to Emacs daemon, waiting for input\n*   4   0   0    0.0   0 inactive Run Bar Process\n*   5   0   0    0.0   0 waiting  Editor Server, waiting for input\nCL-USER(4):\n}}}\n*my-lisp-listener* というプロセス名で Listener プロセスができています。\n- なお、fi:open-lisp-listener で起動したREPLのメジャーモードは、fi:inferior-common-lisp-mode ではなく、fi:lisp-listener-mode になります。\n\n** Listener 終了\n- :processes にて終了したい Listener が紐付いているプロセスを確認します。上の例では、*my-lisp-listener* でした。\n- :kill でそのプロセスを終了します。\n{{{\nCL-USER(5): :kill '*my-lisp-listener*\nCL-USER(6): :processes\n:processes\nP Bix Dis Sec   dSec Pri State    Process Name, Whostate, Arrest\n*   2   4   3    0.1   0 runnable Initial Lisp Listener\n*   4   0   0    0.0   0 inactive Run Bar Process\n*   5   0   0    0.0   0 waiting  Editor Server, waiting for input\n*   3   0   0    0.0   0 waiting  Connect to Emacs daemon, waiting for input\nCL-USER(7):\n}}}\nちゃんと消えてますね。\n- :exit を実行すると、どの Listener で評価したかに関わらず、Lisp 自体が終了しますので要注意です。\n\n** 補足：lisp-listener-mode\n- fi:open-lisp-listener で開いたREPLのバッファは、fi:inferior-common-lisp-modeにはなりません。fi:lisp-listener-modeになります。\n- そのため、hook等の設定は、fi:inferior-common-lisp-modeのものは適用されません。\n- fi:lisp-listener-mode の hook に個別に設定してあげてもよいですが、次の構成関係に従って、メジャーモード間でhookの設定を共有するのが便利です。\n{{{\nfi:inferior-common-lisp-mode    fi:lisp-mode-hook \n                                fi:subprocess-mode-hook \n                                fi:inferior-common-lisp-mode-hook\nfi:lisp-listener-mode           fi:lisp-mode-hook \n                                fi:subprocess-mode-hook\n                                fi:lisp-listener-mode-hook\nfi:common-lisp-mode             fi:lisp-mode-hook \n                                fi:common-lisp-mode-hook\n}}}\n")
("XML文章のツリーを構築する" . "(:ctime 1363444849 :cuser #f :mtime 1363448569 :muser #f)XMLデータを処理する場合、[http://ja.wikipedia.org/wiki/Document_Object_Model DOM]のように木構造を作ってから処理する方法と、[http://ja.wikipedia.org/wiki/Simple_API_for_XML SAX]のようにイベント駆動型で処理する方法のふたつが主流ですが、ここでは木構造を作ってから処理する方法を紹介します。\n\n* cxml-stp\n\nSTPは[http://ja.wikipedia.org/wiki/Extensible_Markup_Language#XML.E3.81.AE.E6.A7.8B.E6.96.87.E3.81.A8.E6.95.B4.E5.BD.A2.E5.BC.8FXML.E6.96.87.E6.9B.B8 well-formed XML]を処理するためのデータ構造とAPIの仕様です。[http://ja.wikipedia.org/wiki/Document_Object_Model DOM]の代わりとなるように考えて作られたもので、Common Lispからも扱いやすく設計されています。\n\n[[CLiki:cxml-stp]]はこのSTPを実装したもので、XMLデータを処理するためのライブラリです。[http://www.cliki.net/cxml Closure XML]と組み合わせて使うように作られています。\n\n- [[XML文章のツリーを構築する:cxml-stp]]\n\n* XMLS\n\n[[CLiki:xmls]]はS式指向のシンプルなXMLパーサです。スキーマを検証したり親切にエラーを報告してくれる機能はありませんが、小さくて高速です。\n\n- [[XML文章のツリーを構築する:XMLS]]\n")
("クラスを定義する" . "(:ctime 1229668892 :cuser #f :mtime 1229668892 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* クラスを定義する\n\nクラスを定義するには、 [[$$hs defclass]] を使用します。\n[[$$hs defclass]] には様々なオプションがありますが、最も簡単な定義は下記のようなものになるでしょう。\n\nまた、スーパークラスの指定を省略した場合、 [[$$hs standard-object]] をスーパークラスに指定したことになります。\n{{{\n;; 構文\n(defclass クラス名 (スーパークラス*)\n  (スロット*))\n\n;; 例\nx yというスロットを持つfooクラスを定義\n(defclass foo () \n  (x y))\n\n(defclass bar (foo) ;fooを継承\n  (z))\n\n;; 確かめる\n(describe (make-instance 'bar))\n;-> #<BAR 23498C67> is a BAR\n;   Z      #<unbound slot>\n;   X      #<unbound slot>\n;   Y      #<unbound slot>\n}}}\n")
(" %Tag:closure-html" . "(1667978046 (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
(" %Tag:url-rewrite" . "(1668301799 (\"URIエンコード\" :ctime 1227424464 :cuser #f :mtime 1228812075 :muser #f))")
("reduceと一般的なfold系関数との比較" . "(:ctime 1331810349 :cuser #f :mtime 1335996460 :muser #f)[[$$tag 早見表]]\n\n*** [[$$hs reduce]]と Scheme(srfi/R6RS)のfold系関数との比較\n{{{\n;;; (fold-left op 'z '(a b c d))\n(reduce op '(a b c d) :initial-value 'z)\n\n;;; (fold-right 'z '(a b c d))\n(reduce op '(a b c d) :initial-value 'z :from-end T)\n\n;;; srfi 1: (fold op 'z '(a b c d))\n(reduce (lambda (x y) (op y x)) '(a b c d) :initial-value 'z)\n}}}\n\n**** consと組み合せた場合\n{{{\n(reduce #'cons '(a b c d) :initial-value 'z)\n;=>  ((((Z . A) . B) . C) . D)\n\n(reduce #'cons '(a b c d) :initial-value 'z :from-end T)\n;=>  (A B C D . Z)\n\n(reduce (lambda (x y) (cons y x)) '(a b c d) :initial-value 'z)\n;=>  (D C B A . Z)\n}}}\n\n**** その他の違い\n[[$$hs reduce]] は[[$$hs sequence]]全般で利用できる\n{{{\n(reduce (lambda (x y) (cons y x)) \"abcd\" :initial-value '#\\z)\n;=>  (#\\d #\\c #\\b #\\a . #\\z)\n}}}\n[[$$hs reduce]] は [[$$hs sequence]] を一つしか取れないが、schemeのfoldは複数取ることが可能\n{{{\n(fold-right cons* '() '(1 2 3 4) '(a b c d))\n;=>  (1 a 2 b 3 c 4 d)\n}}}\n")
("SchemeプログラマがCommon Lispでハマりそうなところ" . "(:ctime 1336546326 :cuser #f :mtime 1340867449 :muser #f)SchemeとCommon Lispではっきりと違うところは、それ程問題にならないかと思いますが、名前が似ているのに結果や引数が微妙に違ったりするところはハマりどころです。~%\n:CLではstringはvectorのsubtypeである:\n{{{\n(vectorp \"foo\")\n;=>  T\n\n(vector? \"foo\")\n;=>  #f\n}}}\nこういうことをしているとはまります\n{{{\n(cond ((vectorp obj)...)\n      ((stringp obj)...)\n      ...)\n}}}\n:3.141592と書いた場合single-floatになる:\nR5RS Schemeでは基本double-floatですが、CLでは、デフォルトでは、single-floatとして読み取られます。~%\ndouble-floatで読む込むには[[$$hs *read-default-float-format*]]に、[[$$hs double-float]]を設定します。もしくは、3.141592d0と書き直します。\n:1.と書いた場合、1.0の略記ではない:\nCLは、10進表記の1ということになります。[[$$hs *read-base*]]が10以外の時などに利用したり\n10進であることを強調する場合に用いられます。\n\n:&rest引数が必ずしもコピーされない:\nSchemeでは、\"\"\"(define (foo . xs) ...)\"\"\" と定義して \"\"\"(apply foo ys)\"\"\" と呼び出した場合、xsは常に新たにアロケートされたリスト(ysはコピーされる)であることが保証されています (R5RS 4.1.4)。CLでは\"\"\"(defun foo (&rest xs) ...)\"\"\" と定義して \"\"\"(apply #'foo ys)\"\"\"と呼び出した場合に、処理系はysをそのまま(コピーせずに)xsに渡して良いことになっています (CLHS 3.4.1.3)。コピーする処理系もありますが、ポータブルなコードでは&rest引数を破壊する場合は自分でコピーしなければなりません。~%\n&rest引数を破壊するなんて普通しないと思うかもしれませんが、[[$$hs delete-if]]とか\n[[$$hs sort]]などをうっかり使ってしまう、ってことはあります(実話)。\n\n:doマクロは繰り返し変数を上書きする:\nSchemeではdoマクロは再帰に展開されるので、繰り返し変数は繰り返しの度に新たに作られます。繰り返しが進んでも、一度クロージャで取り込んだ値は変わりません。\n{{{\n(do ((x 0 (+ x 1))\n     (r '() (lambda () x)))\n    ((= x 1) (r))\n  )\n;=> 0  ;; (lambda () x)が閉じ込めるxはx=0の時のxで、x=1になるxとは別\n}}}\nCLではこうなります。\n{{{\n(do ((x 0 (+ x 1))\n     (r '() (lambda () x)))\n    ((= x 1) (funcall r))\n  )\n;=> 1  ;; (lambda () x)が閉じ込めるxが繰り返しによって上書きされx=1になっている\n}}}\n繰り返し変数のその時の値を捕捉したい場合は、\"\"\"(let ((x x)) (lambda () x))\"\"\"などとする必要があります。\n\n:map系の名前でも返り値を利用しないものがある:\nSchemeでは、map系の名前は、要素に関数を適用して、新しい集合を作って返すもの、for-each系の名前は、mapに似ているけれども、副作用が目的で、返り値は利用しないもの、という命名規約がありますが、CLでは、mapから始まっている名前だからといって返り値を利用するとは限りません。~%\nmapから始まる名前で、返り値を利用しないことが慣習である(もしくは返り値が有用でない)関数には、~%\n[[$$hs maphash]], [[$$hs mapc]], [[$$hs mapl]]\nがあります。\n\n:listpは、list?と動作が違う:\nCLのlistpは、consか、nilであれば、真正リストかどうかは関係なくTを返します。\n{{{\n(listp '(car . cdr))\n;=>  T\n\n(list? '(car . cdr))\n;=>  #f\n}}}\n:シンボルのreadは*package*の影響を受ける:\nS式でデータをセーブ/ロードしたりネットワーク越しに送ったりするのはLisperの常套手段ですが、\nCommon LispではS式を読み込む時にシンボルが「その時点での*package*」にinternされます。\n全く同じに見えるS式を読んでいても*package*が異なると読んだものが同じになりません。\nSchemeでは名前空間はシンボルとは別の層で管理されてて、シンボル自体は同じに見えればeq?なので、\n送ってるデータをダンプしていくら睨んでも原因がわからず途方に暮れることが。\n\n")
("ストリームを扱うように出力先としてシーケンスを指定したい" . "(:ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f)[[$$tag 入出力 ライブラリ flexi-streams]]\n\n* ストリームを扱うように出力先としてシーケンスを指定したい\n\n自作するかライブラリを利用します。\n\n下記の例では、 [[ライブラリ:flexi-streams]]を利用しています。\n{{{\n(flexi-streams:with-output-to-sequence (out :as-list t)\n  (loop for i across (flexi-streams:string-to-octets \"あいう\" :external-format :utf-8)\n        do (write-byte i out)))\n;=> (227 129 130 227 129 132 227 129 134)\n}}}\n")
("整数値のビット長を求める" . "(:ctime 1456494178 :cuser #f :mtime 1456494178 :muser #f)整数値について、２進数（２の補数）で表現した場合に最低でも必要なビット長を\n[[$$hs integer-length]] 関数で求めることができます。\n\n{{{\n(integer-length 128) ;=> 8\n(integer-length 127) ;=> 7\n(integer-length #b0110) => 3\n(integer-length -5) ;=> 3\n(integer-length -8) ;=> 3\n(integer-length -9) ;=> 4\n}}}\n\n** 注意点\n\nCommon Lisp の整数値は、無限の長さを持つことができます。\nそのため、引数の整数値を表すために必要な最短のビット長さを求めることになります。\n負の整数の場合、値は２の補数として扱われます。\n\n負の整数の場合の戻り値は、負の数を示すための最上位ビット分を除いた値となっています。\n実際の値を表すために最低でも必要なビットの長さは、最上位ビット分の１を加える必要があります。\n\n(例) -5 は 8bit の２の補数では 1111 1011 と表現できます。\ninteger-length は 011 のみを考え 3 と返します。\n負の数であることを明示する最上位ビットが１ケタ分必要です。\n\n(例) -8 は 8bit の２の補数では 1111 1000 と表現できます。\ninteger-length は 000 のみを考え 3 と返します。\n")
(" %Tag:配列 and 1>1" . "(1624124152)")
("キーが存在しない場合のデフォルト値を設定する" . "(:ctime 1227413661 :cuser #f :mtime 1370593420 :muser #f)[[$$tag ハッシュ]]\n* キーが存在しない場合のデフォルト値を設定する\nハッシュテーブルのデフォルト値は処理系依存になっています。~%\n\n- [http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_has.htm make-hash-table]\n\nデフォルトの値を設定しキーが存在しない場合に返すとすると、2値目を判定して動作する、下記のようなコードが考えられるでしょう。\n{{{\n(let ((ht (make-hash-table :test #'equal))\n      (default 100))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  (multiple-value-bind (val win) (gethash \"papaia\" ht)\n    (if win val default)))\n;=> 100\n}}}\n")
(" %Tag:配列' AnD sLeep(3) ANd '1" . "(1624124219)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45) --  /*" . "(1624124340)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45) -- /* order by 'as /*" . "(1624124721)")
("Ltk:チェックボタンを表示する" . "(:ctime 1619741987 :cuser #f :mtime 1619744686 :muser #f)* チェックボタン\n\n{{{\n;;; LTKでチェックボタンを表示する\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-05\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-05)\n\n(defun main ()\n  (with-ltk ()\n    (let* (\n           (cbtn1 (make-instance\n                'check-button\n                :text \"check button1\"\n                :command (lambda (value)\n                           (format t \"check-button1:~A~%\" value)\n                           )))\n\n           (cbtn2 (make-instance\n                'check-button\n                :text \"check button2\"))\n\n           (cbtn3 (make-instance\n                'check-button\n                :text \"Close\"))\n\n           (btn (make-instance\n                 'button\n                 :text \"check on!\"\n                 :command (lambda ()\n                             (setf (value cbtn1) t)\n                             (print (value cbtn1)))))\n           )\n      (pack (list cbtn1 cbtn2 cbtn3) :side :top :fill :both :expand :yes) ; fill,both,expand,yesを指定すると、Wiindowのハシをドラッグして伸ばしても、ボタンが上下左右に大きくなる。\n      (pack btn :side :top :fill :both :expand :yes)\n      )))\n\n(main)\n}}}\n")
("配列から重複した要素を取り除く" . "(:ctime 1228889087 :cuser #f :mtime 1363964743 :muser #f)[[$$tag 配列]]\n\n* 配列から重複した要素を取り除く\n\n[[$$hs remove-duplicates]] や [[$$hs delete-duplicates]] を使います。\ndelete-duplicates は引数として与えられた配列の内容を処理系が返り値を効率よく作成するために破壊しても構わないことになっています。\n\nまた、値をテストするための関数を :test キーワードにて与えることができます。(デフォルトではeql)\n\n返り値のリストは、基本では、前に出現した重複分が消去されますので、前のものを優先したい場合は、 :from-end に非nil値を与えます。\n{{{\n(remove-duplicates #(\"abc\" \"cba\" \"abc\") :test #'equal) \n;=> #(\"cba\" \"abc\")\n\n(remove-duplicates #(\"abc\" \"cba\" \"abc\") :test #'equal :from-end T) \n;=> #(\"abc\" \"cba\")\n\n(let ((a (copy-seq #(a b c a a b a c))))\n  (list (delete-duplicates a)\n        a))\n;=> (#(B A C) #(A B C A A B A C)) \n}}}\n")
("構造体" . "(:ctime 1229599940 :cuser #f :mtime 1329126153 :muser #f)[[$$tag 構造体]]\n\n- [[構造体を作成する]]\n- [[構造体要素をカンマ区切りで出力する]]\n- [[構造体の要素数を取得する]]\n- [[構造体を任意の初期値で埋める]]\n- [[コンストラクタが受け取る引数の形式を変更したい]]\n")
("Ltk:メニューを表示する" . "(:ctime 1619742215 :cuser #f :mtime 1619744771 :muser #f)* メニュー\n\n{{{\n;;; LTKのメニュー\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-18\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-18)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"メニュー\")\n    (minsize *tk* 600 500)\n\n    (let* (\n           ;; メニューバー作成\n           (mb (make-menubar))\n           \n           ;;メニュー\"種類\"\n           (mshurui (make-menu mb \"種類\" ))\n\n           (mf-command (make-menubutton mshurui \"コマンド\"\n                                        (lambda () ;(error \"asdf\")\n                                          (format t \"コマンド pressed~&\")\n                                          (finish-output))\n                                        :underline 1))\n\n\n           (mf-checkbtn (make-instance 'menucheckbutton \n                                       :master mshurui\n                                       :text\"チェックボタン\"))\n\n\n           (sep1 (add-separator mshurui))\n\n           (mf-radiobtn1 (make-instance 'menuradiobutton\n                                        :master mshurui \n                                        :text \"ラジオボタン①\"\n                                        :group \"group1\"))\n                                        \n\n           (mf-radiobtn2 (make-instance 'menuradiobutton\n                                        :master mshurui\n                                        :text \"ラジオボタン②\"\n                                        :group \"group1\"))\n\n           (mf-radiobtn3 (make-instance 'menuradiobutton\n                                        :master mshurui\n                                        :text \"ラジオボタン③\"\n                                        :group \"group1\"))\n\n           (sep2 (add-separator mshurui))\n\n           (mf-export (make-menu mshurui \"カスケード\"))\n\n           (mfe-jpg (make-menubutton mf-export \"コマンド①\" (lambda ()\n                                                              (format t \"cmd1 pressed~&\")\n                                                              (finish-output))))\n           (mfe-gif (make-menubutton mf-export \"コマンド②\" (lambda ()\n                                                              (format t \"cmd2 pressed~&\")\n                                                              (finish-output))))\n\n           (sep3 (add-separator mshurui))\n\n\n           (mf-close (make-menubutton mshurui \"終了\"\n                                        (lambda () ;(error \"asdf\")\n                                          (format t \"終了 pressed~&\")\n                                          (setf *exit-mainloop* t)\n                                          (finish-output))\n                                        :underline 1))\n\n           (msg (make-instance 'message\n                               :text \"これはメニューのテストウィンドウです。\"\n                 :width 1000\n                 :background \"#FFFFFF\"))\n\n           (b1 (make-instance\n                'button\n                :text \"Close\"\n                :command (lambda ()\n                           (format t \"終了\")\n                           (setf *exit-mainloop* t)))))\n\n      (pack msg\n            :side :top\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n      (pack b1\n            :side :bottom\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n\n      ;; (configure msg\n      ;;            :anchor :w\n      ;;            )\n\n      )))\n\n(main)\n\n}}}\n")
("ディレクトリが存在するかどうかを判定する" . "(:ctime 1247419119 :cuser #f :mtime 1247419810 :muser #f)与えられたパスネームがディレクトリとして存在するかどうかを確認する方法は、処理系依存になります。\n下記の例では、 [[CLiki:CL-FAD]] と [[CLiki:KMRCL]] を利用しています。\n{{{\n;; /tmpはディレクトリ\n;; /tm/は存在していないシステムに存在しておらず、passwdはファイルとする\n(cl-fad:directory-exists-p #P\"/tmp/passwd\")\n;=> NIL\n\n(cl-fad:directory-exists-p #P\"/tmp\")\n;=> #P\"/tmp/\"\n\n(cl-fad:directory-exists-p #P\"/tm\")\n;=> NIL\n\n(kmrcl:probe-directory #P\"/tmp/passwd\")\n;=> NIL\n\n(kmrcl:probe-directory #P\"/tmp\")\n;=> #P\"/tmp/\"\n\n(kmrcl:probe-directory #P\"/tm\")\n;=> NIL\n}}}\n* 議論\n")
("XML:Closure XML" . "(:ctime 1363449844 :cuser #f :mtime 1363449844 :muser #f)- [[XML文章のツリーを構築する:cxml-stp]]\n- [[文字列からXML文章を構築する:cxml-stp]]\n- [[条件を満すノードを探したい:cxml-stp]]\n- [[要素名で探して処理する:cxml-stp]]\n- [[要素名で探して処理する:plexippus-xpath]]\n- [[指定id属性の値をもつ要素を探す:plexippus-xpath]]\n- [[指定id属性の値をもつ要素を探す:klacks]]\n- [[XML文章内のデータをソート:plexippus-xpath]]\n- [[指定パスの要素だけ取り出したい:cxml-stp]]\n- [[指定パスの複数の要素を取り出したい:cxml-stp]]\n- [[選択的に属性を追加する:cxml-stp]]\n")
("文字列の先頭・末尾の空白を削除する" . "(:ctime 1227347967 :cuser #f :mtime 1430348911 :muser #f)[[$$tag 文字列 シーケンス]]\n* 文字列の先頭・末尾の空白を削除する\n\n文字列の先頭・末尾の空白を削除するには、[[$$hs string-trim]], [[$$hs string-left-trim]], [[$$hs string-right-trim]] を使用します。第一引数は削除する文字のリスト(ベクタも可)なので、全角スペースや通常の文字も削除可能です。\n\n{{{\n(string-right-trim '(#\\Space) \" abc \") ;=> \" abc\"\n(string-left-trim '(#\\Space) \" abc \")  ;=> \"abc \"\n(string-trim '(#\\Space) \" abc \")       ;=> \"abc\"\n\n;; 削除する文字を文字列、ベクタで指定した場合\n(string-trim \" \" \" abc \") ;=>  \"abc\"\n(string-trim #(#\\Space) \" abc \") ;=>  \"abc\"\n}}}\n")
("オブジェクトのスロットの値をまとめて変更する" . "(:ctime 1336347630 :cuser #f :mtime 1526495292 :muser #f)[[$$tag MOP ライブラリ closer-mop]]\n\nオブジェクトのスロットの値は、初期化の際にまとめて設定することが可能です([[オブジェクトの初期化を行う]])が、生成した後にまとめて変更したい場合もあります。~%\nこの様な場合は、[[$$hs with-slots]] を利用するのが便利です。\n{{{\n(defclass tips-cl ()\n  (a b c d e))\n}}}\n\n{{{\n(let ((obj (make-instance 'tips-cl)))\n  (with-slots (a b c d e) obj\n     (setq a 1\n           b 2\n           c 3\n           d 4\n           e 5))\n  (describe obj))\n;->  #<TIPS-CL {100FBD6C63}>\n;      [standard-object]\n;\n;    Slots with :INSTANCE allocation:\n;      A  = 1\n;      B  = 2\n;      C  = 3\n;      D  = 4\n;      E  = 5\n;\n;=>  <no values>\n}}}\n個別スロットの名前を指定するというより、オブジェクトのスロット全体を変更したい場合は、スロット名を取得し、[[$$hs slot-value]] で変更することになるでしょう。(MOPを利用します)\n{{{\n;; Closer to MOPの導入\n(ql:quickload :closer-mop)\n}}}\n{{{\n(let ((obj (make-instance 'tips-cl)))\n  (mapc (lambda (s)\n          (setf (slot-value obj (c2mop:slot-definition-name s))\n                :foo!))\n        (c2mop:class-slots (class-of obj)))\n  (describe obj))\n;->  #<TIPS-CL {100FC71373}>\n;      [standard-object]\n;\n;    Slots with :INSTANCE allocation:\n;      A  = :FOO!\n;      B  = :FOO!\n;      C  = :FOO!\n;      D  = :FOO!\n;      E  = :FOO!\n;\n;=>  <no values>\n}}}\n\nまた [[$$hs slot-value]] を用いる方法よりは多少の制限がありますが、より高速なアクセスが期待される [http://metamodular.com/CLOS-MOP/standard-instance-access.html standard-instance-access] を利用する方法もあります。\n\n{{{\n(let ((obj (make-instance 'tips-cl)))\n  (dotimes (idx (length (c2mop:class-slots (class-of obj))))\n    (setf (c2mop:standard-instance-access obj idx)\n          :foo!))\n  (describe obj))\n;->  #<TIPS-CL {100FC71374}>\n;      [standard-object]\n;\n;    Slots with :INSTANCE allocation:\n;      A  = :FOO!\n;      B  = :FOO!\n;      C  = :FOO!\n;      D  = :FOO!\n;      E  = :FOO!\n;\n;=>  <no values>\n}}}\n\n")
("指定した位置の要素を取り除く" . "(:ctime 1229191528 :cuser #f :mtime 1229256880 :muser #f)[[$$tag 配列]]\n\n* 指定した位置の要素を取り除く\n\nRubyのArray#delete_atメソッドのようなものはANSI CLの標準には含まれていませんが、下記のようなものが考えられるでしょう。\n\n{{{\n(defun remove-at (pos seq)\n  (remove-if (constantly T) seq :start pos :count 1))\n\n(let ((a (vector 5 1 4 2 3)))\n  (remove-at 0 (remove-at 0 a)))\n;=> #(4 2 3)\n}}}\n\n;; ↑改善案を参考にしました↓\nremove-at別解\n{{{\n(defun remove-at (pos seq)\n  (remove nil seq :start pos :count 1 :test (constantly T)))\n\n;; 破壊的変更版\n(defun delete-at (pos seq)\n  (delete nil seq :start pos :count 1 :test (constantly T)))\n}}}\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 20 #" . "(1624125125)")
(" %Tag:cl-cron?p=Tag:cl-cron" . "(1491336556)")
("メソッドを定義するには" . "(:ctime 1229673282 :cuser #f :mtime 1229673589 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* メソッドを定義するには\n\n標準のCLOSでのメソッドの定義とは総称関数を定義することになり、[[$$hs defgeneric]]、[[$$hs defmethod]] を使用して定義します。\n\nCLOSの特徴としてメソッドが特定のクラスに属していないことが挙げられますが、メソッドは通常 [[$$hs defclass]] で定義する [[$$hs standard-object]] のオブジェクト以外にも、[[$$hs built-in-class]] (リストやベクタ、数値等々)、 [[$$hs structure-class]](構造体) にも定義することが可能です。\n\nまた、EQLスペシャライザ(特定子)により特定のオブジェクトそのものに対してメソッドを設定することも可能です。\n{{{\n(defclass foo () ())                    ;fooクラス\n(defstruct foo-struct)                  ;構造体\n\n(defgeneric foo (obj))                  ;総称関数を定義\n\n;; fooクラス\n(defmethod foo ((x foo))\n  \"foo class!\")\n\n;; foo-struct構造体\n(defmethod foo ((x foo-struct))\n  \"foo struct!\")\n\n;; built-in-class float\n(defmethod foo ((x float))\n  \"float!\")\n\n;; built-in-class function\n(defmethod foo ((x function))\n  \"function!\")\n\n;; eql特定子\n(defmethod foo ((x (eql 1)))\n  \"one!\")\n\n;;; 試してみる\n(let ((a (make-instance 'foo))\n      (b (make-foo-struct))\n      (c pi)\n      (d #'car)\n      (e 1))\n  (mapcar #'foo (list a b c d e)))\n;=> (\"foo class!\" \"foo struct!\" \"float!\" \"function!\" \"one!\")\n}}}\n")
("配列同士の和・差・積を取る" . "(:ctime 1228453798 :cuser #f :mtime 1228453798 :muser #f)[[$$tag 配列]]\n\n* 配列同士の和・差・積を取る FIXME\n\n集合を扱う関数は標準ではリストにのみ準備されていますので、配列の場合は自作するか、リスト用の関数の結果を型変換することが考えられるでしょう。\n\nオペレータを作成するマクロ\n{{{\n(defmacro list-op->seq-op (result-type list-op-name)\n  `(defun ,(intern \n            (concatenate 'string (string result-type) \n                                 \"-\"\n                                 (string list-op-name))) \n       (x y &rest keys)\n     (COERCE\n      (apply #',list-op-name (coerce x 'list) (coerce y 'list)\n             keys)\n      ',RESULT-TYPE)))\n}}}\n上記で作成したものを試してみる。cf. [[リスト同士の和・差・積を取る]]\n{{{\n(list-op->seq-op vector set-difference)\n(list-op->seq-op vector union)\n(list-op->seq-op vector intersection)\n\n(vector-union #(1 3 5 7) #(2 4 6 8)) ;=> #(8 6 4 2 1 3 5 7)\n(vector-union #(1 2 3 4) #(3 4 5 6) :test #'eql) ;=> #(6 5 1 2 3 4)\n\n(vector-set-difference #(1 3 5 7) #(2 4 6 8)) ;=> #(7 5 3 1)\n(vector-set-difference #(1 2 3 4) #(3 4 5 6)) ;=> #(2 1)\n\n(vector-intersection #(1 3 5 7) #(2 4 6 8)) ;=> #()\n(vector-intersection #(i 2 3 4) #(3 4 5 6)) ;=> #(4 3)\n}}}\n")
("配列要素をカンマ区切りで出力する" . "(:ctime 1228099965 :cuser #f :mtime 1362956728 :muser #f)[[$$tag 配列]]\n\n* 配列要素をカンマ区切りで出力する\n\nCLではこの様な場合、データをリストに格納することが多くライブラリもリストを扱うものが多いのでベクタの場合、ベクタをリストに型変換するか、ベクタ用に自作するかになります。\n{{{\n(let ((v (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")))\n  (with-output-to-string (s)\n    (loop :with last := (1- (length v))\n\t  :for i :from 0 :to last\n\t  :do (princ (aref v i) s)\n\t  :unless (= i last) :do (princ \",\" s))))\n;=> \"はちべえ,やしち,かくさん,すけさん\"\n}}}\n型変換してformatに渡す\n{{{\n(let ((v (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")))\n  (format nil \"~{~A~^,~}\" (coerce v 'list)))\n;=> \"はちべえ,やしち,かくさん,すけさん\"\n}}}\nフォーマッタ関数を作成してformatへ渡す\n{{{\n(defun join-strings (s char v)\n  (loop :with last := (1- (length v))\n\t:for i :from 0 :to last\n\t:do (princ (aref v i) s)\n\t:unless (= i last) :do (princ char s)))\n\n(defun join/comma (s arg)\n  (join-strings s #\\, arg))\n\n(format nil #'join/comma (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\"))\n;=> \"はちべえ,やしち,かくさん,すけさん\"\n}}}\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45) -- /* order by 'as /*" . "(1624124767)")
("特定のURLからドキュメントを抽出する" . "(:ctime 1227424335 :cuser #f :mtime 1431159651 :muser #f)[[$$tag インターネットサービス drakma ライブラリ]]\n* 特定のURLからドキュメントを抽出する\n[[CLiki:drakma]]を利用\n{{{\n(drakma:http-request \"http://tips.lisp-users.org/common-lisp\")\n;=> \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\n       \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\n...\"\n}}}\n")
("ファイルから行をランダムに取り出す" . "(:ctime 1231136258 :cuser #f :mtime 1231164888 :muser #f)[[$$tag 入出力]]\n\n* ファイルから行をランダムに取り出す\n\n乱数の生成に、[[$$hs random]]、ファイルのポジション移動に[[$$hs file-position]]を利用した例\n{{{\n(defun picking-random-nline (nline file)\n  (with-open-file (in file)\n    (let ((tab (make-hash-table))\n          (lnum 0))\n      (setf (gethash 0 tab) 0)\n      (loop :for c := (read-char in nil) :while c\n            :do (when (char= #\\Newline c) \n                  (setf (gethash (incf lnum) tab)\n                        (file-position in))))\n      (flet ((random-line ()\n               (file-position in (gethash (random lnum) tab))\n               (read-line in nil)))\n        (loop :repeat nline :collect (random-line))))))\n\n;; 試してみる\n(picking-random-nline 4 \"/usr/share/dict/words\")\n;=> (\"whirligig's\" \"sluicing\" \"hovercraft\" \"Sterno\")\n}}}\n\n[[CLiki:SERIES]]を使った実装\n{{{\n(in-package :series)\n\n(defun picking-random-nline (nline file)\n  (let* ((lines (scan-file file #'read-line))\n         (len (collect-length lines))\n         (rands (sort (loop :repeat nline :collect (random len)) \n                      #'<)))\n    (collect (choose (mask (scan rands)) \n                     lines))))\n\n;; 注. 結果がファイルの先頭からの順番になっています。\n(picking-random-nline 4 \"/usr/share/dict/words\")\n;=> (\"Chirico's\" \"ritually\" \"sweetie's\" \"sycophant\")\n}}}\nファイルの長さを求めるのに[[$$hs file-length]]を利用しファイルの長さでランダムに収集した例\n\n行数を知らなくても動作するメリットはありますが、長い行の次の行が出現しやすくなり、行の長さが均一でないとランダムになりません。\n{{{\n(defun picking-random-nline (nline file)\n  (with-open-file (in file)\n    (let ((len (file-length in)))\n      (flet ((random-line ()\n               (file-position in (random len))\n               (read-line in)           ;捨て\n               (or (read-line in nil)\n                   (progn (file-position in 0)\n                          (read-line in nil)))))\n        (loop :repeat nline :collect (random-line))))))\n\n(picking-random-nline 4 \"/usr/share/dict/words\")\n;=> (\"tumid\" \"Judaic\" \"grownups\" \"telecommunications\")\n}}}\n\n** 議論\n- これ、行の長さが同じでないとランダムにならないんじゃないでしょうか。注記があった方が良いのでは (←こういうコメントが邪魔だったら消してください)。\n-- おお、気付かれましたか(笑) 長い行の確率が高くなるんですよね。\n\n\n")
("プログラムで配列を定義する" . "(:ctime 1229189109 :cuser #f :mtime 1229232047 :muser #f)[[$$tag 配列]]\n\n* プログラム中で配列を定義する\n\nプログラム中で配列(一次元配列=>ベクタ)を得るには [[$$hs vector]] が利用できます。\n{{{\n(vector \"foo\" \"bar\" \"baz\")\n;=> #(\"foo\" \"bar\" \"baz\")\n}}}\nまた、直に#()を用いて記述することも可能です。[http://www.lispworks.com/documentation/HyperSpec/Body/02_dhc.htm #(] はリーダーマクロで#(から)までで構成される要素を含む単純ベクタとしてリーダーに読まれます。また、10進の数値を取ることができ、指定した要素より少ない場合はエラー、多い場合は最後の要素が長さを満すまで繰り返されます。\nクオートは付ける必要はありません\n{{{\n#(\"foo\" \"bar\" \"baz\")\n;=> #(\"foo\" \"bar\" \"baz\")\n\n#2(\"foo\" \"bar\" \"baz\")\n;>>> error\n\n#10(\"foo\" \"bar\" \"baz\")\n;=> #(\"foo\" \"bar\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\")\n}}}\nまた、バッククオート記法も利用可能です。\n{{{\n(let ((foo 1) (bar 2) (baz '(3 4)))\n  `#(,foo ,bar ,@baz))\n;=> #(1 2 3 4)\n}}}\n\n----\n\nちょっと細かい注記：\nvectorを使う例と#()を使う例は、結果として同じような値が得られますが、\n意味的に違いがあります。\n\n- (vector x ...) はその式が実行される度に、新たな配列のインスタンスが作られます。\n- #(x ...) はその式が読み込まれた時に一度だけ、配列のインスタンスが作られます。\n(特にあらかじめコンパイルした場合、配列はコンパイルされたコードの一部になります)。\n\n前者はコンストラクタ呼び出し、後者はリテラルと言うこともできます。\n(バッククオートの場合、基本的にはvectorなどを使った呼び出しへと展開されますが、\n処理系依存なので例えばコンパイラが不変であると証明できる部分については\nリテラル扱いになるかもしれません。)\n\n{{{\n(defun vec1 () (vector 1 2 3))\n(defun vec2 () #(1 2 3))\n\n(eq (vec1) (vec1))  ;=> NIL\n(eq (vec2) (vec2))  ;=> T\n}}}\n")
(" %Tag:【募雁E¸­、E" . "(1427810056)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45) -- /* order by \"as /*" . "(1624125016)")
("デーモンプロセスでシグナルをハンドリングする" . "(:ctime 1363856841 :cuser #f :mtime 1363856841 :muser #f)Common Lispでデーモンプロセスを作成した場合で、特定の操作(データのリロード)が手動で必要となるような場合、シグナルを送信して指示することが便利です。~%\n下記では、Unix系OSを想定し、処理系間の互換性のため[[CLiki:KMRCL]]を利用しています。\n\n高度にインタラクティブな操作が必要な場合は、SWANK/SLIME等で接続した方が良いでしょう。\n{{{\n(kmrcl:set-signal-handler :usr1 \n                          (lambda (&rest args)\n                            (declare (ignore args))\n                            (format t \"~&* Reloading data...~%\")\n                            (force-output)\n                            (reload-it)                           ;なんらかのリロード\n                            (format t \"~&...done.~%\")\n                            (force-output)))\n}}}\n{{{\n;; プロセスIDを確認\n(kl:getpid)\n;=> 6269\n}}}\n{{{\n# 他のシェル等から\n$ kill -USR1 6269\n}}}\n{{{\n;; 処理系が起動しているターミナル/ログ等\n* Reloading data...\n............\n...done.\n}}}\n\n")
("配列の並列処理" . "(:ctime 1337151010 :cuser #f :mtime 1337151010 :muser #f)一つの配列を複数のタスクに分けて処理する例です。~%\n下記の例では、[[CLiki:Xecto]] を利用しています。~%\n\nライブラリの導入方法 (今のところSBCLのみ対応)\n- https://github.com/pkhuong/Xecto\n\n{{{\n;;; #(\"1\" \"2\" \"3\" ...)というような整数を文字列にしたものを要素にもつ配列\n(declaim ((simple-vector 100000) *number-strings*))\n(defvar *number-strings*\n  (make-array 100000))\n\n;; 初期化\n(dotimes (i 100000)\n  (setf (svref *number-strings* i)\n        (write-to-string i)))\n\n;;; 数字を要素に持つ配列\n(declaim ((simple-array integer (100000)) *numbers*))\n(defvar *numbers*\n  (make-array 100000))\n\n\n(aref *number-strings* 100)\n;=>  \"100\"\n\n(aref *numbers* 100)\n;=>  0\n}}}\n処理例\n{{{\n(defconstant max-threads 2)\n\n(progn\n  (parallel-future:with-context (max-threads) ;max-threadsの値まで並列実行\n    (parallel:dotimes (i (length *numbers*))\n      :wait                             ;ループごとのボディ部の実行完了を待つ\n      (setf (aref *numbers* i)\n            (parse-integer (aref *number-strings* i)))))\n  (reduce #'+ *numbers*))\n;=> 4999950000\n}}}\n")
("サブクラス関係かどうか判定する" . "(:ctime 1233062751 :cuser #f :mtime 1233062836 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\nCommon Lispでは組み込み型とクラスは統合されていますので判定には[[$$hs subtypep]]が利用できます。\n[[$$hs subtypep]]は2値を返し、第1引数が第2引数のサブタイプ/クラスである場合は、1値目がTになります。\nサブクラスでない場合は、1値目がNILになり、判定できない場合は、2値目がNILとなります。(T,NILという組み合わせはありません。)\n{{{\n(defclass foo () ())\n(defclass bar (foo) ())\n(defclass baz () ())\n\n(subtypep 'foo 'bar)\n;=> NIL\n;   T\n\n(subtypep 'foo 'baz)\n;=> NIL\n;   T\n\n(subtypep 'bar 'foo)\n;=> T\n;   T\n}}}\n\n\n")
(" %Tag:%u3010%u52df%u96c6%u4e2d%u3011" . "(1598450202)")
("配列" . "(:ctime 1228095119 :cuser #f :mtime 1612437813 :muser #f)[[$$tag 配列]]\n\n- [[プログラムで配列を定義する]]\n- [[指定した長さの配列を作成する]]\n- [[配列要素をカンマ区切りで出力する]]\n- [[配列の要素数を取得する]]\n- [[配列に要素を追加する]]\n- [[配列の先頭または末尾から要素を取りだす]]\n- [[部分配列を取りだす]]\n- [[配列を任意の値で埋める]]\n- [[配列を空にする]]\n- [[配列同士を結合する]]\n- [[配列同士の和・差・積を取る]]\n- [[複数の要素を変更する]]\n- [[配列の配列をフラットな配列にする]]\n- [[配列をソートする]]\n- [[条件式を指定したソート]]\n- [[配列を逆順にする]]\n- [[指定した位置の要素を取り除く]]\n- [[一致する要素を全て取り除く]]\n- [[配列から重複した要素を取り除く]]\n- [[配列から指定条件を満たす要素を取り除く]]\n- [[配列中の要素を探す]]\n- [[配列の配列を検索する]]\n- [[配列の各要素に関数を適用し配列を作成する]]\n- [[配列の各要素に対して関数を適用する]]\n- [[配列の要素をランダムに抽出する]]\n- [[多次元の配列を1つのインデックスで扱う]]\n- [[多次元配列の要素をランダムに抽出する]]\n- [[配列をリストに変換する]]\n- [[配列を縮小したい]]\n- [[ARRAY-TOTAL-SIZE-LIMIT]]\n")
(" %Tag:split-sequence" . "(1668266389 (\"文字列を分割する\" :ctime 1280337523 :cuser #f :mtime 1349988541 :muser #f))")
("ファイルの最終更新時刻を取得する" . "(:ctime 1312884726 :cuser #f :mtime 1312884726 :muser #f)[[$$tag 入出力]]\n* ファイルの最終更新時刻を取得する\n[[$$hs file-write-date]] 関数にファイルのパスネームを渡すことで universal timeで最終更新時刻を取得できます。\n\n{{{\n(file-write-date #p\"/var/log/boot.log\")\n;=> 3521838581\n}}}\n")
("HTMLのパース・作成" . "(:ctime 1329736499 :cuser #f :mtime 1331442034 :muser #f)[[$$tag HTML]]\n\n* HTMLの作成\n\n** net.html.generator\n\nFranzのAllegroServeの一部です。リストで表現したツリーからHTMLを出力するためのライブラリです。\n\n{{{\n(defpackage :htmlgen.use (:use :cl :net.html.generator))\n(in-package :htmlgen.use)\n\n(html (:html\n        (:head (:title \"タイトル\"))\n        (:body (:p \"段落\"))))\n;=> \"</html>\"\n;-> <html><head><title>タイトル</title></head><body><p>段落</p></body></html>\n}}}\n\n基本はnet.html.generator:htmlマクロです。このマクロは、ツリーから変換したHTMLをnet.html.generator:*html-stream*に出力します。特に指定しない場合、*html-stream*は標準出力です。\n\nまた、*html-stream*を簡単に設定するために、net.html.generator:html-streamというマクロも用意されています。\n\n*** 使用例\n\n{{{\n;; 部分的なツリーも変換できる\n(html (:p \"段落\"))\n;-> <p>段落</p>\n\n;; 文字列は単純に出力される\n(html \"テキスト\")\n;-> テキスト\n\n;; 直接タグを出力することもできる\n(html \"<em>強調</em>\")\n;-> <em>強調</em>\n\n;; キーワードは開始タグとして解釈される\n(html :br)\n;-> <br>\n\n;; HTMLに存在しない要素をキーワードに指定するとエラーになる\n(html :abc)\n;>> Error: unknown html keyword :ABC\n\n;; 最初の要素がキーワードのリストは要素として解釈される\n(html (:code \"コード\"))\n;-> <code>コード</code>\n\n;; 最初の要素がキーワードのリストのリストは属性を持つ要素として解釈される\n(html ((:a :href \"URL\") \"リンク\"))\n;-> <a HREF=\"URL\">リンク</a>\n\n;; それ以外の式はLispの式として評価されるが出力はされない\n(html (list 0 1 2))\n;=> (0 1 2)\n}}}\n")
("loop" . "(:ctime 1336291276 :cuser #f :mtime 1630548022 :muser #f)[[$$tag 制御構造 ]]\n* 繰り返し(loop)\n\n*** 無限ループ\nloopキーワードをなにも指定しなければ無限ループです。\n{{{\n(loop (print \"hello\")\n      (print (random 100)))\n;-> \"hello\" \n    49 \n    \"hello\" \n    37\n    ... \n}}}\n\n*** シーケンス上でのループ\nforキーワードでループ変数を宣言できます。\n続けて in でリスト上を across でベクタ上を渡り歩きます。\nハッシュテーブルには being hash-keys of または being hash-values of を使います。\n{{{\n;; 奇数の要素のみ取り出して、その二乗した値をリストにして返します。\n(loop for i in '(1 2 3 4 5) if (oddp i) collect (* i i))\n;=> (1 9 25)\n\n;; 文字コードが奇数の文字のみ取り出してリストにして返します。\n(loop for i across \"hello\" if (oddp (char-code i)) collect i)\n;=> (#\\e #\\o)\n\n;; ハッシュテーブルを渡り歩きます。順序は定義されていません。\n(loop for i being the hash-keys of (make-hash-table)\n      do (print i))\n;; キーだけでなく値も参照したい場合は using で指定します。\n(loop for i being the hash-keys of (make-hash-table)\n      using (hash-value j)\n      do (print (cons i j)))\n}}}\n\n複数のforを指定できますが、入れ子になるのではなく並列して処理されます。\n最初に終端にきたところでループは終わります。\n{{{\n(loop for i in '(1 2 3)\n      for j in '(4 5)\n      do (print (cons i j)))\n;-> (1 . 4) \n    (2 . 5)\n;=> NIL\n}}}\n\n*** 補助変数の導入\nwithキーワードでループ内変数を宣言できます。\n初期値を指定しない場合はnilになります。\nforと違い値は勝手に更新されません。\n{{{\n(loop with x = 1\n      with y\n      repeat 3\n      do (setf y x)\n         (print y))\n}}}\n\n*** ループ変数の型指定\nof-type キーワードでループ変数の型を指定できます。\nコンパイラが優秀であれば効率の良いコード生成の助けになるでしょう。\n{{{\n;; i の型を fixnum と宣言します。\n(loop for i of-type fixnum from 0 to 10 do (print i))\n}}}\n")
(" %Tag:ライブラリ'A=0" . "(1570372357)")
("配列同士を結合する" . "(:ctime 1228193096 :cuser #f :mtime 1228193097 :muser #f)[[$$tag 配列]]\n\n* 配列同士を結合する\n\nシークエンスを結合する関数 [[$$hs concatenate]] が使えます。第一引数に戻り型を指定し、その後ろに結合する配列を渡します。配列の個数は任意です。\n{{{\n(let ((v1 (vector 0 1 2))\n      (v2 (vector 3 4 5))\n      (v3 (vector 6 7 8)))\n  (concatenate 'vector v1 v2 v3))\n;=> #(0 1 2 3 4 5 6 7 8)\n\n(concatenate 'vector)\n;=> #()\n}}}\n")
(" %Tag:コンディション" . "(1668187752 (\"コンディションを発生させる\" :ctime 1236616487 :cuser #f :mtime 1397890667 :muser #f) (\"隠蔽されたコンディションの発生を活性化する\" :ctime 1397873712 :cuser #f :mtime 1397875998 :muser #f) (\"コンディション\" :ctime 1229668291 :cuser #f :mtime 1397872707 :muser #f) (\"独自のコンディションを定義し発生させる\" :ctime 1236568282 :cuser #f :mtime 1238215730 :muser #f) (\"特定のコンディションだけを捕捉する\" :ctime 1238214428 :cuser #f :mtime 1238214428 :muser #f) (\"発生したコンディションからの回復手段（再起動）を提供する\" :ctime 1236617333 :cuser #f :mtime 1238213866 :muser #f))")
(" %Tag:最適化'[0]" . "(1591784350)")
("大文字・小文字に揃える" . "(:ctime 1227347707 :cuser #f :mtime 1328603013 :muser #f)[[$$tag 文字列 シーケンス]]\n* 大文字・小文字に揃える\n{{{\n(string-upcase \"Hi, CLer\") ;=> \"HI, CLER\"\n(string-downcase \"Hi, CLer\") ;=> \"hi, cler\"\n}}}\n[[$$hs format]] も使えます。\n{{{\n(format nil \"~:@(~A~)\" \"Hi, CLer\")      ;=> \"HI, CLER\"\n(format nil \"~(~A~)\" \"Hi, CLer\")        ;=> \"hi, cler\"\n}}}\n;; * 大文字と小文字を入れ替える\n;; {{{\n;; ;;(import (rnrs unicode))\n;; ;;\n;; ;;(string-foldcase \"Hi, Schemer\") ; \"hI, sCHEMER\"\n;; \n")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45) --  /*" . "(1624124453)")
(" %Tag:local-time and 1=2" . "(1660041620)")
(" %Tag:コマンドライン" . "(1668194754 (\"trivial-shell\" :ctime 1432435430 :cuser #f :mtime 1432435430 :muser #f))")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae%' and 1=1 and '%'='" . "(1656001231)")
("命名の慣習" . "(:ctime 1232523500 :cuser #f :mtime 1436571557 :muser #f)ここでは、関数名や変数名の主な命名の慣習を挙げます。\n\n** 変数名\n\n:*global-variable*:\n大域変数で用いられます。Common Lispの場合は、更にスペシャル変数であることを意味することが多いようです。\nスペシャル変数に**が一貫して付いているのはCommon Lispの仕様策定の際に投票で議決された結果です。\n\n:constant-variable:\n大域定数。Common Lisp標準の大域定数は、飾りは付いていません ([[$$hs pi]]、[[$$hs most-positive-fixnum]]等々)\n一貫して定数には何も装飾がされていないのはCommon Lispの仕様策定の際に投票で議決された結果です。\n\n:+constant-variable+:\n比較的最近の慣習のようですがユーザ定義の定数で用いられます。~%\nCLIM方面が発祥のようです。\n\n** 関数名\n:foo1:\n:foo-1:\nfooの補助関数を表わすことが多いようです。foo1の補助関数は、foo2となります。かなり古くからある慣習のようでLISP 1.5時代からあるようです。\n\n:foo-aux:\n:foo-internal:\nfooの補助関数を表わします。\n\n:%foo: \n:|foo-internal|:\nユーザが使うことを意図していない、内部的な関数を意味することが多いようです。\n||で囲むのは、伝統的に関数名は大文字だけの所を敢えて小文字を含めて特殊な記述することにより内部的なものであることを強調する意図があるようです(特殊な記号を含めることもあります)。~%\nMIT Lispマシンでは、%fooというのはマイクロコードで書かれた関数を表わしており、処理系の内部的なところに使われていましたので、この辺りが由来と思われます。\n\n:nfoo:\n:dfoo:\n:foo!:\nfooと同じ結果を返す破壊的な関数です。例えばreverseに対するnreverseなどです。Nは「No Consing」からのようです。\nInterlisp方面では、d(estructive)を付けます。(dreverse等)\nSchemeでは!を付けるのが慣習となっています。\n\n** 述語\n:foop:\n:foo-p:\n:foo?:\n述語(predicate)の場合、最後にpを付けることが昔からの伝統になっています。foo?も多く使われます。\nsinglep、multi-word-pのように一語にはpを、複数語にはハイフン付き-pを使うのも伝統のようです。\nCLtL2ではstring-lesspはstring型に対するlesspである、としてハイフンの使い方の一貫性にこだわりを見せています。\n\n** 変換するもの\n:foo-to-bar:\n:bar-from-foo:\n:foo->bar:\n:foo-bar:\nfooからbarへ変換するようなものに付けられます。\n:ensure-foo:\n引数が既に要求を満している場合は、そのまま引数を、そうでなければ、要求を満すように加工して返したり、新しく生成したりするものに良く使われます\n** CLOS\n:foo-mixin:\nmixinという考えは、Rubyで有名になりましたが、それ自体はインスタンスを作らず何かと混ぜて利用するクラスをfoo-mixinのように命名する慣習は、CLOS以前のFlavorsの時代からあるようです。\n\n** マクロ\n:deffoo:\n:define-foo-bar:\nfooを定義するようなマクロに付けられます。~%\n-p系と同じく、一単語で完結する場合は、deffooを、複数単語で構成する場合は、define-foo-barとする場合が多いようです。~%\n\n:with-foo:\n:without-foo:\n何かの処理を準備し、本体が終了すれば、後始末をするようなマクロに付けられることが多いようです。\n[[$$hs with-open-file]]等。\n\n:do-foo:\n主に副作用目的で何かをするマクロに付けられることが多いようです。\n\n:make-foo:\nfooを生成する場合に用いられます。[[$$hs defstruct]]の定義では自動で生成もされます。\n\n:foof:\n[[$$hs setf]]のように汎変数を扱うfooマクロを表わします。FはFieldの略だそうです。\n\n:set-foo:\nfooになにかを設定する場合に使われますが、CLの場合、[[$$hs setf]]での汎変数の仕組みがありますので、(setf (foo x) val)とする場合が多いようです。\n\n:fooq:\n# (foo 'bar)というものがあった場合、quoteの省略としてqを付けます。[[$$hs setq]]等。かなり古くからの伝統のようですが、CLでは、[[$$hs setq]]に残るのみです。\n# (foo 'bar :test #'eq)というものがあった場合、省略形態としてqを付けます。CL以前の処理系の慣習です。CL以前の処理系では、CLのようにテスト関数を取ることはありませんでしたので、比較関数に応じたものが存在していました。memq等([[$$hs eq]]で比較する[[$$hs member]])等。\n\n** その他\n:*foo:\n# fooの補助関数を表わしますが、fooよりも機能が足りないものを表わすことがあるようです。固定引数の*my-equalを定義し、それを利用して可変引数のmy-equalを定義する、等。\n# fooという関数が先にあった場合、名前の衝突を避けるために付けることがあるようです。\n\n:foo*:\n# 主に束縛をするマクロの場合、パラレルに束縛するのではなくシリアルに束縛する場合に付けられます。[[$$hs let]]と[[$$hs let*]]、[[$$hs do]]と[[$$hs do*]]等。\n# fooの補助関数を表わしますが、fooよりも機能が多い万能的な関数を表わすことがあるようです。万能的な関数としてmap*を定義し、それに与えるオプションを変えることにより、mapcar、mapc、maplist、maplを作成する等。\n\n* 参考\n[[CLiki:Naming conventions]]\n")
("うるう年かどうか判定する" . "(:ctime 1227414804 :cuser #f :mtime 1227714916 :muser #f)[[$$tag 日付と時刻 metatilities]]\n* うるう年かどうか判定する\n自作するか、ライブラリを利用する\n下記では、[[ライブラリ:Metatilities]]を利用\n{{{\n(metatilities:leap-year-p 2000)\n;=> T\n\n(metatilities:leap-year-p 2001)\n;=> nil\n}}}\n----\n{{{\n(defun leap-year-p ( y )\n   (and (zerop (mod y 4))\n       (or (plusp (mod y 100))(zerop (mod y 400)))))\n}}}\n")
("ABCLでDISASSEMBLEする" . "(:ctime 1230125046 :cuser #f :mtime 1365504930 :muser #f)[[$$tag その他 ABCL]]\n\n* ABCLでDISASSEMBLEする\n\nABCLは [[$$hs disassemble]] に外部コマンドのjadを利用しますのでjadを導入すれば結果が表示されます。\n\n- [http://en.wikipedia.org/wiki/JAD_%28JAva_Decompiler%29 jad]\n\n{{{\n(disassemble (compile nil (lambda (x y) (+ x y))))\n;>> ; The class file version is 49.0 (only 45.3, 46.0 and 47.0 are supported)\n;>> ; // Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.\n;>> ; // Jad home page: http://www.geocities.com/kpdus/jad.html\n;>> ; // Decompiler options: packimports(3) annotate \n;>> ; \n;>> ; import org.armedbear.lisp.*;\n;>> ; \n;>> ; public final class abcl_af0d0b20_2c9a_411b_bb3d_931658d78a2c extends CompiledPrimitive\n;>> ; {\n;>> ; \n;>> ;     public final LispObject execute(LispObject lispobject, LispObject lispobject1)\n;>> ;     {\n;>> ;         return lispobject.add(lispobject1);\n;>> ;     //    0    0:aload_1         \n;>> ;     //    1    1:aload_2         \n;>> ;     //    2    2:invokevirtual   #24  <Method LispObject LispObject.add(LispObject)>\n;>> ;     //    3    5:areturn         \n;>> ;     }\n;>> ; \n;>> ;     public abcl_af0d0b20_2c9a_411b_bb3d_931658d78a2c()\n;>> ;     {\n;>> ;         super(Lisp.NIL, Lisp.readObjectFromString(\"(X Y)\"));\n;>> ;     //    0    0:aload_0         \n;>> ;     //    1    1:getstatic       #6   <Field org.armedbear.lisp.Symbol Lisp.NIL>\n;>> ;     //    2    4:ldc1            #8   <String \"(X Y)\">\n;>> ;     //    3    6:invokestatic    #12  <Method LispObject Lisp.readObjectFromString(String)>\n;>> ;     //    4    9:invokespecial   #18  <Method void CompiledPrimitive(LispObject, LispObject)>\n;>> ;     //    5   12:return          \n;>> ;     }\n;>> ; }\n;=> NIL\n}}}\n")
(" %Tag:仕様/ドキュメント" . "(1668285408 (\"仕様/ドキュメント\" :ctime 1227970340 :cuser #f :mtime 1237821656 :muser #f))")
("コーディングスタイル" . "(:ctime 1227967130 :cuser #f :mtime 1529826119 :muser #f)[[$$tag コーディングスタイル]]\n\n* コーディングスタイル\n- [[コメント]]\n- [[命名の慣習]]\n- [[大文字と小文字の使い分け]]\n\n----\n\n* 指針\n\nコーディングスタイルは人それぞれですが、ある程度、こうした方が良い、という緩やかなコンセンサスが、CLerの間でできているものもあります。定番のものから意見の分かれるものまで、コーディングスタイルについて書くページです。\n\n----\n\n[[$$toc]]\n\n----\n\n* コメント\n\n[http://norvig.com/luv-slides.ps Tutorial on Good Lisp Programming Style]の「3. Tips on Near-Standard Tools」では、\n\n<<<\nObey comment conventions~%\n; for inline comment~%\n'''';; for in-function comment~%\n'''';;; for between-function comment~%\n'''';;;; for section header (for outline mode)~%\n>>>\n\nと紹介されています。[http://www.gnu.org/software/emacs/manual/elisp.html GNU Emacs Lisp Reference Manual]における[http://www.gnu.org/software/emacs/manual/html_node/elisp/Tips.html#Tips Appendix D]の[http://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html#Comment-Tips D.7 Tips on Writing Comments]ではコード例を交えて、また、[[WiLiKi:Lisp:コメント]]では日本語で、同じ趣旨のことが書いてあります。後者に簡潔で分かりやすいコード例があるので引用します。\n\n{{{\n;;;; ファイル全体に対するコメント\n\n;;; いくつかの関数グループに対するコメント\n\n(defun foo (args)\n  (let ((a 0) (b 1))\n    ;; 関数内コードブロックに対するコメント\n    (apply #'+ a b args)    ; 一つの式に対するコメント\n  ))\n}}}\n\n----\n\n* ひとつの行をあまり長くしない\n\n（書きかけ）\n\n- 80文字と良く言われる\n- 最近ではターミナルもエディタも80文字以上で使うことも多いので臨機応変に\n- ただし、横に長いコードは左右への視点移動が必要になって読み辛い\n\n----\n\n* 命名規則\n\n（書きかけ）\n\n- スペシャル変数は*special*\n- 定数は+constant+\n- 内部関数は%internal-function\n- ヘルパー関数はfunction-1\n- *p, *-p\n- with-*\n- do-*\n- def*, define-*\n\n----\n\n* 関数は簡潔に\n\n<<<\nMaximize LOCNW: lines of code not written.~%\n\"Shorter is better and shortest is best.\"~%\n~- Jim Meehan\n>>>\n\nこれは[http://norvig.com/luv-slides.ps Tutorial on Good Lisp Programming Style]からの引用ですが、別に[http://codegolf.com/ コードゴルフ]の勧めというわけではなく、無駄なコードは書かないようにしましょう、ということです。他の言語でも良く言われることと同じです。\n\n[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]の[http://www.faqs.org/faqs/lisp-faq/part1/section-4.html How can I improve my Lisp programming style and coding efficiency?]にも同じことが書いてあります。\n\n<<<\nWrite short functions, where each function provides a single, well-defined operation. Small functions are easier to read, write, test, debug, and understand.\n>>>\n\n標準ライブラリにあるものを再発明したり、同じ計算を何度もしたり、関数に機能をいくつも詰め込んだりせずに、関数を簡潔に保つことで、書くのも簡単で、読みやすく、テストもデバッグもしやすくなります。\n\n----\n\n* 関数や変数の名前は分かりやすく\n\n（書きかけ）\n\n- 賛否は分かれるかもしれない\n- エディタが補完してくれる\n- pgなど、短い関数名や変数名を好む人もいる\n- 短い関数や、クロージャの引数にはxなどを使う人も多い\n\n----\n\n* 条件式の使い分け\n\n（書きかけ）\n\n- ifは二方向に分岐する式\n- それ以外はwhenやunlessで\n- andやorは真偽値に対して\n- condは複数の方向に分岐する式に対して\n- ifやwhenやunless vs cond\n- ifとprogn vs cond\n\n----\n\n* 省略可能な引数とキーワード引数を一緒に使わない\n\n省略可能な引数とキーワード引数を一緒に使うのは避けるべきです。キーワード引数の指定のつもりで、省略可能な引数に値を渡してしまって、見付けにくいバグにつながる事があります。\n\n次の例を見てください。\n\n{{{\n(defun f (x &optional y z &key k)\n  (list x y z k))\n\n(f 0)\n;=> (0 NIL NIL NIL)\n(f 0 1)\n;=> (0 1 NIL NIL)\n(f 0 1 2)\n;=> (0 1 2 NIL)\n(f 0 :z 1)\n;=> (0 :Z 1 NIL)\n(f 0 1 :z 2)\n;>> Error\n}}}\n\n(f 0 :z 1)のケースが特に危険で、省略可能な引数の値としてキーワードシンボルが使えてしまえる場合、一見問題なさそうに見えるが、動作がおかしい、ということになりかねません。\n\nそのような関数は定義しない、と思うかもしれませんが、実は標準ライブラリにも存在します。[[$$hs read-from-string]]の定義を見てください。まさにこのパターンです。利用するときには注意しましょう。[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]でも、[http://www.faqs.org/faqs/lisp-faq/part3/section-1.html Why does (READ-FROM-STRING \"foobar\" :START 3) return FOOBAR instead of BAR?]で取り上げられています。\n\n----\n\n* 真偽値の偽と空リストを区別する\n\n''これは賛否が分かれるのではないでしょうか。''\n\n[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]の[http://www.faqs.org/faqs/lisp-faq/part1/section-4.html How can I improve my Lisp programming style and coding efficiency?]では、可読性を良くする方法のひとつとして、\n\n<<<\nWhen NIL is used as an empty list, use () in your code. When NIL is used as a boolean, use NIL. Similarly, use NULL to test for an empty list, NOT to test a logical value. Use ENDP to test for the end of a list, not NULL.\n>>>\n\nのように、真偽値の偽と空リストを区別して扱うスタイルが提案されています。\n\n[http://www.lispworks.com/documentation/HyperSpec/Front/index.htm Common Lisp HyperSpec]では、[http://www.lispworks.com/documentation/HyperSpec/Body/26_a.htm 26.1 Glossary]の[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_n.htm#nil nilの項]で\n\n<<<\n'''nil''' n. the ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object object]'' that is at once the ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#symbol symbol]'' named \"NIL\" in the COMMON-LISP package, the ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_e.htm#empty_list empty list]'', the ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_b.htm#boolean boolean]'' (or ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_g.htm#generalized_boolean generalized boolean]'') representing ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#false false]'', and the ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_n.htm#name name]'' of the ''[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_e.htm#empty_type empty type]''.\n>>>\n\nと定義されています。[[$$hs nil]]には真偽値の偽としての意味と、空リストとしての意味、型の名前としての意味があるわけです。これは、Lispではリストの処理を良くするので都合が良く、コードを簡潔にするのに一役買っています。\n\n{{{\n;; nilと空リストが同じものと仮定したコード\n(labels ((rec (rest r)\n           (if rest\n               (rec (cdr rest) (+ r (car rest)))\n               r)))\n  (rec '(1 2 3 4 5 6 7 8 9) 0))\n;=> 45\n\n;; nilと空リストが違うものと仮定したコード\n(labels ((rec (rest r)\n           (if (null rest)      ; 空リストも真になるので条件式に直接渡せない\n               r\n               (rec (cdr rest) (+ r (car rest))))))\n  (rec '(1 2 3 4 5 6 7 8 9) 0))\n}}}\n\nですが、真偽値の偽と空リストという、本来は違う概念をひとつの同じものとして扱っていることへの反対意見もあります。その考えを推し進めたものが、[http://ja.wikipedia.org/wiki/Scheme Scheme]での真偽値の偽と空リストの扱いですが（偽は#fで空リストは()と別物）、nilと()の使い分けというのは、ややこちら寄りの考えと言えます。\n\n{{{\n;; 空リストは()\n(reduce (lambda (r x) (cons x r))\n        '(1 2 3)\n        :initial-value '())\n;=> (3 2 1)\n\n;; 真偽値はnil\n(let ((*read-eval* nil))\n  (read-from-string \"#.(+ 1 2)\"))\n;>> Error\n}}}\n\n----\n\n* cddddrなどはなるべく使わない\n\n（書きかけ）\n\n- 賛否は分かれるかもしれない\n- dの数を数えて頭の中で変換するのは遠回りで間違えやすい\n- nthやnthcdr、third、destructuring-bind、パターンマッチングの使用を考慮する\n\n----\n\n* 循環リスト以外のリストの長さはlengthで\n\nリストが循環リストでないなら、[[$$hs list-length]]よりも[[$$hs length]]の方が効率的です。lengthはシーケンスに対する汎用の関数のため、遅く思えますが、\n\n{{{\n;; Clozure CL 1.6 on Windows XP\n(let ((l (make-list 100000)))\n  (time (dotimes (n 10000) (list-length l)))\n  (time (dotimes (n 10000) (length l))))\n;-> (DOTIMES (N 10000) (LIST-LENGTH L)) took 5,375 milliseconds (5.375 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 5,141 milliseconds (5.141 seconds) were spent in user mode\n;                       0 milliseconds (0.000 seconds) were spent in system mode\n;    48 bytes of memory allocated.\n;   (DOTIMES (N 10000) (LENGTH L)) took 2,265 milliseconds (2.265 seconds) to run \n;                       with 2 available CPU cores.\n;   During that period, 2,156 milliseconds (2.156 seconds) were spent in user mode\n;                       0 milliseconds (0.000 seconds) were spent in system mode\n;    48 bytes of memory allocated.\n}}}\n\n実際にはlengthの方が効率的です。\n\nこれは、list-lengthが循環リストも扱えないといけないように決められているからです。[http://www.lispworks.com/documentation/HyperSpec/Front/index.htm Common Lisp HyperSpec]の[[$$hs list-length]]によると、\n\n<<<\nReturns the length of list if list is a proper list. Returns nil if list is a circular list.\n>>>\n\nとなっています。実際に循環リストに適用してみても、\n\n{{{\n(defparameter *circular* '#1=(a b . #1#))\n\n(list-length *circular*)\n;=> NIL\n(length *circular*)\n;>> Error\n}}}\n\nlist-lengthはきちんと動作しますが、lengthはエラーになります。\n\n----\n\n* 連想リストへの要素の追加\n\n[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]の[http://www.faqs.org/faqs/lisp-faq/part1/section-4.html How can I improve my Lisp programming style and coding efficiency?]では、\n\n<<<\nWhen adding an entry to an association list, use ACONS, not two calls to CONS. This makes it clear that you're using an alist.\n>>>\n\nと書かれています。連想リストに要素を追加するときは、[[$$hs cons]]を使うよりも[[$$hs acons]]を使った方が、少しだけ簡潔になり、コードを読む人に連想リストを使っていることを伝えやすくなります。\n\n{{{\n(defparameter *alist* '((:a . 1) (:b . 2)))\n\n; 少し冗長\n(cons (cons :c 3) *alist*)\n; 簡潔で連想リストを扱っていることも分かりやすい\n(acons :c 3 *alist*)\n;=> ((:C . 3) (:A . 1) (:B . 2))\n}}}\n\n----\n\n* リストの要素に関数を適用して戻り値を捨てるとき\n\n副作用を目的として、リストの要素に関数を適用したい、つまり、[http://ja.wikipedia.org/wiki/Scheme Scheme]の[http://practical-scheme.net/gauche/man/?l=jp&p=for-each for-each]と同じことをしたい場合、Common Lispでは[[$$hs mapc]]を使うと良いとされています。これは、mapcが最初に渡されたリストをそのまま返し、新たなメモリの割り当てが起きないからです。\n\n[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]の[http://www.faqs.org/faqs/lisp-faq/part1/section-4.html How can I improve my Lisp programming style and coding efficiency?]には、\n\n<<<\nIf you like using MAPCAR instead of DO/DOLIST, use MAPC when no result is needed -- it's more efficient, since it doesn't cons up a list.\n>>>\n\nと書かれています。\n\n{{{\n(mapc #'print '(0 1 2 3 4))\n;=> (0 1 2 3 4)\n;-> 0\n;   1\n;   2\n;   3\n;   4\n}}}\n\nちなみに、\n\n{{{\n(dolist (x '(0 1 2 3 4))\n  (print x))\n;=> NIL\n;-> 0\n;   1\n;   2\n;   3\n;   4\n}}}\n\nと書いても同じです。mapcの方が少しだけ簡潔で、関数的な書き方ですが、処理を追加したくなったとき、mapcでは関数合成や[[$$hs lambda]]を使わなければなりません。どちらを選ぶかは趣味の問題でしょう。\n\n----\n\n* *-if-notや:test-notは使わない\n\n[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]の[http://www.faqs.org/faqs/lisp-faq/part1/section-4.html How can I improve my Lisp programming style and coding efficiency?]では、\n\n<<<\nIf using REMOVE and DELETE to filter a sequence, don't use the :test-not keyword or the REMOVE-IF-NOT or DELETE-IF-NOT functions. Use COMPLEMENT to complement the predicate and the REMOVE-IF or DELETE-IF functions instead.\n>>>\n\nのように、[[$$hs find-if-not]]や[[$$hs remove-if-not]]などの、条件が成り立たない場合に処理をするための関数や、:test-notを使うのは避け、*-ifや:testと[[$$hs  complement]]を組み合わせるべきだと書かれています。\n\n{{{\n; find-if-notを使う場合\n(find-if-not #'zerop '(0 0 3))\n; complementを使って書く場合\n(find-if (complement #'zerop) '(0 0 3))\n;=> 3\n}}}\n\nなお、[http://www.lispworks.com/documentation/HyperSpec/Front/index.htm HyperSpec]にも書いてありますが、*-if-notや:test-notは「deprecated（廃止予定）」です。\n\n- [http://www.lispworks.com/documentation/HyperSpec/Issues/iss172.htm Issue FUNCTION-COMPOSITION:JAN89-X3J13]\n- [http://www.lispworks.com/documentation/HyperSpec/Issues/iss345.htm Issue TEST-NOT-IF-NOT:FLUSH-ALL]\n\nで詳しい内容が書かれています。complementがあれば*-if-notや:test-notは不要になり、:testと:test-notを一緒に使ったときの分かりにくい動作もなくせる、という理由によるものです。\n\n----\n\n* openやcloseはできるだけ直接使わない\n\n<<<\nUse WITH-OPEN-FILE instead of OPEN and CLOSE.\n>>>\n\n[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]の[http://www.faqs.org/faqs/lisp-faq/part1/section-4.html How can I improve my Lisp programming style and coding efficiency?]からの引用です。\n\n[[$$hs open]]や[[$$hs close]]を必要もないのに直接使うのは避けた方が良いと言われます。[[$$hs with-open-file]]というマクロがあるからで、これはファイルを自動的に開き、閉じてくれるほか、エラーが発生したときでも確実にファイルを閉じてくれるという優れものです。\n\n{{{\n(defparameter *csv*\n  (with-open-file (s \"13tokyo.csv\")\n    (loop for line = (read-line s nil)\n          while line\n          collect line)))\n}}}\n\nプログラマはファイルに対する処理だけに集中できます。\n\nこのwith-*という形は何かと便利なので、リソースを確保して処理を行い、リソースを解放する、というパターンで幅広く使われます。[http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9 API]のデザインをするときのために、覚えておくと良いでしょう。\n\n----\n\n* evalの使用は慎重に\n\n[[$$hs eval]]は慎重に使うべきだと言われています。\n\n[http://norvig.com/luv-slides.ps Tutorial on Good Lisp Programming Style]では、「any use of eval」は「red flag（危険信号）」であるとされ、[http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]の[http://www.faqs.org/faqs/lisp-faq/part1/section-4.html How can I improve my Lisp programming style and coding efficiency?]では、\n\n<<<\nNovices almost always misuse EVAL. When experts use\nEVAL, they often would be better off using APPLY, FUNCALL, or\nSYMBOL-VALUE. Use of EVAL when defining a macro should set off\na warning bell -- macro definitions are already evaluated\nduring expansion. See also the answer to question 3-12.\nThe general rule of thumb about EVAL is: if you think you need\nto use EVAL, you're probably wrong.\n>>>\n\nと書かれています。evalを使うのが正しいケースについては、[http://www.faqs.org/faqs/lisp-faq/part3/section-13.html When is it right to use EVAL?]で書かれていますが、例えば、REPLをアプリケーションから提供するケースです。\n\n----\n\n* defpackageなどで使われるstring designatorについて\n\n[[$$hs require]]や[[$$hs defpackage]]などに渡す、モジュール名やパッケージ名として使われる[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_designator string designator]ですが、この値として何を渡すか、たまに話題になることがあります。（例としては[https://groups.google.com/group/comp.lang.lisp/browse_thread/thread/4a8f0f8bb30d6dea/ A Question about DEFPACKAGE syntax]を見てください）\n\n** 文字列\n\n大文字を入力したり、ダブルクォートで囲む手間があるので少数派です。\n\n{{{\n> (require \"ITERATE\")\n\"ITERATE\"\nNIL\n> (use-package \"ITERATE\")\nT\n}}}\n\n** 普通にインターンされるシンボル\n\nこちらも少数派です。意図しないシンボルの衝突が起きる危険があるので避けた方が良いでしょう。\n\n{{{\n> (require 'iterate)\nITERATE\nNIL\n> (use-package 'iterate)\nError: Using #<Package \"ITERATE\"> in #<Package \"ITER-TEST\"> \n       would cause name conflicts with symbols already present in that package: \n       ITERATE  ITERATE:ITERATE\n}}}\n\n** キーワード\n\n最近の多数派です。大文字を入力しないで済みますし、クォートする必要もありません。シンボルはキーワードパッケージにインターンされるので、意図しない衝突は起きません。\n\n{{{\n> (require :iterate)\n:ITERATE\nNIL\n> (use-package :iterate)\nT\n}}}\n\n** インターンされないシンボル\n\n多数派ではないですが、少数派ほど少ないわけでもありません。タイプ数はキーワードに比べて多くなります。シンボルがどのパッケージにもインターンされないのが利点です。衝突は起きません。\n\n{{{\n> (require '#:iterate)\n#:ITERATE\nNIL\n> (use-package '#:iterate)\nT\n}}}\n\n----\n\n* 参考文献\n\n- [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm Common Lisp HyperSpec]\n- [http://www.faqs.org/faqs/lisp-faq/ FAQ: Lisp Frequently Asked Questions]\n- [http://norvig.com/luv-slides.ps Tutorial on Good Lisp Programming Style]（[http://www010.upp.so-net.ne.jp/okshirai/tutorial-on-good-lisp-programming-style-ja.txt 日本語訳]）\n- [[WiLiKi:Scheme:コーディングスタイル]]\n- [https://groups.google.com/group/comp.lang.lisp/browse_thread/thread/4a8f0f8bb30d6dea/ A Question about DEFPACKAGE syntax]\n- [[Tutorial on Good Lisp Programming Style]]\n- [http://lisphub.jp/doc/google-common-lisp-style-guide/lispguide.xml Google Common Lisp Style Guide日本語訳]\n\n")
("Elephant" . "(:ctime 1329736550 :cuser #f :mtime 1329736550 :muser #f)[[$$tag 【募集中】]]\n")
("文字列を1文字ずつに分ける" . "(:ctime 1282412075 :cuser #f :mtime 1313400711 :muser #f)[[$$tag 文字列 シーケンス cl-ppcre]]\n\n* 一文字ずつ文字にする\n\n[[$$hs coerce]]を利用して文字列を文字のリストに変換します。\n{{{\n(coerce \"いろはにほへとちりぬるを\" 'list)\n;=> (#\\い #\\ろ #\\は #\\に #\\ほ #\\へ #\\と #\\ち #\\り #\\ぬ #\\る #\\を)\n}}}\n\n** 一文字ずつ文字列にする\n\n[[$$hs map]]を利用します。[[$$hs string]]で一文字ずつ文字を文字列に変換したものをリストで返します。\n{{{\n(map 'list #'string \"いろはにほへとちりぬるを\")\n;=> (\"い\" \"ろ\" \"は\" \"に\" \"ほ\" \"へ\" \"と\" \"ち\" \"り\" \"ぬ\" \"る\" \"を\")\n}}}\n\nPerl風に正規表現で分割することもできます。[[CLiki:CL-PPCRE]]のsplitを利用します。\n{{{\n;; split //, \"いろはにほへとちりぬるを\";\n(ppcre:split \"\" \"いろはにほへとちりぬるを\")\n;=> (\"い\" \"ろ\" \"は\" \"に\" \"ほ\" \"へ\" \"と\" \"ち\" \"り\" \"ぬ\" \"る\" \"を\")\n}}}\n")
(" %Tag:【募集中】?p=Tag:【募集中】" . "(1491321932)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45) -- /* order by \"as /*" . "(1624124824)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45) -- /* order by \"as /*" . "(1624124971)")
(" %Tag:????2121121121212.1" . "(1587484315)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45) -- /* order by \"as /*" . "(1624124915)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45) -- /* order by 'as /*" . "(1624124732)")
("ライブラリ:KMRCL" . "(:ctime 1227238969 :cuser #f :mtime 1227238969 :muser #f)[[$$toc]]\nKevin Rosenberg氏によるユーティリティ集\nhttp://www.cliki.net/kmrcl\n")
(" %Tag:?????" . "(1584214734)")
(" %Tag:local-time' or (1=1) and 'a'='a" . "(1660041624)")
("cl-http" . "(:ctime 1329736460 :cuser #f :mtime 1329736460 :muser #f)[[$$tag 【募集中】]]\n")
(" %Tag:CL-TEST-MORE' and 'x'='y" . "(1582882536)")
(" %Tag:配列' And SLeep(3) UniON SEleCT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643 #" . "(1624125329)")
("Ltk:ラベルを設定する" . "(:ctime 1619742158 :cuser #f :mtime 1619744739 :muser #f)* ラベル\n\n{{{\n;;; LTKのラベルをテストする\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-14\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-14)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"ラベルテスト\")\n    (minsize *tk* 300 100)\n\n    (let* ((lbl (make-instance\n                 'label\n                 :text \"\"\n                 :background \"#FFFFFF\"))\n\n           (fradio (make-instance 'frame))\n           (r1 (make-instance 'radio-button :master fradio :text \"いちばん上\" :value 1 :variable \"group1\"\n                              :command (lambda (value)\n                                         (format t \"radio-button1_click!:~A~%\" value)\n                                         (setf (text lbl) \"いちばん上\"))))\n\n           (r2 (make-instance 'radio-button :master fradio :text \"真ん中　　\" :value 2 :variable \"group1\"\n                              :command (lambda (value)\n                                         (format t \"radio-button2_click!:~A~%\" value)\n                                         (setf (text lbl) \"真ん中\" ))))\n\n           (r3 (make-instance 'radio-button :master fradio :text \"いちばん下\" :value 3 :variable \"group1\"\n                              :command (lambda (value)\n                                         (format t \"radio-button3_click!:~A~%\" value)\n                                         (setf (text lbl) \"いちばん下\" ))))\n           \n           \n           (b1 (make-instance\n                'button\n                :text \"Close\"\n                :command (lambda ()\n                           (format t \"終了\")\n                           (setf *exit-mainloop* t)))))\n      ;(pack (list b1 b2 b3) :side :top)\n      ;(pack (list b1 b2 b3) :side :left)\n      ;(pack (list b1 b2 b3) :side :right)\n      ;(pack (list b1 b2 b3) :side :bottom)\n\n      (pack lbl :side :top :fill :x)\n      (pack fradio :side :top)\n      (pack (list r1 r2 r3) :side :top)\n      (pack b1 :side :top :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n      )))\n\n(main)\n}}}\n")
("数値を文字列に変換する" . "(:ctime 1228788799 :cuser #f :mtime 1328663465 :muser #f)[[$$tag 数値]]\n\n* 数値を文字列に変換する\n[[$$hs write-to-string]]、[[$$hs prin1-to-string]]、[[$$hs princ-to-string]] などを使います\n{{{\n(write-to-string 1234) ;=> \"1234\"\n(write-to-string 123.4) ;=> \"123.4\"\n}}}\n")
("AllegroServe" . "(:ctime 1329736467 :cuser #f :mtime 1329736467 :muser #f)[[$$tag 【募集中】]]\n")
("ニックネームを追加する" . "(:ctime 1379367692 :cuser #f :mtime 1379368049 :muser #f)[[$$tag パッケージ]]\n* ニックネームを追加する\n\n既存のパッケージにニックネームを追加する関数は、標準では用意されていませんが、\n[[$$hs rename-package]] と\n[[$$hs package-nicknames]] を用いることで実現できます。\n\n{{{\n(defun add-nickname (nickname package)\n  (rename-package package\n                  (package-name package)\n                  (cons nickname (package-nicknames package))))\n}}}\n\n{{{\n;;;; 使用例\n\n(defpackage :foo-bar-baz)\n\n(package-nicknames :foo-bar-baz)\n;=> NIL\n\n(add-nickname :foo :foo-bar-baz)\n;=> #<PACKAGE \"FOO-BAR-BAZ\">\n\n(package-nicknames :foo-bar-baz)\n;=> (\"FOO\")\n}}}\n")
("コンディション処理の後に処理をやり直す" . "(:ctime 1329736339 :cuser #f :mtime 1329736339 :muser #f)[[$$tag 【募集中】]]\n")
("Quicklispを使う" . "(:ctime 1292893400 :cuser #f :mtime 1299547197 :muser #f)[[$$tag ライブラリ管理]]\n\n[[CLiki:Quicklisp]]はZach Beaneが開発しているライブラリ管理ツールです。まだBetaリリースですが、多くのライブラリが登録されておりLinux,Mac,Windowsにも対応しています。\n\n* インストール\n\nインストールは非常に簡単で、[http://beta.quicklisp.org/quicklisp.lisp quicklisp.lisp]をダウンロードしてきて、\n処理系からloadしたら、以下のように自動セットアップを実行するだけです。\n{{{\n(quicklisp-quickstart:install)\n}}}\nプロキシを設定したい場合は:proxyキーワードを使います。\n{{{\n(quicklisp-quickstart:install :proxy \"http://192.168.x.xx:8080\")\n}}}\nすると、自動的にセットアップが実行され、~/quicklispにインストールされます。もし次回の処理系の実行時にも自動的にロードしてほしいと思ったら\n{{{\n(ql:add-to-init-file)\n}}}\nを実行しておくと、自動的にその[[処理系のinitファイル]]にquicklispをロードするようのコードが挿入されます。\n\n* インストールディレクトリを変更\n\nホームディレクトリにインストールされるのが嫌であれば、セットアップ後に自由に移動すれば大丈夫です。\n\n{{{\n# ~/.quicklispに移動\n$ mv quicklisp .quicklisp\n}}}\n\nその後[[処理系のinitファイル]]に追加されたディレクトリパスを変更します。\n\n ;;; The following lines added by ql:add-to-init-file:\n #-quicklisp\n (let ((quicklisp-init (merge-pathnames \"'''.quicklisp'''/quicklisp/setup.lisp\"\n                                        (user-homedir-pathname))))\n   (when (probe-file quicklisp-init)        \n     (load quicklisp-init)))\n\n* ライブラリの検索\n\nQuicklispに登録されているライブラリを検索するにはql:system-aproposを使います。\n\n{{{\n(ql:system-apropos \"web\")\n;-> #<system cl-webdav / cl-webdav-0.2.0 / quicklisp 2010-12-07>\n;   #<system symbolicweb / symbolicweb-20101207-git / quicklisp 2010-12-07>\n;   #<system symbolicweb-examples / symbolicweb-20101207-git / quicklisp 2010-12-07>\n;   #<system symbolicweb-jquery / symbolicweb-20101207-git / quicklisp 2010-12-07>\n;   #<system webactions / portableaserve-20101006-cvs / quicklisp 2010-12-07>\n;   #<system weblocks / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-demo / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-demo-popover / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-memory / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-prevalence / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-s11 / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-scripts / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-store-test / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-yarek / weblocks-20101207-hg / quicklisp 2010-12-07>\n;   #<system weblocks-yui / weblocks-20101207-hg / quicklisp 2010-12-07>\n;=> nil\n}}}\n\n* ライブラリのインストール\n\nライブラリをインストールするにはql:quickloadを使います。\n\n{{{\n(ql:quickload :weblocks)\n}}}\n\n一度インストールされたライブラリをロードするときにも同じql:quickloadを使います。\n\n* ライブラリ情報のアップデート\n\nQuicklispのリポジトリに登録されているライブラリは毎月更新されます(毎月7日？)。ローカルのリポジトリを新しい情報に更新するにはREPLで以下のコードを実行します。\n\n{{{\n(ql:update-all-dists)\n}}}\n\n* プロキシの設定\n\nインストール時にプロキシを設定した場合は既にプロキシが設定されていますが、一時的にプロキシを設定したい場合はql-http:*proxy-url*にURLをセットします。\n\n{{{\n(setf ql-http:*proxy-url* \"http://192.168.x.xx:8080\")\n}}}\n\n* 自分のライブラリを登録してもらうには\n\n[https://github.com/quicklisp/quicklisp-projects/issues GitHub]にアクセスし、左のCreate Issueをクリックします。タイトルに自分のライブラリ名、本文にライブラリの内容などを入力して登録します。\n\nビルドできることが確認され、次のアップデートサイクルのときに登録されます。\n")
("パッケージとは" . "(:ctime 1329736400 :cuser #f :mtime 1329736400 :muser #f)[[$$tag 【募集中】]]\n")
("データベース" . "(:ctime 1293000330 :cuser #f :mtime 1329736521 :muser #f)- [[cl-sql]]\n- [[Postmodern]]\n- [[Elephant]]\n")
("JSONのパース・生成" . "(:ctime 1346850276 :cuser #f :mtime 1346932427 :muser #f)[[$$tag JSON cl-json yason]]\n\n[http://ja.wikipedia.org/wiki/JavaScript_Object_Notation JSON]を扱う場合、専用のライブラリを使うと簡単です。\n\n* CL-JSON\n\nJSONデータとCommon Lispのオブジェクトを変換するためのライブラリです。動作を細かく変更できるようになっているので、幅広いケースに対応できるでしょう。\n\n{{{\n;;; JSON文字列の変換\n\n(json:decode-json-from-string \"{\\\"x\\\": 0, \\\"y\\\": 1}\")\n;=> ((:X . 0) (:Y . 1))\n\n(json:encode-json-to-string '((:x . 0) (:y . 1)))\n;=> \"{\\\"x\\\":0,\\\"y\\\":1}\"\n\n;;; ストリームからの読み込みと書き出し\n\n(with-input-from-string (s \"{\\\"x\\\": 0, \\\"y\\\": 1}\")\n  (json:decode-json s))\n;=> ((:X . 0) (:Y . 1))\n\n(with-output-to-string (s)\n  (json:encode-json '((:x . 0) (:y . 1)) s))\n;=> \"{\\\"x\\\":0,\\\"y\\\":1}\"\n}}}\n\n* YASON\n\nCL-JSONと目的やできることが似ていますが、単純な仕組みになっています。JSONデータから[http://ja.wikipedia.org/wiki/Common_Lisp_Object_System CLOS]オブジェクトへの直接的な変換はサポートしていません。\n\nJSONデータをパースするには[http://common-lisp.net/project/yason/#parse yason:parse]を使います。\n\n{{{\n(let (l (ht (yason:parse \"{\\\"x\\\": 0, \\\"y\\\": 1}\")))\n  (maphash (lambda (k v) (push (cons k v) l)) ht)\n  (values ht l))\n;=> #<HASH-TABLE :TEST EQUAL size 2/60 #x302000F52B0D>,\n;   ((\"y\" . 1) (\"x\" . 0))\n}}}\n\nyason:parseに入力として指定できるのは[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string 文字列]と[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#stream ストリーム]のどちらかです。\n\n{{{\n(let ((ht (yason:parse \"{\\\"x\\\": 0, \\\"y\\\": 1}\")))\n  (maphash (lambda (k v) (format t \"~a, ~a~%\" k v)) ht))\n;-> x, 0\n;   y, 1\n\n(with-input-from-string (s \"{\\\"x\\\": 0, \\\"y\\\": 1}\")\n  (let ((ht (yason:parse s)))\n    (maphash (lambda (k v) (format t \"~a, ~a~%\" k v)) ht)))\n;-> x, 0\n;   y, 1\n}}}\n\nJSONオブジェクトは\n\n- [http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#association_list 連想リスト]\n- [http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#property_list プロパティリスト]\n- [http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_h.htm#hash_table ハッシュテーブル]\n\nに変換できます。JSONデータとCommon Lispオブジェクトの対応の詳細は[http://common-lisp.net/project/yason/#mapping Mapping between JSON and CL datatypes]を見てください。\n\n{{{\n;; 標準では比較関数がcl:equalのハッシュテーブルに変換する\n(yason:parse \"{\\\"x\\\": 0, \\\"y\\\": 1}\")\n;=> #<HASH-TABLE :TEST EQUAL size 2/60 #x302000F1E5DD>\n\n;; 連想リストに変換する。:object-asで作るオブジェクトの種類を決められる\n(yason:parse \"{\\\"x\\\": 0, \\\"y\\\": 1}\" :object-as :alist)\n;=> ((\"y\" . 1) (\"x\" . 0))\n\n;; プロパティリストに変換する。yason:*parse-object-as*スペシャル変数でもコントロールできる\n(let ((yason:*parse-object-as* :plist))\n  (yason:parse \"{\\\"x\\\": 0, \\\"y\\\": 1}\"))\n;=> (\"x\" 0 \"y\" 1)\n}}}\n\nJSONデータへのエンコードには\n\n- [http://common-lisp.net/project/yason/#encode yason:encode]\n- [http://common-lisp.net/project/yason/#encode-alist yason:encode-alist]\n- [http://common-lisp.net/project/yason/#encode-plist yason:encode-plist]\n\nを使います。エンコードされた結果はストリームに書き出されます。\n\n{{{\n;; 基本的にyason:encodeでエンコードする\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"x\" ht) 0)\n  (setf (gethash \"y\" ht) 1)\n  (yason:encode ht *standard-output*))\n;-> {\"x\":0,\"y\":1}\n\n;; ストリームの指定を省略すると標準出力へ\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"x\" ht) 0)\n  (setf (gethash \"y\" ht) 1)\n  (yason:encode ht))\n;-> {\"x\":0,\"y\":1}\n\n;; 連想リストからのエンコードにはencode-alistを使う\n;; 連想リストのキーはcl:symbol-nameで文字列に変換される\n(yason:encode-alist '((:x . 0) (:y . 1)))\n;-> {\"X\":0,\"Y\":1}\n\n;; JSONオブジェクトのキーを小文字にしたい場合は小文字のシンボルを使う\n(yason:encode-alist '((:|x| . 0) (:|y| . 1)))\n;-> {\"x\":0,\"y\":1}\n\n;; プロパティリストからのエンコードにはencode-plistを使う\n(yason:encode-plist '(:x 0 :y 1))\n;-> {\"X\":0,\"Y\":1}\n}}}\n\nyason:encodeは[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_g.htm#generic_function 総称関数]なので、[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_m.htm#method メソッド]を定義することでユーザ定義のCLOSオブジェクトを直接エンコードできるようになります。\n\n{{{\n;; 連想リストを表わすクラスを定義する\n(defclass alist () ((content :initarg :content)))\n\n;; エンコードのために特殊化したメソッドを定義する\n(defmethod yason:encode ((object alist) &optional (stream *standard-output*))\n  (yason:encode-alist (slot-value object 'content) stream))\n\n;; オブジェクトを直接変換できるように\n(yason:encode (make-instance 'alist :content '((:x . 0) (:y . 1))))\n;-> {\"X\":0,\"Y\":1}\n}}}\n")
(" %Tag:テストフレームワーク" . "(1668213227 (\"prove\" :ctime 1460644309 :cuser #f :mtime 1460644309 :muser #f) (\"CL-TEST-MORE\" :ctime 1294028420 :cuser #f :mtime 1460644076 :muser #f))")
("特定のURLからファイルをダウンロードする" . "(:ctime 1431153805 :cuser #f :mtime 1431269795 :muser #f)[[$$tag インターネットサービス trivial-http ライブラリ]]\n* 特定のURLからファイルをダウンロードする\t\n[[CLiki:trivial-http]]を利用\n{{{\n(ql:quickload :trivial-http)\n\n(trivial-http:http-download\n ;; ファイルのURL\n \"http://www.lisperati.com/lisplogo_alien.svg\"\n ;; 保存するファイル名\n \"/tmp/lisplogo_alien.svg\"                    　\n ;; エラー発生でシグナルを上げない\n :signal-error? nil) \n;=>  41783 ;ダウンロードしたバイト数\n;    \"http://www.lisperati.com/lisplogo_alien.svg\" ;ダウンロードしたURL\n}}}\n\n[[CLiki:drakma]]を利用してダウンロードクライアントを作成\n{{{\n(defun download-file (filename uri)\n  (with-open-file (out filename\n                   :direction :output\n                   :if-exists :supersede\n                   :element-type '(unsigned-byte 8))\n    (with-open-stream (input (drakma:http-request uri :want-stream t :connection-timeout nil))\n      (loop :for b := (read-byte input nil -1)\n            :until (minusp b)\n            :do (write-byte b out)))))\n\n;; 利用例\n(download-file \"alien.svg\" \"http://www.lisperati.com/lisplogo_alien.svg\")\n}}}\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45) -- /* order by 'as /*" . "(1624124642)")
("キーに関連付けられた値を取得する" . "(:ctime 1227413525 :cuser #f :mtime 1227413525 :muser #f)[[$$tag ハッシュ]]\n* キーに関連付けられた値を取得する\nキーに関連づけられた値を取得するにはgethash関数を使用します。指定したキーが存在しない場合、nilが返却されます。gethashは多値を返し、2値目で検索に成功したかをT/nilで返します。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  (print (gethash \"apple\" ht))\n  (print (gethash \"banana\" ht))\n  (print (gethash \"lemon\" ht))\n  (print (gethash \"papaia\" ht)))\n;-> 150 \n    300 \n    300 \n    nil \n;=> nil\n}}}\n")
(" %Tag:CL-TEST-MORE' and 'x'='x" . "(1582882535)")
(" %Tag:local-time or(1=2)-- -" . "(1660041659)")
(" %Tag:local-time') as tempxtestxtable where 1=1-- -" . "(1660041714)")
("時刻中の曜日を日本語に変換する" . "(:ctime 1227414645 :cuser #f :mtime 1347284004 :muser #f)[[$$tag 日付と時刻]]\n* 時刻中の曜日を日本語に変換する\ndecode-universal-timeの7番目の値が曜日を数値で表現したものになります。dayの値は0が月曜日で、6が日曜日に対応します。これにより、例えば以下のようにして曜日を日本語で得ることができます。\n{{{\n(defconstant +wdays+ #(\"月\" \"火\" \"水\" \"木\" \"金\" \"土\" \"日\"))\n\n(format nil \n        \"今日は、~A曜日です。\"\n        (aref +wdays+\n              (nth-value 6\n                (decode-universal-time (get-universal-time)))))\n\n;=> \"今日は、金曜日です。\"\n}}}\n\n[[$$hs format]] の機能を活用\n{{{\n(format nil \n        \"今日は、~[月~;火~;水~;木~;金~;土~;日~]曜日です。\"\n        (nth-value 6 (decode-universal-time (get-universal-time))))\n;=> \"今日は、金曜日です。\"\n}}}\n")
("リストの各要素をカンマ区切りで出力する" . "(:ctime 1229550300 :cuser #f :mtime 1453044634 :muser #f)[[$$tag リスト]]\n\n[[$$hs format]] 関数の書式指定には繰り返しを指示する機能があります。\n{{{\n(format nil \"~{~A~^, ~}\" '(1 2 3))\n;-> \"1, 2, 3\"\n}}}\n\n* 文字列のエスケープを行う場合\n文字列中にカンマ、改行文字などを含む場合は、文字列のエスケープが必要です。\n\n[[$$tag 【募集中】]]\n\n* 参考\n- [https://gist.github.com/takeisa/3769042 Common Lisp format memo]\n- [http://www.gigamonkeys.com/book/a-few-format-recipes.html 18. A Few FORMAT Recipes]\n")
("現在の日付を求める" . "(:ctime 1227414677 :cuser #f :mtime 1227947512 :muser #f)[[$$tag 日付と時刻 metatilities]]\n* 現在の日付を求める\n自作するか、ライブラリを使用する。下記では、[[ライブラリ:Metatilities]]を利用\n{{{\n(metatilities:date-string)\n;=>\"Saturday, November 22, 2008\"\n\n(metatilities:date-string-brief)\n;=> \"11-22-2008\"\n}}}\n\nget-decoded-time は多値で秒、分、時、日、月、年、曜日、サマータイム、タイムゾーンを返すのでそれを利用することもできます。\n{{{\n(get-decoded-time)\n;=> 38\n;   28\n;   17\n;   29\n;   11\n;   2008\n;   5\n;   NIL\n;   -9\n(multiple-value-bind (second\n                      minute\n                      hour\n                      date\n                      month\n                      year\n                      day-of-weak\n                      daylight-p\n                      time-zone)\n    (get-decoded-time)\n  (format nil \"~d-~d-~d\" year month date))\n;=> \"2008-11-29\"\n}}}\n\n")
("format:NIL を () として印字したい" . "(:ctime 1333793406 :cuser #f :mtime 1626990240 :muser #f)[http://www.lispworks.com/documentation/HyperSpec/Body/22_cda.htm ~A]もしくは[http://www.lispworks.com/documentation/HyperSpec/Body/22_cdb.htm ~S]の引数にコロン修飾子を付けることによりNILを () として印字可能です。\n{{{\n(format t \"~:A\" '())\n;->  ()\n;=>  NIL\n}}}\n\nリストの内部を再帰的に変換するオプションはありませんので、自作かライブラリを利用することになるでしょう\n;; {{{\n;; ;;; 処理系の出力文字列をcl-ppcreを使って置換\n;; (defun cl-user::super-aesthetic (stream arg colon at)\n;;   (declare (ignore colon at))\n;;   (princ (ppcre:regex-replace-all \"NIL\"\n;;                                   (princ-to-string arg)\n;;                                   \"()\")\n;;          stream))\n;; \n;; (let ((*print-circle* t))\n;;   (format t\n;;         \"~/super-aesthetic2/\"\n;;         '#1=(nil nil nil . #1#)))\n;; ;>>  #1=(() () () . #1#)\n;; ;=>  NIL\n;; }}}\n\n{{{\n;;; 再帰的にリストを処理 (この実装は循環構造やプリティ・プリントに対応していない)\n(defun cl-user::super-aesthetic (stream arg colon at)\n  (declare (ignore colon at))\n  (labels ((pr (arg)\n             (princ arg stream))\n           (rec-pr (arg)\n             (typecase arg\n               (null (pr \"()\"))\n               (atom (pr arg))\n               (T (pr \"(\")\n                  (mapl (lambda (e)\n                          (rec-pr (car e))\n                          (and (cdr e) (pr \" \")))\n                        arg)\n                  (pr \")\")))))\n    (typecase arg\n      (list (rec-pr arg))\n      (T (pr arg)))))\n\n(format t \"~&~/super-aesthetic/ ≡ ~:*~A~%\" '(() ((())) ()))\n;->  (() ((())) ()) ≡ (NIL ((NIL)) NIL)\n;\n;=>  NIL\n\n(format t \"~&~/super-aesthetic/ ≡ ~:*~A~%\" '((a b (c nil d (e nil nil f)))))\n;->  ((A B (C () D (E () () F)))) ≡ ((A B (C NIL D (E NIL NIL F))))\n;\n;=>  NIL\n}}}\n\n** 議論\n")
(" %Tag:CCL" . "(1668268597 (\"処理系:選び方の目安\" :ctime 1529824793 :cuser #f :mtime 1606311892 :muser #f) (\"処理系:日本語の扱い\" :ctime 1529826517 :cuser #f :mtime 1529826517 :muser #f))")
(" %Tag:cl-interpol?Tag:cl-interpol" . "(1476570001)")
(" %Tag:????? and 1>1" . "(1584214736)")
("OS" . "(:ctime 1586446166 :cuser #f :mtime 1586446166 :muser #f)[[$$tag os]]\n\n- [[Linuxのディストリビューションを判定する]]\n")
("Ltk:ウィジェットスタイルを変更する" . "(:ctime 1619741850 :cuser #f :mtime 1619790387 :muser #f)* LTKのウィジェットスタイルを変更\n\n{{{\n;;; LTKのスタイルを設定する\n\n(ql:quickload :ltk)\n\n(defpackage :ltk-style-test\n  (:use :common-lisp :ltk)\n  (:export :main))\n\n(in-package :ltk-style-test)\n\n(defun pack-quit-button ()\n  (pack (make-instance 'button\n                       :text \"Quit\"\n                       :command (lambda ()\n                                  (setf *exit-mainloop* t)))))\n\n(defun theme-names ()\n  (send-wish \"senddatastrings [ttk::style theme names]\")\n  (ltk::read-data))\n\n(defun use-theme (name)\n  (format-wish \"ttk::style theme use ~A\" name))\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"LTK STYLE TEST\")\n    (let ((fradio (make-instance 'frame)))\n      (pack fradio :side :top :fill :x)\n      (pack (mapcar (lambda (name)\n                      (make-instance 'radio-button \n                                     :master fradio\n                                     :text name\n                                     :value name\n                                     :variable (gensym \"radio_button\")\n                                     :command #'use-theme))\n                    (theme-names))\n            :side :left)\n      (pack-quit-button))))\n\n;;; 実行\n(main)\n\n}}}\n")
("サーバ" . "(:ctime 1363856453 :cuser #f :mtime 1363856934 :muser #f)[[$$tag サーバ]]\n- [[Webサーバ]]\n- [[デーモンプロセスでシグナルをハンドリングする]]\n")
(" %Tag:ANSI規定外" . "(1668191540 (\"asdf-installでインストールできるもの\" :ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f))")
(" %Tag:シンボル'[0]" . "(1610730190)")
(" %Tag:文字列'" . "(1656004971)")
("CL-FAD" . "(:ctime 1432468963 :cuser #f :mtime 1432468963 :muser #f)[[$$tag 入出力 ファイル処理 CL-FAD ライブラリ]]\n\n[[CLiki:CL-FAD]] は ディレクトリやパス関連の判定の処理系ごとの違いを吸収して可搬性を向上させるライブラリ\n\n\n{{{\n;; Quicklispでインストール\n(ql:quickload \"cl-fad\")\n\n;; requireですべての関数を読み込む\n(require :cl-fad)\n\n;; ディレクトリの内容一覧を表示\n(cl-fad:list-directory #p\"~/.emacs.d\")\n\n;; パスが存在するかどうか判定\t\n(cl-fad:directory-exists-p \"~/.emacs.d/\")\n;=> p#\"/path/to/.emacs.d/\" ;　存在すればフルパスを返す\n;=> NIL ;　存在しなければnilを返す\n\n;; ファイルが存在するか判定\n(cl-fad:file-exists-p \"~/.emacs.d/\")\n;=> #p\"/path/to/.emacs.d/\" 存在すればフルパスを返す\n;=> NIL ;　存在しなければnilを返す\n\n;; ディレクトリ内のすべてのファイルを再帰的に表示\n(cl-fad:walk-directory \n\t#p\"~/.emacs.d/site-start.d\")\n\n;; ファイルのコピー\n(cl-fad:copy-file \"~/work/hoge.txt\" \"~/work/hoge2.txt\")\n\n;; ディレクトリ、ファイルを削除\n(cl-fad:delete-directory-and-files\n\t#p\"~/.emacs.d/site-start.d\")\n\n}}}\n")
(" %Tag:Webオートメーション" . "(1668164314 (\"Webオートメーション\" :ctime 1231579501 :cuser #f :mtime 1431153441 :muser #f) (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f) (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
(" %Tag:alexandria" . "(1668280097 (\"リストを平坦にする\" :ctime 1302448675 :cuser #f :mtime 1302448825 :muser #f) (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f))")
(" %Tag:split-sequence'nvOpzp" . "(1638416379)")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45) -- /* order by \"as /*" . "(1624124801)")
(" %Tag:url-rewrite'[0]" . "(1665996059)")
(" %Tag:HTML" . "(1667933938 (\"HTML を処理する\" :ctime 1231232078 :cuser #f :mtime 1336654189 :muser #f) (\"HTMLのパース・作成\" :ctime 1329736499 :cuser #f :mtime 1331442034 :muser #f))")
("シンボルの一覧を表示したい" . "(:ctime 1228125924 :cuser #f :mtime 1328609677 :muser #f)CLではシンボルは、見える化いじれる化がされています。~%\n現在のパッケージに含まれているシンボルを確認したいとか、シンボルについてまとめて処理をしたいときなどは [[$$hs do-symbols]]を使います。最も簡単な例として一覧表示の場合を記載します。\n\n{{{\n(do-symbols (sym)\n  (print sym))\n}}}\n\n")
(" %Tag:local-time" . "(1668200122 (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f))")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae' and 1=1-- -" . "(1656001226)")
("切れたリンクを見つける" . "(:ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f)[[$$tag Webオートメーション ライブラリ closure-html drakma puri]]\n\n* 切れたリンクを見つける\n\n[[CLiki:DRAKMA]]のようなウェブクライアントには一通りの機能が揃っていますので、このようなクライアントとページからのリンクの切り出しを組み合わせて実現できるでしょう。\n\n下記の例では、[[CLiki:DRAKMA]]、[[CLiki:closure-html]]、[[CLiki:PURI]]を利用しています。\n{{{\n;; 素朴な実装\n(defun churl (url &optional (out *standard-output*))\n  (format out \"~A:~%\" url)\n  (dolist (u (get-links url))\n    (destructuring-bind (name link) u\n      (declare (ignore name))\n      (unless (search \"mailto:\" link)\n        (let ((stat (http-request-stat\n                     (drakma:http-request (puri:merge-uris link url)\n                                          :method :head\n                                          :force-binary T))))\n          (format out \"~2T~A: ~D~%\" link stat))))))\n\n(defmacro http-request-stat (req)\n  `(nth-value 6 ,req))\n\n(defun get-links (url)\n  (let* ((page (drakma:http-request url))\n         (doc (chtml:parse page (cxml-stp:make-builder)))\n         (ans () ))\n    (stp:do-recursively (a doc)\n      (when (and (typep a 'stp:element)\n                 (equal (stp:local-name a) \"a\"))\n        (push (list (stp:string-value a)\n                    (stp:attribute-value a \"href\"))\n              ans)))\n    ans))\n}}}\n{{{\n;; 実行例\n(churl \"http://www.lisp.org/alu/home\")\n\n;-> http://www.lisp.org/alu/home:\n;     http://www.franz.com/support/tech_corner/using-webactions.html:  OK\n;     http://allegroserve.sourceforge.net: OK\n;     http://www.lispworks.com/products/ilc-goodies.html: OK\n;     http://www.international-lisp-conference.org/2007/:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-contact:  OK\n;     http://www.international-lisp-conference.org/:  OK\n;     http://www.international-lisp-conference.org/:  OK\n;     http://planet.lisp.org: OK\n;     http://wiki.alu.org: Not Found\n;     /alu/~19782bb4773d45b47701c907~/res-research:  OK\n;     /alu/~19782bb4773d45b47701c907~/res-local:  OK\n;     /alu/~19782bb4773d45b47701c907~/res-lisp:  OK\n;     http://www.alu.org/mailman/listinfo:  OK\n;     http://wiki.alu.org/: Not Found\n;     /alu/~19782bb4773d45b47701c907~/conf-all:  OK\n;     /alu/~19782bb4773d45b47701c907~/conf-lugm:  OK\n;     http://www.international-lisp-conference.org/2002/:  OK\n;     http://www.international-lisp-conference.org/2003/index.html:  OK\n;     http://www.international-lisp-conference.org/2005/:  OK\n;     http://www.international-lisp-conference.org/2007/:  OK\n;     http://www.international-lisp-conference.org/2009/:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-contact:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-membership:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-sponsors:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-minutes:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-board:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-history:  OK\n;     http://www.alu.org:  OK\n;=> NIL\n}}}\n\n** 議論\n")
("SBCL:定数の上書きエラーで上書きを選択する" . "(:ctime 1297397660 :cuser #f :mtime 1297397740 :muser #f)SBCLでは、defconstantで定数を再定義する場合、古い値とeqlでない場合、SB-EXT:DEFCONSTANT-UNEQLという継続可能なエラーが発せられます(詳細はマニュアル参照)~%\n下記のようにすることにより、非対話的に再起動し処理を継続し値を上書きすることが可能です。\n{{{\nfoo-constant\n;=> \"foo\"\n\n;; どのようなエラーになるか確認\n(ignore-errors (defconstant foo-constant \"foo\"))\n;=> NIL\n;   #<SB-EXT:DEFCONSTANT-UNEQL {101BF02FD1}>\n\n;; 捕捉して継続\n(handler-bind ((sb-ext:defconstant-uneql #'continue))\n  (defconstant foo-constant \"bar\"))\n\nfoo-constant\n;=> \"bar\"\n}}}\n")
(" %Tag:正規表現'" . "(1592413856)")
(" %Tag:使えないTips" . "(1393853257)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45) -- /* order by 'as /*" . "(1624124609)")
(" %Tag:cl-ppcre" . "(1668147114 (\"CL-PPCRE\" :ctime 1306251958 :cuser #f :mtime 1607226708 :muser #f) (\"正規表現\" :ctime 1236781854 :cuser #f :mtime 1430357064 :muser #f) (\"文字列を分割する\" :ctime 1280337523 :cuser #f :mtime 1349988541 :muser #f) (\"文字列を置換する\" :ctime 1296638328 :cuser #f :mtime 1341729451 :muser #f) (\"文字列を検索する\" :ctime 1313411955 :cuser #f :mtime 1313434559 :muser #f) (\"文字列の中に「hoge」が含まれている場合、その開始位置を知るには\" :ctime 1227690765 :cuser #f :mtime 1313407762 :muser #f) (\"文字列を1文字ずつに分ける\" :ctime 1282412075 :cuser #f :mtime 1313400711 :muser #f) (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1302577221 :muser #f))")
("定義したメソッドを削除するには" . "(:ctime 1238222807 :cuser #f :mtime 1238223605 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n定義したメソッドの総称関数からの削除には、[[$$hs remove-method]]を利用します。\n\n総称関数自体を丸ごと削除する用途には、[[$$hs fmakunbound]]が利用できるでしょう。\n\n{{{\n(defclass foo () ())\n(defclass bar (foo) ())\n\n(defgeneric frob (n))\n(defmethod frob ((x foo)) ;(1)\n  (print :foo-primary))\n(defmethod frob :before ((x foo)) ;(2)\n  (print :foo-before))\n(defmethod frob ((x bar)) ;(3)\n  (print :bar-primary)  \n  (call-next-method))\n(defmethod frob :before ((x bar)) ;(4)\n  (print :bar-before))\n}}}\n\n{{{\n;; 実行\n\n(frob (make-instance 'bar))\n;-> :BAR-BEFORE \n;   :FOO-BEFORE \n;   :BAR-PRIMARY \n;   :FOO-PRIMARY \n;=> :FOO-PRIMARY\n\n; (4)を削除\n(remove-method #'frob (find-method #'frob '(:before) (list (find-class 'bar))))\n(frob (make-instance 'bar))\n\n;-> :FOO-BEFORE \n;   :BAR-PRIMARY \n;   :FOO-PRIMARY \n;=> :FOO-PRIMARY\n\n; (3)を削除\n(remove-method #'frob (find-method #'frob () (list (find-class 'bar))))\n(frob (make-instance 'bar))\n\n;-> :FOO-BEFORE \n;   :FOO-PRIMARY \n;=> :FOO-PRIMARY\n\n; (2)を削除\n(remove-method #'frob (find-method #'frob '(:before) (list (find-class 'foo))))\n(frob (make-instance 'bar))\n;-> :FOO-PRIMARY\n;=> :FOO-PRIMARY\n\n; (1)を削除\n(remove-method #'frob (find-method #'frob () (list (find-class 'foo))))\n(frob (make-instance 'bar))\n;>>> error\n\n}}}\n見てのとおり若干面倒なところもありますので、処理系によっては、undefmethodのようにdefmethodと同じような構文で削除できるユーティリティが定義されていることもあるようです。(CMUCL/Lucid CL等)\n\n*** 他の例\n{{{\n(defgeneric 一期一会 (x))\n(defmethod 一期一会 ((x foo))\n  (remove-method #'一期一会 \n                 (find-method #'一期一会 () (list (find-class 'foo))))\n  (print \"foo:初めまして、さようなら!\"))\n\n(defmethod 一期一会 ((x bar))\n  (print \"bar:初めまして、さようなら!\")\n  (remove-method #'一期一会 \n                 (find-method #'一期一会 () (list (find-class 'bar))))\n  (call-next-method))\n}}}\n\n{{{\n;; 定義後1回目の呼び出し\n(一期一会 (make-instance 'bar))\n;-> \"bar:初めまして、さようなら!\" \n;   \"foo:初めまして、さようなら!\"\n;=> \"foo:初めまして、さようなら!\"\n\n;; 定義後2回目以降の呼び出し\n(一期一会 (make-instance 'bar))\n;>>> error (There is no applicable method for the generic function)\n}}}\n")
(" %Tag:prove?p=Tag:prove" . "(1476570318)")
("シンボルを探す" . "(:ctime 1258733120 :cuser #f :mtime 1328609851 :muser #f)ある文字列を含むシンボル名を探す関数に，[[$$hs apropos]]があります．~%\naproposは標準出力に結果を出力します．リストにして返してほしければ[[$$hs apropos-list]]を用います．~%\n第3引数はオプショナル引数で，探索するパッケージを指定できます．~%\nSBCLは第4引数にexternalシンボルのみを探索するかどうかを指定できるようです．~%\n\n{{{\n(apropos \"gensym\" :cl) \n;-> *GENSYM-COUNTER* (bound)\n    *PRINT-GENSYM* (bound)\n    GENSYM (fbound)\n}}}\n\n他には [[$$hs find-symbol]], [[$$hs find-all-symbols]], [[$$hs do-symbols]], [[$$hs do-all-symbols]]などを用いることができそうです．\n")
(" %Tag:配列' AnD SLeeP(3) #" . "(1624125103)")
("同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい" . "(:ctime 1228012693 :cuser #f :mtime 1228012694 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* 同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい\n\ndefclassの定義で一つのスロットに複数のアクセサを記述することが可能です。\nまた、総称関数を別に定義することでも可能です。\n{{{\n(defclass foo ()\n  ((x :initform 42\n      :accessor foo-accessor\n      :reader foo-reader)))\n\n(defparameter *obj* (make-instance 'foo))\n\n(foo-reader *obj*)\n;=> 42\n(setf (foo-accessor *obj*) 100)\n\n(foo-accessor *obj*)\n;=> 100\n\n(setf (foo-reader *obj*) 200)\n;-> error The function (SETF FOO-READER) is undefined.\n}}}\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 481 #" . "(1624125195)")
("SLIME" . "(:ctime 1229489124 :cuser #f :mtime 1529824240 :muser #f)[[$$tag 開発環境 SLIME]]\n\n- [[SLIME:日本語関係の設定]]\n\n----\n\n* 概説\n\n[http://common-lisp.net/project/slime/ SLIME]（The Superior Lisp Interaction Mode for Emacs）は、[http://ja.wikipedia.org/wiki/Emacs Emacs]のCommon Lisp開発環境です。\n\n- lisp-modeを強化するマイナーモードのslime-mode\n- Emacsのユーザインターフェースを利用したデバッガのSLDB\n- Emacs Lispで書かれたREPL\n- 対話的なオブジェクトインスペクタ\n\nなどが含まれます。\n\n----\n\n[[$$toc]]\n\n----\n\n- [[SLIME:SLDB]]\n- [[SLIME:インスペクタ]]\n- [[SLIME:slime-indentation]]\n\n----\n\n* 動画\n\n紹介動画があります。百聞は一見にしかず、ですから、SLIMEが実際にどういったものか知りたいなら、見てみると良いでしょう。\n\n- [http://common-lisp.net/project/movies/movies/slime.mov slime.mov]（英語）\n- [http://www.unixuser.org/~euske/vnc2swf/slime.html SLIME on Linux]（英語）\n\n----\n\n* インストール\n\n** UNIX系OS\n\nSLIMEをダウンロードします。[http://common-lisp.net/project/slime/ ウェブサイト]から、[http://common-lisp.net/project/slime/snapshots/slime-current.tgz CVSスナップショット]をダウンロードするのが簡単です。\n\n{{{\ncd ~/opt\nwget http://common-lisp.net/project/slime/snapshots/slime-current.tgz\ntar xfz slime-current.tgz\n}}}\n\nCVSで最新のコードをチェックアウトしても構いません。\n\n{{{\ncd ~/opt\ncvs -d :pserver:anonymous:anonymous@common-lisp.net:/project/slime/cvsroot co slime\n}}}\n\n好きな場所に展開、あるいはチェックアウトしてください。頻繁に新しいバージョンに更新するつもりなら、権限の関係上、自分のホームディレクトリの下に置くと良いでしょう。\n\n** Windows\n\nSLIMEをダウンロードして展開し、フォルダごとEmacsのsite-lispフォルダにコピーします。\n\n** Emacsの設定\n\n.emacsに設定を追加します。\n\n{{{\n;; Lisp処理系のコマンド\n(setq inferior-lisp-program \"sbcl\")\n\n;; SLIMEがある場所をEmacsのロードパスに追加\n(add-to-list 'load-path \"~/opt/slime\")\n\n;; SLIMEを実行するときに自動的にロードさせる\n(require 'slime-autoloads)\n\n;; どのcontribパッケージを読み込むかの設定\n(slime-setup)\n}}}\n\n----\n\n* 設定\n\n** 文字コード\n\nSLIMEが処理系と通信するときに使うエンコーディングを、slime-net-coding-systemで設定できます。処理系との間で設定に食い違いがあると、日本語を正しく扱えません。\n\n{{{\n(setq slime-net-coding-system 'utf-8-unix)\n}}}\n\n** SLIMEとSKKとの衝突を回避する設定\n\n特定の場面で、SLIMEとSKKとの間でスペースキーのキーバインドが競合して、SKKでの変換ができなくなります。\n\n{{{\n(defun my-slime-space (n)\n  (interactive \"p\")\n  (if (and (boundp 'skk-henkan-mode) skk-henkan-mode)\n      (skk-insert n)\n      (slime-space n)))\n\n(define-key slime-mode-map \" \" 'my-slime-space)\n}}}\n\n自分の環境(Emacs 23～24 CVS版SLIME)では特に対策しなくても問題なく動作するようです --g000001\n\nllibra(2010/12/05 10:47:34 JST): Emacs 23.2、SKK 14.1.50、SLIME 2010-10-09でもこのkludgeなしで動作するみたいです。以前、漢字変換できなかったときは、SKKのバージョンが古かったので、その後修正があったのかもしれません。\n\nllibra(2010/12/08 22:16:35 JST): 訂正。同環境でlisp-modeのバッファでやっぱりコンフリクトしている模様。\n\n** SLIMEのREPLを特定のパッケージに入った状態で起動する\n\nSLIMEのREPLは、通常、common-lisp-user（cl-user）パッケージに入った状態で起動しますが、slime-connected-hookにフックを仕掛け、slime-repl-set-packageでパッケージを切り替えることで、好きなパッケージに入った状態で起動できます。\n\n{{{\n(add-hook 'slime-connected-hook\n          (lambda ()\n            (slime-repl-set-package \":foo\")))\n}}}\n\n** 起動する処理系を簡単に切り替えられるようにする\n\nSLIMEでは、事前に設定をしておくことで、起動する処理系を簡単に切り替えることができます。\n\n{{{\n(setq slime-lisp-implementations `((sbcl (\"sbcl\"))\n                                   (clisp (\"clisp\"))\n                                   (ecl (\"c:/MinGW/msys/1.0/bin/bash\" \"-c\" \"c:/ecl/ecl.exe\"))))\n}}}\n\nのように設定します。設定後にM-- M-x slimeを実行すると、ミニバッファに、\n\n{{{\nLisp name: \n}}}\n\nと入力を促すプロンプトが表示されます。ここで、先ほど設定したsbclやclispなどを入力すると、その処理系が起動します。なお、補完もできますので、処理系を何という名前で設定したか忘れても心配いりません。\n")
("キーワードを生成したい" . "(:ctime 1227906421 :cuser #f :mtime 1328609558 :muser #f)[[$$tag シンボル]]\n\n* キーワードを生成したい\n\n[[$$hs intern]]で keywordパッケージにインターンしてください。\n\n{{{\n(intern \"FOO\" :keyword)\n;=> :FOO\n}}}\n\n':fooのようなシンボルはkeywordパッケージのシンボルの略記で、'keyword:fooの略記ともみなせますので、keywordパッケージにインターンすることによって作成します。\n{{{\n(intern \":FOO\")\n}}}\nとしても|:FOO|というシンボルが作成されるだけですので注意してください。\n")
(" %Tag:数値?p=Tag?Tag:数値?p=Tag" . "(1467042264)")
(" %Tag:trivial-shell'[0]" . "(1659138846)")
(" %Tag:日付と時刻'[0]" . "(1599051313)")
("大文字と小文字を入れ替える" . "(:ctime 1231317189 :cuser #f :mtime 1263648758 :muser #f)[[$$tag 文字列]]\n\n* 大文字と小文字を入れ替える\n\n標準で大文字と小文字を入れ替える方法はありませんので自作するかライブラリを利用することになるでしょう。\n\n文字列/文字の大文字/小文字変換については、[[$$hs string-upcase]]、[[$$hs char-upcase]]等の仲間が利用できます。\n{{{\n(defun string-invertcase (str)\n  (map 'string (lambda (x y)\n                 (if (eql x y) \n                     (char-downcase x)\n                     y))\n       str\n       (string-upcase str)))\n\n(string-invertcase \"Hi, CLer\")\n;=> \"hI, clER\"\n}}}\n\n大文字小文字の対応については、ASCIIの範囲になります。Schemeの様にASCII以外の範囲(ギリシャ文字等)までは決まっていません。\n")
("ファイルサイズを知る" . "(:ctime 1238425394 :cuser #f :mtime 1238425394 :muser #f)[[$$tag 入出力]]\n\nファイルサイズを得る目的には[[$$hs file-length]]が利用できます。\n\nバイナリファイルでは、指定した:element-typeの大きさを単位とした値が算出されます。\n\n{{{\n$ ls -l\n-rwxr-xr-x   1 0              0          109728  6月 27  2008 /bin/ls\n}}}\n\n{{{\n(with-open-file (s \"/bin/ls\" :element-type '(unsigned-byte 8))\n  (file-length s))\n;=> 109728\n}}}\n")
("コンディションを捕捉する" . "(:ctime 1329736323 :cuser #f :mtime 1635157426 :muser #f)[[$$tag 【募集中】]]\n\n\nコンディションの補足には handler-bind を用います。\n\n\n  (defun parent ()\n    (handler-bind ((error (lambda (c)\n                        ...ハンドリング...)))\n     ;; body\n     (child1)\n     (child2)\n     (child3)))\n\nhandler-bind の body 中でエラーが発生すると、\n発生したエラーコンディションを引数 c として ハンドラ関数 が呼び出されます。\n\nハンドラ関数のうち、コンディションの型が合致しているものだけが呼び出されます。\nそのため、例えば上の child1 が warning を発生した場合、用意されているハンドラが error 用ハンドラだけなのでそれは補足されません。(warningとerrorは別のクラス。)\n\n** ハンドリングをうまく使うには\n\n\nさて、ここからがコンディションシステムと他の言語のエラーハンドリングとの違いです。\n多少、コンディションシステムの仕組みの詳細に踏み込んでいますが、すこし頑張ってください。\n大切なことは、エラーを補足した時点ではまだスタックは巻き戻っていないということです。\nchild2 が error をシグナル(発生)し、parent の handler がこれを補足 (handle) したとしましょう。このとき、コールスタックは以下のようになっています。\n\n\n  parent > child2 > error > (lambda (c) ...ハンドリング...)\n\n\nこのスタックを巻き戻すためには、 go, return-from, throw のうちどれかを用いて (lambda (c) ) の外にコードを移動させる必要があります。この操作を「非局所脱出」と呼びます。\n\n\n例:\n\n{{{\n(tagbody\n   start\n   (handler-bind ((error (lambda (c) (go start)))\n      (child1))\n   finish)\n}}}\n\nこのコードは、child1の中でerrorが発生する限り、強制的にスタックを巻き戻して\nstartからやり直させます。もしchildが常にエラーを発生させる場合、無限ループになります。\n\n\n例2:\n\n{{{\n(block my-block\n   (handler-bind ((error (lambda (c) (return-from my-block 0)))\n      (child1)\n      (return-from my-block 1)))\n}}}\n\nこのコードは、child1 がエラーを投げた場合、スタックを巻き戻して my-block ブロックから値 0 を返します。エラーを投げない場合、1をブロックから返します。\n\nこのような非局所脱出を行わない場合、どうなるでしょうか?\n非局所脱出が行われない場合を、「ハンドラがハンドリングの責務を decline (辞退)した」と呼びます。この場合、ハンドラ関数は ''実行されます'' が、スタックは巻き戻されず、その後同じコンディションがより上位のhandler-bind に渡されます。なお、すべての handler-bind が辞退した場合に備えて、最上位のハンドラがいます。それがデバッガです。\n\n** handler-case\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/m_hand_1.htm handler-case] は、機能を一言で言えば、上の 例2 を簡単に書けるようにしたマクロです。\n私個人としてはあんまり好きではありません。\n\n{{{\n(handler-case (child1)\n  (error (c)\n    ...ハンドラ...))\n}}}\n\nコンディションシステムを、通常のcase文のように使おうという意図があるようです。\nそのため、 :no-error という節を追加することができます。\n\n{{{\n(handler-case (child1)\n  (error (c)\n    ...ハンドラ...)\n  (warning (c)\n    ...ハンドラ...)\n  (:no-error (c)\n    ...ハンドラ...))\n}}}\n\n")
(" %Tag:asdf-install" . "(1667934018 (\"asdf-installでインストールできるもの\" :ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f))")
("Linuxのディストリビューションを判定する" . "(:ctime 1586446374 :cuser #f :mtime 1586447198 :muser #f)[[$$tag os]]\n\nLinuxのディストリビューションごとにリリースバージョンを格納したファイルがそれぞれ固有のファイル名で存在するようですので、これらのファイルを検出することで判定が可能でしょう。\n\n* 定義例\n\n{{{\n(defvar *distro-alist*\n  '((:SuSE\n     \"/etc/SuSE-release\")\n    (:redhat\n     \"/etc/redhat-release\"\n     \"/etc/redhat_version\")\n    (:fedora\n     \"/etc/fedora-release\")\n    (:slackware\n     \"/etc/slackware-release\"\n     \"/etc/slackware-version\")\n    (:debian\n     \"/etc/debian_release\"\n     \"/etc/debian_version\"\n     \"/etc/os-release\")\n    (:mandrake\n     \"/etc/mandrake-release\")\n    (:yellowdog\n     \"/etc/yellowdog-release\")\n    (:gentoo\n     \"/etc/gentoo-release\")))\n\n(defun detect-distro ()\n  (car (or (find-if (lambda (x)\n                      (find-if #'probe-file (cdr x)))\n                    *distro-alist*)\n           '(:unknown))))\n}}}\n\n* 動作\n\n{{{\n(detect-distro)\n;=> :debian\n}}}\n\n* 参考\n- [https://unix.stackexchange.com/questions/35183/how-do-i-identify-which-linux-distro-is-running How do I identify which Linux distro is running?]\n")
("配列を逆順にする" . "(:ctime 1228464721 :cuser #f :mtime 1228464722 :muser #f)[[$$tag 配列]]\n\nベクタを逆順にするには [[$$hs reverse]] 関数を使います。\n\n{{{\n(reverse #(1 2 3 4)) ; => #(4 3 2 1)\n(reverse #()) ; => #()\n}}}\n\n[[$$hs reverse]] には破壊的変更版として [[$$hs nreverse]] もあります。\n\n{{{\n(let ((v (copy-seq #(1 2 3 4))))\n  (setq v (nreverse v)))\n;=> #(4 3 2 1)\n}}}\n[[$$hs nreverse]] は結果の生成の為にベクタを破壊的に変更するのみで、必ずしも元のベクタを逆順にするわけではありませんので、必要な場合には元の変数に値をセットし直す必要があります。\n")
("LISP用語とその由来" . "(:ctime 1258547673 :cuser #f :mtime 1333038909 :muser #f):SETQ:\nSET QUOTE (set (quote x))の慣用句が結合したもの\n\n:SETF:\nSET FIELD\n\n:SEXPR,S-exp,SEXP:\nSymbolic EXPRession\n\n:CAR:\nContents of the Address part of the Register\n\n:CDR:\nContents of the Decrement part of the Register\n\n:PRINC:\nPRINt Characters~%\n[http://groups.google.co.jp/group/comp.lang.lisp/browse_frm/thread/5addd533ea72207a/3d01f02a08dc0d5e?hl=ja&q=prin1+princ#3d01f02a08dc0d5e 参照:comp.lang.lisp: The history of print, prin1, and princ?]\n:PRIN1:\n:TERPRI:\nTERminate PRInt (LISP 1 Programmer's Manual)\n:PROG:\nPROGram feature\n:PROG1:\n\n:SUBR:\nSUBRoutine\n:FSUBR:\nForm SUBRoutine ???\n:LSUBR:\nList SUBRoutine ???\n\n:EXPR:\nEXPRession\n:FEXPR:\nForm EXPRession ???\n\n:SUBLIS:\nSUBstitute LISt ???\n\n:MAPCAR:\nLISP 1.5でのmapは、現在のCommon Lispでいう[[$$hs maplist]]であり、その動作とcarを組合せるとmapcarになるので、これに由来 ???\n\n:MAPCON:\nMAP + nCONC ???\n\n:MAPCAN:\nMAPCAr + Nconc ???\n\n:NCONC:\nNo consing CONCatenate ???\n\n:REVAPPEND:\nREVerse APPEND\n\n:NRECONC:\nNo consing REverse CONCatenate ???\n\n:FASL:\nFASt Loading\n")
("文字列を結合する" . "(:ctime 1227347577 :cuser #f :mtime 1399135818 :muser #f)[[$$tag 文字列 シーケンス]]\n\n** 複数の文字列を結合する\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string 文字列]は[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#sequence シーケンス]なので[[$$hs concatenate]]で結合できます。また、[[$$hs format]]で文字列に出力しても良いでしょう。\n\n{{{\n;; concatenateはシーケンスをつなげることができる\n(concatenate 'string \"foo\" \"bar\")       ;=> \"foobar\"\n\n;; formatの文字列に出力する機能を利用する\n(format nil \"~A~A\" \"foo\" \"bar\")         ;=> \"foobar\"\n}}}\n\nconcatenateもformatも、もとの文字列は変更しません。\n\n{{{\n;; concatenateを評価してもs1とs2には影響はない\n(let ((s1 \"foo\")\n      (s2 \"bar\"))\n  (list (concatenate 'string s1 s2) s1 s2))\n;=> (\"foobar\" \"foo\" \"bar\")\n}}}\n\n[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_stream 文字列ストリーム]を使うこともできます。\n\n{{{\n;; with-output-to-stringはストリームに出力した内容を文字列にして返す\n(with-output-to-string (out)\n  (format out \"foo\")\n  (format out \"bar\"))\n;=> \"foobar\"\n}}}\n\n** 文字列のリストを結合する\n文字列のリストを結合するときはformatを使うと便利です。\n\n{{{\n;; formatでリストの要素を繰り返し処理する\n(format nil \"~{~A~}\" '(\"foo\" \"bar\"))\n;=> \"foobar\"\n}}}\n\nconcatenateに[[$$hs apply]]を使う方法もあります。\n{{{\n;; applyの引数は柔軟に書ける\n(apply #'concatenate 'string '(\"foo\" \"bar\"))\n;=> \"foobar\"\n}}}\n\n文字列ストリームを使うとより柔軟に結合できます。\n\n{{{\n;; ストリームに出力していけばいいので単純で自由度が高い\n(with-output-to-string (s)\n  (dolist (e '(\"foo\" \"bar\"))\n    (princ e s)))\n;=> \"foobar\"\n}}}\n\n途中で一時的な文字列を作るため効率は良くありませんが、[[$$hs reduce]]でつなげていくこともできます。\n\n{{{\n;; reduceで畳み込む\n(reduce (lambda (r x) (concatenate 'string r x))\n        '(\"foo\" \"bar\"))\n;=> \"foobar\"\n}}}\n")
("外部からの入力バイト列を文字列にしたい(文字コード変換含む)" . "(:ctime 1229261302 :cuser #f :mtime 1236779813 :muser #f)[[$$tag 入出力 日本語 jp FIXME]]\n\n*  外部からの入力バイト列を文字列にしたい(文字コード変換含む)\n\nWebページを取得しページを加工することを考えてみます。\nCLでは処理系依存で文字コードを指定し扱う方法がそれぞれありますが、Webページ取得の場合にはエンコードを決め打ちにしてしまうと、指定したエンコードのページしか正しく処理できないことになってしまいます。これでは、現在の日本のようにエンコードが複数使われている状況では不便です。\n\n下記の例では[http://lispuser.net/ onjo氏]作のjpパッケージを利用し、文字エンコーディングを自動判別してバイト列を文字列に変換しています。\n\njpパッケージの詳細については[http://lispuser.net/commonlisp/japanese.html Common Lisp と 日本語 と 文字コード]を参照して下さい\n{{{\n(let ((vec (drakma:http-request \"http://tips.lisp-users.org/common-lisp/\" :force-binary T)))\n  (jp:decode vec :guess))\n;=> \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\n;       \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\n; <html><head><title>逆引きCommonLisp</title\n; ... \"\n}}}\n\n----\n- '''decode''' ''vector external-format'' &key ''(start 0) end''\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 1 #" . "(1624125114)")
(" %Tag:mudballs" . "(1667934140 (\"mudballsを使う\" :ctime 1229134338 :cuser #f :mtime 1335997943 :muser #f))")
(" %Tag:flexi-streams'[0]" . "(1612614873)")
("リストを作成する" . "(:ctime 1229551584 :cuser #f :mtime 1229551944 :muser #f)[[$$tag リスト]]\n\n{{{\n;; 0から10までの数値のリストを作成する。\n(loop for i to 10 collect i)\n;=> (0 1 2 3 4 5 6 7 8 9 10)\n}}}\n\n{{{\n;; 乱数を10個生成してリストを作成する。\n(loop repeat 10 collect (random 100))\n;=> (29 4 98 52 16 48 74 72 39 82) ; 評価のたびに異なります。\n}}}\n")
(" %Tag:Weblocks" . "(1667839842)")
("制御構造" . "(:ctime 1227174305 :cuser #f :mtime 1458560623 :muser #f)[[$$tag 制御構造]]\n\n* 条件判断・分岐\n- [[条件判断(if スペシャルフォーム)]]\n- [[条件判断(cond マクロ)]]\n- [[条件判断(case)]]\n\n* 繰り返し処理\n- [[loop]]\n- [[loop:指定値までの繰り返し]]\n- [[loop:リストを回しつつ、要素の数え上げもする]]\n- [[繰り返し(do)]]\n- [[繰り返し(while)]]\n- [[指定回数の繰り返し]]\n- [[指定値までの指定ステップ毎に繰り返し]]\n- [[繰り返しからの脱出]]\n\n* 処理の中断・分岐\n- [[ブロックからの脱出]]\n- [[繰り返しからの脱出]]\n- [[繰り返しの前処理・後処理]]\n- [[確実に後処理を行なう]]\n- [[goto文]]\n\n* 代入\n- [[代入(setf)]]\n- [[リスト構造を分解して変数に代入する]]\n- [[多値を変数に代入する]]\n- [[一時変数を使わずに値を交換する]]\n\n\n* その他\n- [[有意な値を返さない]]\n- [[値を真偽値に変換したい]]\n- [[null合体演算子]]\n- [[ジェネレータ]]\n")
("ハッシュの要素をランダムに抽出する" . "(:ctime 1227413899 :cuser #f :mtime 1630548071 :muser #f)[[$$tag ハッシュ 【募集中】]]\n* ハッシュの要素をランダムに抽出する\nCommon Lispのハッシュテーブルは順番付きハッシュテーブルではありません。値に無頓着に何か要素が一つ欲しいということであれば、[[$$hs with-hash-table-iterator]]等で先頭の一つを取り出せば良いでしょう。~%\n要素の中から都度ランダムに取り出したいということならば、下記の様になるでしょう。\n{{{\n(defun hash-table-choice (hash-table)\n  (block nil\n    (let ((pos (random (hash-table-count hash-table)))\n          (cnt 0))\n      (maphash (lambda (k v)\n                 (when (= pos cnt) (return (values k v)))\n                 (incf cnt))\n               hash-table))))\n}}}\n{{{\n;; loopで\n(defun hash-table-choice (hash-table)\n  (loop :with pos := (random (hash-table-count hash-table))\n        :for k :being :each :hash-keys :using (:hash-value v) :of hash-table\n        :for idx :from 0\n        :when (= idx pos) :return (values k v)))\n\n}}}\n実行\n{{{\n(hash-table-choice \n (alexandria:alist-hash-table (pairlis '(1 2 3 4 5) '(a b c d e))))\n;=>  5\n;    E\n}}}\n")
("Ltk:複数行テキストを表示する" . "(:ctime 1619742194 :cuser #f :mtime 1619744757 :muser #f)* 複数行テキスト\n\n{{{\n;;; LTKで複数行テキスト表示\n\n(ql:quickload :ltk)\n\n\n;; パッケージの作成\n(defpackage :ex4-17\n  (:use :common-lisp\n        :ltk)\n  (:export :main))\n\n(in-package :ex4-17)\n\n(defun main ()\n  (with-ltk ()\n    (wm-title *tk* \"複数行テキスト表示(message)\")\n    (minsize *tk* 600 500)\n\n    (let* ((msg (make-instance\n                 'message\n                 :text \"ああああああああああああああああああああああ日本語日本語日本語日本語感じaaaaaaaaaaaabbbbbbbbbcdefgいいいいいいいいいいいいいいいいいいいいいいいううううううううううううううううううええええええええええええええええええええおおおおおおおおおおおおおおおおおおおおっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっ\"\n                 :width 1000\n                 :background \"#FFFFFF\"))\n\n\n           (b1 (make-instance\n                'button\n                :text \"Close\"\n                :command (lambda ()\n                           (format t \"終了\")\n                           (setf *exit-mainloop* t)))))\n\n      (pack msg\n            :side :top\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n      (pack b1\n            :side :bottom\n            :fill :x) ; fillを指定すると、Wiindowのハシをドラッグして伸ばしてもボタンが大きくなる。\n\n      (configure msg\n                 :anchor :w\n                 )\n\n      )))\n\n(main)\n}}}\n")
("一定の値を返す関数を得る" . "(:ctime 1229257495 :cuser #f :mtime 1229257495 :muser #f)[[$$tag 関数]]\n\n* 一定の値を返す関数を得る\n\n[[$$hs constantly]] は引数に与えられた値を返す関数を作成して返します。関数を引数に取るものと組み合わせて使用することが多いでしょう。\n{{{\n(mapcar (constantly 1) '(a b c d e f))\n;=> (1 1 1 1 1 1)\n\n(defun my-length (list)\n  (apply #'+ (mapcar (constantly 1) list)))\n\n(my-length '(1 2 3 4 5))\n;=> 5\n}}}\n")
("スレッドに引数を渡す" . "(:ctime 1229082548 :cuser #f :mtime 1229092264 :muser #f)[[$$tag スレッド ライブラリ portable-threads bordeaux-threads]]\n\n* スレッドに引数を渡す\n\n** portable-threadsでの例\n\n引数を渡してスレッドを生成するには spawn-thread の第3引数に渡します。\n\n{{{\n(defpackage :thread-test\n  (:use :cl :portable-threads))\n(in-package :thread-test)\n\n(flet ((spawn-test (mesg)\n         (let ((*standard-output* \n                #.*standard-output*)) ;printの出力を一箇所に纏めるため\n           (print \"Start thread\")\n           (print mesg)\n           (sleep 3)\n           (print \"End thread\"))))\n  (print \"Test start\")\n  (print \"Create thread\")\n  (let ((th (spawn-thread \"foo\" #'spawn-test \"こんにちは!!!\")))\n    (loop :while (thread-alive-p th) \n          :do (sleep 0.005)) ;wait FIXME joinとかないのだろうか。\n    (print \"Test compleated\")))\n;-> \"Test start\" \n    \"Create thread\" \n    \"Start thread\" \n    \"こんにちは!!!\" \n    \"End thread\" \n    \"Test compleated\" \n;=> \"Test compleated\" \n}}}\n** bordeaux-threadsでの例\n")
("三角関数を計算する" . "(:ctime 1302500063 :cuser #f :mtime 1364079086 :muser #f)[[$$tag 数値]]\n\n三角関数を計算するには、[[$$hs sin]]、[[$$hs cos]]、[[$$hs tan]] を使います。それぞれ 角度 θを与えることで 正弦(サイン/sine)・余弦(コサイン/cosine)・正接(タンジェント/tangent) を返します。角度はラジアンで指定することに注意してください。\n\n{{{\n;; sin 0度\n(sin 0)\n; => 0.0\n\n;; sin 90度\n(sin (/ pi 2))\n; => 1.0D0\n\n;; cos 0度\n(cos 0)\n; => 1.0\n\n;; cos 180度\n(cos pi)\n; => -1.0D0\n\n;; tan 0度\n(tan 0)\n; => 0.0\n\n;; sin 180度(Win32 CCL Ver 1.6にて)\n(sin pi)\n; => 1.2246063538223773D-16\n}}}\n\n最後の sin180度の値を見るとわかりますが、PIの精度に限度があるため僅かな誤差が出る場合もあります。\n")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45) -- /* order by \"as /*" . "(1624124937)")
("Common LispのマクロとCのマクロの違い" . "(:ctime 1551867620 :cuser #f :mtime 1551868871 :muser #f)* 実現方法の違い\n\n:C:基本的に文字列(トークン)の置換\n:Common Lisp: 構文操作(リスト操作) 。~%\n構文の文脈(レキシカル変数等)も操作可能(&environment等を利用する)。~%\nなお、構文操作の枠組みで文字列置換でマクロ展開することも可能(マクロ展開の仕組みの中で文字列操作すれば良い)\n\n* 処理フェイズの違い\n\n:C:プリプロセッサによる置換処理\n:Common Lisp:基本的にコンパイル前のマクロ展開が利用されるが、[[$$hs eval]]実行時に展開することも可能\n\n* 参考文献\n- D-Expressions:  Lisp Power, Dylan Style\n-- https://people.csail.mit.edu/jrb/Projects/dexprs.pdf\n")
(" %Tag:usocket" . "(1668273375 (\"簡単なDNSルックアップ\" :ctime 1230782977 :cuser #f :mtime 1230783022 :muser #f))")
(" %Tag:???? and 1=1" . "(1587484316)")
("非破壊版、破壊版 関数対応表" . "(:ctime 1303380120 :cuser #f :mtime 1411985294 :muser #f)[[$$tag 【募集中】]]\n* 非破壊版、破壊版 関数対応表\n\n引数の一部を処理中に変更する、所謂 \"破壊的な関数\"があります。これらの多くは引数を破壊しないバージョンも存在します。以下はその 破壊的な関数と 非破壊的な関数の対応表です。\n\n*** append x nconc系\n|| 非破壊関数 || 破壊関数 ||\n|| [[$$hs append]] || [[$$hs nconc]] ||\n|| [[$$hs revappend]] || [[$$hs nreconc]] ||\n\n*** foo x nfoo系\n|| 非破壊関数 || 破壊関数 ||\n|| [[$$hs butlast]] || [[$$hs nbutlast]] ||\n|| [[$$hs intersection]] || [[$$hs nintersection]] ||\n|| [[$$hs reverse]] || [[$$hs nreverse]] ||\n|| [[$$hs set-difference]] || [[$$hs nset-difference]] ||\n|| [[$$hs set-exclusive-or]] || [[$$hs nset-exclusive-or]] ||\n|| [[$$hs string-capitalize]] || [[$$hs nstring-capitalize]] ||\n|| [[$$hs string-downcase]] || [[$$hs nstring-downcase]] ||\n|| [[$$hs string-upcase]] || [[$$hs nstring-upcase]] ||\n|| [[$$hs sublis]] || [[$$hs nsublis]] ||\n|| [[$$hs subst]] || [[$$hs nsubst]] ||\n|| [[$$hs subst-if]] || [[$$hs nsubst-if]] ||\n|| [[$$hs subst-if-not]] || [[$$hs nsubst-if-not]] ||\n|| [[$$hs substitute]] || [[$$hs nsubstitute]] ||\n|| [[$$hs substitute-if]] || [[$$hs nsubstitute-if]] ||\n|| [[$$hs substitute-if-not]] || [[$$hs nsubstitute-if-not]] ||\n|| [[$$hs union]] || [[$$hs nunion]] ||\n\n*** remove x delete系\n|| 非破壊関数 || 破壊関数 ||\n|| [[$$hs remove]] || [[$$hs delete]] ||\n|| [[$$hs remove-duplicates]] || [[$$hs delete-duplicates]] ||\n|| [[$$hs remove-if]] || [[$$hs delete-if]] ||\n|| [[$$hs remove-if-not]] || [[$$hs delete-if-not]] ||\n\n*** ありそうでない系\n|| 非破壊関数 || 破壊関数 ||\n|| なし || [[$$hs sort]] ||\n|| なし || [[$$hs merge]] ||\n|| なし || [[$$hs remf]] ||\n|| [[$$hs ldiff]] || なし ||\n\n*** 対応してるといえば対応してる、してないといえばしてない系\n|| 非破壊関数 || 破壊関数 ||\n|| [[$$hs cons]] || [[$$hs push]] ||\n|| [[$$hs car]] or [[$$hs cdr]] || [[$$hs pop]] ||\n|| [[$$hs mapcar]] or [[$$hs map]] || [[$$hs map-into]] ||\n|| [[$$hs adjoin]] || [[$$hs pushnew]] ||\n|| [[$$hs subseq]] || [[$$hs replace]] or (setf [[$$hs subseq]])||\n|| [[$$hs substitute-if]] item (constantly t) ||[[$$hs fill]] ||\n\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae) and 1=2-- -" . "(1656001235)")
(" %Tag:jp'[0]" . "(1664487348)")
("リストから指定条件を満たす要素を取り除く" . "(:ctime 1228980905 :cuser #f :mtime 1229557393 :muser #f)[[$$tag リスト]]\n\n[[$$hs remove-if]] [[$$hs delete-if]] は第1引数に与えられた関数が真(非nil)値を返した要素を除外したリストを返します。\n{{{\n(let ((a (list 30 100 50 80 79 40 95)))\n  (list (remove-if (lambda (x) (< x 80)) a)\n        a))\n;=> ((100 80 95) (30 100 50 80 79 40 95))\n}}}\n{{{\n(let ((a (list 30 100 50 80 79 40 95)))\n  (list (delete-if (lambda (x) (< x 80)) a)\n        a))\n;=> ((100 80 95) \n     (30 100 80 95)) ;処理系依存\n}}}\n[[$$hs delete-if]] は破壊的に与えられたリストを変更し結果を生成しますが、元のリストが結果と一致するとは限りません(処理系依存)ので確実にしたい場合は、再度代入する必要があります。\n{{{\n(let ((a (list 30 100 50 80 79 40 95)))\n  (setq a (delete-if (lambda (x) (< x 80)) a)))\n;=> (100 80 95)\n}}}\n\n[[$$hs loop]] でも書けます。結果のリストは新しく生成されたものです。\n{{{\n(loop for x in (list 30 100 50 80 79 40 95)\n      unless (< x 80) collect x)\n;=> (100 80 95)\n\n;; 条件を満たすものとそうでないものに分割。\n(loop for x in (list 30 100 50 80 79 40 95)\n      unless (< x 80) collect x into i\n      else collect x into j\n      finally (return (list i j)))\n;=> ((100 80 95) (30 50 79 40))\n}}}\n")
("関数" . "(:ctime 1228173344 :cuser #f :mtime 1599528850 :muser #f)[[$$tag 関数]]\n\n- [[一定の値を返す関数を得る]]\n- [[状態を持った手続きを作る]]\n- [[引数のリストに関数を適用する]]\n- [[QUOTEとFUNCTIONを使い分ける]]\n- [[SETF関数を取り出す]]\n- [[&optionalや&keyで引数が指定されて呼び出されたか調べる]]\n- [[関数が定義されているか調べる]]\n- [[キーワード引数を使って大域変数を束縛する]]\n- [[非破壊版、破壊版 関数対応表]]\n- [[無名関数をなんらかの方法で選別したい]]\n- [[関数に別名をつけたい]]\n- [[引数リスト情報の表示を変更したい]]\n- [[仮引数で宣言されていないキーワードを渡す]]\n")
(" %Tag:drakma?Tag?Tag?Tag?Tag:drakma?Tag?Tag?Tag" . "(1476570374)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45) -- /* order by 'as /*" . "(1624124598)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45) -- /* order by 'as /*" . "(1624124508)")
(" %Tag:【募集中】/admin/view/javascript/common.js" . "(1585999583)")
(" %Tag:パスネーム" . "(1668224389 (\"処理系を起動したディレクトリのパスネームを返す\" :ctime 1227447346 :cuser #f :mtime 1579751086 :muser #f))")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45) -- /* order by \"as /*" . "(1624124858)")
(" %Tag:リーダーマクロ" . "(1668287556 (\"リードテーブルを標準の状態に復元する方法\" :ctime 1229195021 :cuser #f :mtime 1229195129 :muser #f))")
("QUOTEとFUNCTIONを使い分ける:もう少し詳しい説明" . "(:ctime 1230180273 :cuser #f :mtime 1342951207 :muser #f)* QUOTEとFUNCTIONを使い分ける:もう少し詳しい説明\n\nQUOTEとFUNCTIONについてもう少し踏み込んだ説明をすると、\n\n- FUNCTION特殊形式はシンボルに関係付けられた関数オブジェクトを返す\n- QUOTE特殊形式はシンボルそのものを返す\n\nという違いです。したがって、(apply #'foo ...) ではapplyが受け取るのは「関数オブジェクト」であるのに対し、(apply 'foo ...) では単なるシンボルです。\n単なるシンボルを渡された場合に、symbol-functionで大域関数を取り出す、という操作はapplyやfuncallがやってくれる仕事です。~%\n関数を取り出す動作がひと手間増えるため#'fooの方が若干速くなることもありますが、大抵の場合、(funcall 'foo)と、(funcall #'foo)に違いはないでしょう。\n\n** 挙動に違いがでる場合\n- [[$$hs function]]でないとローカル関数は呼べない\n\n{{{\n(labels ((foo () :hello))\n  (funcall 'foo))\n;>>> エラー\n\n\n(labels ((foo () :hello))\n  (funcall #'foo))\n;=>  :HELLO\n}}}\nローカル関数は、[[$$hs function]]でないと参照することはできず、クォートでは大域関数を呼ぶことしかできません\n\n- 変数に保存した場合\n\n#'foo という形式では、関数オブジェクトを取り出しますので、変数に保存すれば、その時点の関数が保存されます。関数オブジェクトは、名前とは関連づけられていませんので、同名で再定義しても影響はありません。~%\n一方 'fooは単なる名前ですので、呼び出し時点の関数を引いてくることになり、過去の状態を保存することはできません\n{{{\n(defun xyzzy () (princ \"1\"))\n;=>  XYZZY\n\n\n(defvar *f1* #'xyzzy)\n;=>  *F1*\n\n\n(defvar *q1* 'xyzzy)\n;=>  *Q1*\n\n\n;;; 再定義\n(defun xyzzy () (princ \"2\"))\n;=>  XYZZY\n\n\n(defvar *f2* #'xyzzy)\n;=>  *F2*\n\n\n(defvar *q2* 'xyzzy)\n;=>  *Q2*\n}}}\n{{{\n(funcall *f1*)\n;->  1\n;=>  \"1\"\n\n\n(funcall *q1*)\n;->  2\n;=>  \"2\"\n\n\n(funcall *f2*)\n;->  2\n;=>  \"2\"\n\n\n(funcall *q2*)\n;->  2\n;=>  \"2\"\n}}}\n\n- 関数をインライン化し、それを[[$$hs function]]で呼んだ場合(処理系依存)\n\n{{{\n(declaim (inline fn))\n(defun fn (x) :hello)\n\n\n(defun test-quote ()\n  (mapcar 'fn (make-list 5)))\n\n\n(defun test-function ()\n  (mapcar #'fn (make-list 5)))\n\n\n(test-quote)\n;=>  (:HELLO :HELLO :HELLO :HELLO :HELLO)\n\n(test-function)\n;=>  (:HELLO :HELLO :HELLO :HELLO :HELLO)\n\n(defun fn (x) :goodbye)\n\n(test-quote)\n;=>  (:GOODBYE :GOODBYE :GOODBYE :GOODBYE :GOODBYE)\n\n(test-function)\n;=>  (:HELLO :HELLO :HELLO :HELLO :HELLO)\n}}}\n※インライン化は、処理系によりされる場合とされない場合がありますので、この動作は、処理系依存になります~%\n[[$$hs function]]を利用して記述した場合、関数であることは確実ですので、コンパイル時にインライン展開されます。~%\nこのため、fnの再定義されても、test-functionが再度コンパイルされfnのインライン展開がされないと元の定義が埋め込まれたままになります。\n\n\n")
("有意な値を返さない" . "(:ctime 1232958366 :cuser #f :mtime 1233045023 :muser #f)[[$$tag 制御構造]]\n\n有意な値を返さないことを示すイディオムとしては、[[$$hs values]]を利用するものがあり、\n{{{\n(values)\n}}}\nのように書かれます。\nこれは、0個の多値を返すことを示します。\n{{{\n(defun hello ()\n  (format t \"こんにちは!!~%\")\n  (values))\n\n(hello)\n;-> こんにちは!!\n;=> No values\n}}}\n\n** 参考\n0個の返り値は、フォームの用いられる場所によっては値がnilとして扱われます。\n{{{\n(if (values) \"はい\" \"いいえ\")\n;=> \"いいえ\"\n\n(or (values) (values) (values))\n;=> No values\n(or (values) (values) (values 1))\n;=> 1\n}}}\n\n** 議論\n\n- 「0個の返り値は〜nilとして扱われます」というのは、単に\n「期待されている値より少ない値が返ってきた場合、足りない値はnilとして扱う」\nという一般的なルールの1インスタンスにすぎないのでは。\n\n- \n{{{\n(multiple-value-bind (a b c d e) (values 1)\n  (list a b c d e))\n;=> (1 NIL NIL NIL NIL)\n\n(multiple-value-bind (a b c d e) (values)\n  (list a b c d e))\n;=> (NIL NIL NIL NIL NIL)\n}}}\nというところですね。\n確かにその方が統一的で綺麗ですし、「0個の返り値は〜nilとして扱われます」と書いたのは曖昧な含みがあるかと思いました。\nただ、[http://www.lispworks.com/documentation/HyperSpec/Body/03_ag.htm 3.1.7 Return Values]を参照すると0個の多値の扱われ方については親切に解説しているのですが、「期待されている値より少ない値が返ってきた場合、足りない値はnilとして扱う」という取り決めからの帰結かどうかは確認できなかったので、インスタンス的な解説個所をそのまま引いて来た感じになりました。自分の解釈では、「受取側は必ず1つ以上の返り値を期待していて、0個の場合はnilになる」のかなと思えました。\n{{{\n(values (values))\n;=> NIL\n}}}\n等。また、[[$$hs multiple-value-bind]]等でも、足りない場合にどうするかはインスタンスの事例的に書かれているように思われました。\n個人的には、「期待されている値より少ない値が返ってきた場合、足りない値はnilとして扱う」の記述がどこかにあっても良いような気がしますし、確認できたら記載したいと思います。 \nどちらかというと、「(values)は有意な値を返さないイディオムなんですが、(values)自体はNILとして扱われてしまいますよー」ということが記述の意図だったのですが、追及すると深いので曖昧にしてしまいました。\nまた、関連してですが、CLとSchemeでの未定義値的な扱いの違いについて別項目を立てるのも有意義かなと思いました(CLでは実際のところNILになってしまいますが…) --g000001\n\n")
("slimv" . "(:ctime 1329736668 :cuser #f :mtime 1329736668 :muser #f)[[$$tag 【募集中】]]\n")
(" %Tag:参考文献" . "(1668189709 (\"Tutorial on Good Lisp Programming Style\" :ctime 1227969021 :cuser #f :mtime 1431247962 :muser #f) (\"COMMON LISP 第2版\" :ctime 1227971790 :cuser #f :mtime 1228812722 :muser #f) (\"Common Lisp の スコープ と エクステント\" :ctime 1228170031 :cuser #f :mtime 1228170119 :muser #f) (\"新規ページ作成の手順\" :ctime 1227422988 :cuser #f :mtime 1228111845 :muser #f))")
("ライブラリ:Metatilities" . "(:ctime 1227244104 :cuser #f :mtime 1227244126 :muser #f)[[$$toc]]\nGary King氏によるCLのユーティリティ集\nhttp://common-lisp.net/project/metatilities/\n")
(" %Tag:最適化" . "(1668097368 (\"最適化\" :ctime 1228170916 :cuser #f :mtime 1529824649 :muser #f) (\"最適化指針\" :ctime 1529823480 :cuser #f :mtime 1529823481 :muser #f) (\"末尾呼び出しの最適化\" :ctime 1228171120 :cuser #f :mtime 1228812122 :muser #f))")
(" %Tag:正規表現'A=0" . "(1598601927)")
("Webオートメーション" . "(:ctime 1231579501 :cuser #f :mtime 1431153441 :muser #f)[[$$tag Webオートメーション]]\n\n* Webオートメーション\n\n- [[特定のURLからドキュメントを抽出する]]\n- [[特定のURLからファイルをダウンロードする]]\n- [[URIエンコード]]\n- [[MIMEのパース・作成]]\n- [[HTML を処理する]]\n- [[HTMLのパース・作成]]\n- [[文字列を Base64 エンコードする]]\n- [[切れたリンクを見つける]]\n- [[ページの最終更新日を調べる]]\n- [[JSONのパース・生成]]\n")
(" %Tag:ドキュメント" . "(1668226141 (\"ドキュメンテーション\" :ctime 1229516095 :cuser #f :mtime 1229517828 :muser #f))")
(" %Tag:配列1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45),CHAR(45,120,50,53,45,81,45) -- /* order by \"as /*" . "(1624125059)")
(" %Tag:開発環境'[0]" . "(1652233887)")
(" %Tag:eli" . "(1667934087 (\"複数 Listener を使う\" :ctime 1252504504 :cuser #f :mtime 1252507229 :muser #f) (\"ELI\" :ctime 1252164417 :cuser #f :mtime 1252324712 :muser #f) (\"基本的構成を確立する\" :ctime 1252242002 :cuser #f :mtime 1252324555 :muser #f))")
(" %Tag:????\" or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- \"x\"=\"x" . "(1587484329)")
(" %Tag:cl-interpol" . "(1668279257 (\"複数行の文字列を作成する\" :ctime 1227347816 :cuser #f :mtime 1313402031 :muser #f))")
("タイマーとスケジューリング" . "(:ctime 1458229030 :cuser #f :mtime 1458229030 :muser #f)[[$$tag cl-cron]]\n\n* タイマー処理\n[[$$tag 【募集中】]]\n\n* スケジュール処理 : cl-cron\nLinux におけるスケジューラ cron のような動作を Common Lisp 環境上で実現できます。cronを使用しているわけではないため、Windows, MacOS でも使用可能です。\n\n１日毎、１か月毎、１年毎といった長期間にわたる定期処理を実行することができます。\n\n５分毎であれば\n{{{\n(cron:start-cron)\n(cron:make-cron-job #'(lambda () (format t \"Print this each 5 minutes\")) :step-min 5)\n}}}\n\n１年ごとは少し特殊ですが１２か月ごとの処理として実現できそうです。\n{{{\n(cron:start-cron)\n(cron:make-cron-job #'(lambda () (format t \"Print this each year\")) :step-month 12)\n}}}\n\ncl-cron のスケジュール処理を終了するには, stop-cron 関数を使用します\n{{{\n(cron:stop-cron)\n}}}\n\n\n'''参考'''\n- [http://quickdocs.org/cl-cron/api Quickdocs]\n- [http://g000001.cddddr.org/3622892400 cl-cronとはなにか]\n\n")
("リストに対するand/or" . "(:ctime 1507662958 :cuser #f :mtime 1507662958 :muser #f)[[$$tag リスト]]\n\n[[$$hs and]] マクロや [[$$hs or]] マクロは引数の一部を評価した段階で値が確定する場合、それ以降の引数の評価を打ち切ります。例えば [[$$hs and]] マクロで最初の引数が偽だった場合、それ以降の引数の値に関わらず結果は偽となるので、そこで評価が打ち切られます。\n\n{{{\n;; 第二引数以降は評価されない。\n(and nil nil t)\n}}}\n\n[[$$hs and]] / [[$$hs or]] はマクロであるので、 [[$$hs apply]] を使ってリストに対して適用することはできません。\n\n{{{\n;; エラー\n(apply #'and '(nil nil t))\n}}}\n\nリストなどのシーケンスに対する and / or を取るには、 [[$$hs every]]、[[$$hs some]]、[[$$hs notevery]]、[[$$hs notany]] などを使う方法があります。\n{{{\n; (or nil nil t) に相当\n(some #'identity '(nil nil t))  \n(notevery #'null '(nil nil t))\n\n; (and nil nil t) に相当\n(every #'identity '(nil nil t))\n(notany #'null '(nil nil t))\n}}}\nただし、マクロ版と違い、すべての引数が評価されてしまうことに注意が必要です。\n")
("一時的にリードテーブルを変更して読み込む" . "(:ctime 1229846380 :cuser #f :mtime 1229846380 :muser #f)[[$$tag マクロ FIXME]]\n\n* 一時的にリードテーブルを変更して読み込む\n\n一時的にリードテーブルを変更するには様々は方法が考えられますが、何がリード時に作用するのかを良く考える必要があるでしょう。\n下記の例では、一時的に!をquoteに定義してみています。\n{{{\n(let ((*readtable* (copy-readtable))) ;引数を省略するとカレントのものが渡る\n  (set-syntax-from-char #\\! #\\')\n  (eval (read-from-string \"!(foo bar baz)\")))\n;=> (FOO BAR BAZ)\n}}}\nその他の例\n{{{\n(progn\n  #.(defparameter *rt* *readtable*) ;リード時に作用\n  #.(set-syntax-from-char #\\! #\\')  ;リード時に作用\n\n  (prog1 !(foo bar baz)\n         #.(setq *readtable* (copy-readtable *rt*)))) ;リード時に作用\n;=> (FOO BAR BAZ)\n}}}\n\n")
(" %Tag:?????\" and \"x\"=\"y" . "(1584214739)")
(" %Tag:配列1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45) --  /*" . "(1624124420)")
(" %Tag:【募集中】/wp-includes/js/jquery/jquery.js" . "(1585999572)")
(" %Tag:MOP'[0]" . "(1592742044)")
("処理系を起動したディレクトリのパスネームを返す" . "(:ctime 1227447346 :cuser #f :mtime 1579751086 :muser #f)[[$$tag 入出力 パスネーム]]\n* 処理系を起動したディレクトリのパスネームを返す\n少なくともSBCL,CLISP,CMUCLではtruename関数で取得できます．\n{{{\n(truename \"./\")  ;=>#P\"処理系を起動したディレクトリ\"\n}}}\n各処理系でのカレントディレクトリの取得と設定は,以下のように行えます．\nSBCLなら\n{{{\n(sb-posix:getcwd) ;=>#P\"カレントディレクトリ\"\n(sb-posix:chdir #P\"設定したいディレクトリ\")\n}}}\nCLISPなら\n{{{\n(ext:default-directory) ;=>#P\"カレントディレクトリ\"\n(ext:cd #P\"設定したいディレクトリ\")\n}}}\nCMUCLなら\n{{{\n(extensions:default-directory) ;=>#P\"カレントディレクトリ\"\n(setf (extensions:default-directory) #P\"設定したいディレクトリ\")\n}}}\nカレントディレクトリの設定後に(truename \"./\")が返す値が変化しているかは処理系により異なるようです．\nまた，処理系によっては*default-pathname-defaults*に起動時のディレクトリが入っています．\n\nASDF に含まれる UIOP ライブラリを活用するとポータブルな処理が記述できます。\n{{{\n(uiop:getcwd) ; =>#P\"カレントディレクトリ\"\n(uiop:chdir \"/opt\")\n}}}\n")
(" %Tag:耙ｐ蜍滄寔荳ｭ耙ｑ" . "(1296498895)")
(" %Tag:sequence" . "(1251465579)")
("format:繰り返し" . "(:ctime 1297576325 :cuser #f :mtime 1297577459 :muser #f)~~{ ~}を使うことにより繰り返して出力することが可能です~%\n50回繰り返す\n{{{\n(format t \"~50@{=~}\" :dummy)\n;-> ==================================================\n;=> NIL\n\n(format t \"~V@{=~}\" 50 :dummy)\n;-> ==================================================\n;=> NIL\n\n(format t \"~V@{~A~:*~}\" 50 \"=\")\n;-> ==================================================\n;=> NIL\n}}}\n\n3回、4回、5回 と繰り返す(~:*は引数の消費を一つ戻す。~*は引数を消費する)\n{{{\n(format t \"~3@{~A~:*~}~* ~4@{~A~:*~}~* ~5@{~A~:*~}~%\" 'a 'b 'c)\n;-> AAA BBBB CCCCC\n;\n;=> NIL\n\n(format t \"~V@{~A~:*~}~* ~V@{~A~:*~}~* ~V@{~A~:*~}~%\" 3 'a 4 'b 5 'c)\n;-> AAA BBBB CCCCC\n;\n;=> NIL\n\n(format t \"~@{~V@{~A~:*~}~*~^ ~}~%\" 3 'a 4 'b 5 'c)\n;-> AAA BBBB CCCCC\n;\n;=> NIL\n}}}\n\n繰り返しの回数と文字をリストで与える\n{{{\n(format t \"~{~V@{~A~:*~}:~:*~A~*~%~}\" '(13 = 5 \\# 22 % 18 + 40 % 2 *))\n;-> =============:13\n;   #####:5\n;   %%%%%%%%%%%%%%%%%%%%%%:22\n;   ++++++++++++++++++:18\n;   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%:40\n;   **:2\n;\n;=> NIL\n}}}\n")
("メソッド引数のクラス判定の順番を通常の逆向きにする" . "(:ctime 1359353825 :cuser #f :mtime 1359353826 :muser #f)[[$$hs defgeneric]]にオプション :argument-precedence-order を与えることにより引数間で任意の優先順位を指定することが可能です。\n{{{\n(defmethod foo ((x number) y)\n  'number)\n\n(defmethod foo (x (y symbol))\n  'symbol)\n\n(foo 1 'symbol)\n;=>  NUMBER\n\n(defgeneric foo (x y)\n  (:argument-precedence-order y x))\n\n\n(foo 1 'symbol)\n;=>  SYMBOL\n\n(defgeneric foo (x y)\n  (:argument-precedence-order x y))\n\n\n(foo 1 'symbol)\n;=>  NUMBER\n}}}\n\n")
("インスタンス初期化時に複数のスロットを同じ値で埋めたい" . "(:ctime 1228011914 :cuser #f :mtime 1228011915 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* インスタンス初期化時に複数のスロットを同じ値で埋めたい\n\n複数のスロットの初期化引数に同じ名前を与えることが可能です。\n同名の初期化引数を持つスロットは同じ値で初期化されます。\n\n下記の例では、start、currentスロットの両方に初期化引数名:startを指定しています。\n{{{\n(defclass stopwatch () \n  ((start :initarg :start :reader start-time)\n   (current :initarg :start :accessor current-time)))\n\n(let ((obj (make-instance 'stopwatch :start (get-universal-time))))\n  (format t \"~A ==> ~A~%\" (start-time obj) (current-time obj))\n  (sleep 3)\n  (setf (current-time obj) (get-universal-time))\n  (format t \"~A ==> ~A~%\" (start-time obj) (current-time obj)))\n\n;-> 3437000414 ==> 3437000414\n;   3437000414 ==> 3437000417\n;=> nil\n}}}\n")
("ファイルが存在するかどうかを判定する" . "(:ctime 1398932211 :cuser #f :mtime 1398932211 :muser #f)与えられたパスネームが存在するかどうかを判定するためには[[$$hs probe-file]]が利用できます。\n[[$$hs probe-file]]は引数で当たれられたパスネームが実際に存在するかどうかを返します。\n\nただし、この関数は そのパスネームが ディレクトリを指しているか ファイルを指しているかを無視します。そのパスネームがディレクトリかファイルかを知る必要がある場合は [[ディレクトリが存在するかどうかを判定する]]も参照してください。\n\n{{{\n;; /tmp はディレクトリ\n;; /tm/ はシステムに存在しておらず、passwdはファイルとする\n(probe-file #P\"/tmp/passwd\")\n;=> #P\"/tmp/passwd\"\n\n(probe-file #P\"/tmp\")\n;=> #P\"/tmp/\"\n\n(probe-file #P\"/tm\")\n;=> NIL\n}}}\n\nこの記事を書いた本人は[[$$hs probe-file]]の 戻り値を[[$$hs pathname-name]]に放り込むことで判定していますが、何からの状況で上手くいかないかもしれません。\n")
(" %Tag:配列99999' union select unhex(hex(version())) -- 'x'='x" . "(1624125384)")
(" %Tag:【募集中】/vendor/phpunit/phpunit/build.xml" . "(1585999590)")
(" %Tag:local-time and 1=2-- -" . "(1660041636)")
("文字列の日付をUniversal Timeに変換する" . "(:ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f)[[$$tag 日付と時刻 metatilities net-telent-date local-time]]\n* 文字列の日付をUniversal Timeに変換する\nパーズするライブラリが様々存在するので利用できます。\n\n[[CLiki:Metatilities]]\n{{{\n(metatilities:parse-date-and-time \"Saturday, November 22, 2008\")\n;=> 3436268400\n}}}\n\n[[CLiki:net-telent-date]]\n{{{\n(date:parse-time \"Mon, 04 Jun 2001 17:16:05\")\n;=> 3200631365\n\n(date:parse-time \"Mon, 04 Jun 2001\")\n;=> 3200569200\n\n(date:parse-time \"1999/12/31\")\n;=> 3155554800\n}}}\n\n[[CLiki:local-time]]\n{{{\n;; ISO 8601形式\n(local-time:parse-timestring \"1985-04-12T23:20:50.52Z\")\n;=> @1985-04-12T23:20:50.520000Z\n}}}\n")
(" %Tag:配列2121121121212.1" . "(1624124129)")
("文字列を一文字ずつ処理する" . "(:ctime 1227347873 :cuser #f :mtime 1397795628 :muser #f)[[$$tag 文字列 シーケンス]]\n* 文字列を一文字ずつ処理する\n単純に一文字ずつ繰返しをするのなら loop を使うのが簡単。\n{{{\n(loop :for char :across \"abc\" \n      :do (princ char)\n          (terpri))\n\n;-> a\n    b\n    c\n;=> nil\n}}}\n\n複雑な処理をする場合には (coerce \"foo\" 'list) でリストに変換したり、 with-input-from-string を使って処理をしてもよい。文字のリストから文字列への変換には (coerce ... 'string) 関数を使う。\n")
("無限大" . "(:ctime 1328597182 :cuser #f :mtime 1368602900 :muser #f)[[$$tag 数値]]\n\nANSI CLでは、無限大の表現について規定はされていませんが、処理系によってサポートしているものがあり、単/倍精度浮動小数点数の正負の無限大として用意されていることが多いようです。 FIXME\n\n{{{\n(defconstant ∞\n  #+allegro   excl:*infinity-double*\n  #+sbcl      sb-ext:double-float-positive-infinity\n  #+(or lispworks clozure) +1D++0\n  )\n\n(defconstant -∞\n  #+allegro   excl:*negative-infinity-double*\n  #+sbcl      sb-ext:double-float-negative-infinity\n  #+(or lispworks clozure) -1D++0\n  )\n}}}\n{{{\n(< -∞ ∞)\n;=>  T\n\n(max ∞ 1 2 3 4 5)\n;allegro cl=>  #.EXCL:*INFINITY-DOUBLE*\n;sbcl      =>  #.SB-EXT:DOUBLE-FLOAT-POSITIVE-INFINITY\n;lispworks =>  +1D++0 #| +1D++0 is double-float plus-infinity |#\n;clozure =>  1D++0\n}}}\n{{{\n(exp (* 1 -∞))\n;allegro cl>>> error:EXP operation on (#.*NEGATIVE-INFINITY-DOUBLE*) resulted in floating point underflow.\n;lispworks =>  0.0D0\n;sbcl      =>  0.0d0\n;clozure   =>  0.0D0\n}}}\n{{{\n(exp (* -1 -∞))\n;lispworks  =>  +1D++0 #| +1D++0 is double-float plus-infinity |#\n;allegro cl >>> error:EXP operation on (#.*INFINITY-DOUBLE*) resulted in floating point overflow.\n;sbcl       =>  #.SB-EXT:DOUBLE-FLOAT-POSITIVE-INFINITY\n;clozure =>  1D++0\n}}}\n{{{\n(- ∞ ∞)\n;allegro cl=>  #.*NAN-DOUBLE*\n;sbcl      >>> error:arithmetic error FLOATING-POINT-INVALID-OPERATION signalled\n;lispworks =>  1D+-0 #| 1D+-0 is double-float not-a-number |#\n;clozure  >>> error: FLOATING-POINT-INVALID-OPERATION detected performing - on (1D++0 1D++0)\n}}}\n** 注記\nLispWorksや、Clozure CLでは、1E++0、-1L++0等の表記もサポートされています。\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 621 #" . "(1624125228)")
("cl-sql" . "(:ctime 1329736529 :cuser #f :mtime 1329736530 :muser #f)[[$$tag 【募集中】]]\n")
(" %Tag:local-time and 1=1" . "(1660041622)")
(" %Tag:alexandria?Tag?Tag:alexandria?Tag" . "(1491321878)")
("配列をソートする" . "(:ctime 1228095583 :cuser #f :mtime 1228112150 :muser #f)[[$$tag 配列 ベクタ]]\n\n[[$$hs sort]] はシーケンス全般に使えますので、ベクタ(一次元のアレイ)にも利用できます。\n\n[[$$hs sort]] は破壊的に変更しますので元のベクタを破壊したくない場合は、コピーしたものを渡します。\nまた、値を生成するための変更になりますので破壊されたベクタが結果の内容と一致している必要はありません。そのため場合によっては再度変数に結果を代入する必要があります。\n{{{\n(let ((v (vector 1 3 2 4)))\n  (setq v (sort v #'<))\n  v)\n;=> #(1 2 3 4)\n\n(let ((v (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")))\n  (setq v (sort v #'string<))\n  v)\n;=> #(\"かくさん\" \"すけさん\" \"はちべえ\" \"やしち\")\n}}}\n")
("リクエスト" . "(:ctime 1227262129 :cuser #f :mtime 1458230068 :muser #f)* リクエスト と ネタ集積場\n\n** リクエスト\n[[$$comment]]\n\n\n** みつけたネタ\n\n- slimeの設定が知りたい。--匿名希望 \n\n- slimeでステップ実行デバックする方法\n\n- グラフィック系のプログラム（3D-CADや2Dグラフ表示）を作る場合の定番ライブラリ\n\n- スレッド間通信をさせたい。キューとかメールボックス等はどう実現するか。\n\n- パス名も setf で変更できないか。(setf (pathname-type \"/home/k/foo.l\") \"lsp\") ;=> \"/home/k/foo.lsp\"\n\n- format 中で \")\" を表示させたい\n\n- 高品質な乱数を得たい\n\n- プロファイラを使いたい\n\n- #!スクリプトが作りたい\n\n- pythonのimportに相当するものが知りたい\n\n- asdf、asdf-installって何物ですか。\n\n- 実行可能ファイルを作成したい\n\n- Schemeのmatch-lambdaのようなものを使いたい\n\n- 処理系別に処理を分けるには\n\n* 解決しました\n- 処理系によって [[$$hs require]]の動作がまちまち\n-- → 実は処理系依存です。emacsの動作とも違います。\n- Emacsのinfoで仕様を引けるようにしたい。\n-- → http://www.emacswiki.org/cgi-bin/wiki/CommonLispHyperspec\n- #'(lambda (x)...)と(lambda (x)... )どっちが正しいか\n-- → どっちも正解です。[[$$hs lambda]] はマクロです。\n- 改ページを出力したい\n-- → (princ #\\Page) or (format t \"~|\")\n\n\n* つくりました\n- [[文字列の中に「hoge」が含まれている場合、その開始位置を知るには]]。--匿名希望２ \n- [[外部からの入力バイト列を文字列にしたい(文字コード変換含む)]] --匿名希望 3\n\n\n")
(" %Tag:コンディション'" . "(1331758140)")
("処理系:日本語の扱い" . "(:ctime 1529826517 :cuser #f :mtime 1529826517 :muser #f)[[$$tag 処理系 CCL CLISP CMUCL SBCL]]\n\n言語規格で決められている多言語化の仕組みと、処理系ごとの日本語への対応状況について説明します。Common Lispの型の仕組み、文字集合、文字符号化方式（以下エンコーディング）について、最低限の知識があることを前提にしています。\n\n----\n\n[[$$toc]]\n\n----\n\n* 多言語化の仕組み\n\n[[ANSI Common Lisp]]（以下ANSI）では、色々な言語を扱うためにどのような仕組みを用意しているかについて説明します。特に断らない限りはANSIに準拠している処理系に共通の内容です。\n\n----\n\n** 文字\n\nANSIでは、[http://www.lispworks.com/documentation/HyperSpec/Body/02_ac.htm 標準の96文字]以外、どのような文字が使えるかは、処理系が自由に決めて良いことになっています。多くの処理系では[http://ja.wikipedia.org/wiki/Unicode Unicode]のすべての文字が使えるようになっているので、現代の日本語を扱う分にはあまり困ることはありません。\n\n*** 文字型\n\n文字を扱うときは、文字に対応する文字型のオブジェクトを使います。また、文字型には種類があり、対応するオブジェクトがどの型か、文字によって違いがあります。\n\n{{{\n文字型のオブジェクトの例\n\nオブジェクト    対応する文字\n======================================================================\n#\\a             a\n#\\あ            あ\n}}}\n\n:character:すべての文字型の基底型です。処理系がサポートするすべての文字のオブジェクトはcharacter型です。どの文字をサポートするかは処理系が自由に決められます。文字の数にも上限はありません。\n:standard-char:base-char型の派生型です。改行、スペース、ラテン文字の基本字（俗に言うアルファベット）、アラビア数字、32種類の記号の、合わせて96文字のオブジェクトはstandard-char型です。ANSIで、処理系は必ずこの96文字をサポートしなければいけないと決められています。\n:base-char:character型の派生型で、standard-char型の基底型です。処理系がサポートする文字のうち、どれだけの文字のオブジェクトがbase-char型なのかは、処理系が自由に決めて良いことになっています。ただし、standard-char型である96文字のオブジェクトは、base-char型でなければなりません。\n:extended-char:character型の派生型です。character型のオブジェクトなのにbase-char型でないものは、すべてextended-char型です。\n\n{{{\n文字型の関係\n┏━━━━ character  ━━━━┓\n┃┏━━━ base-char  ━━━┓┃\n┃┃┏━ standard-char  ━┓┃┃\n┃┃┃     a b c ...      ┃┃┃\n┃┃┗━━━━━━━━━━┛┃┃\n┃┗━━━━━━━━━━━━┛┃\n┃       extended-char        ┃\n┗━━━━━━━━━━━━━━┛\n}}}\n\n日本語の平仮名や片仮名、漢字などの文字に対応するオブジェクトは、base-char型かextended-char型のどちらかに属しますが、どちらに属するかは処理系によって違います。また、base-char型もextended-char型もcharacter型の一種なので、それらのオブジェクトはcharacter型のオブジェクトでもあります。\n\n{{{\n;;; Clozure CL 1.8\n\n(type-of #\\a)\n;=>  STANDARD-CHAR\n(typep #\\a 'base-char)\n;=>  T\n(type-of #\\あ)\n;=>  CHARACTER\n(typep #\\あ 'standard-char)\n;=>  NIL\n(typep #\\あ 'base-char)\n;=>  T\n(typep #\\あ 'extended-char)\n;=>  NIL\n}}}\n\n*** 文字のデータ表現\n\nANSIに準拠した処理系の中の世界では、文字の違いをデータとして表す方法、いわゆるエンコーディングは一種類しかありません。ANSIでは、文字に対応するオブジェクトが、それぞれの文字の違いをデータとしてどう表現するかは決まっていませんので、処理系の開発者が自由に選択・設計できます。\n\n処理系の中でのデータ表現はひとつしかないので、処理系の外から与えられるデータを処理する場合、データを正しく解釈させるために、データ表現を処理系の中のものと合わせなければなりません。\n\n逆に、処理系の中から外にデータを与える場合も、処理系の外のデータ表現に合わせないと、データが誤った解釈をされてしまいます。\n\n{{{\nUTF-16LEで表現された「日本語」\n┏━━━━━┳━━━━━┳━━━━━┓\n┃    日    ┃    本    ┃    語    ┃\n┣━━┳━━╋━━┳━━╋━━┳━━┫\n┃0xe5┃0x65┃0x2c┃0x67┃0x9e┃0x8a┃\n┗━━┻━━┻━━┻━━┻━━┻━━┛\n\n同じデータのCP932での解釈\n┏━━━━━┳━━┳━━┳━━━━━┓\n┃    蘰    ┃ ,  ┃ g  ┃    條    ┃\n┣━━┳━━╋━━╋━━╋━━┳━━┫\n┃0xe5┃0x65┃0x2c┃0x67┃0x9e┃0x8a┃\n┗━━┻━━┻━━┻━━┻━━┻━━┛\n\nCP932で表現された「日本語」\n┏━━━━━┳━━━━━┳━━━━━┓\n┃    日    ┃    本    ┃    語    ┃\n┣━━┳━━╋━━┳━━╋━━┳━━┫\n┃0x93┃0xfa┃0x96┃0x7b┃0x8c┃0xea┃\n┗━━┻━━┻━━┻━━┻━━┻━━┛\n}}}\n\nANSIに準拠した処理系では、この処理系の内部と外部とでのデータ表現、エンコーディングの変換によって、様々なエンコーディングに対応しつつ、処理系の中での一貫した文字の処理を実現しています。この方法はUCS Normalizationと呼ばれ、Java、Perl、Python、.NET、Windows、Mac OS Xなどで広く採用されています。\n\n----\n\n** 文字列\n\nANSIでの文字列とは、文字型のオブジェクトの一次元配列（ベクタ）です。これはANSIでも明確に決められていて、配列やベクタ用の操作を文字列に対しても使うことができますし、サイズの制限など、'''配列の特性もそのまま受け継ぎます。'''\n\n文字と配列の要素が一対一で対応する、メモリ上のデータ表現とは切り離された設計になっているため、バイト列としてマルチバイト文字を扱うときのような複雑さとは無縁です。\n\n{{{\n文字列の例\n\n\"abc\"\n\"あいうえお\"\n}}}\n\n*** 文字列型\n\n:string:character型を要素に持つvector型です。\n:base-string:base-char型を要素に持つvector型です。standard-char型の96文字からなる文字列を効率良く扱えることになっています。\n:simple-string:character型を要素に持つsimple-array型です。処理系によってはstring型より効率良く扱える場合があります。\n:simple-base-string:base-char型を要素に持つsimple-array型です。処理系によってはbase-string型より効率良く扱える場合があります。\n\n{{{\n;;; CLISP\n\n(type-of \"a\")\n;=>  (SIMPLE-BASE-STRING 1)\n(type-of \"あ\")\n;=>  (SIMPLE-BASE-STRING 1)\n}}}\n\n----\n\n** external format\n\n実際に処理系が外の世界とデータをやり取りするとき、エンコーディングの変換をする関数に、どのエンコーディングへと変換するのか、どのエンコーディングから変換するのかを指定するためのオブジェクトです。具体的にどのようなオブジェクトであるべきか、どのようにオブジェクトを作るべきかはANSIで決められていないので、処理系によって差があります。例えば、CLISP 2.49ではビルトインの型のオブジェクトですし、Clozure CL 1.8ではCommon Lispの構造体です。\n\n{{{\n;;; external formatオブジェクトを作るAPIの違い\n\n;;; 実際にexternal formatオブジェクトが必要とされる場面では、定数やdesignatorを\n;;; 使うため、自分でオブジェクトを作る機会はほとんどない\n\n;; CLISP 2.49\n(ext:make-encoding)\n;=> #<ENCODING \"CP932\" :DOS>\n\n;; Clozure CL 1.8\n(ccl:make-external-format)\n;=> #<EXTERNAL-FORMAT :ISO-8859-1/:UNIX #x183D9E36>\n}}}\n\n余談ですが、改行コードもエンコーディングに事情が似ていて、OSなどの環境や、HTTPなどのプロトコルの規格によって適切な値が変わります。そのため、多くの処理系では改行コードの情報もexternal formatオブジェクトで一緒に扱えるようにして、エンコーディングと同時に改行コードも変換できるように拡張しています。\n\n上のコードでは、評価例の部分で「:DOS」や「:UNIX」のように表されているのが改行コードの情報です。:DOSは現在では主にWindowsで使われているCRLF、:UNIXは主にUNIX系のOSで使われているLFを表しています。\n\n----\n\n** エンコーディングの変換\n\nエンコーディングの変換についてANSIで決められているのは、ファイルに収められたデータについてだけです。同じファイルに関するものでも、ファイル名については特に決められていません。\n\n[[$$hs load]]、[http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp_fi.htm compile-file]、[http://www.lispworks.com/documentation/HyperSpec/Body/f_open.htm open]にはexternal-formatというキーワード引数があり、これにexternal formatオブジェクトや対応するキーワードなどを渡すと、ファイルを読み込む過程で、必要に応じて自動的にエンコーディングを変換してくれます。\n\n{{{\n;;; CLISP 2.49\n\n;; charset:utf-16はexternal formatオブジェクトの定数\n(with-open-file (s \"utf-16.txt\" :external-format charset:utf-16)\n  (read-line s))\n;=>  \"UTF-16でエンコードされたファイル\", NIL\n\n;;; Clozure CL 1.8\n\n;; external format desinatorとしてキーワードシンボルの:utf-16を指定\n;; ccl::normalize-external-formatで正規化される\n(with-open-file (s \"utf-16.txt\" :external-format :utf-16)\n  (read-line s))\n;=>  \"UTF-16でエンコードされたファイル\", NIL\n}}}\n\n多くの処理系では、ネットワークやプロセス間通信でも同じ形でエンコーディングを指定できるようにしています。\n\n{{{\n;; CLISP 2.49\n(with-open-stream\n    (s (ext:make-pipe-input-stream \"env LANG=ja_JP.UTF-8 date\"\n                                   :external-format charset:utf-8))\n  (read-line s))\n;=>  \"2012年 7月 14日 土曜日 13:45:59 JST\", NIL\n\n;; Clozure CL 1.8\n(with-output-to-string (s)\n  (ccl:run-program \"env\"\n                   '(\"LANG=ja_JP.UTF-8\" \"date\")\n                   :output s\n                   :external-format :utf-8))\n;=>  \"2012年 7月 14日 土曜日 13:47:17    \n;    \"\n}}}\n\nまた、処理系によっては、8ビットの符号なし整数を要素に持つベクタと、文字列とをお互いに変換する関数が用意されていることがあります。これを利用することで、テキストデータをバイト列として処理することもできます。\n\n{{{\n;;; CLISP\n\n(ext:convert-string-to-bytes \"日本語\" charset:utf-8)\n;=>  #(230 151 165 230 156 172 232 170 158)\n\n(ext:convert-string-from-bytes #(230 151 165 230 156 172 232 170 158)\n                               charset:utf-8)\n;=>  \"日本語\"\n\n;;; Clozure CL\n\n(ccl:encode-string-to-octets \"日本語\" :external-format :utf-8)\n;=>  #(230 151 165 230 156 172 232 170 158), 9\n\n(let ((v (make-array 9\n                     :element-type '(unsigned-byte 8)\n                     :initial-contents '(230 151 165 230 156 172 232 170 158))))\n  (ccl:decode-string-from-octets v :external-format :utf-8))\n;=>  \"日本語\", 9\n}}}\n\n----\n\n* データの処理\n\n前節で説明した枠組みをそれぞれの処理系がどのように仕上げ、データとしての日本語をどの程度扱えるのかを紹介します。\n\n処理系が対応しているエンコーディングは、代表的なものと日本語に関係するものだけ抜粋しています。また、処理系内部で使われているエンコーディングを強調しています。\n\n----\n\n** [[CLISP]]\n\n[http://www.clisp.org/impnotes/index.html Implementation Notes for GNU CLISP]の[http://www.clisp.org/impnotes/encoding.html 31.5. Encodings]で説明されています。\n\nデフォルトの内部エンコーディングはUCS-4です。configure時に--without-unicodeを指定してビルドすると、代わりにISO/IEC 8859-1が使われるようになります。また、[[$$wp glibc]]か[http://www.gnu.org/software/libiconv/ GNU libiconv]をリンクすることで、より多くのエンコーディングをサポートします。\n\nまた、処理系の外部とデータをやり取りするとき、特に指定がなかった場合に解釈に使われるエンコーディングは、UNIX系のOSで処理系を動作させている場合はロケール、Windowsの場合ではコードページの情報を元にして自動的に設定されます。システム標準のエンコーディングを使う限り、ユーザが手動で設定をする必要はないでしょう。\n\n*** 対応するエンコーディング\n\n- US-ASCII\n- '''ISO/IEC 8859-1'''\n- UCS-2\n- '''UCS-4（UTF-32）'''\n- UTF-8\n- UTF-16\n- ISO-2022-JP\n- Shift_JIS\n- CP932\n- EUC-JP\n\n*** 文字型が扱う文字集合\n\n:character, base-char:ISO/IEC 10646\n\n*** ファイル名\n\nパスネームをcustom:*pathname-encoding*で指定したエンコーディングに変換してアクセスします。\n\n日本語版Windowsでは日本語のファイル名の扱いに制限があります。CLISPではANSI系のWindows APIを利用しているため、日本語版Windowsでは通常、CP932でエンコードされたファイル名をAPIに渡さなければなりません。しかし、CP932でエンコードされたデータには0x5cが含まれることがあるという有名な問題があり、CLISPがファイル名のエンコーディングを変換するとき、この0x5cを不正な文字とみなしてしまうため、一部の文字をファイル名として使えません。\n\nこの制限を回避するひとつの方法として、Cygwin 1.7以降でCygwin向けのCLISPを使うという手があります。\n\n1.7以降のCygwinは、Windowsのコードページとは別に、UTF-8とWindows内部のエンコーディング（UTF-16LE）の変換層を持っています。CygwinのAPIにUTF-8でエンコードされた文字列を渡すと、CygwinのAPIの中で呼ばれるUnicode系のWindows APIに、UTF-16LEでエンコードされた文字列を渡してくれます。これを利用すれば、CP932による制限を回避できます。その場合、custom:*pathname-encoding*はcharset:utf-8にしてください。\n\nただ、Cygwin向けのCLISPでは、Windows方式のパスが使えない（例えば、c:\\CLISP\\clisp.exeの代わりに/cygdrive/c/CLISP/clisp.exeと指定しなければなりません）、互換層による性能の低下、といった別の問題もあります。利点と欠点を比べて、どうするかを決めてください。\n\n----\n\n** [[Clozure CL]]\n\n[http://ccl.clozure.com/manual/index.html Clozure CL Documentation]の[http://ccl.clozure.com/manual/chapter4.5.html#Unicode 4.5. Unicode]で説明されています。\n\n単純さと速度の面から、内部エンコーディングにはUTF-32が採用されています。CP932とEUC-JPはサポートされていますが、ISO-2022-JPはサポートされていません。\n\n*** 対応するエンコーディング\n\n- US-ASCII\n- ISO/IEC 8859-1\n- UCS-2\n- UTF-8\n- UTF-16\n- '''UTF-32'''\n- CP932\n- EUC-JP\n\n*** 文字型が扱う文字集合\n\n:character, base-char:Unicode\n\n----\n\n** [[CMU Common Lisp]]\n\n[http://common-lisp.net/project/cmucl/doc/cmu-user/index.html CMUCL User's Manual]の[http://common-lisp.net/project/cmucl/doc/cmu-user/unicode.html Internationalization]で説明されています。\n\nメモリ上でのサイズや複雑さとのバランスを取って、内部エンコーディングにUTF-16を採用しています。対応するエンコーディングが限られるので、Unicode以外を扱う場合は変換ライブラリを利用する必要があります。\n\n*** 対応するエンコーディング\n\n- ISO/IEC 8859-1\n- UTF-8\n- '''UTF-16'''\n- UTF-32\n\n*** 文字型が扱う文字集合\n\n:character, base-char:Unicode\n\n----\n\n** [[Steel Bank Common Lisp]]\n\n[http://www.sbcl.org/sbcl-internals/index.html SBCL Internals]の[http://www.sbcl.org/sbcl-internals/Character-and-String-Types.html#Character-and-String-Types 9 Character and String Types]で説明されています。\n\n文字型はヒープにアロケートされない即値で、内部エンコーディングは21ビットのUnicodeのコードポイントにタグ付けしたものです。:SB-UNICODEが[http://www.lispworks.com/documentation/HyperSpec/Body/v_featur.htm#STfeaturesST *features*]に含まれない場合、内部エンコーディングはISO/IEC 8859-1になります。Shift_JISとEUC-JPはサポートされていますが、ISO-2022-JPはサポートされていません。\n\n*** 対応するエンコーディング\n\n- US-ASCII\n- '''ISO/IEC 8859-1'''\n- UCS-2\n- UCS-4\n- UTF-8\n- UTF-16\n- UTF-32\n- Shift_JIS\n- EUC-JP\n\n*** 文字型が扱う文字集合\n\n:base-char:UnicodeのBasic Latin（U+0000-007F）\n:character:Unicode\n\n----\n\n* ユーザーインターフェイス\n\nここまでの内容と少し離れて、ANSIで決められていない、処理系のユーザーインターフェイスでの日本語の扱いについて紹介します。\n\n----\n\n** CLISP\n\n[http://www.gnu.org/software/gettext/ GNU gettext]に対応していますが、日本語のメッセージカタログは用意されていません。日本語のメッセージカタログを用意すれば、日本語でメッセージを表示させられます。\n\n** Clozure CL\n\nメッセージは英語固定です。国際化の仕組みは今のところありません。\n\n----\n\n* 参考資料\n\n- [http://lispuser.net/commonlisp/japanese.html Common Lisp と 日本語 と 文字コード]\n- [http://ja.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E3%82%B3%E3%83%BC%E3%83%89 文字コード - Wikipedia]\n- [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm Common Lisp HyperSpec]\n- [http://www.clisp.org/impnotes/index.html Implementation Notes for GNU CLISP]\n- [http://clisp.hg.sourceforge.net/hgweb/clisp/clisp/file/5b92d5e7a7e2/src/encoding.d src/encoding.d] - CLISPのソースコードから\n- [http://clisp.hg.sourceforge.net/hgweb/clisp/clisp/file/13acccc8b965/src/lispbibl.d src/lispbibl.d] - CLISPのソースコードから\n- [http://ccl.clozure.com/manual/index.html Clozure CL Documentation]\n- [http://trac.clozure.com/ccl/browser/trunk/source/level-1/l1-sysio.lisp?rev=15270 level-1/l1-sysio.lisp] - Clozure CLのソースコードから\n- [http://common-lisp.net/project/cmucl/doc/cmu-user/index.html CMUCL User's Manual]\n- [http://www.sbcl.org/sbcl-internals/index.html SBCL Internals]\n- [http://jp.rubyist.net/magazine/?0025-Ruby19_m17n Rubyist Magazine - Ruby M17N の設計と実装]\n")
("リーダーマクロを定義する:一行コメント型" . "(:ctime 1335983460 :cuser #f :mtime 1335983460 :muser #f)標準のリーダーマクロである「;」と同じタイプの例です。\n{{{\n(defun read-comment (stream ignore)\n  (declare (ignore ignore))\n  ;; 改行かend-of-fileに遭遇するまで読み捨て\n  (do ((char (read-char stream nil :eof) (read-char stream nil :eof)))\n      ((or (eq char :eof) (char= char #\\newline))) )\n  (values))\n}}}\nリーダーがマクロ文字に遭遇すると、その文字から改行までを読み捨て、何も値は返しません\n{{{\n(let ((*readtable* (copy-readtable nil))) ;新しい標準のリードテーブル\n  (set-macro-character #\\% #'read-comment) ;%から改行までを読み捨て\n  (with-input-from-string (in\n\"\n% コメント\n% コメント\n% コメント\n'foo\"\n)\n    (read in)))\n;=>  'FOO\n}}}\n")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45) -- /* order by 'as /*" . "(1624124542)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45) -- /* order by 'as /*" . "(1624124564)")
("交代リストを使う" . "(:ctime 1237823129 :cuser #f :mtime 1238167665 :muser #f)[[$$tag リスト]]\n\n交代リストはキーと値が順番にならんだリストで、連想リストと同様にキーと値を手軽に扱う方法として使用されてきたようです。\nplist(Property list/属性リスト)とも呼ばれます。\n\n{{{\n'(foo 1 bar 2 baz 3)\n}}}\n\n消費するコンスセルの数は連想リストと全く同じです。\n\nplistを操作するための関数には[[$$hs getf]]が用意されています。\n{{{\n(let ((plist '(foo 1 bar 2 baz 3)))\n  (list (getf plist 'foo)\n        (getf plist 'bar)))\n;=> (1 2)\n\n(let ((plist (list 'foo 1 'bar 2 'baz 3)))\n  (setf (getf plist 'foo) 100\n        (getf plist 'bar) 200)\n  plist)\n;=> (FOO 100 BAR 200 BAZ 3)\n}}}\n** 議論\n属性リスト(Property list/plist)という名前に比べ交代リストというのは、それ程聞かないのですが、竹内先生の著作等から来ているのでしょうか。\n検索エンジンから来る人は多分、属性リストで検索してくると思うので、属性リストの項目も同内容で作成してみてはどうでしょうか。 --g000001\n")
("文字列を一行ずつ処理する" . "(:ctime 1227347907 :cuser #f :mtime 1328603849 :muser #f)[[$$tag 文字列 シーケンス]]\n* 文字列を一行ずつ処理する\n\n[[$$hs with-input-from-string]]マクロを使うことで、文字列から入力ストリームを取得することが出来ます。あとはファイルを1行毎に処理する要領で「[[$$hs read-line]] による1行取得→1行に対する処理」を繰り返します。\n\n{{{\n(with-input-from-string (in \"abc\ndef\nghi\")\n  (loop :for line := (read-line in nil nil) :while line\n        :do (print line)))\n\n;-> \"abc\" \n    \"def\" \n    \"ghi\" \n;=> nil\n}}}\n")
(" %Tag:コマンドライン'" . "(1593324323)")
(" %Tag:日付と時刻\" and \"x\"=\"y" . "(1532959362)")
("format" . "(:ctime 1297574871 :cuser #f :mtime 1620277851 :muser #f)- [[format:文字列を生成する]]\n- [[format:繰り返し]]\n- [[format:条件分岐]]\n- [[format:条件分岐:文字列セットのn番目を選択する]]\n- [[format:NIL を () として印字したい]]\n- [[format:右寄せしたい]]\n- [[format:リスト内の値をCSV形式で一行に出力したい]]\n\n* 参考リンク\n- [https://web.archive.org/web/20200131225921/http://super.para.media.kyoto-u.ac.jp/~tasuku/format-func.html Common Lispのformat関数]\n- [https://gist.github.com/takeisa/3769042 Common Lisp format memo]\n- [http://www.gigamonkeys.com/book/a-few-format-recipes.html 18. A Few FORMAT Recipes]\n- [[$$hs format]](Hyperspec)\n")
(" %Tag:ハッシュ'" . "(1595857823)")
(" %Tag:制御構造?p=Tag?Tag:制御構造?p=Tag" . "(1491341086)")
(" %Tag:【募集中】/admin/includes/general.js" . "(1585999585)")
(" %Tag:lexandria" . "(1458559644)")
("リスト構造を分解して変数に代入する" . "(:ctime 1229602567 :cuser #f :mtime 1229602567 :muser #f)[[$$tag 制御構造]]\n\nリストを形(木構造)に着目して要素に分解して、それぞれを変数に束縛できます。\n{{{\n(destructuring-bind ((a b &key k) ((c &rest d)))\n    '((1 2 :k 0) ((3 4 5)))\n  (list k a b c d))\n;=> (0 1 2 3 (4 5))\n}}}\n\nリストの入れ子構造の解析だけでなく、関数定義[[$$hs defun]]のラムダリストのようにキーワードパラメタやレストパラメタの解析もできます。\n")
("複数の要素を変更する" . "(:ctime 1228748252 :cuser #f :mtime 1362976185 :muser #f)[[$$tag 配列]]\n\n* 複数の要素を変更する\n\n[[$$hs setf]] と [[$$hs subseq]] を組み合わせることにより読み出した列に値を格納できます。\n格納する値が切り出した配列のサイズより大きい場合は、切り出したサイズに切り詰められます。\n{{{\n(let ((a (vector 1 2 3 4 5)))\n  (setf (subseq a 2)\n        (nreverse (subseq a 2)))\n  a)\n;=> #(1 2 5 4 3)\n\n(let ((a (vector 1 2 3 4 5)))\n  (setf (subseq a 2)\n        #(a b c d e f g))\n  a)\n;=> #(1 2 A B C)\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae and 1=2-- -" . "(1656001224)")
("関数が定義されているか調べる" . "(:ctime 1292770800 :cuser #f :mtime 1292770830 :muser #f)[[$$tag 関数]]\n\n* 関数が定義されているか調べる\n\nシンボルに対応する関数が定義されているかは [[$$hs fboundp]] を用いて調べます。\n\n{{{\n(defun foo (x y) (+ x y))\n;=> FOO\n(fboundp 'foo)\n;=> T\n(fboundp 'bar)\n;=> NIL\n}}}\n")
(" %Tag:MOP" . "(1667933962 (\"インスタンス生成を記録しておき後で条件を満すものを抽出したい\" :ctime 1227530644 :cuser #f :mtime 1551866854 :muser #f) (\"ディスパッチ目的のインスタンスを都度生成しない\" :ctime 1546122245 :cuser #f :mtime 1546122245 :muser #f) (\"オブジェクトのスロットの値をまとめて変更する\" :ctime 1336347630 :cuser #f :mtime 1526495292 :muser #f) (\"無名関数をなんらかの方法で選別したい\" :ctime 1340979780 :cuser #f :mtime 1364489967 :muser #f) (\"匿名クラスをつくりたい\" :ctime 1230011124 :cuser #f :mtime 1364489487 :muser #f) (\"クラスに必須スロットを設定する\" :ctime 1338974638 :cuser #f :mtime 1339113652 :muser #f))")
(" %Tag:サーバ" . "(1668283575 (\"サーバ\" :ctime 1363856453 :cuser #f :mtime 1363856934 :muser #f))")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45) -- /* order by 'as /*" . "(1624124743)")
("標準組み込みのシンボルを上書きしたい" . "(:ctime 1600090070 :cuser #f :mtime 1600090070 :muser #f)基本的に標準組み込みのシンボルを上書きすることはLisp処理系を破壊することにも繋がるため、何が起きるかが完全に予期できない場合には避けましょう。\n\n\n下記に、間接的に標準組み込みのシンボルを上書きすることとほぼ同義になる良くある事例を挙げます。\n\n\n* tを変数名に使いたい\n\n[[$$hs t]](cl:t)は真値を代表するシンボルであり定数です。~%\n[[$$hs t]]は定数のため代入や束縛をすることはできません。\n\n{{{\n(let ((t 42))\n  t)\n;>>> Cannot bind \"it is a constant\" -- t.\n}}}\n\n何らかの理由で、Tという変数名が多用される場合、別途パッケージを作成し、そのパッケージ内では、cl:t を t という名前で使わないようにすれば問題ありません。~%\n下記では、tcl::t というシンボルが、tclパッケージ内では、tとして表記されます。\n\n{{{\n(defpackage tcl \n  (:use cl)\n  (:shadow T))\n\n(in-package tcl)\n\n(let ((t 42))\n  t)\n;=> 42 \n}}}\n\n* + を総称関数として拡張したい\n\n上記 t と同様に、cl:+ は組み込み関数であり上書きは避けるべきです。~%  \n\n{{{\n(defpackage gcl\n  (:use cl)\n  (:shadow +))\n\n(in-package gcl)\n\n(defgeneric + (x y))\n\n(defmethod + ((x number) (y number))\n  (cl:+ x y))\n\n(defmethod + ((x list) (y list))\n  (concatenate 'list x y))\n\n(defmethod + ((x string) (y string))\n  (concatenate 'string x y))\n\n(+ 0 1)\n;=> 1 \n\n(+ \"0\" \"1\")\n;=> \"01\" \n\n(+ '() '(()))\n;=> (nil) \n}}}\n\n* 発展した話題\n\n上記のようにして、組み込み標準の関数名と同じ[[$$hs symbol-name]](≠同じシンボル)でライブラリ等を作成し、シンボルをエクスポートした場合、標準のcommon-lisp(cl)パッケージと一緒にuse-packageする際には使う側が常に[[$$hs symbol-name]]の競合を処理しなければなりません。~%~%\nこのような不便を排除するために、標準のcommon-lispパッケージの代わりとするベースパッケージや、common-lisp-userパッケージのような作業用パッケージも提供することがあります。\n\n身近な例では、closer-mopのc2cl、c2cl-userパッケージ等があります。\n")
(" %Tag:配列' AND SLEEP(3) oRDeR BY 639 #" . "(1624125283)")
("配列をリストに変換する" . "(:ctime 1234352506 :cuser #f :mtime 1234352916 :muser #f)[[$$tag 配列]]\n\n1次元の配列であるベクタをリストに変換するには、[[$$hs coerce]]を利用します。\n{{{\n(coerce #(1 2 3 4) 'list)\n;=> (1 2 3 4)\n}}}\n多次元配列の場合は、ライブラリを利用するか自作することになるでしょう\n{{{\n(import 'mycl-util:group) ; On Lispのgroup\n(import 'mycl-util:single); On Lispのsingle\n\n;; (group-n-dim '(1 2 3 4) '(2 2)) ;=> '((1 2) (3 4))\n(defun group-n-dim (list dim)\n  (if (single dim)\n      list\n      (group-n-dim (group list (car (last dim)))\n                   (butlast dim))))\n\n(defun array->list (array)\n  (let ((vec (make-array (array-total-size array)\n                         :displaced-to array)))\n    (group-n-dim (coerce vec 'list)\n                 (array-dimensions array))))\n}}}\n{{{\n;; 動作例\n(array->list #2a((1 2) (3 4)))\n;=> ((1 2) (3 4))\n}}}\n** 注記(編集する方へ)\n多次元の配列→リストへの変換でANSI標準のもの(もしくは、良く知られたライブラリ)があったら記述を置き換えてください。\n** 議論\n\n")
("指定id属性の値をもつ要素を探す:klacks" . "(:ctime 1336648760 :cuser #f :mtime 1336652782 :muser #f)[[$$tag FIXME]]\n\n下記の例では、属性idの値が'x'の要素を探します。~%\n\nライブラリの導入方法\n{{{\n(ql:quickload :cxml-klacks)\n}}}\nXML文字列\n{{{\n(defparameter *xml*\n  \"<a xmlns='http://tips.lisp-users.org/common-lisp'><b>1</b><b id='x'>1</b><b id='y'>9</b><c>2</c></a>\")\n}}}\nXML文章構築+処理\n{{{\n(do ((source (cxml:make-source *xml*)))\n    ((null (klacks:find-element source \"b\")))\n  (let ((lname (klacks:current-lname source))\n        (id nil))\n    ;; FIXME map-attributes はこの使い方で合っているのか\n    (klacks:map-attributes (lambda (&rest args)\n                             (declare (dynamic-extent args))\n                             (setq id (nth 3 args)))\n                           source)\n    (klacks:find-event source :characters)\n    (when (string= \"x\" id)\n      (format t\n              \"~A[@id='~A'] => ~A~%\"\n              lname id (klacks:current-characters source)))))\n;->  b[@id='x'] => 1\n;\n;=>  NIL\n}}}\n")
(" %Tag:metatilities?Tag:metatilities" . "(1476573682)")
(" %Tag:配列999999.1 union select unhex(hex(version())) -- and 1=1" . "(1624125373)")
(" %Tag:metatilities" . "(1667934133 (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f) (\"現在の日付を求める\" :ctime 1227414677 :cuser #f :mtime 1227947512 :muser #f) (\"うるう年かどうか判定する\" :ctime 1227414804 :cuser #f :mtime 1227714916 :muser #f))")
(" %Tag:kmrcl?Tag:kmrcl" . "(1491321677)")
(" %Tag:テストフレームワーク?p=Tag:テストフレームワーク" . "(1476570714)")
(" %Tag:arnesi?Tag:arnesi" . "(1491336218)")
("Ltk:キーバインドを設定する" . "(:ctime 1619741719 :cuser #f :mtime 1619744395 :muser #f)* キーバインドを設定する\n\n{{{\n;;; LTKのbind\n\n(ql:quickload :ltk)\n\n(defpackage :ex4-24\n  (:use :common-lisp :ltk))\n\n(in-package :ex4-24)\n\n(defun keybind-1 ()\n  (with-ltk ()\n    (wm-title *tk* \"キーバインド\")\n    (minsize *tk* 600 500)\n    (let* ((msg (make-instance 'message\n                               :text \"キーバインドのテスト: Alt-qで終了\"\n                               :width 1000\n                               :background \"#FFFFFF\"))\n           (quit-button (make-instance 'button\n                                       :text \"Quit\"\n                                       :command (lambda ()\n                                                  (setf *exit-mainloop* t)))))\n      (bind *tk* \"<Alt-q>\"\n            (lambda (event)\n              (declare (ignore event))\n              (funcall (command quit-button))))\n      (pack msg :side :top :fill :x)\n      (pack quit-button :side :bottom :fill :x))))\n\n(keybind-1)\n}}}\n\n\n* キーバインドを設定する②\n\n{{{\n(ql:quickload :ltk)\n\n(defpackage :ltkdoc-bind\n  (:use :common-lisp :ltk))\n\n(in-package :ltkdoc-bind)\n\n(defun scribble ()\n  (with-ltk ()\n    (wm-title *tk* \"Bindのテスト\")\n\n    ;;オブジェクト定義\n    (let* ((msg (make-instance 'message\n                               :text \"Ctrl-r 赤色、Ctrl-b 青色、 Ctrl-g 緑色、Alt-qで終了\"\n                               :width 1000\n                               :background \"#FFFFFF\"))\n           (stat (make-instance 'message\n                                :text \"\"\n                                :width 1000\n                                :background \"#FFFFFF\"))\n           (canvas (make-instance 'canvas :background :black))\n           (down nil)\n           (color :white))\n      (pack msg :side :top :fill :x)\n      (pack stat :side :top :fill :x)\n      (pack canvas)\n      ;;マウスボタン定義\n      (bind canvas\n            \"<ButtonPress-1>\"\n            (lambda (evt)\n              (setf down t)\n              (setf (text stat) \"<ButtonPress-1>\")\n              (itemConfigure canvas\n                             (create-oval canvas\n                                          (- (event-x evt) 10) (- (event-y evt) 10)\n                                          (+ (event-x evt) 10) (+ (event-y evt) 10))\n                             \"fill\" color)))\n      (bind canvas\n            \"<ButtonRelease-1>\"\n            (lambda (evt)\n              (declare (ignore evt))\n              (setf (text stat) \"<ButtonRelease-1>\")\n              (setf down nil)))\n      (bind canvas \n            \"<Motion>\"\n            (lambda (evt)\n              (when down\n                (setf (text stat) \"<ButtonPress-1> + <Motion>\")\n                (itemConfigure canvas\n                               (create-oval canvas\n                                            (- (event-x evt) 10) (- (event-y evt) 10)\n                                            (+ (event-x evt) 10) (+ (event-y evt) 10))\n                               \"outline\" color))))\n      ;;キーバインド定義\n      (bind *tk* \"<Alt-q>\"              ; 終了\n            (lambda (event)\n              (declare (ignore event))\n              (setf *exit-mainloop* t)))\n      (bind *tk* \"<Control-b>\"          ; 青色にする\n            (lambda (event)\n              (declare (ignore event))\n              (configure canvas :background :blue)))\n      (bind *tk* \"<Control-r>\"          ; 赤色にする\n            (lambda (event)\n              (declare (ignore event))\n              (configure canvas :background :red)))\n      (bind *tk* \"<Control-g>\"          ; 緑色にする\n            (lambda (event)\n              (declare (ignore event))\n              (configure canvas :background :green))))))\n\n(scribble)\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae and 1=1" . "(1656001219)")
(" %Tag:local-time') as tempxtestxtable where 1=2-- -" . "(1660041713)")
("マクロの展開結果のgensymを通常のシンボルに置き換える" . "(:ctime 1385900140 :cuser #f :mtime 1385983090 :muser #f)大きな展開結果のマクロをデバッグする場合、展開結果の全体や一部を直接実行したいことがあります。~%\nしかし、展開結果に[[$$hs gensym]]が混っていると色々と厄介です。~%\nこの様な場合、[[$$hs *print-gensym*]]を[[$$hs nil]]にすることにより結果から[[$$hs gensym]]の#:を取り除くことが可能です。~%\n(ただし、シンボルそのものを置き換えるわけではなく、印字表現を得るのみです)\n\n{{{\n(prin1-to-string\n (macroexpand '(loop :repeat 100 :do (print 'hello))))\n;=>  \"(BLOCK NIL\n;      (LET ((#:LOOP-REPEAT-3100 (CEILING 100)))\n;        (DECLARE (TYPE INTEGER #:LOOP-REPEAT-3100))\n;        (SB-LOOP::LOOP-BODY NIL\n;                            ((IF (<= #:LOOP-REPEAT-3100 0)\n;                                 (GO SB-LOOP::END-LOOP)\n;                                 (DECF #:LOOP-REPEAT-3100)))\n;                            ((PRINT 'HELLO))\n;                            ((IF (<= #:LOOP-REPEAT-3100 0)\n;                                 (GO SB-LOOP::END-LOOP)\n;                                 (DECF #:LOOP-REPEAT-3100)))\n;                            NIL)))\"\n}}}\n\n- [[$$hs *print-gensym*]]をnilにすれば、#:が印字されない\n\n{{{\n(let ((*print-gensym* nil))\n  (prin1-to-string (macroexpand '(loop :repeat 100 :do (print 'hello)))))\n;=>  \"(BLOCK NIL\n;      (LET ((LOOP-REPEAT-3099 (CEILING 100)))\n;        (DECLARE (TYPE INTEGER LOOP-REPEAT-3099))\n;        (SB-LOOP::LOOP-BODY NIL\n;                            ((IF (<= LOOP-REPEAT-3099 0)\n;                                 (GO SB-LOOP::END-LOOP)\n;                                 (DECF LOOP-REPEAT-3099)))\n;                            ((PRINT 'HELLO))\n;                            ((IF (<= LOOP-REPEAT-3099 0)\n;                                 (GO SB-LOOP::END-LOOP)\n;                                 (DECF LOOP-REPEAT-3099)))\n;                            NIL)))\"\n}}}\n\n*** slime/swankでの応用\nswankでは、swank::*macroexpand-printer-bindings* で印字時に束縛する変数を指定できますのでこれを利用して\"#:\"が印字されない展開結果を表示するコマンドも作れるでしょう。\n{{{\n(defun swank-macroexpand-all/no-gensym (form)\n  (let ((swank::*macroexpand-printer-bindings*\n         (cons '(*print-gensym*)\n               swank::*macroexpand-printer-bindings* ) ))\n    (swank:swank-macroexpand-all form) ))\n}}}\n{{{\n;;; emacs\n(defun slime-macroexpand-all/no-gensym ()\n  (interactive)\n  (slime-eval-macroexpand 'swank-macroexpand-all/no-gensym))\n}}}\n")
(" %Tag:local-time) and 1=2 and (2=2" . "(1660041710)")
("新規ページ作成の手順" . "(:ctime 1227422988 :cuser #f :mtime 1228111845 :muser #f)* 新規ページ作成の手順\n# 項目のページに新しいエントリを作成します。\n{{{\n[[文字列を複製]] \n}}}\n# ?をクリックして編集を開始します。\n# 雛型を参考に作成します。ライブラリを利用する場合は、ライブラリ名と「ライブラリ」タグをタグ名に追加します。\n{{{\n[[$$tag タグ名 ライブラリ名 ライブラリ]]\n* タイトル\n\n...\n}}}\n* 項目だけ作成して、内容は募集したい場合\nタグに【募集中】といれます。\n{{{\n[[$$tag タグ【募集中】]]\n* タイトル\n\n...\n}}}\n* 参考文献\n1文献1ページとし、タグに 参考文献 といれます。\n{{{\n[[$$tag 参考文献]]\nドキュメント/書籍の説明 ...\n...\n}}}\n* HyperSpec へのリンク\n{{{\n[[$$hs format]]\n}}}\nのように書くとHyperSpecへのリンクになります。\n同様に\n{{{\n[[$$mop compute-slots]]\n}}}\nと書くと、MOPへのリンクになります。\n\n")
(" %Tag:asdf" . "(1667934011 (\"asdf-installでインストールできるもの\" :ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f))")
(" %Tag:fare-utils?Tag?Tag?Tag:fare-utils?Tag?Tag" . "(1491336896)")
(" %Tag:local-time' and 1=1 and 'a'='a" . "(1660041668)")
(" %Tag:配列1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45) -- /* order by 'as /*" . "(1624124620)")
(" %Tag:?????2121121121212.1" . "(1584214734)")
("loop:指定値までの繰り返し" . "(:ctime 1336291343 :cuser #f :mtime 1336291343 :muser #f)* 指定値までの繰り返し\n[[$$tag 制御構造]]\n{{{\n;; この例では、3から5まで繰り返します。\n(loop :for i :from 3 :upto 5 :do (print i))\n;-> 3\n    4\n    5\n;=> nil\n}}}\n{{{\n;; この例では、5から3まで繰り返します。\n(loop :for i :from 5 :downto 3 :do (print i))\n;-> 5\n    4\n    3\n;=> nil\n}}}\n{{{\n;; この例では、リストの要素が3を超えるまで繰り返します。\n(loop for i in '(1 2 3 4 5) until (< 3 i) collect i)\n;=> (1 2 3)\n}}}\n")
(" %Tag:%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae') and 1=1#" . "(1656001237)")
