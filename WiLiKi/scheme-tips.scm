(" %Tag:FIXME?Tag?Tag:FIXME?Tag" . "(1476573974)")
(" %Tag:日付と時刻" . "(1668192347 (\"日付と時刻\" :ctime 1227248209 :cuser #f :mtime 1307027816 :muser #f) (\"日付に対する加算\" :ctime 1227429056 :cuser #f :mtime 1227669157 :muser #f) (\"月の最後の日を調べる\" :ctime 1227429229 :cuser #f :mtime 1227429229 :muser #f) (\"日付の曜日を日本語で出力する\" :ctime 1227428927 :cuser #f :mtime 1227428927 :muser #f) (\"現在の日付を調べる\" :ctime 1227428862 :cuser #f :mtime 1227428862 :muser #f))")
(" %Tag:制御構造" . "(1668271418 (\"ループを記述する\" :ctime 1229916880 :cuser #f :mtime 1230388452 :muser #f) (\"確実に後処理を行なう\" :ctime 1228880199 :cuser #f :mtime 1228953202 :muser #f))")
("リストから要素を取り出す" . "(:ctime 1227501516 :cuser #f :mtime 1228349850 :muser #f)[[$$tag リスト R6RS SRFI]]\n\nリストの n 番目の要素を参照するには [[$$r6rs list-ref]] 手続きを使う。\n\n{{{\n(import (rnrs))\n\n(define xs '(0 1 2 3 4 5))\n\n(list-ref xs 0) ; => 0\n(list-ref xs 4) ; => 4\n}}}\n\nまた SRFI-1 には first から tenth までのリスト参照手続きが用意されている。\n\n{{{\n(import (rnrs) (except (srfi :1) map for-each fold-right assoc member remove))\n\n(first '(1 2 3)) ; => 1\n(nineth '(1 3 5 7 9 11 13 15 17 19 21)) ; => 19\n}}}\n\nリストを cons セルの列なりや木構造として考える場合には [[$$r6rs car]], [[$$r6rs cdr]], [[$$r6rs caar]] といった手続きを使うことが多い。\n{{{\n(import (rnrs))\n\n(car '(a b)) => a\n(caar '((a 1) (b 2) (c 3)) ; => a\n}}}\n")
("リストから重複した要素を取り除く" . "(:ctime 1227608876 :cuser #f :mtime 1228802710 :muser #f)[[$$tag リスト R6RS SRFI]]\n\n[[$$srfi 1]] の delete-duplicates や delete-duplicates! を使う。 delete-duplicates! は引数として与えられたリストを変更することがあるので注意。\n\n{{{\n(import (rnrs) (only (srfi :1) delete-duplicates delete-duplicates!))\n\n(delete-duplicates '(\"abc\" \"cba\" \"abc\")) ; => (\"abc\" \"cba\")\n(delete-duplicates '(a b c a a b a c) eq?) ; => (a b c)\n(delete-duplicates! '(a a a) eq?) ; => maybe &assertion or (a)\n}}}\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45) -- /* order by \"as /*" . "(1624116729)")
(" %Tag:スレッド\" and \"x\"=\"x" . "(1624115904)")
(" %Tag:FIXME" . "(1668130536 (\"CGI を作る\" :ctime 1282540225 :cuser #f :mtime 1296491816 :muser #f) (\"文字列を Base64 エンコードする\" :ctime 1229176092 :cuser #f :mtime 1238220404 :muser #f) (\"文字列を分割する\" :ctime 1230369695 :cuser #f :mtime 1230908706 :muser #f) (\"文字列のエンコーディングを変換する\" :ctime 1228799761 :cuser #f :mtime 1228799761 :muser #f))")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 638 #" . "(1624116960)")
("レコード型の詳細を隠蔽する" . "(:ctime 1233358166 :cuser #f :mtime 1233358167 :muser #f)[[$$tag R6RS レコード]]\n\n[[$$r6rs define-record-type]] 中で opaque 属性に #t を指定するとそのレコード型は不透明になり、ために、 [[$$r6rs record-rtd]] 手続きに対して例外を発生させるようになり、事実上  (rnrs records inspection) ライブラリの手続きが適用できなくなる。\n\n{{{\n(import (rnrs))\n\n(define-record-type point\n  (opaque #t)\n  (fields\n   (mutable x)\n   (mutable y)))\n\n(define p (make-point 0 0))\n\n(record? p) ; => #f\n(record-rtd p) ; => &assertion\n}}}\n\n一方で、 (rnrs records syntactic) の [[$$r6rs record-type-descriptor]] 構文を用いれば、不透明な構造体からもレコード型記述子を取り出せるため、レコード型の詳細を完全に隠蔽するためには構造体名をライブラリを使って非公開にしなければならない。\n{{{\n(import (rnrs))\n\n(define-record-type point\n  (opaque #t)\n  (fields\n   (mutable x)\n   (mutable y)))\n\n(define p (make-point 0 0))\n\n(record-type-name (record-type-descriptor point)) ; => point\n}}}\n\n{{{\n(library (foo)\n  (export make-point) ; not export record type name\n  (import (rnrs))\n\n  (define-record-type point\n    (opaque #t)\n    (fields\n     (mutable x)\n     (mutable y)))\n  )\n\n(import (rnrs) (foo))\n\n(define p (make-point 0 0))\n\n(record-type-name\n (record-type-descriptor point) ; => &syntax\n )\n}}}\n")
(" %Tag:SRFI?p=Tag:SRFI" . "(1467037244)")
("名前を変更して import する" . "(:ctime 1227883697 :cuser #f :mtime 1228348785 :muser #f)[[$$tag ライブラリ R6RS]]\n\n名前を変更して [[$$r6rs import]] するには rename 節を使う。\n\n{{{\n(import (rnrs)\n\t(rename (srfi :61)\n\t\t(cond general-cond)))\n}}}\n\n単純に識別子に接頭辞をつけたい場合には prefix 節が使える。\n\n{{{\n(import (rnrs)\n\t(prefix (srfi :71) srfi-71:))\n}}}\n")
(" %Tag:FIXME\" and \"x\"=\"y" . "(1581247074)")
("ソースファイルの拡張子" . "(:ctime 1232012254 :cuser #f :mtime 1232012254 :muser #f)[[$$tag R6RS]]\n\n慣習として用途ごとに様々な拡張子が使われる。\n\n* トップレベルプログラム\n:.sch: '''Sch'''eme\n:.scm: '''Sc'''he'''m'''e\n:.ss: '''S'''cheme '''S'''ource\n:.sps: R6RS '''S'''cheme '''P'''rogram '''S'''ource\n\n* ライブラリ\n:.sls: R6RS '''S'''cheme '''L'''ibrary '''S'''ource\n")
(" %Tag:レコード" . "(1668301332 (\"レコードの初期化をカスタマイズする\" :ctime 1233362979 :cuser #f :mtime 1233538776 :muser #f) (\"レコード型を定義する\" :ctime 1233379492 :cuser #f :mtime 1233537295 :muser #f) (\"レコード型を拡張する\" :ctime 1233383241 :cuser #f :mtime 1233383241 :muser #f) (\"レコード\" :ctime 1233356925 :cuser #f :mtime 1233365578 :muser #f) (\"レコード型の詳細を調べる\" :ctime 1233365564 :cuser #f :mtime 1233365565 :muser #f) (\"レコード型を拡張できないようにする\" :ctime 1233357230 :cuser #f :mtime 1233358211 :muser #f) (\"レコード型の詳細を隠蔽する\" :ctime 1233358166 :cuser #f :mtime 1233358167 :muser #f))")
(" %Tag:HTML'[0]" . "(1660729120)")
("ファイルに追記する" . "(:ctime 1227427711 :cuser #f :mtime 1227427711 :muser #f)[[$$tag 入出力 R6RS]]\n\n* ファイルに追記する\n\nファイルを入出力両用ポートとして開き、 get-string-all / get-bytevector-all 手続きでファイル位置をファイル終端に移動させてから書き込みを行なう。\n\n{{{\n(import (rnrs))\n\n(call-with-port\n  (open-file-input/output-port\n    \"/path/to/text\"\n    (file-options no-fail no-truncate)\n    (buffer-mode block)\n    (make-transcoder (latin-1-codec)))\n  (lambda (port)\n    (get-string-all port)\n    (put-string port \"\\nabc\\n\")))\n}}}\n")
("CPUのエンディアンを調べる" . "(:ctime 1229999208 :cuser #f :mtime 1230013773 :muser #f)[[$$tag プラットフォーム固有の情報]]\n\n(rnrs bytevectors) の[[$$r6rs native-endianness]]によりbig endianかlittle endianかを知ることができる。\n\n{{{\n(import (rnrs bytevectors))\n\n(native-endianness)\n;=> おそらくbigかlittle\n}}}\n\nただし、big, little以外の値が返らないことが保証されているわけではない。\n(例えばARMはモードによってdoubleをbig endianでもlittle endiandでもない\n形式で格納することがあるが、そういう場合にnative-endiannessがどういう\nシンボルを返すべきかは規定されていない。 Cf. [http://www.r6rs.org/formal-comments/comment-58.txt R6RS Formal comment #58])\n\nより正確にメモリ上の表現を知りたい場合は、\n[[$$r6rs bytevector-u32-native-ref]]や\n[[$$r6rs bytevector-ieee-double-native-ref]]などを使って\nバイトベクタによるネイティブ表現を直接読み書きすれば良い。\n")
("特定の識別子だけを import する" . "(:ctime 1227883231 :cuser #f :mtime 1228348833 :muser #f)[[$$tag ライブラリ R6RS]]\n\n特定の識別子だけを [[$$r6rs import]] するには import の only 節に所望の名前を列挙する。\n\n{{{\n(import (only (srfi :13) string-trim))\n}}}\n\n特定の識別子だけを import 対象から除外したい場合には except 節を使う。\n\n{{{\n(import (except (rnrs) equal?)\n\t(srfi :47))\n}}}\n")
(" %Tag:SXML99999\" union select unhex(hex(version())) -- \"x\"=\"x" . "(1573238434)")
("入出力" . "(:ctime 1227408592 :cuser #f :mtime 1228778293 :muser #f)[[$$tag 入出力]]\n\n- [[ファイルを開く]]\n- [[ポートを閉じる]]\n- [[バイナリポートをテキストポートに変換する]]\n- [[ファイルに追記する]]\n- [[データを読み書きする]]\n")
(" %Tag:HTML99999' union select unhex(hex(version())) -- 'x'='x" . "(1582392997)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45) --  /*" . "(1624116002)")
(" %Tag:スレッド'/**/AND/**/SlEEp(3)/**/AND/**/'1" . "(1624116795)")
("確実に後処理を行なう" . "(:ctime 1228880199 :cuser #f :mtime 1228953202 :muser #f)[[$$tag R6RS 例外処理 制御構造 マクロ]]\n\nファイルを開いた場合やネットワークに接続した場合、例外が発生した場合でもその後処理を確実に行ないたいことがある。そのような場合、 [[$$r6rs with-exception-handler]] を使い例外ハンドラの内部でも後処理を行なうようにしておけばよい。\n\n{{{\n(let ((p (open-file-input-port \"foo\")))\n  (with-exception-handler\n      (lambda (e)\n\t(cond ((non-continuable-violation? e)\n\t       (close-port p)\n\t       (raise e))\n\t      (else\n\t       (raise-continuable e))))\n    (lambda ()\n      (let-values ((v (some-procedure p)))\n\t(close-port p)\n\t(apply values v)))))\n}}}\n\nこれは定型的な処理なのでマクロ化しておくとよい。\n\n{{{\n(define-syntax unwind-protect\n  ((_ body cleanup ...)\n   (with-exception-handler\n       (lambda (e)\n         (cond ((non-continuable-violation? e)\n\t\tcleanup\n\t\t...\n\t\t(raise e))\n\t       (else\n\t\t(raise-continuable e))))\n     (lambda ()\n       (let-values ((v body))\n\t cleanup\n\t ...\n\t (apply values v))))))\n}}}\n\nすると次のように書ける。\n\n{{{\n(let ((p (open-file-input-port \"foo\")))\n  (unwind-protect\n      (begin (some-procedure p))\n    (close-port p)))\n}}}\n\nただし、ポートに関する処理について言えば [[$$r6rs call-with-port]] を使った方がよい。\n\n{{{\n(call-with-port (open-file-input-port \"foo\")\n  (lambda (p)\n    (some-procedure p)))\n}}}\n\nまたちなみに、 [[$$r6rs raise]] によって起動される例外ハンドラは raise を呼び出した場所での動的存続期間で起動されるため、 [[$$r6rs dynamic-wind]] によって例外に対応することはできない。\n\n{{{\n;; XXX: うまく動かない\n(let ((p (open-file-input-port \"foo\")))\n  (dynamic-wind\n    (lambda () #f)\n    (lambda () (some-procedure p))\n    (lambda () (close-port p))))\n}}}\n\n[[$$r6rs dynamic-wind]]で後始末をすることのもうひとつの問題点は、\n[[$$r6rs call/cc]]と[[$$r6rs dynamic-wind]]の組み合わせは\ndynamic-windの中に再び戻ってくるような用途にも使われるということだ\n(例えばユーザレベルのコルーチンやスレッドなど)。dynamic-windの\nafter-thunkで不可逆的な後始末をしてしまうと、再びbody-thunkに\n戻って処理を続行することが出来なくなってしまう。\ndynamic-windのbefore/after thunkの処理は動的環境の一貫性を\n保つこと(例えばbody thunkにおけるactive exception handlerのすげ替えなど)に\n限定し、後始末などは上位の機構であるwith-exception-handlerや[[$$r6rs guard]]に\n任せるのが良い。\n\n")
("CPUのワードサイズを調べる" . "(:ctime 1229998776 :cuser #f :mtime 1229999415 :muser #f)[[$$tag プラットフォーム固有の情報]]\n\n規格上はメモリが許す限りどんなに大きい正確な整数値もシームレスに扱えなければならないので、CPUのワードサイズはプログラムから見えないように隠されている。ポータブルにワードサイズを調べる方法はない。\n\nしかし、多くの処理系では性能のために、小さな整数はヒープではなくタグ付きワードの中に直接置かれる。ヒープに置かれる多倍長整数bignumに対して小さな整数をfixnumと呼ぶ。通常、fixnumはCPUのワード長からタグのための数ビット(1〜3bitであることが多い)を引いたビット数を使う。\n\nR6RSではこのfixnumのビット数を得ることができる : [[$$r6rs fixnum-width]]\n{{{\n(import (rnrs))\n\n(fixnum-width)\n;; => 29 など\n}}}\n\nこの値が29,30,31などの場合は32bit CPUである可能性が、\n61, 62, 63などの場合は64bit CPUである可能性が高い。\n(但し、絶対にそうだと言いきれる保証はない。また処理系によっては\nタグにより多くのビット数を割いている可能性もある)。\n\n")
("InterWikiName" . "(:ctime 1228480859 :cuser #f :mtime 1237040483 :muser #f):WiLiKi:practical-scheme.net/wiliki/wiliki.cgi?p=\n:wikipedia-en:en.wikipedia.org/wiki/\n:wikipedia-ja:ja.wikipedia.org/wiki/\n")
(" %Tag:ハッシュ" . "(1297243474)")
(" %Tag:FIXME and 1>1" . "(1581247072)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45) -- /* order by 'as /*" . "(1624116410)")
(" %Tag:プラットフォーム固有の情報" . "(1668092676 (\"CPUのエンディアンを調べる\" :ctime 1229999208 :cuser #f :mtime 1230013773 :muser #f) (\"CPUのワードサイズを調べる\" :ctime 1229998776 :cuser #f :mtime 1229999415 :muser #f) (\"プラットフォームに関する情報を得る\" :ctime 1229997881 :cuser #f :mtime 1229998838 :muser #f))")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45) -- /* order by \"as /*" . "(1624116564)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 1 #" . "(1624116818)")
(" %Tag:スレッド99999\" union select unhex(hex(version())) -- \"x\"=\"x" . "(1624117090)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45) -- /* order by 'as /*" . "(1624116420)")
(" %Tag:R6RS" . "(1668183722 (\"CGI を作る\" :ctime 1282540225 :cuser #f :mtime 1296491816 :muser #f) (\"XML を処理する\" :ctime 1282540270 :cuser #f :mtime 1282540270 :muser #f) (\"末尾呼び出しの最適化\" :ctime 1228157227 :cuser #f :mtime 1264385826 :muser #f) (\"文字列を数値に変換する\" :ctime 1227425885 :cuser #f :mtime 1240391591 :muser #f) (\"文字列を Base64 エンコードする\" :ctime 1229176092 :cuser #f :mtime 1238220404 :muser #f) (\"エンディアンを変換する\" :ctime 1234244573 :cuser #f :mtime 1234244574 :muser #f) (\"レコードの初期化をカスタマイズする\" :ctime 1233362979 :cuser #f :mtime 1233538776 :muser #f) (\"レコード型を定義する\" :ctime 1233379492 :cuser #f :mtime 1233537295 :muser #f) (\"レコード型を拡張する\" :ctime 1233383241 :cuser #f :mtime 1233383241 :muser #f) (\"レコード\" :ctime 1233356925 :cuser #f :mtime 1233365578 :muser #f) (\"レコード型の詳細を調べる\" :ctime 1233365564 :cuser #f :mtime 1233365565 :muser #f) (\"レコード型を拡張できないようにする\" :ctime 1233357230 :cuser #f :mtime 1233358211 :muser #f) (\"レコード型の詳細を隠蔽する\" :ctime 1233358166 :cuser #f :mtime 1233358167 :muser #f) (\"R6RS と SRFI で非互換な点\" :ctime 1227638827 :cuser #f :mtime 1233287037 :muser #f) (\"コンディションを合成する\" :ctime 1233267797 :cuser #f :mtime 1233267797 :muser #f) (\"コンディションを定義する\" :ctime 1233267117 :cuser #f :mtime 1233267156 :muser #f) (\"例外を発生させる\" :ctime 1233265934 :cuser #f :mtime 1233265935 :muser #f) (\"例外を補足する\" :ctime 1233259568 :cuser #f :mtime 1233265370 :muser #f) (\"コンディション\" :ctime 1228790694 :cuser #f :mtime 1233265097 :muser #f) (\"ベクタの各要素に手続きを適用する\" :ctime 1233088003 :cuser #f :mtime 1233088003 :muser #f) (\"リストを定義する\" :ctime 1227502058 :cuser #f :mtime 1233062123 :muser #f) (\"ベクタの内容を変更する\" :ctime 1233021648 :cuser #f :mtime 1233021876 :muser #f) (\"ベクタから要素を探す\" :ctime 1233014179 :cuser #f :mtime 1233018921 :muser #f) (\"ベクタをソートする\" :ctime 1233018720 :cuser #f :mtime 1233018720 :muser #f) (\"ベクタから要素を取り出す\" :ctime 1233013310 :cuser #f :mtime 1233013310 :muser #f) (\"ベクタの要素数を取得する\" :ctime 1233013066 :cuser #f :mtime 1233013066 :muser #f) (\"ベクタをリストに変換する\" :ctime 1233012569 :cuser #f :mtime 1233012569 :muser #f) (\"ベクタを作成する\" :ctime 1233011767 :cuser #f :mtime 1233011767 :muser #f) (\"識別子の命名規約\" :ctime 1227637244 :cuser #f :mtime 1232676886 :muser #f) (\"識別子を生成する\" :ctime 1232448535 :cuser #f :mtime 1232448535 :muser #f) (\"ソースファイルの拡張子\" :ctime 1232012254 :cuser #f :mtime 1232012254 :muser #f) (\"処理系依存部分のあるライブラリを書く\" :ctime 1231150071 :cuser #f :mtime 1231249974 :muser #f) (\"ライブラリ\" :ctime 1227882981 :cuser #f :mtime 1231150135 :muser #f) (\"リストの各要素に手続きを適用する\" :ctime 1230927390 :cuser #f :mtime 1231011574 :muser #f) (\"文字列を分割する\" :ctime 1230369695 :cuser #f :mtime 1230908706 :muser #f) (\"ループを記述する\" :ctime 1229916880 :cuser #f :mtime 1230388452 :muser #f) (\"文字列を URI エンコードする\" :ctime 1228696992 :cuser #f :mtime 1230361031 :muser #f) (\"環境変数を取得する\" :ctime 1230276136 :cuser #f :mtime 1230343874 :muser #f) (\"循環リストを使う\" :ctime 1230320100 :cuser #f :mtime 1230322530 :muser #f) (\"状態機械を書く\" :ctime 1230242609 :cuser #f :mtime 1230316779 :muser #f) (\"手続き\" :ctime 1227355895 :cuser #f :mtime 1230242707 :muser #f) (\"リストをソートする\" :ctime 1229597489 :cuser #f :mtime 1229597489 :muser #f) (\"簡単なリスト用のループマクロの例\" :ctime 1228352098 :cuser #f :mtime 1229595593 :muser #f) (\"マクロを定義するマクロ\" :ctime 1229501665 :cuser #f :mtime 1229507234 :muser #f) (\"マクロ展開時に計算処理を行なう\" :ctime 1229058729 :cuser #f :mtime 1229058729 :muser #f) (\"引数のリストに手続きを適用する\" :ctime 1229044401 :cuser #f :mtime 1229050131 :muser #f) (\"確実に後処理を行なう\" :ctime 1228880199 :cuser #f :mtime 1228953202 :muser #f) (\"コマンドライン引数を解析する\" :ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f) (\"エラーを通知する\" :ctime 1228790688 :cuser #f :mtime 1228878329 :muser #f) (\"手続きの仮引数として正しい形式か検査する\" :ctime 1228837883 :cuser #f :mtime 1228837883 :muser #f) (\"非真正リストを真正リストに変換する\" :ctime 1228837296 :cuser #f :mtime 1228837456 :muser #f) (\"複数の手続きで状態を共有する\" :ctime 1228299113 :cuser #f :mtime 1228835061 :muser #f) (\"文字列の先頭・末尾の空白を削除する\" :ctime 1227425646 :cuser #f :mtime 1228802815 :muser #f) (\"リストから重複した要素を取り除く\" :ctime 1227608876 :cuser #f :mtime 1228802710 :muser #f) (\"文字列のエンコーディングを変換する\" :ctime 1228799761 :cuser #f :mtime 1228799761 :muser #f) (\"データを読み書きする\" :ctime 1228778287 :cuser #f :mtime 1228784319 :muser #f) (\"プログラムを終了させる\" :ctime 1228701545 :cuser #f :mtime 1228701546 :muser #f) (\"コマンドライン引数を取得する\" :ctime 1228701025 :cuser #f :mtime 1228701026 :muser #f) (\"マクロの引数の検査\" :ctime 1228352845 :cuser #f :mtime 1228352846 :muser #f) (\"一時識別子の生成\" :ctime 1228352724 :cuser #f :mtime 1228352724 :muser #f) (\"anaphoric if\" :ctime 1228352551 :cuser #f :mtime 1228352611 :muser #f) (\"quasisyntax を使う\" :ctime 1228352468 :cuser #f :mtime 1228352468 :muser #f) (\"構文キーワード\" :ctime 1228352274 :cuser #f :mtime 1228352274 :muser #f) (\"XPath を使う\" :ctime 1228228236 :cuser #f :mtime 1228351743 :muser #f) (\"リストから要素を取り出す\" :ctime 1227501516 :cuser #f :mtime 1228349850 :muser #f) (\"リストの要素数を取得する\" :ctime 1227501083 :cuser #f :mtime 1228349764 :muser #f) (\"リストから要素を探す\" :ctime 1227502775 :cuser #f :mtime 1228349669 :muser #f) (\"リストを逆順にする\" :ctime 1227503090 :cuser #f :mtime 1228349551 :muser #f) (\"連想リストを使う\" :ctime 1227505307 :cuser #f :mtime 1228349479 :muser #f) (\"リストを結合する\" :ctime 1227532498 :cuser #f :mtime 1228349286 :muser #f) (\"リストを作成する\" :ctime 1227500527 :cuser #f :mtime 1228349150 :muser #f) (\"特定の識別子だけを import する\" :ctime 1227883231 :cuser #f :mtime 1228348833 :muser #f) (\"名前を変更して import する\" :ctime 1227883697 :cuser #f :mtime 1228348785 :muser #f) (\"名前を変更して export する\" :ctime 1227884232 :cuser #f :mtime 1228348740 :muser #f) (\"R5RS ライブラリを R6RS ライブラリに加工する\" :ctime 1227885126 :cuser #f :mtime 1228348606 :muser #f) (\"コメント\" :ctime 1227924794 :cuser #f :mtime 1228348546 :muser #f) (\"変数\" :ctime 1227920472 :cuser #f :mtime 1228348417 :muser #f) (\"手続きを作成する\" :ctime 1228154104 :cuser #f :mtime 1228348278 :muser #f) (\"省略可能引数のある手続き\" :ctime 1228154387 :cuser #f :mtime 1228348185 :muser #f) (\"複数の値を返す手続き\" :ctime 1228154452 :cuser #f :mtime 1228348136 :muser #f) (\"ループから脱出する\" :ctime 1228303091 :cuser #f :mtime 1228347944 :muser #f) (\"HTML を処理する\" :ctime 1228218142 :cuser #f :mtime 1228237475 :muser #f) (\"数値を文字列に変換する\" :ctime 1227864472 :cuser #f :mtime 1228202563 :muser #f) (\"手続きを返す手続きを書く\" :ctime 1228154284 :cuser #f :mtime 1228160726 :muser #f) (\"状態を持った手続きを作る\" :ctime 1228154331 :cuser #f :mtime 1228154331 :muser #f) (\"引数を一部固定した手続きを作る\" :ctime 1228154185 :cuser #f :mtime 1228154236 :muser #f) (\"文字列を結合する\" :ctime 1227424944 :cuser #f :mtime 1227811722 :muser #f) (\"日付に対する加算\" :ctime 1227429056 :cuser #f :mtime 1227669157 :muser #f) (\"ハッシュテーブル内に値があるかどうか確認する\" :ctime 1227601455 :cuser #f :mtime 1227602965 :muser #f) (\"ハッシュテーブルの内容を取得する\" :ctime 1227602654 :cuser #f :mtime 1227602655 :muser #f) (\"ハッシュテーブルのキーの一覧を取得する\" :ctime 1227602553 :cuser #f :mtime 1227602554 :muser #f) (\"変更不可能なハッシュテーブルを作成する\" :ctime 1227602439 :cuser #f :mtime 1227602440 :muser #f) (\"ハッシュテーブルを複製する\" :ctime 1227602195 :cuser #f :mtime 1227602196 :muser #f) (\"ハッシュテーブルを空にする\" :ctime 1227602126 :cuser #f :mtime 1227602127 :muser #f) (\"ハッシュテーブルに値を設定する\" :ctime 1227601175 :cuser #f :mtime 1227602027 :muser #f) (\"ハッシュテーブルの値を参照する\" :ctime 1227601383 :cuser #f :mtime 1227601995 :muser #f) (\"キーに対応する値を更新する\" :ctime 1227601795 :cuser #f :mtime 1227601928 :muser #f) (\"ハッシュテーブルの要素を削除する\" :ctime 1227601889 :cuser #f :mtime 1227601889 :muser #f) (\"ハッシュテーブルを作成する\" :ctime 1227601018 :cuser #f :mtime 1227601255 :muser #f) (\"乱数を生成する\" :ctime 1227510174 :cuser #f :mtime 1227510174 :muser #f) (\"月の最後の日を調べる\" :ctime 1227429229 :cuser #f :mtime 1227429229 :muser #f) (\"日付の曜日を日本語で出力する\" :ctime 1227428927 :cuser #f :mtime 1227428927 :muser #f) (\"現在の日付を調べる\" :ctime 1227428862 :cuser #f :mtime 1227428862 :muser #f) (\"文字列を一行づつ処理する\" :ctime 1227425501 :cuser #f :mtime 1227428351 :muser #f) (\"ファイルに追記する\" :ctime 1227427711 :cuser #f :mtime 1227427711 :muser #f) (\"バイナリポートをテキストポートに変換する\" :ctime 1227427432 :cuser #f :mtime 1227427432 :muser #f) (\"ポートを閉じる\" :ctime 1227427369 :cuser #f :mtime 1227427369 :muser #f) (\"ファイルを開く\" :ctime 1227427294 :cuser #f :mtime 1227427295 :muser #f) (\"計算結果を分数から小数にしたい\" :ctime 1227426282 :cuser #f :mtime 1227426282 :muser #f) (\"文字とUnicodeスカラー値を相互変換する\" :ctime 1227425943 :cuser #f :mtime 1227425944 :muser #f) (\"文字列を一文字づつ処理する\" :ctime 1227425322 :cuser #f :mtime 1227425322 :muser #f) (\"部分文字列を取り出す\" :ctime 1227425232 :cuser #f :mtime 1227425233 :muser #f) (\"複数行の文字列を作成する\" :ctime 1227425167 :cuser #f :mtime 1227425167 :muser #f) (\"大文字と小文字を入れ替える\" :ctime 1227425090 :cuser #f :mtime 1227425090 :muser #f) (\"大文字・小文字に揃える\" :ctime 1227425017 :cuser #f :mtime 1227425018 :muser #f))")
("文字列を Base64 エンコードする" . "(:ctime 1229176092 :cuser #f :mtime 1238220404 :muser #f)[[$$tag R6RS 文字列 Web FIXME]]\n\n[[wikipedia-ja:Base64]]\n\n* エンコード\n\n{{{\n(import\n  (rnrs base)\n  (rnrs io ports)\n  (rnrs io simple)\n  (rnrs bytevectors)\n  (rnrs control)\n  (rename (rnrs arithmetic bitwise)\n    (bitwise-and &&)\n    (bitwise-ior !!)\n    (bitwise-arithmetic-shift-left <<)\n    (bitwise-arithmetic-shift-right >>)))\n\n(define (base64-encode str)\n  (define base64chars \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n  (define hex->base64char\n    (lambda (b) (if (<= 0 b #x3F) (string-ref base64chars b) #\\?)))\n  (define filter\n    (lambda (in out)\n      (let* ((b1 (get-u8 in)) (b2 (get-u8 in)) (b3 (get-u8 in)))\n        (cond\n          ((eof-object? b1))\n          ((eof-object? b2)\n            (put-char out (hex->base64char (&& #x3F (>> b1 2))))\n            (put-char out (hex->base64char (&& #x30 (<< b1 4))))\n            (put-char out #\\=)\n            (put-char out #\\=))\n          ((eof-object? b3)\n            (put-char out (hex->base64char (&& #x3F (>> b1 2))))\n            (put-char out (hex->base64char (!! (&& #x30 (<< b1 4)) (&& #x0F (>> b2 4)))))\n            (put-char out (hex->base64char (&& #x3C (<< b2 2))))\n            (put-char out #\\=))\n          (else\n            (put-char out (hex->base64char (&& #x3F (>> b1 2))))\n            (put-char out (hex->base64char (!! (&& #x30 (<< b1 4)) (&& #x0F (>> b2 4)))))\n            (put-char out (hex->base64char (!! (&& #x3C (<< b2 2)) (&& #x03 (>> b3 6)))))\n            (put-char out (hex->base64char (&& #x3F b3)))\n            (filter in out))))))\n  (call-with-port (open-bytevector-input-port (string->utf8 str))\n    (lambda (in)\n      (call-with-string-output-port\n        (lambda (out) (filter in out))))))\n\n(base64-encode \"逆引き Scheme\") ; => \"6YCG5byV44GNIFNjaGVtZQ==\"\n}}}\nあるいは、\n{{{\n(import (rename (rnrs)\n\t\t(bitwise-and &&)\n\t\t(bitwise-ior !!)\n\t\t(bitwise-arithmetic-shift-left <<)\n\t\t(bitwise-arithmetic-shift-right >>)))\n\n(define (base64-encode str)\n  (define base64-chars \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                        abcdefghijklmnopqrstuvwxyz\\\n                        0123456789+/\")\n  (define (hex->base64-char b)\n    (if (<= 0 b #x3f) (string-ref base64-chars b) #\\?))\n  (call-with-port (open-bytevector-input-port (string->utf8 str))\n    (lambda (in)\n      (call-with-string-output-port\n\t(lambda (out)\n\t  (define (s1 b1)\n\t    (unless (eof-object? b1)\n\t      (put-char out (hex->base64-char (&& #b00111111 (>> b1 2))))\n\t      (s2 b1 (get-u8 in))))\n\t  (define (s2 b1 b2)\n\t    (cond ((eof-object? b2)\n\t\t   (put-char out (hex->base64-char (&& #b00110000 (<< b1 4))))\n\t\t   (put-char out #\\=)\n\t\t   (put-char out #\\=))\n\t\t  (else\n\t\t   (put-char out (hex->base64-char\n\t\t\t\t  (!! (&& #b00110000 (<< b1 4))\n\t\t\t\t      (&& #b00001111 (>> b2 4)))))\n\t\t   (s3 b2 (get-u8 in)))))\n\t  (define (s3 b2 b3)\n\t    (cond ((eof-object? b3)\n\t\t   (put-char out (hex->base64-char (&& #b00111100 (<< b2 2))))\n\t\t   (put-char out #\\=))\n\t\t  (else\n\t\t   (put-char out (hex->base64-char\n\t\t\t\t  (!! (&& #b00111100 (<< b2 2))\n\t\t\t\t      (&& #b00000011 (>> b3 6)))))\n\t\t   (put-char out (hex->base64-char (&& #b00111111 b3)))\n\t\t   (s1 (get-u8 in)))))\n\t  (s1 (get-u8 in)))))))\n}}}\n\n* デコード\n\n{{{\n(import (rename (rnrs)\n\t\t(bitwise-and &&)\n\t\t(bitwise-ior !!)\n\t\t(bitwise-arithmetic-shift-left <<)\n\t\t(bitwise-arithmetic-shift-right >>)))\n\n(define (base64-decode str)\n  (define base64char->hex\n    (lambda (c)\n      (cond\n        ((char<=? #\\A c #\\Z) (- (char->integer c) (char->integer #\\A)))\n        ((char<=? #\\a c #\\z) (+ (- (char->integer c) (char->integer #\\a)) #x1A))\n        ((char<=? #\\0 c #\\9) (+ (- (char->integer c) (char->integer #\\0)) #x34))\n        ((char=? #\\+ c) #x3E)\n        ((char=? #\\/ c) #x3F)\n        (else #f))))\n  (define filter\n    (lambda (in out)\n      (let loop ((c (get-char in)) (oc 0) (counter 0))\n        (unless (or (eof-object? c) (char=? #\\= c))\n          (let ((code (base64char->hex c)))\n            (if code\n              (cond\n                ((= 0 counter)\n                 (loop (get-char in) code (+ 1 counter)))\n                ((= 1 counter)\n                 (put-u8 out (!! (&& #xFC (<< oc 2)) (&& #x03 (>> code 4))))\n                 (loop (get-char in) code (+ 1 counter)))\n                ((= 2 counter)\n                 (put-u8 out (!! (&& #xF0 (<< oc 4)) (&& #x0F (>> code 2))))\n                 (loop (get-char in) code (+ 1 counter)))\n                ((= 3 counter)\n                 (put-u8 out (!! (&& #xC0 (<< oc 6)) (&& #x3F code)))\n                 (loop (get-char in) 0 0)))\n              (loop (get-char in) oc counter)))))))\n  (bytevector->string\n    (call-with-port (open-string-input-port str)\n      (lambda (in)\n        (call-with-bytevector-output-port\n          (lambda (out) (filter in out)))))\n    (make-transcoder (utf-8-codec))))\n}}}\n")
(" %Tag:stub and 1=1" . "(1580892180)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 621 #" . "(1624116927)")
(" %Tag:数値" . "(1668195815 (\"数値\" :ctime 1227153196 :cuser #f :mtime 1234244577 :muser #f) (\"数値を文字列に変換する\" :ctime 1227864472 :cuser #f :mtime 1228202563 :muser #f) (\"乱数を生成する\" :ctime 1227510174 :cuser #f :mtime 1227510174 :muser #f) (\"計算結果を分数から小数にしたい\" :ctime 1227426282 :cuser #f :mtime 1227426282 :muser #f))")
(" %Tag:SXML'\"" . "(1573238419)")
("レコード型を定義する" . "(:ctime 1233379492 :cuser #f :mtime 1233537295 :muser #f)[[$$tag R6RS レコード]]\n\nレコード型を定義するには [[$$r6rs define-record-type]] 構文を使う。 define-record-type の構文はおよそ次の通りである。\n\n (define-record-type ''<name-spec>''\n   (fields\n    ''<field-spec>''\n    ...))\n\n''<name-spec>'' は\n ''<record-name>''\nか\n (''<record-name>'' ''<constructor-name>'' ''<predicate-name>'')\nのいずれかの形式を取り、\n ''<record-name>''\n    ≡ (''<record-name>'' make-''<record-name>'' ''<record-name>''?)\nである。 <record-name> は定義されるレコード型の名前であり、 <constructor-name> はレコード型のインスタンスの構築子の名前、 <predicate-name> はオブジェクトがそのレコード型のインスタンスかどうか調べる述語の名前になる。 <field-spec> はそのレコード型の持つフィールドの特性について宣言し、\n (mutable ''<field-name>'' ''<accessor-name>'' ''<mutator-name>'')\n (immutable ''<field-name>'' ''<accessor-name>'')\n (mutable ''<field-name>'')\n    ≡ (mutable ''<field-name>'' ''<record-name>''-''<field-name>'' ''<record-name>''-''<field-name>''-set!)\n ''<field-name>''\n    ≡ (immutable ''<field-name>'')\n    ≡ (immutable ''<field-name>'' ''<record-name>''-''<field-name>'')\nのいずれかの形式を取る。 mutable と宣言されたフィールドはインスタンス化後も変更可能であり、 immutable と宣言されたフィールドは変更が不可能である。 ''<accessor-name>'' はフィールドの値を取り出す手続きの名前になり、 ''<mutator-name>'' はフィールドの値を変更する手続きの名前になる。フィールドの並び順には意味があり、レコード型構築子は引数に取ったオブジェクトをその順番で各フィールドに設定してゆく。\n\nfields 節以外の節については別頁で説明する。\n\n例えば、変更不可能な name フィールドと変更の可能な age フィールドを持つ person レコード型は次のように定義できる。\n{{{\n(import (rnrs))\n\n(define-record-type person\n  (fields\n   (immutable name)\n   (mutable age)))\n\n(define bob (make-person 'bob 32))\n\n(person-name bob) ; => bob\n(person-age bob) ; => 32\n\n(person-age-set! bob 33)\n(person-age bob) ; => 33\n}}}\n\n必要に応じて述語やアクセサの名前を明示して指定することもできる。例えば複素数を表すレコード型を作るとすると次のように書ける。\n{{{\n(import (except (rnrs)\n\t\tmake-rectangular\n\t\tcomplex?\n\t\treal-part\n\t\timag-part))\n\n(define-record-type (complex make-rectangular complex?)\n  (fields\n   (immutable re real-part)\n   (immutable im imag-part)))\n\n(define x (make-rectangular 1 2)) ; 1+2i\n\n(real-part x) ; => 1\n(imag-part x) ; => 2\n}}}\n")
(" %Tag:バイトベクタ?p=Tag:バイトベクタ" . "(1476573342)")
(" %Tag:SXML or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- and 1=1" . "(1573238435)")
("バイナリポートをテキストポートに変換する" . "(:ctime 1227427432 :cuser #f :mtime 1227427432 :muser #f)[[$$tag 入出力 R6RS]]\n\n* バイナリポートをテキストポートに変換する\n\n{{{\n(import (rnrs))\n\n(transcoded-port (standard-input-port) (make-transcoder (utf-8-codec)))\n}}}\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45) -- /* order by \"as /*" . "(1624116696)")
("ベクタをソートする" . "(:ctime 1233018720 :cuser #f :mtime 1233018720 :muser #f)[[$$tag ベクタ R6RS]]\n\n[[$$r6rs vector-sort]] はベクタの要素を与えられた比較手続きについて昇順に並べかえ新たなベクタを返す。\n{{{\n(import (rnrs))\n\n(vector-sort < #'(3 5 2 1)) ; => #(1 2 3 5)\n(vector-sort >\x05;\x05;\x0e;\x0e; #'(3 5 2 1)) ; => #(5 3 2 1)\n}}}\n\nこの並べ替えは安定であり O(''n'' log ''n'') であることが保証されている。\n{{{\n(import (rnrs))\n\n(define v1 '#(\"a\" \"c\" \"a\" \"b\"))\n(define v2 (vector-sort string<? v1))\n\nv1 ; => #(\"a\" \"a\" \"b\" \"c\")\n\n(eq? (vector-ref v1 0) (vector-ref v2 0)) ; => #t\n}}}\n\n一方、 [[$$r6rs vector-sort!]] 手続きは引数として与えられたベクタを破壊的に並べかえる。\n{{{\n(import (rnrs))\n\n(define v (vector 3 5 2 1))\n\n(vector-sort! < v) ; => #<unspecified>\nv ; => #(1 2 3 5)\n}}}\nvector-sort! は空間効率がよい一方、安定な並べ替えであることが保証されず最悪の場合 O(''n''^2) になる。\n{{{\n(import (rnrs))\n\n(define v1 '#(\"a\" \"c\" \"a\" \"b\"))\n(define v2 (vector-map values v1))\n\n(vector-sort! string<? v2)\nv2 ; => #(\"a\" \"a\" \"b\" \"c\")\n\n(eq? (vector-ref v1 0) (vector-ref v2 0)) ; => #t or #f\n}}}\n")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45) --  /*" . "(1624116103)")
(" %Tag:FIXME?p=Tag?Tag:FIXME?p=Tag" . "(1467037299)")
("コマンドライン引数を取得する" . "(:ctime 1228701025 :cuser #f :mtime 1228701026 :muser #f)[[$$tag R6RS プログラム]]\n\nコマンドライン引数を取得するには [[$$r6rs command-line]] 手続きを使う。戻り値はリストであり、 car に実行中のプログラムの名前、 cdr に引数列が格納されている。\n\n例えば、\n{{{\n% some-script -arg1 a -arg2 b\n}}}\nのようにしてプログラムを起動した場合の戻り値は\n{{{\n(command-line) ; => (\"some-script\" \"-arg1\" \"a\" \"-arg2\" \"b\")\n}}}\nのようになる。\n")
(" %Tag:SXPath" . "(1667933858 (\"XPath を使う\" :ctime 1228228236 :cuser #f :mtime 1228351743 :muser #f))")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45) --  /*" . "(1624116014)")
(" %Tag:文字列?p=Tag:文字列" . "(1467042019)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45) --  /*" . "(1624116114)")
(" %Tag:文字列'[0]" . "(1631113076)")
("リストを定義する" . "(:ctime 1227502058 :cuser #f :mtime 1233062123 :muser #f)[[$$tag リスト R5RS R6RS]]\n\nScheme のプログラムはリストです。~%\nプログラムのリストとデータのリストを区別するため、データのリストは [[$$r6rs quote]] する必要があります。\n\n{{{\n(quote (1 2 3))\n}}}\n\nquote の略記法として ' を使うことができます。\n\n{{{\n'(1 2 3)\n}}}\n\n[[$$r6rs quasiquote]] を使うとリスト内に [[手続き]] を含むことができます。~%\n[[$$r6rs unquote]] は式を一つ取り、式の結果がリスト内の要素になります。~%\n[[$$r6rs unquote-splicing]] はリストを返す式を一つ取り、式の結果をリスト内に展開します。\n\nquasiquote の略記法は ` (※ quote との違いに注意！)~%\nunquote の略記法は , ~%\nunquote-splicing の略記法は ,@ ~%\n\n{{{\n(quasiquote (1 2 (unquote (+ 1 2)) 4 5))\n;=> (1 2 3 4 5)\n\n`(1 2 ,(+ 1 2) 4 5)\n;=> (1 2 3 4 5)\n}}}\n\n{{{\n(quasiquote (1 2 (unquote-splicing (list 3 4 5)) 6 7 8))\n;=> (1 2 3 4 5 6 7 8)\n\n`(1 2 ,@(list 3 4 5) 6 7 8)\n;=> (1 2 3 4 5 6 7 8)\n}}}\n\n* 議論\n- Scheme の用語として「定義する」と言うと [[$$r6rs define]] するという意味に取られがちな気がして、このページのタイトルはミスリーディングなように思います。ここで説明しているのはリストの作成のしかた、記述のしかたではないでしょうか。\n- quote と list の違いを書きたかったんですが、「定義する」という表現はちょっと紛らわしいですね。「作成する」というのも微妙な気がしますが、用途的に考えると作成のほうでまとめたほうが良さそうですね。\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45) -- /* order by 'as /*" . "(1624116246)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45) -- /* order by \"as /*" . "(1624116508)")
(" %Tag:日付と時刻?p=Tag:日付と時刻" . "(1467047752)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45) -- /* order by \"as /*" . "(1624116718)")
(" %Tag:HTML'" . "(1578336113)")
(" %Tag:stub2121121121212.1" . "(1580892179)")
("スレッド" . "(:ctime 1227970633 :cuser #f :mtime 1228795142 :muser #f)[[$$tag スレッド SRFI]]\n\nスレッドに関する機能は [[$$srfi 18]] と [[$$srfi 21]] で提供されている。\n")
("逆引きScheme書式" . "(:ctime 1227534783 :cuser #f :mtime 1233539964 :muser #f)書式の指針を以下に示します。あくまで指針であり、絶対に従わなければならないというものではありません。多少不統一があっても、小人さんが直してくれるので大丈夫です。\n\n* 文体\nである調で書きます。文章の終わりを気をつければ十分です。\n\n* 戻り値の書き方\n次の行に「;; => 」に続けて書くか、式と同一行に「; => 」に続けて書きます。\n\n例)\n{{{\n(+ 1 1)\n;; => 2\n\n(+ 1 1) ; => 2\n}}}\n\n** 多値の書き方\n「; => 」に続けて空白で区切り各値を書くか、一つ目の戻り値を次の行に「;; => 」に続けて書き、以降の戻り値をそれぞれ別個の行にひとつめの戻り値と桁を揃えて書きます。\n\n例)\n{{{\n(values 1 2)\n;; => 1\n;;    2\n}}}\n\n** 戻り値無しの書き方\n必要であれば「=> 」に続けて「#<no value>」と書きます。\n\n例)\n{{{\n(values) ; => #<no value>\n}}}\n\n** 未規定値の書き方\n戻り値が規定されていないことを明示したい場合には「=> 」に続けて「#<unspecified>」と書きます。\n{{{\n(set! v 0) ; => #<unspecified>\n}}}\n\n* 標準出力の書き方\n戻り値の前に「-> 」に続けて書きます。複数行の場合は一行目に桁を揃えます。\n\n例)\n{{{\n(display 1)\n;; -> 1\n;; => #<unspecified>\n\n(for-each (lambda (x) (display x) (newline)) '(1 2 3))\n;; -> 1\n;;    2\n;;    3\n;;\n;; => #<unspecified>\n}}}\n")
("ユリウス日からグレゴリオ暦を計算する" . "(:ctime 1307027894 :cuser #f :mtime 1307576867 :muser #f)[[$$tag 日付けと時刻 SRFI]]\n\n (import (rnrs))\n (define (julian-day->gregorian jd)\n   (let* ((j (+ jd 32044))\n          (g (div j 146097)) (dg (mod j 146097))\n          (c (div (* (+ (div dg 36524) 1) 3) 4)) (dc (- dg (* c 36524)))\n          (b (div dc 1461)) (db (mod dc 1461))\n          (a (div (* (+ (div db 365) 1) 3) 4)) (da (- db (* a 365)))\n          (y (+ (* g 400) (* c 100) (* b 4) a))\n          (m (- (div (+ (* da 5) 308) 153) 2))\n          (d (+ (- da (div (* (+ m 4) 153) 5)) 122))\n          (year (+ (- y 4800) (div (+ m 2) 12)))\n          (month (+ (mod (+ m 2) 12) 1))\n          (day (+ d 1)))\n     (values year month day)))\n\n[[$$srfi 19]] を使うと次のように書ける。\n\n{{{\n(import (rnrs) (srfi :19))\n\n(define (julian-day->gregorian jd)\n  (let ((d (julian-day->date jd)))\n    (values (date-year d)\n            (date-month d)\n            (date-day d))))\n}}}\n\nただし、上のアルゴリズム（[http://en.wikipedia.org/wiki/Julian_day#Gregorian_calendar_from_Julian_day_number WikipediaEn:Julian_day#Gregorian_calendar_from_Julian_day_number]？）では西暦 1 年の前年を 0 年とするのに対し、 SRFI-19 では西暦 1 年の前年を -1 年（= 紀元前 1 年。[http://ja.wikipedia.org/wiki/%E7%B4%80%E5%85%83%E5%89%8D WikipediaJa:紀元前]）と表現することから、紀元前の日付けに対して、このふたつは異なる値を返す。\n{{{\n(julian-day->gregorian\n (exact (ceiling (date->julian-day (make-date 0 0 0 0 1 1 -1 0)))))\n;; => 0 1 1\n\n;; SRFI-19 版\n(julian-day->gregorian\n (exact (ceiling (date->julian-day (make-date 0 0 0 0 1 1 -1 0)))))\n;; => -1 1 1\n}}}\n")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45) --  /*" . "(1624116179)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 642 #" . "(1624117013)")
(" %Tag:SXML" . "(1668224797 (\"XML を処理する\" :ctime 1282540270 :cuser #f :mtime 1282540270 :muser #f) (\"XPath を使う\" :ctime 1228228236 :cuser #f :mtime 1228351743 :muser #f) (\"HTML を処理する\" :ctime 1228218142 :cuser #f :mtime 1228237475 :muser #f))")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45) -- /* order by \"as /*" . "(1624116586)")
("ハッシュテーブル" . "(:ctime 1227354846 :cuser #f :mtime 1227600818 :muser #f)[[$$tag ハッシュテーブル]]\n\n- [[ハッシュテーブルを作成する]]\n- [[ハッシュテーブルに値を設定する]]\n- [[ハッシュテーブルの値を参照する]]\n- [[ハッシュテーブル内に値があるかどうか確認する]]\n- [[キーに対応する値を更新する]]\n- [[ハッシュテーブルの要素を削除する]]\n- [[ハッシュテーブルを空にする]]\n- [[ハッシュテーブルを複製する]]\n- [[変更不可能なハッシュテーブルを作成する]]\n- [[ハッシュテーブルのキーの一覧を取得する]]\n- [[ハッシュテーブルの内容を取得する]]\n")
(" %Tag:スレッド2121121121212.1" . "(1624115850)")
("簡単なリスト用のループマクロの例" . "(:ctime 1228352098 :cuser #f :mtime 1229595593 :muser #f)[[$$tag R6RS マクロ]]\n\nリストの要素ごとに繰り返す Common Lisp の dolist のようなものについて考える。文法は\n{{{\n(dolist (var list-form [result-form])\n  body ...)\n}}}\nとする。これと同じ動作をするものを Scheme の標準の構文で書き下すと\n{{{\n(do ((var list-form (cdr var)))\n    ((null? var) result-form)\n  body ...)\n}}}\nとなる。 [[$$r6rs syntax-rules]] ではこれをそのままパターン言語で記述すればよい。\n{{{\n(import (rnrs))\n\n(define-syntax dolist\n  (syntax-rules ()\n    ((_ (var list-form) body ...)\n     (dolist (var list-form (if #f #f)) body ...))\n    ((_ (var list-form result-form) body ...)\n     (do ((var list-form (cdr var)))\n\t ((null? var) result-form)\n       body ...))))\n}}}\nここでは result の省略された場合に未規定値を返すために (if #f #f) という式を用いている。\n\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45) -- /* order by 'as /*" . "(1624116453)")
(" %Tag:プログラム'[0]" . "(1666815355)")
(" %Tag:FIXME2121121121212.1" . "(1581247070)")
(" %Tag:コーディングスタイル" . "(1668286236 (\"コメント\" :ctime 1227924794 :cuser #f :mtime 1228348546 :muser #f))")
(" %Tag:日付けと時刻?p=Tag:日付けと時刻" . "(1476570227)")
("エンディアンを変換する" . "(:ctime 1234244573 :cuser #f :mtime 1234244574 :muser #f)[[$$tag R6RS バイトベクタ]]\n\nバイト列のエンディアンを変換するにはバイトベクタを介すると簡単である。\n\n{{{\n(import (rnrs))\n\n(define (bytevector-change-endian bv from-endian to-endian size)\n  (if (eq? from-endian to-endian)\n      bv\n      (let* ((l (bytevector-length bv))\n\t     (rbv (make-bytevector l 0)))\n\t(do ((i 0 (+ i size)))\n\t    ((>= i l) rbv)\n\t  (bytevector-uint-set! rbv i\n\t\t\t\t(bytevector-uint-ref bv i from-endian size)\n\t\t\t\tto-endian\n\t\t\t\tsize)))))\n\n(define s \"abcde\")\n\n(define bv (string->utf32 s (endianness big)))\nbv ; => #vu8(0 0 0 97 0 0 0 98 0 0 0 99 0 0 0 100 0 0 0 101)\n\n(define bv2 (bytevector-change-endian bv (endianness big) (endianness little) 4))\nbv2 ; => #vu8(97 0 0 0 98 0 0 0 99 0 0 0 100 0 0 0 101 0 0 0)\n\n(utf32->string bv2 (endianness little)) ; => \"abcde\"\n}}}\n")
("文字列を URI エンコードする" . "(:ctime 1228696992 :cuser #f :mtime 1230361031 :muser #f)[[$$tag R6RS 文字列 Web]]\n\n[[$$r6rs string->utf8]] で文字列を一旦 UTF-8 バイト列に変換したうえで処理を行えばよい。\n\n{{{\n(import (rnrs))\n\n(define uri-unreserved-char-sv?\n  (let ((unreserved-char-svs (map char->integer\n\t\t\t\t  (string->list\n\t\t\t\t   \"abcdefghijklmnopqrstuvwxyz¥\n                                    ABCDEFGHIJKLMNOPQRSTUVWXYZ¥\n                                    0123456789-._‾\"))))\n    (lambda (sv)\n      (and (memv sv unreserved-char-svs) #t))))\n\n(define (uri-encode str)\n  (let ((svs (bytevector->u8-list (string->utf8 str))))\n    (call-with-string-output-port\n     (lambda (p)\n       (for-each\n\t(lambda (sv)\n\t  (cond ((uri-unreserved-char-sv? sv)\n\t\t (display (integer->char sv) p))\n\t\t(else\n\t\t (display \"%\" p)\n\t\t (display (number->string sv 16) p))))\n\tsvs)))))\n\n(uri-encode \"逆引き Scheme\") ; => \"%e9%80%86%e5%bc%95%e3%81%8d%20Scheme\"\n}}}\n\n----\n\n* デコード\n\n{{{\n(import (rnrs base)\n        (rnrs control)\n        (rnrs io ports)\n        (rnrs io simple)\n        (rnrs bytevectors))\n\n(define (uri-decode str)\n  (define digit->integer\n    (lambda (c)\n      (cond\n        ((char<=? #\\0 c #\\9) (- (char->integer c) (char->integer #\\0)))\n        ((char<=? #\\a c #\\f) (+ 10 (- (char->integer c) (char->integer #\\a))))\n        ((char<=? #\\A c #\\F) (+ 10 (- (char->integer c) (char->integer #\\A))))\n        (else #f))))\n  (define percent-filter\n    (lambda (in out err)\n      (let loop ((c (peek-char in)))\n        (and (not (eof-object? c)) (char=? c #\\%)\n          (let* ((cp (get-char in)) (c1 (get-char in)) (c2 (get-char in)))\n            (cond\n              ((eof-object? c1) (put-char err cp))\n              ((eof-object? c2) (put-char err cp) (put-char err c1))\n              (else\n                (let ((i1 (digit->integer c1)) (i2 (digit->integer c2)))\n                  (cond\n                    ((and i1 i2)\n                      (put-u8 out (+ (* 16 (digit->integer c1)) (digit->integer c2)))\n                      (loop (peek-char in)))\n                    (else\n                      (put-char err cp)\n                      (put-char err c1)\n                      (put-char err c2)))))))))))\n  (define filter\n    (lambda (in out)\n      (let loop ((c (peek-char in)))\n        (when (not (eof-object? c))\n          (if (char=? c #\\%)\n            (put-string out\n              (bytevector->string\n                (call-with-bytevector-output-port\n                  (lambda (op) (percent-filter in op out)))\n                (make-transcoder (utf-8-codec))))\n            (let ((c (get-char in)))\n              (cond\n                ((char=? c #\\+) (put-char out #\\space))\n                (else (put-char out c)))))\n          (loop (peek-char in))))))\n  (call-with-port (open-string-input-port str)\n    (lambda (in)\n      (call-with-string-output-port\n        (lambda (out) (filter in out))))))\n\n(uri-decode \"%e9%80%86%e5%bc%95%e3%81%8d%20Scheme\") ; => \"逆引き Scheme\"\n}}}\n")
("HTML を処理する" . "(:ctime 1228218142 :cuser #f :mtime 1228237475 :muser #f)[[$$tag R6RS HTML SXML htmlprag]]\n\nXML として妥当でない HTML の読み込みや、構文に誤りを含む HTML 文書を [[Tag:SXML]] に変換するライブラリとしては [http://www.neilvandyke.org/htmlprag/ HtmlPrag] がある。\n\nこれを使うと XML としては妥当でない HTML 文書（例えば、 http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-21.html など）を SXML に変換することができる。変換には html->sxml 手続きを使う。\n\n{{{\n(import (rnrs) (htmlprag))\n\n(call-with-port (open-file-input-port \"r6rs-lib-Z-H-21.html\"\n                                      (file-options)\n                                      (buffer-mode block)\n                                      (make-transcoder (latin-1-codec)))\n  html->sxml)\n; => (*TOP*\n;      (*DECL*\n;        DOCTYPE\n;        html\n;        PUBLIC\n;        \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n;        \"http://www.w3.org/TR/html4/loose.dtd\")\n;      \"\\n\"\n;      (html\n;        \"\\n\"\n;        ...\n}}}\n")
(" %Tag:スレッド99999' union select unhex(hex(version())) -- 'x'='x" . "(1624117079)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45) --  /*" . "(1624116047)")
("日付の曜日を日本語で出力する" . "(:ctime 1227428927 :cuser #f :mtime 1227428927 :muser #f)[[$$tag 日付と時刻 R6RS SRFI]]\n\n* 日付の曜日を日本語で出力する\n\n日付の曜日部分は 0 を起点に日曜日から番号付けされているので、それを利用する。\n\n{{{\n(import (rnrs) (srfi :19))\n\n(let ((d (current-date)))\n  (string-ref \"日月火水木金土\" (date-week-day d)))\n}}}\n")
("変数" . "(:ctime 1227920472 :cuser #f :mtime 1228348417 :muser #f)[[$$tag R6RS SRFI]]\n\nトップレベルプログラムとライブラリボディーのトップレベルで定義した変数はそのプログラムおよびライブラリ内で参照・代入ができる。\n\n{{{\n(define *var* 1)\n\n*var* ; => 1\n(set! *var* 2)\n*var* ; => 2\n}}}\n\nただし、他のライブラリから [[$$r6rs import]] した変数に代入することはできず、他の言語で言うところの定数のようなものとして扱われる。\n\n{{{\n(library (some-library)\n  (export *variable*)\n  (import (rnrs))\n\n  (define *variable* 1)\n  )\n\n(import (rnrs) (some-library))\n\n(set! *variable* 2) ; => &assertion\n}}}\n\nまた、リテラルとして書いたオブジェクト、 [[$$r6rs symbol->string]] により生成された文字列は変更が不可能なので注意が必要である。\n\n{{{\n(import (rnrs) (rnrs mutable-pairs) (rnrs mutable-strings))\n\n(define xs '(1 2 3))\n(define s1 \"abc\")\n(define v '#(0 1 2))\n(define s2 (symbol->string 'define))\n\n(set-car! xs 0) ; => &assertion\n(string-set! s1 0 #\\d) ; => &assertion\n(vector-set! v 2 3) ; => &assertion\n(string-fill! s2 #\\a) ; => &assertion\n}}}\n\n変更可能な大域的な状態を扱うには SRFI 39 のパラーメータオブジェクトを使う。パラメータオブジェクトの実体は make-parameter 手続きを使って生成されるクロージャであり、手続き呼び出しにより値を参照/設定する。\n\n{{{\n(import (rnrs) (srfi :39))\n\n(define *x* (make-parameter 1))\n(*x*) ; => 1\n(*x* 2) ; => 2\n(*x*) ; => 2\n}}}\n\n{{{\n(library (some-library)\n  (export var print-var)\n  (import (rnrs) (srfi :39))\n\n  (define var (make-parameter 1))\n  (define (print-var)\n    (display var))\n  )\n\n(import (rnrs) (some-library))\n\n(print-var) ; -> 1\n(var 3) ; => 3\n(print-var) ; -> 3\n}}}\n\nパラメータの値を一時的に変更するには parameterize マクロを使う。\n\n{{{\n(define v (make-parameter 1))\n(define (print-v)\n  (display v))\n\n(parameterize ((v 3))\n  (print-v) ; -> 3\n  )\n\n(print-v) ; -> 1\n}}}\n\nこのとき、 v の値は pameterize の本体部分の動的存続期間の間だけ値が 3 に変更される。\n")
("計算結果を分数から小数にしたい" . "(:ctime 1227426282 :cuser #f :mtime 1227426282 :muser #f)[[$$tag 数値 R6RS]]\n\n* 計算結果を分数から小数にしたい\n\n{{{\n(import (rnrs))\n(/ 2 3) ; => 2/3\n(inexact (/ 2 3)) ; => 0.666667\n}}}\n\n分数の状態は、計算結果が exact（正確）となっているので inexact 手続きで非正確（inexact）な状態にすれば良い。\n")
(" %Tag:HTML and 1>1" . "(1582392988)")
(" %Tag:スレッド and 1>1" . "(1624115871)")
("逆引きScheme" . "(:ctime 1227150323 :cuser #f :mtime 1233038662 :muser #f)- [[逆引きScheme書式]]\n- [[ライセンスについて]]\n- [[編集に関する基本方針]]\n\n----\n\n- [[文字列]]\n- [[数値]]\n- [[リスト]]\n- [[ベクタ]]\n- [[手続き]]\n- [[ハッシュテーブル]]\n- [[レコード]]\n- [[入出力]]\n- [[ライブラリ]]\n- [[コンディション]]\n- [[マクロ]]\n- [[日付と時刻]]\n- [[正規表現]]\n- [[スレッド]]\n- [[ネットワーク]]\n- [[その他]]\n- [[用語集]]\n\n- [[Tag:FIXME]], [[Tag:stub]]\n\n----\n\n欲しい項目、質問事項があれば直接編集、もしくは [[リクエスト]] へどうぞ！\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45) -- /* order by 'as /*" . "(1624116290)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 80 #" . "(1624116851)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45) --  /*" . "(1624115959)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45) --  /*" . "(1624116081)")
("一時識別子の生成" . "(:ctime 1228352724 :cuser #f :mtime 1228352724 :muser #f)[[$$tag R6RS マクロ]]\n\n変数名のリストと多値を生成する式を受け取り、生成された値を変数に代入する set!-values を考える。\n\n{{{\n(import (rnrs))\n\n(define-syntax set!-values\n  (lambda (x)\n    (syntax-case x ()\n      ((_ (var vars ...) expr)\n       (with-syntax (((t ts ...) (generate-temporaries #'(var vars ...))))\n\t #'(let-values (([t ts ...] expr))\n\t     (set! var t)\n\t     (set! vars ts) ...))))))\n}}}\n\n手続き [[$$r6rs generate-temporaries]] は引数として受け取ったリストと同一個数の一時識別子のリストを返す。これと同じことは [[$$r6rs syntax-rules]] を用いても可能だが多少手間がかかる。\n{{{\n(library (set!-values aux)\n  (export %set!-values)\n  (import (rnrs))\n\n  (define-syntax %set!-values\n    (syntax-rules ()\n      ((_ () (ts ...) (vs ...) expr)\n       (let-values (([ts ...] expr))\n\t (set! vs ts) ...))\n      ((_ (v vs ...) (ts ...) (ws ...) expr)\n       (%set!-values (vs ...) (x ts ...) (ws ... v) expr))))\n  )\n\n(import (rnrs) (for (set!-values aux) expand))\n\n(define-syntax set!-values\n  (syntax-rules ()\n    ((_ (v vs ...) expr)\n     (%set!-values (v vs ...) () () expr))))\n}}}\n\n")
(" %Tag:バイトベクタ?p=Tag?Tag:バイトベクタ?p=Tag" . "(1476573658)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45) --  /*" . "(1624116092)")
(" %Tag:マクロ" . "(1668192338 (\"マクロ\" :ctime 1227133972 :cuser #f :mtime 1232448539 :muser #f) (\"識別子を生成する\" :ctime 1232448535 :cuser #f :mtime 1232448535 :muser #f) (\"簡単なリスト用のループマクロの例\" :ctime 1228352098 :cuser #f :mtime 1229595593 :muser #f) (\"マクロを定義するマクロ\" :ctime 1229501665 :cuser #f :mtime 1229507234 :muser #f) (\"マクロ展開時に計算処理を行なう\" :ctime 1229058729 :cuser #f :mtime 1229058729 :muser #f) (\"確実に後処理を行なう\" :ctime 1228880199 :cuser #f :mtime 1228953202 :muser #f) (\"手続きの仮引数として正しい形式か検査する\" :ctime 1228837883 :cuser #f :mtime 1228837883 :muser #f) (\"複数の手続きで状態を共有する\" :ctime 1228299113 :cuser #f :mtime 1228835061 :muser #f) (\"マクロの引数の検査\" :ctime 1228352845 :cuser #f :mtime 1228352846 :muser #f) (\"一時識別子の生成\" :ctime 1228352724 :cuser #f :mtime 1228352724 :muser #f) (\"anaphoric if\" :ctime 1228352551 :cuser #f :mtime 1228352611 :muser #f) (\"quasisyntax を使う\" :ctime 1228352468 :cuser #f :mtime 1228352468 :muser #f) (\"構文キーワード\" :ctime 1228352274 :cuser #f :mtime 1228352274 :muser #f) (\"R5RS ライブラリを R6RS ライブラリに加工する\" :ctime 1227885126 :cuser #f :mtime 1228348606 :muser #f) (\"複数の値を返す手続き\" :ctime 1228154452 :cuser #f :mtime 1228348136 :muser #f))")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45) -- /* order by 'as /*" . "(1624116464)")
(" %Tag:手続き?p=Tag?Tag:手続き?p=Tag" . "(1476570287)")
(" %Tag:HTML'A=0" . "(1578309338)")
("状態機械を書く" . "(:ctime 1230242609 :cuser #f :mtime 1230316779 :muser #f)[[$$tag R6RS 手続き]]\n\n[[末尾呼び出しの最適化]]を利用し、手続きそのものを状態とし、手続き呼び出しを状態遷移として状態機械を記述すると簡潔に記述できることがある。\n\n例えば CSV の各行内のフィールドを分割する手続きを書くとき、クォート外とクォート内というふたつの状態を手続きで表し、その間の遷移を手続き呼び出しで表すと次のようになる（Cf. [[wikipedia-ja:CSV]]）。\n\n{{{\n(import (rnrs))\n\n(define (csv-split-line str)\n  (define (normal cs rfcs rfs)\n    (if (null? cs)\n\t(reverse (cons (list->string (reverse rfcs)) rfs))\n\t(case (car cs)\n\t  ((#\\,)\n\t   (normal (cdr cs) '() (cons (list->string (reverse rfcs)) rfs)))\n\t  ((#\\\")\n\t   (in-quote (cdr cs) rfcs rfs))\n\t  (else\n\t   (normal (cdr cs) (cons (car cs) rfcs) rfs)))))\n  (define (in-quote cs rfcs rfs)\n    (if (null? cs)\t\t\t; for robustness\n\t(reverse (cons (list->string (reverse rfcs)) rfs))\n\t(case (car cs)\n\t  ((#\\\")\n\t   (if (and (not (null? (cdr cs)))\n\t\t    (char=? (cadr cs) #\\\"))\n\t       (in-quote (cddr cs) (cons #\\\" rfcs) rfs)\n\t       (normal (cdr cs) rfcs rfs)))\n\t  (else\n\t   (in-quote (cdr cs) (cons (car cs) rfcs) rfs)))))\n  (normal (string->list str) '() '()))\n\n(csv-split-line \"a,ab,abc\") ; => (\"a\" \"ab\" \"abc\")\n(csv-split-line \"a,ab,a\\\"\\\"bc\") ; => (\"a\" \"ab\" \"abc\")\n(csv-split-line \"a,ab,a\\\"b\\\"c\") ; => (\"a\" \"ab\" \"abc\")\n(csv-split-line \"a,ab,\\\"ab\\\"\\\"c\\\"\") ; (\"a\" \"ab\" \"ab\\\"c\")\n}}}\n\nまた、文章やフローチャートで書かれたアルゴリズムをそのまま記述する場合にも便利なことがある。例えば『The Art of Computer Programming (2) 日本語版 Seminumerical algorithms』（ISBN 4756145434）では選択サンプリング法のアルゴリズムを次のように説明している。\n<<<\n'''アルゴリズム S'''（選択サンプリング法 (''Selection sampling technique'')）。 0 < n ≦ N とし、 N 個の中からランダムに n 個のレコードを選択する方法。\n\n- S1 : ［初期設定］ t ← 0, m ← 0 とする（このアルゴリズムで、 m は既に選択したレコードの数を表し、 t は既に扱った入力レコードの数を表す）。\n- S2: ［U を生成］ 0 と 1 の間で一様に分布するランダムな数 U を生成する。\n- S3:［検定］ (N - t)U ≧ n -m ならばステップ S5 に進む。\n- S4:［選択］ サンプルの次のレコードを選択し、 m と t を 1 増やす。 m < n ならば、ステップ S2 に進む。そうでなければ、サンプリングを終えたから、アルゴリズムの実行を停止する。\n- S5:［スキップ］ 次のレコードをスキップし（次のレコードはサンプルに含めない）、 t を 1 増加する。ステップ S2 に戻る。\n>>>\n\nこれを素朴に書き下すと次のようになる。\n{{{\n(import (rnrs) (srfi :27))\n\n(define (algorithm-S n N)\n  (define (s1 t m U rs)\n    (s2 0 0 U rs))\n  (define (s2 t m U rs)\n    (s3 t m (random-real) rs))\n  (define (s3 t m U rs)\n    (if (>= (* (- N t) U) (- n m))\n\t(s5 t m U rs)\n\t(s4 t m U rs)))\n  (define (s4 t m U rs)\n    (let ((t* (+ t 1))\n\t  (m* (+ m 1))\n\t  (rs* (cons t rs)))\n      (if (< m* n)\n\t  (s2 t* m* U rs*)\n\t  (reverse rs*))))\n  (define (s5 t m U rs)\n    (s2 (+ t 1) m U rs))\n  (s1 #f #f #f '()))\n\n(algorithm-S 5 20) ; => (5 6 7 11 18) for example\n}}}\n\nこれはあまりスマートなプログラムではないが、アルゴリズムの説明とこのプログラムが正しく対応していることを確認するのは難しくない。効率も悪いわけではない。逆に、「より Scheme らしい」次のプログラムが上のアルゴリズムと等価であることを判断するのはそれほど容易ではないだろう。\n\n{{{\n(import (rnrs) (srfi :27))\n\n(define (algorithm-S n N)\n  (let loop ((t 0) (m 0) (rs '()))\n    (cond ((= m n)\n\t   (reverse rs))\n\t  ((< (- n m) (* (- N t) (random-real)))\n\t   (loop (+ t 1) m rs))\n\t  (else\n\t   (loop (+ t 1) (+ m 1) (cons t rs))))))\n}}}\n\n\n手続きをひとつの状態やステップと見做すことでプログラムの見通しがよくなることは多い。\n")
("リストの要素数を取得する" . "(:ctime 1227501083 :cuser #f :mtime 1228349764 :muser #f)[[$$tag リスト R6RS]]\n\nリストの長さは [[$$r6rs length]] 手続きで調べることができる。\n\n{{{\n(import (rnrs))\n\n(length '(1 2 3 4)) ; => 4\n}}}\n\nただし、リストの構造を調べるような場合には length を使うよりも [[$$r6rs car]], [[$$r6rs cdr]], [[$$r6rs null?]] を使って構造を調べた方が効率がよい。例えばリストが [[$$r6rs if]] フォームとして適正な形をしているか調べる手続きを考える。\n\n{{{\n(import (rnrs))\n\n(define (if? xs)\n  (and (<= 3 (length xs) 4)\n       (eq? (car xs) 'if)))\n}}}\n\nこの場合、 length で長さを調べると、引数で与えられたリストの長さが大きい場合、余計な時間がかかってしまう。\n\n{{{\n(import (rnrs))\n\n(define (if? xs)\n  (and (pair? xs)\n       (eq? (car xs) 'if)\n       (not (null? (cdr xs)))\n       (not (null? (cddr xs)))\n       (or (null? (cdddr xs))\n\t   (null? (cddddr xs)))))\n}}}\nとすれば引数のリストの長さにかかわらず定数時間で計算が終了する。\n\n同じ理由で、リストが空かどうか調べるには length を使うよりも null? を使う方がよい。\n{{{\n(import (rnrs) (only (srfi :1) make-list))\n\n;; fast version\n(null? (make-list 5000000 0)) ; => #f\n;; slow version\n(zero? (length (make-list 5000000 0))) ; #f\n}}}\n")
("ポートを閉じる" . "(:ctime 1227427369 :cuser #f :mtime 1227427369 :muser #f)[[$$tag 入出力 R6RS]]\n\n* ポートを閉じる\n\nポートを閉じるには close-port 手続きを使う。ポートの入力/出力による区別はない。\n\n{{{\n(close-port port)\n}}}\n\n特定の処理を行なってからポートを閉じる場合には次のように call-with-port を使った方がよい。\n\n{{{\n(call-with-port port\n  (lambda ()\n    ...))\n}}}\n")
(" %Tag:リスト'A=0" . "(1562354915)")
(" %Tag:スレッド' AnD SLeeP(3) #" . "(1624116807)")
(" %Tag:スレッド\" and \"x\"=\"y" . "(1624115915)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45) -- /* order by \"as /*" . "(1624116542)")
(" %Tag:SXML\" and \"x\"=\"x" . "(1573238425)")
("構文キーワード" . "(:ctime 1228352274 :cuser #f :mtime 1228352274 :muser #f)[[$$tag R6RS マクロ]]\n\n構文キーワードを使うマクロの例として、 [[$$r6rs case]] の datum の代わりに述語を指定できる構文を考える。\n{{{\n(library (case/pred aux)\n  (export %case/pred else)\n  (import (rnrs))\n\n  (define-syntax %case/pred\n    (syntax-rules (else)\n      ((_ x ())\n       (if #f #f))\n      ((_ x ((p1? p2? ...) body ...) cls ...)\n       (if (or (p1? x) (p2? x) ...)\n\t   (begin #t body ...)\n\t   (%case/pred x cls ...)))\n      ((_ x (else body ...))\n       (begin (if #f #f) body ...))))\n  )\n\n(import (rnrs) (for (case/pred aux) expand))\n\n(define-syntax case/pred\n  (syntax-rules ()\n    ((_ x cls ...)\n     (let ((y x))\n       (%case/pred y\n         cls ...)))))\n}}}\n[[$$r6rs cond]] の else のような構文キーワードは、 [[$$r6rs syntax-rules]] の最初の括弧の中に並べ、その束縛が自由である（= [[$$r6rs let]] 等で束縛されていない。 [[$$r6rs define]] でトップレベルに定義されている場合は除く）場合、 syntax-rules のパターン部分にマッチする。\n\nここでは各節の式群は 0 個でもよいものとし、その場合通常の条件節では #t を返し else 節では未規定値を返すものとして、空の [[$$r6rs begin]] —— (begin) を避けている。各節には必ずひとつ以上の式が現れなければならないように構文を定義してもかまわない。\n\n")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 561 #" . "(1624116906)")
("ハッシュテーブルを複製する" . "(:ctime 1227602195 :cuser #f :mtime 1227602196 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\nハッシュテーブルを複製するには hashtable-copy を使う。\n\n{{{\n(import (rnrs))\n\n(hashtable-copy ht #t)\n}}}\n\n第 2 引数には複製されたハッシュテーブルが変更可能かどうかを指定する。\n")
(" %Tag:FIXME' and 'x'='y" . "(1581247073)")
(" %Tag:Web" . "(1668289087 (\"CGI を作る\" :ctime 1282540225 :cuser #f :mtime 1296491816 :muser #f) (\"文字列を Base64 エンコードする\" :ctime 1229176092 :cuser #f :mtime 1238220404 :muser #f) (\"文字列を URI エンコードする\" :ctime 1228696992 :cuser #f :mtime 1230361031 :muser #f))")
("ベクタから要素を探す" . "(:ctime 1233014179 :cuser #f :mtime 1233018921 :muser #f)[[$$tag ベクタ R6RS SRFI]]\n\n一般のベクタから要素を探索するには、先頭から線型探索を行なう。\n\nベクタの先頭から特定の述語を満たす要素を探索し、その添字を返す手続きは、例えば次のように書くことができる。\n{{{\n(import (rnrs))\n\n(define (vector-index pred? v)\n  (let ((l (vector-length v)))\n    (do ((i 0 (+ i 1)))\n\t((or (pred? (vector-ref v i))\n\t     (= i l))\n\t (if (= i l) #f i)))))\n\n(vector-index even? '#(1 2 3)) ; => 1\n}}}\n\nSRFI 43 には同名で複数のベクタを引数に取る手続きと、先頭ではなく末尾から探索を行なう vector-index-right 手続きがある。これらの操作は O(''n'') である。\n\nベクタがソート済である場合には SRFI 43 の vector-binary-search を使うことができる。このとき比較手続きには第 1 引数が第 2 引数より小、等しい、より大の場合にそれぞれ負、零、正のの整数を返す手続きを渡す。\n{{{\n(import (rnrs) (only (srfi :43) vector-binary-search))\n\n(vector-binary-search '#(1 3 5 6 8 9 10)\n\t\t      3\n\t\t      (lambda (i j)\n\t\t\t(cond ((< i j) -1)\n\t\t\t      ((= i j) 0)\n\t\t\t      (else 1))))\n;; => 1\n}}}\nこの操作は O(log ''n'') である。\n")
(" %Tag:HTML999999.1 union select unhex(hex(version())) -- and 1=1" . "(1582392996)")
(" %Tag:stub?Tag?Tag?Tag:stub?Tag?Tag" . "(1491336212)")
("コンディションを合成する" . "(:ctime 1233267797 :cuser #f :mtime 1233267797 :muser #f)[[$$tag R6RS コンディション]]\n\n実際に起こった例外的状況をコンディションで説明する場合、単一のコンディションによってではなく、例外の様々な側面を複数のコンディションの合成として記述する。\n\n例えば、[[コンディションを定義する]]ときの例として扱った &http-condition を実際に HTTP 接続を扱うプログラムのなかで使う場合、エラーが発生したこと、例外の発生した場所、操作を行なったときに渡されたオブジェクトなどの情報もあると有益であろう。これらの情報はそれぞれ &error コンディション、 &who コンディションと &irritants コンディションで表される。\n\nコンディションを合成するには [[$$r6rs condition]] 手続きを使う。この手続きは引数として受け取ったコンディションを合成したコンディションを返す。\n\nHTTP 接続における例外的状況を通知する http-error 手続きは次のように書けるであろう。\n{{{\n(import (rnrs))\n\n;; &http-condition の定義\n...\n\n(define (http-error who status-code header body . irritants)\n  (raise (apply condition\n\t\t(make-error)\n\t\t(make-http-condition status-code header body)\n\t\t(make-irritants-condition irritants)\n\t\t(if who (make-who-condition who) '()))))\n}}}\n")
("XPath を使う" . "(:ctime 1228228236 :cuser #f :mtime 1228351743 :muser #f)[[$$tag R6RS SXML SXPath htmlprag]]\n\nSXML ライブラリの sxpath 手続きに XPath 文字列を渡すと、 SXML ツリーから与えられた XPath 文字列を満足するノードのリストを返す手続きを得ることができる。\n\n{{{\n(import (rnrs) (sxml sxpath))\n\n(define tbl '(*TOP*\n\t      (table (tr (td \"1\") (td \"2\") (td \"3\"))\n\t\t     (tr (td \"4\") (td \"5\") (td \"6\"))\n\t\t     (tr (td \"7\") (td \"8\") (td \"9\")))))\n\n(sxpath \"*\") ; => #<procedure>\n((sxpath \"//td\") tbl)\n; => ((td \"1\") (td \"2\") (td \"3\") (td \"4\") (td \"5\") (td \"6\") (td \"7\") (td \"8\") (td \"9\"))\n((sxpath \"/table/tr/td[1]\") tbl)\n; => ((td \"1\"))\n((sxpath \"//tr[td = '9']\") tbl)\n; => ((tr (td \"7\") (td \"8\") (td \"9\")))\n}}}\n\n* 応用\n\nたとえば、 http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-21.html をもとに見出し文字列から URL への対応表を作りたいとする。 HTML ソースを大雑把に見渡すと\n\n- この文書は HTML 文書である（= well formed XML 文書ではない）\n- 見出し文字列は p タグの直下、または p タグの直下の tt タグの中にある\n- URL は a タグの href 属性に書かれている\n- 見出しを含まない p タグは tt 以外の要素、ないしは空白文字列で始まる\n- 見出し、 a タグ、……、見出し、 a タグ、…… という構造になっている\n- a タグが複数含まれる場合には `,' と空白文字で区切られる\n\nことがわかる。\n\nこれらの知識をもとに見出しと URL の対応関係を表す連想リストをつくる手続きを考える。\n\n{{{\n(import (rnrs)\n\t(only (srfi :1) concatenate filter-map)\n\t(srfi :2)\n\t(only (srfi :13) string-every string-trim-both)\n\t(htmlprag)\n\t(sxml sxpath)\n\t(sxml tools))\n\n(define (r6rs-lib-index->alist sxml)\n  (fold-left\n   (lambda (alis x)\n     (cond ((string? x)\n\t    (cons `(,(string-trim-both x)) alis))\n\t   ((eq? (sxml:node-name x) 'tt)\n\t    (cons `(,(car (sxml:content x))) alis))\n\t   ((eq? (sxml:node-name x) 'a)\n\t    (cons `(,(caar alis)\n\t\t    ,(sxml:attr x 'href)\n\t\t    ,@(cdar alis))\n\t\t  (cdr alis)))\n\t   (else (assert #f))))\t\t; should not be reached\n   '()\n   (concatenate\n    (filter-map\n     (lambda (p)\n       (and-let* ((c (remp (lambda (k)\n\t\t\t     (and (string? k)\n\t\t\t\t  (string-every (lambda (c)\n\t\t\t\t\t\t  (or (char=? c #\\,)\n\t\t\t\t\t\t      (char-whitespace? c)))\n\t\t\t\t\t\tk)))\n\t\t\t   (sxml:content p)))\n\t\t  ((not (null? c)))\n\t\t  (t (car c))\n\t\t  ((or (string? t)\n\t\t       (eq? (sxml:node-name t) 'tt))))\n\t c))\n     ((sxpath \"//p\") sxml)))))\n\n(r6rs-lib-index->alist\n (call-with-input-file \"r6rs-lib-Z-H-21.html\" html->sxml))\n; => ((\"write-char\"\n;      \"r6rs-lib-Z-H-9.html#node_idx_822\"\n;      \"r6rs-lib-Z-H-9.html#node_idx_820\")\n;     ...)\n}}}\n\n")
(" %Tag:手続き" . "(1668195808 (\"末尾呼び出しの最適化\" :ctime 1228157227 :cuser #f :mtime 1264385826 :muser #f) (\"ループを記述する\" :ctime 1229916880 :cuser #f :mtime 1230388452 :muser #f) (\"状態機械を書く\" :ctime 1230242609 :cuser #f :mtime 1230316779 :muser #f) (\"手続き\" :ctime 1227355895 :cuser #f :mtime 1230242707 :muser #f) (\"引数のリストに手続きを適用する\" :ctime 1229044401 :cuser #f :mtime 1229050131 :muser #f) (\"手続きの仮引数として正しい形式か検査する\" :ctime 1228837883 :cuser #f :mtime 1228837883 :muser #f) (\"複数の手続きで状態を共有する\" :ctime 1228299113 :cuser #f :mtime 1228835061 :muser #f) (\"手続きを作成する\" :ctime 1228154104 :cuser #f :mtime 1228348278 :muser #f) (\"省略可能引数のある手続き\" :ctime 1228154387 :cuser #f :mtime 1228348185 :muser #f) (\"複数の値を返す手続き\" :ctime 1228154452 :cuser #f :mtime 1228348136 :muser #f) (\"ループから脱出する\" :ctime 1228303091 :cuser #f :mtime 1228347944 :muser #f) (\"手続きを返す手続きを書く\" :ctime 1228154284 :cuser #f :mtime 1228160726 :muser #f) (\"状態を持った手続きを作る\" :ctime 1228154331 :cuser #f :mtime 1228154331 :muser #f) (\"引数を一部固定した手続きを作る\" :ctime 1228154185 :cuser #f :mtime 1228154236 :muser #f))")
("数値" . "(:ctime 1227153196 :cuser #f :mtime 1234244577 :muser #f)[[$$tag 数値]]\n\n- [[計算結果を分数から小数にしたい]]\n- [[乱数を生成する]]\n- [[数値を文字列に変換する]]\n- [[エンディアンを変換する]]\n")
("識別子を生成する" . "(:ctime 1232448535 :cuser #f :mtime 1232448535 :muser #f)[[$$tag R6RS マクロ]]\n\n[[$$r6rs define-record-type]] のように、マクロへの引数として渡した識別子以外の識別子への束縛を自動的に生成してくれるマクロがあると便利なことがある。ここでは簡単な例としてタグとして使いたいシンボル ''sym'' を複数個渡し、 $$''sym'' という識別子に束縛する define-tags マクロを考える。このようなものはシンボルを直接即値として書いてもかまわないが、一旦変数に束縛することにより処理系に綴り間違いを確認させることができるという利点が生まれる。\n\n識別子を操作するには、 [[$$r6rs syntax->datum]] で一旦構文オブジェクトをデータに戻し、しかるべき操作をした上で [[$$r6rs datum->syntax]] で構文オブジェクトに戻す。\n\n{{{\n(import (rnrs))\n\n(define-syntax define-tags\n  (lambda (x)\n    (syntax-case x ()\n      ((k tags ...)\n       (with-syntax (((ns ...)\n\t\t      (map (lambda (t)\n\t\t\t     (datum->syntax #'k\n\t\t\t       (string->symbol\n\t\t\t\t(string-append \"$$\" (symbol->string\n\t\t\t\t\t\t     (syntax->datum t))))))\n\t\t\t   #'(tags ...))))\n\t #'(begin\n\t     (define ns 'tags)\n\t     ...))))))\n\n(define-tags foo)\n\n$$foo ; => foo\n}}}\n\nただし、このようなマクロは便利である反面、プログラムの字面上に存在しない識別子を自由に束縛することができるため、混乱を招くことも多い。きちんとした基準を設けて、用法・用量を守って使うべきである。\n\n")
("乱数を生成する" . "(:ctime 1227510174 :cuser #f :mtime 1227510174 :muser #f)[[$$tag 数値 R6RS SRFI]]\n\n乱数については [http://srfi.schemers.org/srfi-27/srfi-27.html SRFI-27] で定められています。\n\n** 乱数発生源を初期化する\n\n{{{\n(import (rnrs) (srfi :27))\n\n(random-source-randomize! default-random-source)\n}}}\n\n** 0 以上 N 未満の正確な整数の乱数を生成する\n\n{{{\n(import (rnrs) (srfi :27))\n\n(let ((N 100))\n  (random-integer N))\n}}}\n\n** 0 より大きく 1 未満の実数の乱数を生成する\n\n{{{\n(import (rnrs) (srfi :27))\n\n(random-real)\n}}}\n")
("コンディションを定義する" . "(:ctime 1233267117 :cuser #f :mtime 1233267156 :muser #f)[[$$tag R6RS コンディション]]\n\nコンディションは例外が発生した場合にその状況に関する情報を表現するためのオブジェクトである。\n\n例えば、 HTTP 接続を扱うプログラムを考えた場合、失敗時に例外を起こしたいと考えるかもしれない。そのような場合、接続先から戻ってきたステータスコード、ヘッダ、メッセージ本体がコンディションに含まれると有用であろう。\n\nコンディションを定義するには [[$$r6rs define-condition-type]] 構文を使う。 define-condition-type の構文は次の通りである。\n{{{\n(define-condition-type <condition-type> <super-type>\n  <constructor> <prpedicate>\n  (<field> <accessor>)\n  ...)\n}}}\n\n先の、 HTTP 接続の状況を表すコンディションは次のように定義できる。\n{{{\n(imort (rnrs))\n\n(define-condition-type &http-condition &condition\n  make-http-condition http-condition?\n  (status-code http-condition-status-code)\n  (heaeder http-condition-heaeder)\n  (body http-condition-body))\n}}}\n\n実際に例外を通知する場合にはこのコンディションと他の[[コンディションを合成する]]ことになるだろう。\n")
(" %Tag:stub'\"" . "(1580892178)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45) -- /* order by \"as /*" . "(1624116520)")
(" %Tag:配列" . "(1297243718)")
(" %Tag:SXML and 1>1" . "(1573238422)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45) --  /*" . "(1624115991)")
("文字列" . "(:ctime 1227101219 :cuser #f :mtime 1515206594 :muser #f)[[$$tag 文字列]]\n\nR6RS, R7RS では文字は Unicode のスカラー値に対応し、文字列はそれを列状に並べ 0 から順に添字付けしたものである。\n\n- [[文字列を結合する]]\n- [[大文字・小文字に揃える]]\n- [[大文字と小文字を入れ替える]]\n- [[複数行の文字列を作成する]]\n- [[部分文字列を取り出す]]\n- [[文字列を一文字づつ処理する]]\n- [[文字列を一行づつ処理する]]\n- [[文字列の先頭・末尾の空白を削除する]]\n- [[文字列を数値に変換する]]\n- [[文字とUnicodeスカラー値を相互変換する]]\n- [[文字列を URI エンコードする]]\n- [[文字列を Base64 エンコードする]]\n- [[文字列のエンコーディングを変換する]]\n- [[文字列を分割する]]\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45) -- /* order by 'as /*" . "(1624116278)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 601 #" . "(1624116917)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 639 #" . "(1624116981)")
("ベクタの各要素に手続きを適用する" . "(:ctime 1233088003 :cuser #f :mtime 1233088003 :muser #f)[[$$tag ベクタ R6RS SRFI]]\n\n[[リストの各要素に手続きを適用する]]場合と同じように、ベクタの各要素に手続きを適用するには [[$$r6rs vector-map]] と [[$$r6rs vector-for-each]] を使う。 vector-map は [[$$r6rs map]] と異なり結果をリストではなくベクタで返す。\n\n{{{\n(import (rnrs))\n\n(vector-map (lambda (x) (* x 2)) '#(0 1 2 3)) ; => #(0 2 4 6)\n(vector-for-each display '#(a b c d)) ; -> abcd\n}}}\n\nSRFI 43 の vector-map と vector-for-each はベクタの要素に加えてその添字も手続きに渡す。\n{{{\n(import (except (rnrs) vector-map vector-for-each)\n\t(only (srfi :43) vector-map vector-for-each))\n\n(vector-map list '#(a b c d)) ; => #((0 a) (1 b) (2 c) (3 d))\n(vector-for-each (lambda (i x) (display i) (display \": \") (display x) (newline)) '#(a b c d))\n;; -> 0: a\n;;    1: b\n;;    2: c\n;;    3: d\n;;\n}}}\n")
(" %Tag:stub?Tag?Tag:stub?Tag" . "(1491321790)")
(" %Tag:プログラム" . "(1668195757 (\"コマンドライン引数を解析する\" :ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f) (\"プログラムを終了させる\" :ctime 1228701545 :cuser #f :mtime 1228701546 :muser #f) (\"コマンドライン引数を取得する\" :ctime 1228701025 :cuser #f :mtime 1228701026 :muser #f))")
("マクロの引数の検査" . "(:ctime 1228352845 :cuser #f :mtime 1228352846 :muser #f)[[$$tag R6RS マクロ]]\n\n例えば、[[一時識別子の生成]]で扱った set!-values の変数名の部分は識別子の列でならなければならない。これを検査するためには [[$$r6rs syntax-case]] の fender を使う。\n\n{{{\n(import (rnrs))\n\n(define-syntax set!-values\n  (lambda (x)\n    (syntax-case x ()\n      ((_ (var vars ...) expr)\n       (for-all identifier? #'(var vars ...))\n       (with-syntax (((t ts ...) (generate-temporaries #'(var vars ...))))\n\t #'(let-values (([t ts ...] expr))\n\t     (set! var t)\n\t     (set! vars ts) ...))))))\n}}}\n\n複数の条件を検査したい場合には、それらを [[$$r6rs and]] でつなぐ。\n\n")
("日付と時刻" . "(:ctime 1227248209 :cuser #f :mtime 1307027816 :muser #f)[[$$tag 日付と時刻]]\n\n日付けと時刻を扱う手続きとデータ型は [[$$srfi 19]] で提供されている。\n\n- [[現在の日付を調べる]]\n- [[日付の曜日を日本語で出力する]]\n- [[日付に対する加算]]\n- [[月の最後の日を調べる]]\n- [[閏年か判定する]]\n- [[グレゴリオ暦からユリウス日を計算する]]\n- [[ユリウス日からグレゴリオ暦を計算する]]\n")
(" %Tag:R6RS'[0]" . "(1667454513)")
(" %Tag:XML" . "(1667933870 (\"XML を処理する\" :ctime 1282540270 :cuser #f :mtime 1282540270 :muser #f))")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45) -- /* order by 'as /*" . "(1624116224)")
(" %Tag:FIXME999999.1 union select unhex(hex(version())) -- and 1=1" . "(1581247076)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45) --  /*" . "(1624116147)")
(" %Tag:ライブラリ" . "(1668195772 (\"処理系依存部分のあるライブラリを書く\" :ctime 1231150071 :cuser #f :mtime 1231249974 :muser #f) (\"ライブラリ\" :ctime 1227882981 :cuser #f :mtime 1231150135 :muser #f) (\"複数の手続きで状態を共有する\" :ctime 1228299113 :cuser #f :mtime 1228835061 :muser #f) (\"特定の識別子だけを import する\" :ctime 1227883231 :cuser #f :mtime 1228348833 :muser #f) (\"名前を変更して import する\" :ctime 1227883697 :cuser #f :mtime 1228348785 :muser #f) (\"名前を変更して export する\" :ctime 1227884232 :cuser #f :mtime 1228348740 :muser #f) (\"R5RS ライブラリを R6RS ライブラリに加工する\" :ctime 1227885126 :cuser #f :mtime 1228348606 :muser #f))")
("文字列を数値に変換する" . "(:ctime 1227425885 :cuser #f :mtime 1240391591 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 文字列を数値に変換する\n\n[[$$r6rs string->number]] を使います。\n\n{{{\n(import (rnrs))\n\n(string->number \"1\") ; => 1\n(string->number \"1/10\") ; => 1/10\n(string->number \"1.2\") ; 1.2\n(string->number \"1+2i\") ; 1+2i\n}}}\n\n文字列表現に応じて、整数、有理数、実数、複素数に適宜変換される。\n\n整数については基数を指定することもできる。\n\n{{{\n(import (rnrs))\n\n(string->number \"11\" 2) ; => 3\n(string->number \"11\" 8) ; => 9\n(string->number \"11\" 10) ; => 11\n(string->number \"11\" 16) ; => 17\n}}}\n\nこの基数指定は文字列の方に基数接頭辞をつけることで上書きすることができる。\n\n{{{\n(import (rnrs))\n\n(string->number \"#d11\" 16) ; => 11\n}}}\n\n数値に変換できなかった場合は #f を返します。\n")
("複数行の文字列を作成する" . "(:ctime 1227425167 :cuser #f :mtime 1227425167 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 複数行の文字列を作成する\n\n文字列リテラルには改行を含めることができる。\n\n{{{\n\"abc\ndef\nghi\" ; => \"abc\\ndef\\nghi\"\n}}}\n\n改行の前にバックスラッシュを置くことで行を継続することができる。このとき、継続行の次の行の行頭の空白文字は無視される。\n\n{{{\n\"abc\\\n def\\\n ghi\" ; => \"abcdefghi\"\n}}}\n")
(" %Tag:Gauche//index.cgi?p=|echo \"Osirys-p0wa\"" . "(1247879027)")
("キーに対応する値を更新する" . "(:ctime 1227601795 :cuser #f :mtime 1227601928 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\n{{{\n(import (rnrs base) (rnrs hashtables))\n\n(hashtable-set! ht key (+ (hashtable-set! ht key 0) 1))\n}}}\n\nとすると key に対応する値（なければ 0）に 1 を足したものを新たに key に対応づけることができるが、これは key のハッシュ値を 2 度計算するので無駄である。\n\nこのような場合は hashtable-update! 手続きを使った方が効率がよい。\n\n{{{\n(import (rnrs base) (rnrs hashtables))\n\n(hashtable-update! ht key 0 (lambda (x) (+ x 1)))\n}}}\n\n典型的な使用例としてはリスト中のオブジェクトの出現回数を調べるなどがある。\n\n{{{\n(import (rnrs base) (rnrs hashtables))\n\n(define (count-occurences xs)\n  (let ((ht (make-hashtable equal? equal-hash)))\n    (for-each (lambda (x)\n      (hashtable-update! ht x 0 (lambda (n) (+ n 1))))\n      xs)\n    ht))\n}}}\n")
(" %Tag:stub" . "(1668105163 (\"コマンドライン引数を解析する\" :ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f))")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45) -- /* order by \"as /*" . "(1624116497)")
("複数の手続きで状態を共有する" . "(:ctime 1228299113 :cuser #f :mtime 1228835061 :muser #f)[[$$tag R6RS 手続き ライブラリ マクロ]]\n\nいちばん簡単なのはライブラリを使うことである。\n\n{{{\n(library (counter)\n  (export counter-value reset! inc! dec!)\n  (import (rnrs))\n  \n  (define v 0)\n\n  (define (counter-value)\n    v)\n\n  (define (reset!)\n    (set! v 0))\n\n  (define (inc!)\n    (set! v (+ v 1)))\n\n  (define (dec!)\n    (set! v (- v 1)))\n  )\n}}}\n\nあるいは、 [[$$r6rs let]] で閉じ込まれた環境を参照する。\n\n{{{\n(import (rnrs))\n\n(define counter-value)\n(define reset!)\n(define inc!)\n(define dec!)\n\n(let ((v 0))\n  (set! counter-value (lambda () v))\n  (set! reset! (lambda () (set! v 0)))\n  (set! inc! (lambda () (set! v (+ v 1))))\n  (set! dec! (lambda () (set! v (1 v 1)))))\n}}}\n\nもしくは次のようなマクロをつくったうえで、字句環境を閉じ込む。\n\n{{{\n(import (rnrs))\n\n(define-syntax define-values\n  (lambda (x)\n    (syntax-case x ()\n      ((_ (v vs ...) expr)\n       (for-all identifier? #'(v vs ...))\n       (with-syntax (((t ts ...) (generate-temporaries #'(v vs ...))))\n\t #'(begin\n\t     (define v)\n\t     (define vs)\n\t     ...\n\t     (define tmp\n\t       (let-values (([t ts ...] expr))\n\t\t (set! v t)\n\t\t (set! vs ts)\n\t\t ...\n\t\t #f))))))))\n\n(define-values (counter-value reset! inc! dec!)\n  (let ((v 0))\n    (values\n     (lambda () v)\n     (lambda () (set! v 0))\n     (lambda () (set! v (+ v 1)))\n     (lambda () (set! v (- v 1))))))\n}}}\n\ndefine-values の定義の最後の define は define-values を定義として扱うためのダミーである。これにより define-values は次のような使い方ができる。\n\n{{{\n(let ()\n  (define foo 10)\n  (define-values (counter-value reset! inc! dec!) ...)\n  (define bar 100) ; <= syntax error if define-values transcribe expression\n  (reset!)\n  (inc!) \n  ...\n  (counter-value))\n}}}\n\n")
("月の最後の日を調べる" . "(:ctime 1227429229 :cuser #f :mtime 1227429229 :muser #f)[[$$tag 日付と時刻 R6RS SRFI]]\n\n* 月の最後の日を調べる\n\n単純な計算によるもの。\n\n{{{\n(import (rnrs) (srfi :19))\n\n(define the-last-day-in-the-month\n  (let ((dv '#(31 #f 31 30 31 30 31 31 30 31 30 31)))\n    (define (leap-year? year)\n      (or (zero? (mod year 400))\n          (and (not (zero? (mod year 100)))\n               (zero? (mod year 4)))))\n    (lambda (date)\n      (or (vector-ref dv (- (date-month date) 1))\n          (if (leap-year? (date-year date)) 29 28)))))\n}}}\n\n次の月の最初の日の前の日 = 月の最後の日、ということを利用した計算。\n\n{{{\n(import (rnrs) (srfi :19))\n\n(define (the-last-day-in-the-month date)\n  (let ((m (date-month date)))\n    (date-day\n      (time-tai->date\n        (subtract-duration (date->time-tai\n          (if (= m 12)\n            (make-date 0 0 0 0 1 1 (+ (date-year date) 1) (date-zone-offset date))\n            (make-date 0 0 0 0 1 (+ m 1) (date-year date) (date-zone-offset date))))\n          (make-time time-duration 0 1))))))\n}}}\n")
(" %Tag:リスト'[0]" . "(1570585365)")
("その他" . "(:ctime 1227635145 :cuser #f :mtime 1232012267 :muser #f)- [[識別子の命名規約]]\n- [[R6RS と SRFI で非互換な点]]\n- [[変数]]\n- [[コメント]]\n- [[XML を処理する]]\n- [[XPath を使う]]\n- [[HTML を処理する]]\n- [[コマンドライン引数を取得する]]\n- [[コマンドライン引数を解析する]]\n- [[プログラムを終了させる]]\n- [[確実に後処理を行なう]]\n- [[プラットフォームに関する情報を得る]]\n- [[環境変数を取得する]]\n- [[CGI を作る]]\n- [[ソースファイルの拡張子]]\n")
(" %Tag:ハッシュテーブル" . "(1668286325 (\"ハッシュテーブル内に値があるかどうか確認する\" :ctime 1227601455 :cuser #f :mtime 1227602965 :muser #f) (\"ハッシュテーブルの内容を取得する\" :ctime 1227602654 :cuser #f :mtime 1227602655 :muser #f) (\"ハッシュテーブルのキーの一覧を取得する\" :ctime 1227602553 :cuser #f :mtime 1227602554 :muser #f) (\"変更不可能なハッシュテーブルを作成する\" :ctime 1227602439 :cuser #f :mtime 1227602440 :muser #f) (\"ハッシュテーブルを複製する\" :ctime 1227602195 :cuser #f :mtime 1227602196 :muser #f) (\"ハッシュテーブルを空にする\" :ctime 1227602126 :cuser #f :mtime 1227602127 :muser #f) (\"ハッシュテーブルに値を設定する\" :ctime 1227601175 :cuser #f :mtime 1227602027 :muser #f) (\"ハッシュテーブルの値を参照する\" :ctime 1227601383 :cuser #f :mtime 1227601995 :muser #f) (\"キーに対応する値を更新する\" :ctime 1227601795 :cuser #f :mtime 1227601928 :muser #f) (\"ハッシュテーブルの要素を削除する\" :ctime 1227601889 :cuser #f :mtime 1227601889 :muser #f) (\"ハッシュテーブルを作成する\" :ctime 1227601018 :cuser #f :mtime 1227601255 :muser #f) (\"ハッシュテーブル\" :ctime 1227354846 :cuser #f :mtime 1227600818 :muser #f))")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 40 #" . "(1624116841)")
("|comments:リクエスト::003" . "(:ctime 1398706946 :cuser #f :mtime 1398706946 :muser #f)* inok (2014/04/28 10:42:26):\n<<<\n最近の動向とかをまとめてみたらどうでしょうか。\n処理系だけでなく、規格とかアプリケーションを含めて。\n\n>>>\n")
(" %Tag:リスト" . "(1668282358 (\"リスト\" :ctime 1227496094 :cuser #f :mtime 1233105288 :muser #f) (\"リストを定義する\" :ctime 1227502058 :cuser #f :mtime 1233062123 :muser #f) (\"リストの各要素に手続きを適用する\" :ctime 1230927390 :cuser #f :mtime 1231011574 :muser #f) (\"循環リストを使う\" :ctime 1230320100 :cuser #f :mtime 1230322530 :muser #f) (\"リストをソートする\" :ctime 1229597489 :cuser #f :mtime 1229597489 :muser #f) (\"手続きの仮引数として正しい形式か検査する\" :ctime 1228837883 :cuser #f :mtime 1228837883 :muser #f) (\"非真正リストを真正リストに変換する\" :ctime 1228837296 :cuser #f :mtime 1228837456 :muser #f) (\"リストから重複した要素を取り除く\" :ctime 1227608876 :cuser #f :mtime 1228802710 :muser #f) (\"リストから要素を取り出す\" :ctime 1227501516 :cuser #f :mtime 1228349850 :muser #f) (\"リストの要素数を取得する\" :ctime 1227501083 :cuser #f :mtime 1228349764 :muser #f) (\"リストから要素を探す\" :ctime 1227502775 :cuser #f :mtime 1228349669 :muser #f) (\"リストを逆順にする\" :ctime 1227503090 :cuser #f :mtime 1228349551 :muser #f) (\"連想リストを使う\" :ctime 1227505307 :cuser #f :mtime 1228349479 :muser #f) (\"リストを結合する\" :ctime 1227532498 :cuser #f :mtime 1228349286 :muser #f) (\"リストを作成する\" :ctime 1227500527 :cuser #f :mtime 1228349150 :muser #f))")
("名前を変更して export する" . "(:ctime 1227884232 :cuser #f :mtime 1228348740 :muser #f)[[$$tag ライブラリ R6RS]]\n\n名前を変更して [[$$r6rs export]] するには[[名前を変更して import する]]場合と同様に rename 節を使うことができる。\n\n{{{\n(library (my-lib)\n  (export (rename srfi-61:cond cond)\n\t  (rename srfi-87:case case)\n\t  ...)\n  (import (rnrs)\n\t  (prefix (srfi :61) srfi-61:)\n\t  (prefix (srfi :87) srfi-87:))\n  )\n}}}\n\nprefix 節を使うことはできない。\n")
(" %Tag:文字列" . "(1668195822 (\"文字列\" :ctime 1227101219 :cuser #f :mtime 1515206594 :muser #f) (\"文字列を数値に変換する\" :ctime 1227425885 :cuser #f :mtime 1240391591 :muser #f) (\"文字列を Base64 エンコードする\" :ctime 1229176092 :cuser #f :mtime 1238220404 :muser #f) (\"文字列を分割する\" :ctime 1230369695 :cuser #f :mtime 1230908706 :muser #f) (\"文字列を URI エンコードする\" :ctime 1228696992 :cuser #f :mtime 1230361031 :muser #f) (\"文字列の先頭・末尾の空白を削除する\" :ctime 1227425646 :cuser #f :mtime 1228802815 :muser #f) (\"文字列のエンコーディングを変換する\" :ctime 1228799761 :cuser #f :mtime 1228799761 :muser #f) (\"文字列を結合する\" :ctime 1227424944 :cuser #f :mtime 1227811722 :muser #f) (\"文字列を一行づつ処理する\" :ctime 1227425501 :cuser #f :mtime 1227428351 :muser #f) (\"文字とUnicodeスカラー値を相互変換する\" :ctime 1227425943 :cuser #f :mtime 1227425944 :muser #f) (\"文字列を一文字づつ処理する\" :ctime 1227425322 :cuser #f :mtime 1227425322 :muser #f) (\"部分文字列を取り出す\" :ctime 1227425232 :cuser #f :mtime 1227425233 :muser #f) (\"複数行の文字列を作成する\" :ctime 1227425167 :cuser #f :mtime 1227425167 :muser #f) (\"大文字と小文字を入れ替える\" :ctime 1227425090 :cuser #f :mtime 1227425090 :muser #f) (\"大文字・小文字に揃える\" :ctime 1227425017 :cuser #f :mtime 1227425018 :muser #f))")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45) -- /* order by \"as /*" . "(1624116641)")
(" %Tag:SXML99999' union select unhex(hex(version())) -- 'x'='x" . "(1573238433)")
("文字列を分割する" . "(:ctime 1230369695 :cuser #f :mtime 1230908706 :muser #f)[[$$tag R6RS 文字列 FIXME]]\n\n{{{\n(import (rnrs base))\n\n(define (string-split-by-char str spliter)\n  (let loop ((ls (string->list str)) (buf '()) (ret '()))\n    (if (pair? ls)\n      (if (char=? (car ls) spliter)\n        (loop (cdr ls) '() (cons (list->string (reverse buf)) ret))\n        (loop (cdr ls) (cons (car ls) buf) ret))\n      (reverse (cons (list->string (reverse buf)) ret)))))\n\n(define (string-split-by-string str spliter)\n  (if (zero? (string-length spliter))\n    (list str)\n    (let ((spl (string->list spliter)))\n      (let loop ((ls (string->list str)) (sp spl) (tmp '()) (buf '()) (ret '()))\n        (if (pair? sp)\n          (if (pair? ls)\n            (if (char=? (car ls) (car sp))\n              (loop (cdr ls) (cdr sp) (cons (car ls) tmp) buf ret)\n              (loop (cdr ls) spl '() (cons (car ls) (append tmp buf)) ret))\n            (reverse (cons (list->string (reverse (append tmp buf))) ret)))\n          (loop ls spl '() '() (cons (list->string (reverse buf)) ret)))))))\n\n(define (string-split str spliter)\n  (cond\n    ((char? spliter) (string-split-by-char str spliter))\n    ((string? spliter) (string-split-by-string str spliter))\n    (else #f)))\n\n(string-split \"\" #\\&)               ;=> (\"\")\n(string-split \"&\" #\\&)              ;=> (\"\" \"\")\n(string-split \"abc&def&ghi\" #\\&)    ;=> (\"abc\" \"def\" \"ghi\")\n(string-split \"&abc&def&ghi&\" #\\&)  ;=> (\"\" \"abc\" \"def\" \"ghi\" \"\")\n\n(string-split \"abc123def123ghi\" \"123\")       ;=> (\"abc\" \"def\" \"ghi\")\n(string-split \"123abc123def123ghi123\" \"123\") ;=> (\"\" \"abc\" \"def\" \"ghi\" \"\")\n}}}\n\nSRFI 13 の string-tokenize を使うと、逆に、構成要素となる文字の集合を指定して文字列を抽出することができる。\n\n{{{\n(import (srfi :13)\n\t(srfi :14))\n\n(string-tokenize \"\" (char-set-complement (char-set #\\&))) ; => ()\n(string-tokenize \"&\" (char-set-complement (char-set #\\&))) ; => ()\n(string-tokenize \"abc&def&ghi\" (char-set-complement (char-set #\\&)))\n;; => (\"abc\" \"def\" \"ghi\")\n(string-tokenize \"&abc&def&ghi\" (char-set-complement (char-set #\\&)))\n;; => (\"abc\" \"def\" \"ghi\")\n}}}\n")
(" %Tag:手続き?p=Tag?Tag?Tag?Tag:手続き?p=Tag?Tag?Tag" . "(1476570502)")
(" %Tag:例外処理" . "(1668195794 (\"例外を発生させる\" :ctime 1233265934 :cuser #f :mtime 1233265935 :muser #f) (\"例外を補足する\" :ctime 1233259568 :cuser #f :mtime 1233265370 :muser #f) (\"コンディション\" :ctime 1228790694 :cuser #f :mtime 1233265097 :muser #f) (\"確実に後処理を行なう\" :ctime 1228880199 :cuser #f :mtime 1228953202 :muser #f) (\"エラーを通知する\" :ctime 1228790688 :cuser #f :mtime 1228878329 :muser #f))")
("複数の値を返す手続き" . "(:ctime 1228154452 :cuser #f :mtime 1228348136 :muser #f)[[$$tag R6RS 手続き マクロ]]\n\nScheme では手続きは [[$$r6rs values]] 手続きを使って任意個数の値を返すことができる。標準の手続きでは例えば、 [[$$r6rs div-and-mod]] などが複数の値を返す。\n\nところで、 [[$$r6rs hashtable-ref]] 手続きは default 値にハッシュテーブル内に存在しうる値を指定すると、それがハッシュテーブル内に存在した値なのか default 値に渡した値なのか区別できない。そこで、例としてハッシュテーブルの参照を行ない、 2 値目にキーに対応した値がハッシュテーブルに存在したかどうかを返す手続き hashtable-ref* を考える。\n\n{{{\n(import (rnrs))\n\n(define (hashtable-ref* ht key default)\n  (values (hashtable-ref ht key default)\n\t  (hashtable-contains? ht key)))\n\n(define ht (make-eqv-hashtable))\n\n(hashtable-set! ht 1 'one)\n(hashtable-set! ht 3 'three)\n\n(hashtable-ref* ht 1 'one) ; => one #t\n(hashtable-ref* ht 2 'two) ; => two #f\n(hashtable-ref* ht 3 'three) ; => three #t\n}}}\n\nこのように手続きは任意個の値を返す可能性があるので、常にそのことを考慮しておかなければならない。関数の合成行なう手続き compose を定義する場合、次のような定義では g が多値を返した場合に動作が規定されない。\n\n{{{\n(import (rnrs))\n\n(define (compose f g)\n  (lambda args\n    (f (apply g args))))\n}}}\n\n多値を考慮する場合次のようにする。\n{{{\n(import (rnrs))\n\n(define (compose f g)\n  (lambda args\n    (call-with-values (lambda () (apply g args)) f)))\n}}}\n\nマクロの場合も同じである。例えば [[$$r6rs begin]] のように式を順に評価し、最後の値ではなく最初の値を返すような構文 begin0 を定義したいと考える。このとき、次のような定義では最初の式が複数の値を返した場合の動作が規定されない。\n\n{{{\n(import (rnrs))\n\n(define-syntax begin0\n  (syntax-rules ()\n    ((_ e es ...)\n     (let ((v e))\n       es ...\n       v))))\n}}}\n\n次のように定義するとうまく行く。\n{{{\n(import (rnrs))\n\n(define-syntax begin0\n  (syntax-rules ()\n    ((_ e es ...)\n     (let-values ((v e))\n       es ...\n       (apply values v)))))\n}}}\n\n")
("プラットフォームに関する情報を得る" . "(:ctime 1229997881 :cuser #f :mtime 1229998838 :muser #f)[[$$tag プラットフォーム固有の情報]]\n\nSchemeはCPUやOSなどをなるべく抽象化して扱う方向でデザインされているため、直接それらの情報を得る手段は規格内では用意されていない。しかし、ある程度は可能である。\n\n- [[CPUのワードサイズを調べる]]\n- [[CPUのエンディアンを調べる]]\n")
("文字列を一行づつ処理する" . "(:ctime 1227425501 :cuser #f :mtime 1227428351 :muser #f)[[$$tag 文字列 入出力 R6RS]]\n\n* 文字列を一行ずつ処理する\n\n文字列ポートを使う。\n\n{{{\n(import (rnrs))\n\n(call-with-port (open-string-input-port \"abc\\ndef\\nghi\")\n  (lambda (p)\n    (do ((line (get-line p) (get-line p)))\n        ((eof-object? line))\n      (display line))))\n}}}\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45) -- /* order by 'as /*" . "(1624116268)")
("例外を補足する" . "(:ctime 1233259568 :cuser #f :mtime 1233265370 :muser #f)[[$$tag R6RS 例外処理]]\n\n例外が送出されると、例外ハンドラと呼ばれる 1 引数の手続きが例外の情報を表すオブジェクトを引数に呼び出される。\n\n例外ハンドラは [[$$r6rs with-exception-handler]] 手続きで設定する。\n\n補足した例外が [[$$r6rs raise]] により発生したものであり、例外ハンドラから処理が戻った場合には &non-continuable コンディションを含む例外が発生する。\n{{{\n(import (rnrs))\n\n(with-exception-handler\n    (lambda (exc)\n      (display exc))\n  (lambda ()\n    (raise 1)))\n;; -> 1\n;; => &non-continuable\n}}}\n\n例外ハンドラは入れ子にすることができ、ハンドラ内で発生したコンディションは上位の例外ハンドラに引き渡される。\n{{{\n(import (rnrs))\n\n(with-exception-handler\n    (lambda (exc)\n      (newline)\n      (display exc))\n  (lambda ()\n    (with-exception-handler\n\t(lambda (exc)\n\t  (display exc))\n      (lambda ()\n\t(raise 1)))))\n;; -> 1\n;;    #<condition &non-continuable>\n;; => &non-continuable\n}}}\n\nハンドラ内で再度 raise してより上位の例外ハンドラに処理を委譲することもできる。\n{{{\n(import (rnrs))\n\n(with-exception-handler\n    (lambda (exc)\n      (newline)\n      (display (* exc 2)))\n  (lambda ()\n    (with-exception-handler\n\t(lambda (exc)\n\t  (display exc)\n\t  (raise exc))\n      (lambda ()\n\t(raise 1)))))\n;; -> 1\n;;    2\n;; => &non-continuable\n}}}\n\nまた、別に例外補足用の構文として [[$$r6rs guard]] がある。\n\nguard では補足した例外を変数に束縛し、 [[$$r6rs cond]] と同様の構文でその例外に対する条件分岐を行なうことができる。 guard によって設定された例外ハンドラで例外が処理された場合には、そのハンドラの戻した値が guard の値になる。\n{{{\n(import (rnrs))\n\n(guard (con\n\t((string? con)\n\t con)\n\t((number? con)\n\t (number->string con))\n\t((symbol? con)\n\t (symbol->string con)))\n  (raise 'exception))\n;; =>\"exception\"\n}}}\nどの条件節でも例外が処理されなかった場合には、その例外はさらに上位のハンドラに再度 raise される。\n{{{\n(import (rnrs))\n\n(guard (con\n\t((string? con)\n\t con)\n\t((number? con)\n\t (number->string con))\n\t((symbol? con)\n\t (symbol->string con)))\n  (raise (make-error)))\n;; => &error\n}}}\n")
("編集に関する基本方針" . "(:ctime 1227344399 :cuser #f :mtime 1227544182 :muser #f)[[$$toc]]\n\n* 編集に関する基本方針\n\nこのコンテンツは [http://practical-scheme.net/wiliki/wiliki.cgi WiLiKi] というWikiエンジンで構築されており、以下の基本方針に同意していただける方であれば、どなたでもコンテンツの追加、修正をすることが可能です。\n\n** 引用先でのクレジット表示不要の確認\n\n引用先でのクレジット表示が必要な投稿はご遠慮下さい。\n\n** 著作権を侵害しない\n\n他者の著作権を侵害する内容を書き込むことはご遠慮ください。\n\n** 改変・削除される可能性があることに同意してください\n\n自分が書き込んだ内容が改変、もしくは削除される可能性があることに同意してください。\n")
("手続きの仮引数として正しい形式か検査する" . "(:ctime 1228837883 :cuser #f :mtime 1228837883 :muser #f)[[$$tag R6RS リスト 手続き マクロ]]\n\n手続きの仮引数（formal parameter）と同一の形式の構文は標準マクロを始めとして多く見られる。\n\n{{{\n(import (rnrs))\n\n(define (formals? xs)\n  (define (p? x)\n    (or (symbol? x)\n\t(identifier? x)))\n  (or (null? xs)\n      (and (not (pair? xs))\n\t   (p? xs))\n      (and (p? (car xs))\n\t   (formals? (cdr xs)))))\n}}}\n")
("環境変数を取得する" . "(:ctime 1230276136 :cuser #f :mtime 1230343874 :muser #f)[[$$tag R6RS SRFI システム環境]]\n\n環境変数を取得するには [[$$srfi 98]] を使う。\n{{{\n(import (srfi :98))\n\n(get-environment-variable \"HOME\") ; => \"/home/schemer\"\n(get-environment-variable \"SHELL\") ; => \"/usr/bin/scsh\"\n}}}\n\nget-environment-variables を使うと環境変数すべてを連想リストとして取り出すことができる。\n{{{\n(import (srfi :98))\n\n(get-environment-variables)\n;; => ((\"USER\" . \"schemer\")\n;;     (\"HOME\" . \"/home/schemer\")\n;;     (\"SHELL\" . \"/usr/bin/scsh\")\n;;     ...\n;;     )\n}}}\n")
(" %Tag:FIXME' and 'x'='x" . "(1581247072)")
("|comments:リクエスト::002" . "(:ctime 1318272287 :cuser #f :mtime 1318272287 :muser #f)* mEsLMuKLCbeiINLRx (2011/10/10 11:44:47):\n<<<\nTo think, I was counfesd a minute ago.\n>>>\n")
(" %Tag:HTML AND 1=1" . "(1582392993)")
("マクロ" . "(:ctime 1227133972 :cuser #f :mtime 1232448539 :muser #f)[[$$tag マクロ]]\n\n- [[簡単なリスト用のループマクロの例]]\n- [[構文キーワード]]\n- [[quasisyntax を使う]]\n- [[anaphoric if]]\n- [[一時識別子の生成]]\n- [[マクロの引数の検査]]\n- [[マクロ展開時に計算処理を行なう]]\n- [[マクロを定義するマクロ]]\n- [[識別子を生成する]]\n")
(" %Tag:HTML' or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- 'x'='x" . "(1582393000)")
("リスト" . "(:ctime 1227496094 :cuser #f :mtime 1233105288 :muser #f)[[$$tag リスト]]\n\n- [[リストを作成する]]\n- [[リストの要素数を取得する]]\n- [[リストから要素を取り出す]]\n- [[リストから要素を探す]]\n- [[リストから重複した要素を取り除く]]\n- [[リストをソートする]]\n- [[リストを逆順にする]]\n- [[リストを結合する]]\n- [[リストの各要素に手続きを適用する]]\n- [[連想リストを使う]]\n- [[非真正リストを真正リストに変換する]]\n- [[手続きの仮引数として正しい形式か検査する]]\n- [[循環リストを使う]]\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45) -- /* order by \"as /*" . "(1624116574)")
(" %Tag:HTML' and 'x'='y" . "(1582392990)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45) -- /* order by \"as /*" . "(1624116620)")
("正規表現" . "(:ctime 1227169928 :cuser #f :mtime 1227184199 :muser #f)R6RS 時点では正規表現については定められていず、処理系依存の方法に頼るか、汎用のライブラリに頼らなければならないのが現状である。\n\n汎用の正規表現ライブラリとしては次のようなものがある。\n- [http://www.ccs.neu.edu/home/dorai/pregexp/pregexp.html pregexp: Portable Regular Expressions for Scheme and Common Lisp]\n- [http://synthcode.com/scheme/irregex/ IrRegular Expressions]\n\n各処理系の正規表現の実装については [http://practical-scheme.net/wiliki/schemexref.cgi?Concept%3aRegularExpression Concept:RegularExpression - Scheme Cross Reference] も参照。\n")
("レコード型の詳細を調べる" . "(:ctime 1233365564 :cuser #f :mtime 1233365565 :muser #f)[[$$tag R6RS レコード]]\n\n(rnrs records inspection) の諸手続きを使うとレコード型について様々な情報を得ることができる。\n\n{{{\n(import (rnrs)\n\t(srfi :28))\n\n(define (print-record record)\n  (let ((rtd (record-rtd record)))\n    (display\n     (format \"type: ~S~%\\\n              parent: ~S~%\\\n              uid: ~S~%\\\n              generative?: ~S~%\\\n              sealed?: ~S~%\\\n              opaque?: ~S~%\\\n              fields:~%\"\n\t     (record-type-name rtd)\n\t     (cond ((record-type-parent rtd) => record-type-name)\n\t\t   (else #f))\n\t     (record-type-uid rtd)\n\t     (record-type-generative? rtd)\n\t     (record-type-sealed? rtd)\n\t     (record-type-opaque? rtd)))\n    (let* ((fnv (record-type-field-names rtd))\n\t   (l (vector-length fnv)))\n      (do ((i 0 (+ i 1)))\n\t  ((= i l))\n\t(display (format \" #~S: ~S = ~S (~S)~%\"\n\t\t\t i (vector-ref fnv i)\n\t\t\t ((record-accessor rtd i) record)\n\t\t\t (if (record-field-mutable? rtd i) 'mutable 'immutable)))))))\n\n(define-record-type point\n  (fields\n   (mutable x)\n   (mutable y)))\n\n(define-record-type colored-point\n  (parent point)\n  (sealed #t)\n  (fields\n   (immutable color)))\n\n(define p (make-point 2 5))\n\n(define cp (make-colored-point 3 4 'red))\n\n(print-record p)\n;; ->  type: point\n;;     parent: #f\n;;     uid: #f\n;;     generative?: #t\n;;     sealed?: #f\n;;     opaque?: #f\n;;     fields:\n;;      #0: x = 2 (mutable)\n;;      #1: y = 5 (mutable)\n;;\n\n(print-record cp)\n;; -> type: colored-point\n;;    parent: point\n;;    uid: #f\n;;    generative?: #t\n;;    sealed?: #t\n;;    opaque?: #f\n;;    fields:\n;;     #0: color = red (immutable)\n;;\n}}}\n\n")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 160 #" . "(1624116863)")
("グレゴリオ暦からユリウス日を計算する" . "(:ctime 1307025392 :cuser #f :mtime 1307038163 :muser #f)ユリウス日とは紀元前4713年1月1日正午(世界標準時)からの日数です。\n\n (import (rnrs))\n (define (gregorian->julian-day year month day)\n   (let* ((a (div (- 14 month) 12))\n          (y (- (+ year 4800) a))\n          (m (- (+ month (* 12 a)) 3)))\n     (- (+ day\n           (div (+ (* 153 m) 2) 5)\n           (* 365 y)\n           (div y 4)\n           (div y 400))\n        (div y 100) 32045)))\n\nsrfi-19にも変換関数があります。(正午で切り替わるので、make-dateのhourに12を渡しています。)\n\n  (date->julian-day (make-date 0 0 0 12 day month year 0))\n")
("処理系依存部分のあるライブラリを書く" . "(:ctime 1231150071 :cuser #f :mtime 1231249974 :muser #f)[[$$tag R6RS ライブラリ]]\n\n標準として定められた方法は存在しないが Ikarus, IronScheme, Larceny, Mosh, MzScheme, Ypsilon では （string-append \".\" (string-downcase ''<処理系名>'') \".sls\") という拡張子のファイルを import 時に探索するため、処理系依存部分をそのような拡張子を持つファイルに分離してやればよい。\n\n例えば foo というライブラリを書く場合、処理系依存の部分を foo/compat.ikarus.sls, foo/compat.ironscheme.sls, ... に記述して抽象化し foo 本体を次のように書けばよい。\n\n{{{\n(library foo\n  (export ...)\n  (import (foo compat)\n\t  ...\n\t  )\n\n  ...)\n}}}\n")
("マクロ展開時に計算処理を行なう" . "(:ctime 1229058729 :cuser #f :mtime 1229058729 :muser #f)[[$$tag R6RS マクロ]]\n\n[[$$r6rs syntax-case]] を使うとマクロ展開時に計算処理を行なうことができる。\n\nここでは、 スター閉包・連接・和だけに構文を簡略化した [http://www.scsh.net/docu/post/sre.html SRE] のサブセットを [http://www.pcre.org/ PCRE] を表す文字列に変換するマクロを考える。\n\n{{{\n(import (rnrs))\n\n(define-syntax rx\n  (lambda (x)\n    (define (regexp-quote s)\n      (call-with-string-output-port\n       (lambda (p)\n\t (string-for-each\n\t  (lambda (c)\n\t    (when (memv c '(#\\( #\\) #\\* #\\|))\n\t      (write-char #\\\\ p))\n\t    (write-char c p))\n\t  s))))\n    (define (intersperse x ys)\n      (fold-right (lambda (y knil)\n\t\t    (if (null? knil)\n\t\t\t(cons y knil)\n\t\t\t(cons* y x knil)))\n\t\t  '() ys))\n    (define (parse re)\n      (syntax-case re (submatch : * or)\n\t((submatch re ...)\n\t (string-append \"(\"\n\t\t\t(apply string-append (map parse #'(re ...)))\n\t\t\t\")\"))\n\t((: re ...)\n\t (string-append \"(?:\"\n\t\t\t(apply string-append (map parse #'(re ...)))\n\t\t\t\")\"))\n\t((* re ...)\n\t (string-append \"(?:\"\n\t\t\t(apply string-append (map parse #'(re ...)))\n\t\t\t\")*\"))\n\t((or re ...)\n\t (string-append \"(?:\"\n\t\t\t(apply string-append\n\t\t\t       (intersperse \"|\" (map parse #'(re ...))))\n\t\t\t\")\"))\n\t(s\n\t (string? (syntax->datum #'s))\n\t (regexp-quote (syntax->datum #'s)))\n\t(pat\n\t (syntax-violation 'rx:parse \"invalid syntax\" x #'pat))))\n    (syntax-case x ()\n      ((k re ...)\n       (datum->syntax #'k (parse #'(: re ...)))))))\n}}}\n\n{{{\n(rx (or \"a\" \"b\")) ; => \"(?:(?:a|b))\"\n(rx (* (or \"|\" \"*\"))) ; => \"(?:(?:(?:\\\\||\\\\*))*)\"\n(rx (: (or \"(\" \")\") \"a\")) ; => \"(?:(?:(?:\\\\(|\\\\))a))\"\n}}}\n\nこれらの計算は実行時ではなくマクロ展開時に行なわれる。コンパイルを行なう処理系ではこれらの計算は実行時に毎回行われるのではなく、コンパイル時にマクロを展開するときに一度だけ行なわれる。このように計算処理を実行時からマクロ展開時にずらすことで効率を上げることができることもある。\n")
(" %Tag:stub\" and \"x\"=\"x" . "(1580892183)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45) -- /* order by \"as /*" . "(1624116675)")
(" %Tag:スレッド' or (1,2)=(select*from(select name_const(CHAR(118,118,69,76,71,89,97,114,77,74),1),name_const(CHAR(118,118,69,76,71,89,97,114,77,74),1))a) -- 'x'='x" . "(1624117048)")
(" %Tag:スレッド999999.1 union select unhex(hex(version())) -- and 1=1" . "(1624117069)")
("手続きを作成する" . "(:ctime 1228154104 :cuser #f :mtime 1228348278 :muser #f)[[$$tag R6RS 手続き]]\n\nScheme では [[$$r6rs lambda]] 式を使うことで、手続き定義を伴わずその場で手続きを作成することができる。\n\n一般的な言語では\n{{{\n(import (rnrs))\n\n(define (add2 x)\n  (+ x 2))\n\n(map add2 '(1 2 3 4 5))\n}}}\nのようにするところを Scheme では\n{{{\n(import (rnrs))\n\n(map (lambda (x) (+ x 2)) '(1 2 3 4 5))\n}}}\nと書くことができる。\n\n")
("レコード" . "(:ctime 1233356925 :cuser #f :mtime 1233365578 :muser #f)[[$$tag R6RS レコード]]\n\n- [[レコード型を定義する]]\n- [[レコード型を拡張する]]\n- [[レコード型を拡張できないようにする]]\n- [[レコード型の詳細を調べる]]\n- [[レコード型の詳細を隠蔽する]]\n- [[レコードの初期化をカスタマイズする]]\n")
("|comments:リクエスト::001" . "(:ctime 1233029108 :cuser #f :mtime 1233029108 :muser #f)* leque (2009/01/26 20:05:08):\n<<<\n基本的に、コード例は RnRS と各 SRFI に準拠している理想的な処理系で動くものと期待して書いています。確認に使っている処理系はその時によって違います。処理系依存の機能を使っている場合はそれを明記するようにしています。\n>>>\n")
("リストをソートする" . "(:ctime 1229597489 :cuser #f :mtime 1229597489 :muser #f)[[$$tag R6RS リスト]]\n\nリストをソートするには [[$$r6rs list-sort]] 手続きを使う。\n\n{{{\n(import (rnrs base)\n\t(rnrs sorting))\n\n(list-sort < '(-1 4 2 6 -7 9 -10 1 2))\n;; => (-10 -7 -1 1 2 2 4 6 9)\n}}}\n\nリストの要素自体とは異なる基準でソートしたい場合には [[wikipedia-en:Schwartzian_transform]] を使う。\n\n{{{\n(import (rnrs base)\n\t(rnrs sorting))\n\n(define (list-sort-by cmp-proc key-proc xs)\n  (map car\n       (list-sort (lambda (a b)\n\t\t    (cmp-proc (cdr a) (cdr b)))\n\t\t  (map (lambda (x)\n\t\t\t (cons x (key-proc x)))\n\t\t       xs))))\n\n(list-sort-by < abs '(-1 4 2 6 -7 9 -10 1 2))\n;; => (-1 1 2 2 4 6 -7 9 -10)\n}}}\n\nlist-sort は安定な並べ替えを行なうことが保証されている。\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45) -- /* order by \"as /*" . "(1624116553)")
("マクロを定義するマクロ" . "(:ctime 1229501665 :cuser #f :mtime 1229507234 :muser #f)[[$$tag R6RS マクロ]]\n\n(rnrs enums) の [[$$r6rs define-enumeration]] マクロの\n{{{\n(define-enumeration color\n  (black white purple maroon)\n  color-set)\n}}}\nという記述は、おおよそ\n{{{\n(define-syntax color\n  (lambda (x)\n    (syntax-case x ()\n      ((_ sym)\n       (memq (syntax->datum #'sym) '(black white purple maroon))\n       #''sym))))\n}}}\nと\n{{{\n(define-syntax color-set\n  (lambda (x)\n    (syntax-case x ()\n      ((_ sym ...)\n       (for-all (lambda (s) (memq s '(black white purple maroon)))\n\t\t(syntax->datum #'(sym ...))))\n      #'((enum-set-constructor (make-enumeration '(black white purple maroon)))\n\t '(sym ...)))))\n}}}\nというふたつのマクロに展開される。 [[$$r6rs syntax-case]] ではマクロ定義中の識別子の意味は通常の識別子と同じく字句構文上もっとも近い識別子と同一と解釈されるため、伝統的なマクロのように [[$$r6rs quasiquote]] の入れ子に悩まされることはない。その代わりに展開形に ... を含めたい場合に、現在のマクロ定義のものと混同しないために (... ...) と書く必要がある。\n\nそれを踏まえた上で define-enumeration マクロは次のように定義できる。\n{{{\n(import (rnrs base)\n\t(rnrs syntax-case)\n\t(except (rnrs enums) define-enumeration))\n\n(define-syntax define-enumeration\n  (syntax-rules ()\n    ((_ type-name (sym ...) constructor-syntax)\n     (begin\n       (define-syntax type-name\n\t (lambda (x)\n\t   (syntax-case x ()\n\t     ((_ sym1)\n\t      (memq (syntax->datum #'sym1) '(sym ...))\n\t      #''sym1))))\n       (define-syntax constructor-syntax\n\t (lambda (x)\n\t   (syntax-case x ()\n\t     ((_ sym2 (... ...))\n\t      (for-all (lambda (s) (memq s '(sym ...)))\n\t\t       (syntax->datum #'(sym2 (... ...))))\n\t      #'((enum-set-constructor (make-enumeration '(sym ...)))\n\t\t '(sym2 (... ...)))))))))))\n}}}\n")
(" %Tag:SXML\" and \"x\"=\"y" . "(1573238427)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45) -- /* order by \"as /*" . "(1624116608)")
(" %Tag:スレッド" . "(1668286290 (\"スレッド\" :ctime 1227970633 :cuser #f :mtime 1228795142 :muser #f))")
(" %Tag:R6RS'" . "(1649773180)")
(" %Tag:HTML' and 'x'='x" . "(1582392989)")
(" %Tag:Web'[0]" . "(1662031617)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45) --  /*" . "(1624116190)")
(" %Tag:日付と時刻'nvOpzp" . "(1662837844)")
("引数のリストに手続きを適用する" . "(:ctime 1229044401 :cuser #f :mtime 1229050131 :muser #f)[[$$tag R6RS 手続き]]\n\n引数のリストに手続きを適用するには [[$$r6rs apply]] 手続きを使う。\n\n{{{\n(import (rnrs))\n\n(apply + '(1 2 3 4)) ; => 10\n\n(apply list 'a 'b '(c d e)) ; => (a b c d e) \n}}}\n\n可変長引数を取る手続きを呼び出す場合、省略可能な部分をリストに保存しておいて適用できると便利なことがある。例えば、指定の *load-path* からファイルを探して開く open-file-input-port/load-path 手続きを考える。この手続きはファイルを *load-path* 内から探索する以外は [[$$r6rs open-file-input-port]] 手続きと同一の引数を取るものとする。 apply のない場合には [[$$r6rs case-lambda]] で場合分けをして引数を渡すか、残余引数を [[$$r6rs car]] や [[$$r6rs cdr]] で分解しなければならない。 apply を使うと次のように書ける。\n\n{{{\n(import (rnrs) (srfi :2) (srfi :39))\n\n(define *load-path*\n  (make-parameter '(\"/usr/share/scheme/\" \"/usr/local/share/scheme/\")))\n\n(define (open-file-input-port/load-path fn . opts)\n  (or (exists (lambda (path)\n\t\t(and-let* ((p (string-append path fn))\n\t\t\t   ((file-exists? p)))\n\t\t  (apply open-file-input-port p opts)))\n\t      (*load-path*))\n      (raise\n       (condition\n\t(make-who-condition 'open-file-input-port/load-path)\n\t(make-message-condition \"file does not exist in load path\")\n\t(make-irritants-condition (*load-path*))\n\t(make-i/o-file-does-not-exist-error fn)))))\n}}}\n")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45) --  /*" . "(1624116125)")
("コメント" . "(:ctime 1227924794 :cuser #f :mtime 1228348546 :muser #f)[[$$tag R6RS コーディングスタイル]]\n\n* 行コメント\n; コメントはコメント対象と同一行に置き、複数連続する場合には桁位置をそろえることが好ましい。\n\n\n'''';; コメントはコメント対象の前の行に置き、通常のコードと同様にインデントを揃える。\n\n'''';;; コメントはコードのまとまりに対するコメントとしてつける。位置は左端に揃える。典型的な使用例としてはプログラム内での設計原理についての説明がある。関数内の行をコメントアウトするのにもこの形式を使う。\n\n'''';;;; コメントはヘッダとして使う。典型的な使用例はファイルヘッダなどである。\n\n{{{\n;;;; my-util.sls - some utility procedures for my own use.\n;;;; License should be wrote here?\n(library (my-util)\n  (export map*)\n  (import (rnrs))\n\n;;; RnRS' map takes lists, each of which has the same length.\n;;; But the version takes lists unequal in length is often useful.\n\n  ;; similar to map, but may takes lists unequal in length.\n  (define (map* f xs . xss)\n    (if (null? xss)\t\t\t; fast path\n\t(map proc xs)\t\t\t; same as the RnRS' map\n\t(let loop ((xs xs)\n\t\t   (xss xss)\n\t\t   (rs '()))\n\t  (if (or (null? xs) (exists null? xss))\n\t      (reverse rs)\n\t      (loop (cdr xs)\n\t\t    (map cdr xss)\n\t\t    (cons (apply proc (car xs) (map car xss)) rs))))))\n  )\n}}}\n\nCf. [http://www.lispworks.com/documentation/HyperSpec/Body/02_ddb.htm CLHS: Section 2.4.4.2], [http://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Comment-Tips GNU Emacs Lisp Reference Manual]\n\n* #;\nある式を一時的にコメントアウトして他の値を代わりに与える場合には #; コメントが便利である。\n\n{{{\n(let ((w (* *weight* 2)))\n  ...)\n}}}\n→\n{{{\n(let ((w #;(* *weight* 2) 3)) ; change weight temporarily\n  ...)\n}}}\n\n* #| ... |#\nコードの大きなまとまりをコメントアウトするには #| ... |# コメントを使う。 #| ... |# コメントは入れ子にすることができるので C の #if 0 〜 #endif のように使うことができる。\n\n{{{\n;;; TODO: implement later on\n#|\n(define (some-complicated-procedure arg . args)\n  ...)\n\n...\n|#\n}}}\n\n")
("|comments:リクエスト::000" . "(:ctime 1230348415 :cuser #f :mtime 1230348415 :muser #f)* none (2008/12/26 19:26:55):\n<<<\nサンプルコードがどの処理系で動作確認されているか書いて欲しいです。\n>>>\n")
(" %Tag:ハッシュテーブル'[0]" . "(1657596286)")
(" %Tag:FIXME'" . "(1582022291)")
("ネットワーク" . "(:ctime 1227970491 :cuser #f :mtime 1227970705 :muser #f)[[$$tag ネットワーク]]\n\nネットワークに関しては RnRS でも SRFI でも規定されていない。処理系依存の機能に頼らなければならないのが現状である。\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45) -- /* order by 'as /*" . "(1624116377)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 20 #" . "(1624116830)")
(" %Tag:入出力" . "(1668195801 (\"文字列のエンコーディングを変換する\" :ctime 1228799761 :cuser #f :mtime 1228799761 :muser #f) (\"データを読み書きする\" :ctime 1228778287 :cuser #f :mtime 1228784319 :muser #f) (\"入出力\" :ctime 1227408592 :cuser #f :mtime 1228778293 :muser #f) (\"文字列を一行づつ処理する\" :ctime 1227425501 :cuser #f :mtime 1227428351 :muser #f) (\"ファイルに追記する\" :ctime 1227427711 :cuser #f :mtime 1227427711 :muser #f) (\"バイナリポートをテキストポートに変換する\" :ctime 1227427432 :cuser #f :mtime 1227427432 :muser #f) (\"ポートを閉じる\" :ctime 1227427369 :cuser #f :mtime 1227427369 :muser #f) (\"ファイルを開く\" :ctime 1227427294 :cuser #f :mtime 1227427295 :muser #f))")
(" %Tag:stub and 1>1" . "(1580892181)")
(" %Tag:FIXME?p=Tag:FIXME" . "(1476573648)")
("省略可能引数のある手続き" . "(:ctime 1228154387 :cuser #f :mtime 1228348185 :muser #f)[[$$tag R6RS 手続き]]\n\nScheme では任意個数の引数を取る手続きを作ることができるので、それを利用して省略可能引数を実現することができる。\n\n{{{\n(import (rnrs))\n\n(define (f . args)\n  (let ((a (if (not (null? args))\n\t       (car args) 1))\n\t(b (if (and (not (null? args))\n\t\t    (not (null? (cdr args))))\n\t       (cadr args) 2))\n\t(c (if (and (not (null? args))\n\t\t    (not (null? (cdr args)))\n\t\t    (not (null? (cddr args))))\n\t       (caddr args) 3)))\n    (list a b c)))\n\n(f) ; => (1 2 3)\n(f 3) ; => (3 2 3)\n(f 0 3) ; => (0 3 3)\n(f 2 4 5) ; => (2 4 5)\n}}}\n\nただし、この場合は [[$$r6rs case-lambda]] を使った方が楽である。\n\n{{{\n(import (rnrs))\n\n(define f\n  (case-lambda\n   (() (f 1))\n   ((a) (f a 2))\n   ((a b) (f a b 3))\n   ((a b c) (list a b c))))\n}}}\n\n")
("手続き" . "(:ctime 1227355895 :cuser #f :mtime 1230242707 :muser #f)[[$$tag R6RS 手続き]]\n\n- [[手続きを作成する]]\n- [[引数を一部固定した手続きを作る]]\n- [[手続きを返す手続きを書く]]\n- [[状態を持った手続きを作る]]\n- [[複数の手続きで状態を共有する]]\n- [[省略可能引数のある手続き]]\n- [[引数のリストに手続きを適用する]]\n- [[複数の値を返す手続き]]\n- [[末尾呼び出しの最適化]]\n- [[ループから脱出する]]\n- [[ループを記述する]]\n- [[状態機械を書く]]\n")
(" %Tag:数値?p=Tag:数値" . "(1476573483)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 320 #" . "(1624116874)")
("手続きを返す手続きを書く" . "(:ctime 1228154284 :cuser #f :mtime 1228160726 :muser #f)[[$$tag R6RS 手続き]]\n\nScheme では lambda 式でその場で手続きを作ることができるため、手続きを返す手続きを簡単に作ることができる。例えば、 2 引数の手続きを受け取り、それの第 1 引数と第 2 引数を逆順にして返す手続きは次のように書ける。\n\n{{{\n(import (rnrs))\n\n(define (flip f)\n  (lambda (x y)\n    (f y x)))\n}}}\n\nこれを使うと任意の手続きの引数の順序を交換するのに次のように書けるようになる。\n\n{{{\n(map (flip cons) '(1 3 5 7) '(2 4 6 8)) ; => ((2 . 1) (4 . 3) (6 . 5) (8 . 7))\n}}}\n\n")
(" %Tag:R6RS/.env" . "(1659736980)")
("ループを記述する" . "(:ctime 1229916880 :cuser #f :mtime 1230388452 :muser #f)[[$$tag R6RS 手続き 制御構造]]\n\nScheme では[[末尾呼び出しの最適化]]が行なわれるため、ループはすべて手続きの末尾呼び出しとして記述される。例えば次のようなループ\n{{{\nint i;\n\nfor (i = 0; i < 10; i++) {\n    ...\n}\n}}}\nは Scheme では\n{{{\n(import (rnrs))\n\n(define (for from to proc)\n  (cond ((< from to)\n\t (proc from)\n\t (for (+ from 1) to proc))))\n\n(for 0 10 (lambda (i) ...))\n}}}\nと記述するか、あるいは内部定義や局所束縛を使い\n{{{\n(import (rnrs))\n\n(define (foo)\n  (define (for from to proc)\n    (cond ((< from to)\n\t   (proc from)\n\t   (for (+ from 1) to proc))))\n  (for 0 10 (lambda (i) ...)))\n}}}\nや\n{{{\n(import (rnrs))\n\n(letrec ((for (lambda (from to proc)\n\t\t(cond ((< from to)\n\t\t       (proc from)\n\t\t       (for (+ from 1) to proc))))))\n  (for 0 10 (lambda (i) ...)))\n}}}\nと記述する。これらのような記述は頻出するので、名前付き [[$$r6rs let]] という繰り返しを記述するのに便利な構文が用意されている。\n{{{\n(import (rnrs))\n\n(let for ((i 0))\n  (cond ((< i 10)\n\t ...\n\t (for (+ i 1)))))\n}}}\nこれは [[$$r6rs letrec]] を使った記述とおよそ同等である。\n\nまた典型的な繰り返しには [[$$r6rs do]] 構文が利用できる。\n{{{\n(import (rnrs))\n\n(do ((i 0 (+ i 1)))\n    ((>= i 10))\n  ...)\n}}}\nさらに、[[リスト]]や[[文字列]]、[[ベクタ]]上の繰り返しには [[$$r6rs for-each]], [[$$r6rs string-for-each]], [[$$r6rs vector-for-each]] が用意されている。これらもまた最終的には手続きの末尾呼び出しに変形される。\n")
(" %Tag:スレッド\" or (1,2)=(select*from(select name_const(CHAR(118,118,69,76,71,89,97,114,77,74),1),name_const(CHAR(118,118,69,76,71,89,97,114,77,74),1))a) -- \"x\"=\"x" . "(1624117058)")
("変更不可能なハッシュテーブルを作成する" . "(:ctime 1227602439 :cuser #f :mtime 1227602440 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\nhashtable-copy の第 2 引数を省略するか偽値を指定すると複製されたハッシュテーブルが変更不可能になる。\n\n{{{\n(import (rnrs))\n\n(hashtable-set! (hashtable-copy ht #f) 'key 0) ;-> error\n}}}\n")
("コンディション" . "(:ctime 1228790694 :cuser #f :mtime 1233265097 :muser #f)[[$$tag R6RS コンディション 例外処理]]\n\n- [[エラーを通知する]]\n- [[例外を補足する]]\n- [[例外を発生させる]]\n- [[コンディションを定義する]]\n- [[コンディションを合成する]]\n\n")
(" %Tag:スレッド and 1=1" . "(1624115861)")
(" %Tag:SXML AND 1=1" . "(1573238428)")
(" %Tag:vO" . "(1425027323)")
(" %Tag:文字列?p=Tag?Tag:文字列?p=Tag" . "(1467042791)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45) -- /* order by \"as /*" . "(1624116751)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 631 #" . "(1624116938)")
(" %Tag:SXML' and 'x'='y" . "(1573238424)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 321 #" . "(1624116885)")
("anaphoric if" . "(:ctime 1228352551 :cuser #f :mtime 1228352611 :muser #f)[[$$tag R6RS マクロ]]\n\n条件部の評価結果を暗黙の変数 it で参照できる制御構造 aif （anaphoric if、前方照応 [[$$r6rs if]]）を考える。暗黙の束縛を導入するようなマクロは [[$$r6rs syntax-case]] と [[$$r6rs datum->syntax]] で記述する。\n\n{{{\n(import (rnrs))\n\n(define-syntax aif\n  (lambda (x)\n    (syntax-case x ()\n      ((ctx expr then else ...)\n       (with-syntax ((it (datum->syntax #'ctx 'it)))\n\t #'(let ((it expr))\n\t     (if it then else ...)))))))\n}}}\n\ndatum->syntax は、第二引数のオブジェクトを構文オブジェクトに変換するとき、変換結果の構文オブジェクトが第一引数の構文オブジェクトと同時にプログラム内に現れたかのように変換する。例えば上の例で、 it は通常の [[$$r6rs syntax-rules]] で記述したマクロのように自動的に、他の変数名と衝突しない一意な変数名に変換されるのではなく、 (aif (string->number s) it 0) と書いたときの `it' は ctx にマッチした `aif' と同一の文脈情報を持つ識別子として変換結果に挿入されるため、変換結果の then 部や else 部で通常の束縛と同じように参照することができる。\n\n")
("コマンドライン引数を解析する" . "(:ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f)[[$$tag R5RS R6RS プログラム SRFI SLIB Gauche stub]]\n\n例として imake(1) コマンドの引数を解析する場合を考える。\n\n[[$$toc]]\n\n* SRFI 37\nSRFI 37 では解析時の状態を手続きの引数で持ち回る形式を取る。多値と手続きを用い副作用なく記述できるという利点がある反面、やや冗長になりやすい傾向がある。\n\n{{{\n(import (rnrs) (srfi :37))\n\n(let-values\n    (([cpp-options\n       template-name\n       input-file-name\n       c-file-name\n       makefile-name\n       execute?\n       verbose?]\n      (args-fold (cdr (command-line))\n\t\t (list\n\t\t  (option '(#\\D) #t #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values (cons* arg (string #\\- name) cpp-opts)\n\t\t\t\t    tfn ifn cfn mfn e? v?)))\n\t\t  (option '(#\\I) #t #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values (cons* arg (string #\\- name) cpp-opts)\n\t\t\t\t    tfn ifn cfn mfn e? v?)))\n\t\t  (option '(#\\U) #t #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values (cons* arg (string #\\- name) cpp-opts)\n\t\t\t\t    tfn ifn cfn mfn e? v?)))\n\t\t  (option '(#\\T) #t #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values cpp-opts arg ifn cfn mfn e? v?)))\n\t\t  (option '(#\\f) #t #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values cpp-opts tfn arg cfn mfn e? v?)))\n\t\t  (option '(#\\C) #t #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values cpp-opts tfn ifn arg mfn e? v?)))\n\t\t  (option '(#\\s) #t #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values cpp-opts tfn ifn cfn arg e? v?)))\n\t\t  (option '(#\\e) #f #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values cpp-opts tfn ifn cfn mfn #t v?)))\n\t\t  (option '(#\\v) #f #f\n\t\t\t  (lambda (opt name arg cpp-opts tfn ifn cfn mfn e? v?)\n\t\t\t    (values cpp-opts tfn ifn cfn mfn e? #t)))\n\t\t  )\n\t\t (lambda (opt name arg . _)\n\t\t   (error 'parse-option \"unrecognized option\" name))\n\t\t (lambda (arg . _)\n\t\t   (error 'parse-option \"superfluous argument\" arg))\n\t\t '() \"Imake.tmpl\" \"Imakefile\" \"Imakefile.c\" \"Makefile\" #f #f)))\n  (display \"options to cpp: \")\n  (display (reverse cpp-options))\n  (display \"\\nthe name of master template file: \")\n  (display template-name)\n  (display \"\\nthe name of input file: \")\n  (display input-file-name)\n  (display \"\\nthe name of .c file: \")\n  (display c-file-name)\n  (display \"\\nthe name of makefile: \")\n  (display makefile-name)\n  (display \"\\nexecute: \")\n  (display execute?)\n  (display \"\\nverbose: \")\n  (display verbose?)\n  (newline))\n\n(exit)\n}}}\n\n* SLIB\n\n\n* Gauche\nGauche では gauche.parseopt モジュールにより、典型的なコマンドライン引数の解析を簡潔に記述できる。\n\n{{{\n(use gauche.parseopt)\n\n(let ((cpp-options '()))\n  (let-args *argv*\n      ((#f \"D=s\" => (lambda (arg)\n\t\t      (push! cpp-options (format \"-D~A\" arg))))\n       (#f \"I=s\" => (lambda (arg)\n\t\t      (push! cpp-options (format \"-I~A\" arg))))\n       (#f \"U=s\" => (lambda (arg)\n\t\t      (push! cpp-options (format \"-U~A\" arg))))\n       (template-name\t\"T=s\" \"Imake.tmpl\")\n       (input-file-name\t\"f=s\" \"Imakefile\")\n       (c-file-name\t\"C=s\" \"Imakefile.c\")\n       (makefile-name\t\"s=s\" \"Makefile\")\n       (execute? \"e\")\n       (verbose? \"v\")\n       (else (opt . _) (error \"Unknown option: \" opt))\n       . rest)\n    (unless (null? rest)\n      (error \"superfluous arguments: \"  rest))\n    (format #t \"options to cpp: ~A\nthe name of master template file: ~A\nthe name of input file: ~A\nthe name of .c file: ~A\nthe name of makefile: ~A\nexecute: ~A\nverbose: ~A~%\"\n\t    (reverse cpp-options)\n\t    template-name input-file-name c-file-name makefile-name\n\t    execute? verbose?)))\n\n(exit)\n}}}\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45),CHAR(45,120,50,53,45,81,45) -- /* order by 'as /*" . "(1624116486)")
(" %Tag:バイトベクタ//index.cgi?p=|echo \"Osirys-p0wa\"" . "(1247880494)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45) --  /*" . "(1624116158)")
("状態を持った手続きを作る" . "(:ctime 1228154331 :cuser #f :mtime 1228154331 :muser #f)[[$$tag R6RS 手続き]]\n\n手続きの字句環境を閉じ込むことで状態を持った手続きを作ることができる。\n\n{{{\n(import (rnrs))\n\n(define count\n  (let ((n 0))\n    (lambda ()\n      (let ((r n))\n\t(set! n (+ n 1))\n\tr))))\n\n(count) ; => 0\n(count) ; => 1\n(count) ; => 2\n}}}\n\nこうすることで大域的な名前空間を汚染せずに手続きに状態を持たせることができる。\n\nさらにこれを高階化することもできる。\n{{{\n(import (rnrs))\n\n(define (make-counter init)\n  (let ((n init))\n    (lambda ()\n      (let ((r n))\n\t(set! n (+ n 1))\n\tr))))\n\n(define c1 (make-counter 0))\n(define c2 (make-counter 5))\n\n(c1) ; => 0\n(c2) ; => 5\n(c2) ; => 6\n(c1) ; => 1\n}}}\n\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45) -- /* order by \"as /*" . "(1624116740)")
("ベクタをリストに変換する" . "(:ctime 1233012569 :cuser #f :mtime 1233012569 :muser #f)[[$$tag ベクタ R6RS]]\n\nScheme は Lisp （LISt Processor）族の言語であるため、一般にベクタを操作する手続きよりも[[リスト]]を操作する手続きの方が豊冨である。要素に対する繰り返しや要素の集積などはリストを使った方がより柔軟に行なえることが多い。一方で、要素の参照はベクタの方が高速である。用途に応じてリストとベクタを使い分けることで、より効率のよいプログラムを書くことができる。\n\nベクタをリストに変換するには [[$$r6rs vector->list]] 手続きを使う。\n{{{\n(import (rnrs))\n\n(vector->list '#(1 2 3)) ; => (1 2 3)\n}}}\n\n入れ子になったベクタではいちばん上の階層しか変換されない。\n{{{\n(import (rnrs))\n\n(vector->list '#(#(1) #(2) #(3))) ;=> (#(1) #(2) #(3))\n}}}\n\n逆にリストをベクタに変換するには [[$$r6rs list->vector]] 手続きを使う。\n\n{{{\n(import (rnrs))\n\n(list->vector '(1 2 3)) ; => #(1 2 3)\n}}}\n")
(" %Tag:HTML99999\" union select unhex(hex(version())) -- \"x\"=\"x" . "(1582392998)")
(" %Tag:SXML' and 'x'='x" . "(1573238424)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45) -- /* order by 'as /*" . "(1624116366)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45),CHAR(45,120,50,53,45,81,45) -- /* order by \"as /*" . "(1624116762)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 636 #" . "(1624116949)")
("リストを逆順にする" . "(:ctime 1227503090 :cuser #f :mtime 1228349551 :muser #f)[[$$tag リスト R6RS]]\n\nリストを逆順にするには [[$$r6rs reverse]] 手続きを使う。\n\n{{{\n(import (rnrs))\n\n(reverse '(1 2 3 4)) ; => (4 3 2 1)\n(reverse '()) ; => ()\n}}}\n\nScheme では計算結果をリストに [[$$r6rs cons]] し逆順に保持しておき、最後に reverse するというイディオムがよく使われる。\n\n{{{\n(import (rnrs))\n\n(define (map1 proc xs)\n  (let loop ((xs xs)\n\t     (rs '()))\n    (if (null? xs)\n\t(reverse rs)\n\t(loop (cons (proc (car xs))) (cdr xs)))))\n}}}\n")
(" %Tag:R5RS" . "(1668199886 (\"リストを定義する\" :ctime 1227502058 :cuser #f :mtime 1233062123 :muser #f) (\"コマンドライン引数を解析する\" :ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f) (\"リストを結合する\" :ctime 1227532498 :cuser #f :mtime 1228349286 :muser #f))")
(" %Tag:FIXME and 1=1" . "(1581247071)")
("現在の日付を調べる" . "(:ctime 1227428862 :cuser #f :mtime 1227428862 :muser #f)[[$$tag 日付と時刻 R6RS SRFI]]\n\n* 現在の日付を調べる\n\n{{{\n(import (srfi :19))\n\n(current-date)\n}}}\n")
(" %Tag:SRFI?p=Tag?Tag:SRFI?p=Tag" . "(1467042314)")
("CGI を作る" . "(:ctime 1282540225 :cuser #f :mtime 1296491816 :muser #f)[[$$tag R6RS Web FIXME]]\n\n* HTTP ヘッダを出力する\n\n{{{\n;; 必要最小限\n(display \"Content-Type: text/html\\r\\n\\r\\n\")\n}}}\n\n{{{\n;; 文字コードを指定する場合\n(display \"Content-Type: text/html;charset=UTF-8\\r\\n\\r\\n\")\n}}}\n\n* HTML 特殊文字をエスケープする\n\n{{{\n(define (html-escape str)\n  (call-with-string-output-port\n    (lambda (out)\n      (string-for-each\n        (lambda (c)\n          (cond\n            ((char=? #\\& c) (put-string out \"&amp;\"))\n            ((char=? #\\< c) (put-string out \"&lt;\"))\n            ((char=? #\\> c) (put-string out \"&gt;\"))\n            ((char=? #\\\" c) (put-string out \"&quot;\"))\n            (else (put-char out c))))\n        str))))\n}}}\n\n* HTML を出力する\n\nHTML を文字列で記述しても良いが、 SXML 形式で記述し文字列に変換して出力する方法がよく用いられる。処理系がSXMLライブラリを持っていない場合は以下のような手続きを作ると良い。\n\n{{{\n(define (put-sxml out sxml)\n  (and (pair? sxml) (symbol? (car sxml))\n    (let ((tag (symbol->string (car sxml))))\n      (let loop ((ls (cdr sxml)) (attrs '()) (vals '()))\n        (if (pair? ls)\n          (if (and (pair? (car ls)) (eq? '$ (caar ls)))\n            (loop (cdr ls) (append attrs (cdar ls)) vals)\n            (loop (cdr ls) attrs (cons (car ls) vals)))\n          (begin\n            (put-char out #\\<)\n            (put-string out tag)\n            (for-each\n              (lambda (attr)\n                (put-char out #\\space)\n                (put-string out\n                  (string-append\n                    (symbol->string (car attr))\n                    \"=\\\"\" (html-escape (cadr attr)) \"\\\"\")))\n              attrs)\n            (if (pair? vals)\n              (begin\n                (put-char out #\\>)\n                (for-each\n                  (lambda (val)\n                    (cond\n                      ((pair? val) (put-sxml out val))\n                      ((string? val) (put-string out val))\n                      ((symbol? val) (put-string out (symbol->string val)))))\n                  (reverse vals))\n                (put-string out (string-append \"</\" tag \">\\n\")))\n              (put-string out \" />\\n\"))))))))\n}}}\n\n※ この例では SXML の @ の代わりに $ を用いています。\n\n{{{\n(put-sxml (current-output-port)\n  `(html\n    (head (title \"Hello, 逆引きScheme!\")\n    (body\n      (h1 \"Hello, 逆引きScheme!\")\n      (p (a ($ (href \"http://tips.lisp-users.org/\")) \"逆引きScheme\"))))))\n}}}\n\n* フォームから送信されたデータをパースする\n\nHTMLフォームからの送信方法には GET と POST の二種類がある。送信方法は環境変数 \"REQUEST_METHOD\" に格納され CGI に渡される。\n\n送信データは、~%\nGET の場合、環境変数 \"QUERY_STRING\" から取り出し、~%\nPOST の場合、標準入力から読み込む。\n\n{{{\n(define (get-cgi-params)\n  (let ((params (make-hashtable string-hash string=?))\n    (method (get-environment-variable \"REQUEST_METHOD\")))\n    (for-each\n      (lambda (query)\n        (let ((ql (string-split query #\\=)))\n          (and (pair? ql) (<= 2 (length ql))\n            (hashtable-set! params (car ql) (uri-decode (cadr ql))))))\n      (string-split\n        (if (and method (string=? method \"GET\"))\n          (or (get-environment-variable \"QUERY_STRING\") \"\")\n          (get-string-n (current-input-port) 65536)) #\\&))\n    params))\n}}}\n\n環境変数の取得方法は [[環境変数を取得する]] を参考にしてください。~%\nstring-split は [[文字列を分割する]] を参考にしてください。~%\nuri-decode は [[文字列を URI エンコードする]] を参考にしてください。\n\n※ POST の場合、読み込むデータ量に制限を加えたほうが良い。この例では 65536 文字まで読み込むようにしています。\n")
(" %Tag:R6RS?p=Tag:R6RS" . "(1476573425)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45) -- /* order by 'as /*" . "(1624116300)")
(" %Tag:SXML999999.1 union select unhex(hex(version())) -- and 1=1" . "(1573238431)")
("R6RS と SRFI で非互換な点" . "(:ctime 1227638827 :cuser #f :mtime 1233287037 :muser #f)[[$$tag R6RS SRFI]]\n\nR6RS と SRFI には、名前が同一でありながら実体が異なり、そのまま同時に import すると例外が発生する識別子がある。ここではそれらの識別子と相違点を列挙する。\n\nCf. [http://practical-scheme.net/wiliki/schemexref.cgi?R6RS%3aCompatibilityNotes R6RS:CompatibilityNotes]\n\n[[$$toc]]\n\n* SRFI 1: List Library\n** map, for-each, fold-right\n引数として渡すリスト群の長さがすべて同じでなくてもよく、どれかひとつが有限リストであればよい。\n\n** member, assoc\n省略可能な第三引数として比較手続きを取る。\n\n** remove\n第一引数としてオブジェクトではなく述語を取る。\n\n* SRFI 5: A compatible let form with signatures and rest arguments\n** let\nnamed-let を define に似た構文で書けるようになり、省略可能引数を扱えるようになる。\n\n* SRFI 9: Defining Record Types\n** define-record-type\n構文が異なる。\n\n* SRFI 13: String Libraries\n** string->list, string-copy, string-fill!, string-titlecase, string-upcase, string-downcase\n省略可能引数で操作の始点と終点を指定できる。\n\n** string-hash\n省略可能な引数でハッシュ値の上限と、ハッシュ値を計算するときの始点と終点を指定できる。\n\n** string-for-each\nR6RS では複数の文字列を渡せるのに対して、省略可能引数で繰返しの始点と終点を指定できる。\n\n\n* SRFI 17: Generalized set!\n** set!\nset! の代入場所指定に手続き適用を指定できる。\n\n* SRFI 23: Error reporting mechanism\n** error\n最初の引数として who を取らない。\n\n* SRFI 35: Conditions\n** condition\nR6RS では手続きとして定義されているのに対し、 SRFI 35 ではマクロとして定義されている。\n\n* SRFI 43: Vector Library\n** vector-map, vector-for-each\n手続きがベクタ群の各要素に加えて最初の引数にその要素の添字を取る。\n\n** vector-fill!, vector->list, list->vector\n省略可能な引数で操作の始点と終点を指定できる。\n\n* SRFI 46: Basic Syntax-rules Extensions\n** syntax-rules\nsyntax-rules の構文が\n{{{\n(syntax-rules [<ellipsis-identifier>] (<literal-identifier> ...)\n  (<pattern> <template>)\n  ...)\n}}}\nのように拡張され、パターン言語に次のような構文が追加される。\n{{{\n (<pattern> ... <ellipsis> <pattern> ...)\n#(<pattern> ... <ellipsis> <pattern> ...)\n}}}\n\n\n* SRFI 47: Array\n** equal?\nequal? が配列に対しても働く。\n\n* SRFI 57: Records\n** define-record-type\n構文が異なる。\n\n;; 60 bitwise-if ??\n\n* SRFI 61: A more general COND clause\n** cond\ncond の構文が\n{{{\n<cond clause> --->\n  ...\n  | (<generator> <guard> => <receiver>)\n}}}\nのように拡張される。\n\n* SRFI 63: Homogeneous and Heterogeneous Arrays\n** equal?\nequal? が配列に対しても働く。\n\n* SRFI 69: Basic hash tables\n** string-hash, string-ci-hash\n省略可能引数でハッシュ値の上限を指定することができる。\n\n* SRFI 71: LET-syntax for multiple values\n** let, let*, letrec\n多値を扱えるように構文が拡張される。\n\n* SRFI 74: Octet-Addressed Binary Blocks\n** endianness\nbig, little, native の値のみを受け付ける。\n\n* SRFI 87: => in case clauses\n** case\ncond 文と同様の構文で => を使いキーの値を受け渡すことができる。\n")
("リストから要素を探す" . "(:ctime 1227502775 :cuser #f :mtime 1228349669 :muser #f)[[$$tag リスト R6RS]]\n\nあるオブジェクトと [[$$r6rs equal?]] なオブジェクトをリストから探索するには [[$$r6rs member]] 手続きを使う。\n\n{{{\n(import (rnrs))\n\n(member \"bc\" '(\"ab\" \"bc\" \"cd\")) ; => (\"bc\" \"cd\")\n(member 'b '(a c e g)) ; => #f\n}}}\n\nmember 手続きは指定の要素が見つかった場合は、リストのその要素から始まる部分を返し、さもなくは #f を返す。比較手続きに [[$$r6rs eqv?]] や [[$$r6rs eq?]] を使う場合には [[$$r6rs memv]] や [[$$r6rs memq]] を使う。自分で比較手続きを指定した場合には [[$$r6rs memp]] を使う。\n\n{{{\n(import (rnrs))\n\n(memv 1 '(4 2 1 3)) ; => (1 3)\n(memq 'a '(f d s a)) ; => (a)\n\n(memp even? '(1 2 3 4)) ; => (2 3 4)\n(memp (lambda (x) (eqv? x 1)) '(4 2 1 3)) ; => (1 3)\n                                          ; === (memv 1 '(4 2 1 3)\n}}}\n\n指定した述語を満たす要素そのものを返して欲しい場合には [[$$r6rs find]] 手続きを使う。\n{{{\n(import (rnrs)\n\n(find even? '(1 2 3 4)) ; => 2\n(find negative? '(1 2 3 4)) ; => #f\n}}}\n\nただし、 find 手続きは述語を満たす要素が #f であった場合と要素が見つからなかった場合を区別できない。\n\n{{{\n(import (rnrs))\n\n(find not '(0 1 #f #t)) ; => #f\n(find not '()) ; => #f\n}}}\n")
("非真正リストを真正リストに変換する" . "(:ctime 1228837296 :cuser #f :mtime 1228837456 :muser #f)[[$$tag R6RS リスト]]\n\n最後の cdr が '() でないリストを普通の（真正）リスト（(proper) list）と区別して非真正リスト（improper list）と呼ぶ。\n\n{{{\n(import (rnrs))\n\n(define (improper-list->proper-list xs)\n  (let loop ((ys xs) (rs '()))\n    (cond\n     ((pair? ys)\n      (loop (cdr ys) (cons (car ys) rs)))\n     ((null? ys)\n      (assertion-violation 'improper-list->proper-list\n\t\t\t   \"improper list required, but got proper list\"\n\t\t\t   xs))\n     (else\n      (reverse (cons ys rs))))))\n}}}\n")
(" %Tag:HTML'\"" . "(1582392984)")
("連想リストを使う" . "(:ctime 1227505307 :cuser #f :mtime 1228349479 :muser #f)[[$$tag リスト R6RS SRFI]]\n\n対をリストにしたものを連想リスト（association list）と呼ぶ。 Lisp では簡単なテーブルが必要な場合に[[ハッシュテーブル]]の代わりに、リストの要素である対の car をキーとし cdr を値とする連想リストをテーブルとして使うことがある。要素が少ない場合にはハッシュ値の計算などのオーバーヘッドもあり、ハッシュテーブルの方が低速になることもある。\n\n連想リストを生成する場合には単純に [[$$r6rs quote]] や [[$$r6rs list]] を使ったり、必要に応じて [[$$r6rs quasiquote]] を使ったりする。\n\n{{{\n(import (rnrs))\n\n(define alist\n  '((one . 1)\n    (two . 2)\n    (three . 3)))\n}}}\n\n要素を追加するには [[$$r6rs cons]] を使う。\n\n{{{\n(cons (cons 'four 4) alist) ; => ((four . 4) (one . 1) (two . 2) (three . 3))\n}}}\n\n便利な略記法として SRFI-1 には alist-cons という手続きがある。\n\n{{{\n(import (rnrs) (only (srfi :1) alist-cons))\n\n(alist-cons 'four 4 alist) ; => ((four . 4) (one . 1) (two . 2) (three . 3))\n}}}\n\n連想リストの参照には [[$$r6rs assoc]], [[$$r6rs assv]], [[$$r6rs assq]], [[$$r6rs assp]] といった手続きを使う。それぞれ引数として与えられたオブジェクトとキーが [[$$r6rs equal?]], [[$$r6rs eqv?]], [[$$r6rs eq?]] な連想リスト中の対、与えられた述語をキーが満たす対を返す。\n\n{{{\n(assoc 'one alist) => (one . 1)\n(assq 'five alist) ; => #f\n(assp (lambda (x) (eq? x 'one)) alist) ; => (one . 1)\n}}}\n\n値だけを取り出したい場合にはイディオムとして [[$$r6rs cond]] や SRFI-2 の and-let* を使う。\n\n{{{\n(import (rnrs) (srfi :2))\n\n(cond ((assq 'one alist) => cdr)\n      (else #f)) ; => 1\n\n(cond ((assq 'six alist) => cdr)\n      (else #f)) ; => #f\n\n(and-let* ((p (assq 'three alist)))\n  (cdr p)) ; => 3\n}}}\n\n")
(" %Tag:HTML or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- and 1=1" . "(1582392999)")
("リストを結合する" . "(:ctime 1227532498 :cuser #f :mtime 1228349286 :muser #f)[[$$tag リスト R5RS R6RS]]\n\n手続き [[$$r6rs append]] を使います。\n最後の引数が行儀の悪いリストまたはリストでない値の場合は、行儀の悪いリストやリストでない値を返します。\n\n{{{\n;; R6RS に記載されている例\n(import (rnrs base))\n\n(append '(x) '(y))         ;=> (x y)\n(append '(a) '(b c d))     ;=> (a b c d)\n(append '(a (b)) '((c)))   ;=> (a (b) (c))\n(append '(a b) '(c . d))   ;=> (a b c . d)\n(append '() 'a)            ;=> a\n}}}\n\n{{{\n(append '(1 2 3) '())      ;=> (1 2 3)\n(append '(1 2) '() '(3 4)) ;=> (1 2 3 4)\n(append '(1 2 3) 4)        ;=> (1 2 3 . 4)\n(append '())               ;=> ()\n(append)                   ;=> ()\n}}}\n")
("|comments:リクエスト::004" . "(:ctime 1583026001 :cuser #f :mtime 1583026001 :muser #f)* goose (2020/03/01 10:26:41):\n<<<\n繰り返し処理の項目を作って欲しいです\n>>>\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45) -- /* order by \"as /*" . "(1624116652)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45) -- /* order by \"as /*" . "(1624116707)")
("引数を一部固定した手続きを作る" . "(:ctime 1228154185 :cuser #f :mtime 1228154236 :muser #f)[[$$tag R6RS 手続き SRFI]]\n\n高階関数に手続きを渡す場合、既存の手続きの引数を一部固定しただけの手続きが必要になることがしばしばある。例えば、リストの各要素に 1 を足す計算を考える。標準では\n\n{{{\n(import (rnrs))\n\n(map (lambda (x) (+ x 1)) '(1 2 3 4 5)) ; => (2 3 4 5 6)\n}}}\n\nと書く。また、各要素を 2 倍する計算、各要素から 1 を引く計算など、これに類似したパターンは多い。\n\nこのような場合、 SRFI-26 を使うと簡潔に書けることがある。\n{{{\n(import (rnrs) (srfi :26))\n\n(map (cut + <> 1) '(1 2 3 4 5)) ; => (2 3 4 5 6)\n(map (cut * 2 <>) '(1 2 3 4 5)) ; => (2 4 6 8 10)\n(map (cut - <> 1) '(1 2 3 4 5)) ; =>(0 1 2 3 4)\n}}}\ncut マクロは <> で指定された部分に引数を取る lambda 式に変換される。 <> は複数指定することもできる。\n\n{{{\n(import (rnrs) (srfi :26))\n\n(map (cut <= <> 5 <>) '(2 4 0 8) '(5 2 9 1)) ; => (#t #f #t #f)\n}}}\n\nただし、引数の順序を交換するようなことはできないので、その場合には lambda 式を書かなければならない。\n\n{{{\n(import (rnrs))\n\n(map (lambda (x y) (cons y x)) '(1 3 5 7) '(2 4 6 8)) ; => ((2 . 1) (4 . 3) (6 . 5) (8 . 7))\n}}}\n\n引数を取らない手続きを thunk と呼ぶ。 <> のない cut を使うと thunk を短かく書けることがある。\n\n{{{\n(call-with-values (cut f a b) g) ; === (call-with-values (lambda () (f a b)) g)\n}}}\n\n")
(" %Tag:SRFI" . "(1668014947 (\"ユリウス日からグレゴリオ暦を計算する\" :ctime 1307027894 :cuser #f :mtime 1307576867 :muser #f) (\"R6RS と SRFI で非互換な点\" :ctime 1227638827 :cuser #f :mtime 1233287037 :muser #f) (\"ベクタの各要素に手続きを適用する\" :ctime 1233088003 :cuser #f :mtime 1233088003 :muser #f) (\"ベクタの内容を変更する\" :ctime 1233021648 :cuser #f :mtime 1233021876 :muser #f) (\"ベクタから要素を探す\" :ctime 1233014179 :cuser #f :mtime 1233018921 :muser #f) (\"環境変数を取得する\" :ctime 1230276136 :cuser #f :mtime 1230343874 :muser #f) (\"循環リストを使う\" :ctime 1230320100 :cuser #f :mtime 1230322530 :muser #f) (\"コマンドライン引数を解析する\" :ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f) (\"リストから重複した要素を取り除く\" :ctime 1227608876 :cuser #f :mtime 1228802710 :muser #f) (\"スレッド\" :ctime 1227970633 :cuser #f :mtime 1228795142 :muser #f) (\"リストから要素を取り出す\" :ctime 1227501516 :cuser #f :mtime 1228349850 :muser #f) (\"連想リストを使う\" :ctime 1227505307 :cuser #f :mtime 1228349479 :muser #f) (\"変数\" :ctime 1227920472 :cuser #f :mtime 1228348417 :muser #f) (\"引数を一部固定した手続きを作る\" :ctime 1228154185 :cuser #f :mtime 1228154236 :muser #f) (\"日付に対する加算\" :ctime 1227429056 :cuser #f :mtime 1227669157 :muser #f) (\"乱数を生成する\" :ctime 1227510174 :cuser #f :mtime 1227510174 :muser #f) (\"月の最後の日を調べる\" :ctime 1227429229 :cuser #f :mtime 1227429229 :muser #f) (\"日付の曜日を日本語で出力する\" :ctime 1227428927 :cuser #f :mtime 1227428927 :muser #f) (\"現在の日付を調べる\" :ctime 1227428862 :cuser #f :mtime 1227428862 :muser #f))")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 481 #" . "(1624116896)")
("ハッシュテーブルのキーの一覧を取得する" . "(:ctime 1227602553 :cuser #f :mtime 1227602554 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\nhashtable-keys はハッシュテーブルのキーの一覧をベクタとして返す。\n\n{{{\n(import (rnrs))\n\n(hashtable-keys ht) ; => #(...)\n}}}\n\n戻り値のベクタの要素の順序は挿入時の順序とは無関係である。\n\nハッシュテーブルの各要素に対して繰返しを行う場合にはこの値に対して vector-for-each や vector-map を用い、 hashtable-ref してもよいが、後述の vector-entries を使用した方が効率がよい。\n")
(" %Tag:Web'A=0" . "(1558429219)")
(" %Tag:HTML and 1=1" . "(1582392987)")
("ベクタを作成する" . "(:ctime 1233011767 :cuser #f :mtime 1233011767 :muser #f)[[$$tag ベクタ R6RS]]\n\nベクタのリテラルは '#(...) と書く。\n{{{\n'#(a b c) ; => #(a b c)\n'#(a 1 b 2) ; => #(a 1 b 2)\n}}}\n\nリテラルのベクタを変更することはできないので注意が必要である。\n{{{\n(import (rnrs))\n\n(vector-set! '#(1 2 3) 0 'one) ; => &assertion\n}}}\n\n変更可能なベクタを作成するには [[$$r6rs vector]] 手続きないしは [[$$r6rs make-vector]] 手続きを使う。\n{{{\n(import (rnrs))\n\n(vector 1 2 3) ; => #(1 2 3)\n\n(define v (vector 1 2 4))\n(vector-set! v 0 0)\nv ; => #(0 2 4)\n\n(make-vector 2 1) ; => #(1 1)\n(make-vector 3 0) ; => #(0 0 0)\n}}}\n\nmake-vector に ''fill'' 引数を渡さなかった場合、ベクタの要素に何が設定されるかは規定されていない。 ''fill'' 引数に渡されたオブジェクトは実体を共有するので注意が必要である。\n\n{{{\n(import (rnrs) (rnrs mutable-pairs))\n\n(define v (make-vector 3 (list 'a))) ; => #((a) (a) (a))\n\n(set-car! (vector-ref v 0) 1)\n\nv ; => #((1) (1) (1))\n}}}\n")
(" %Tag:stub?Tag?Tag?Tag?Tag:stub?Tag?Tag?Tag" . "(1491341307)")
(" %recent-changes" . "((\"リクエスト\" . 1583026001) (\"文字列\" . 1515206594) (\"閏年か判定する\" . 1330521595) (\"ユリウス日からグレゴリオ暦を計算する\" . 1307576867) (\"グレゴリオ暦からユリウス日を計算する\" . 1307038163) (\"日付と時刻\" . 1307027816) (\"CGI を作る\" . 1296473419) (\"末尾呼び出しの最適化\" . 1264385826) (\"文字列を数値に変換する\" . 1240391591) (\"文字列を Base64 エンコードする\" . 1238220404) (\"InterWikiName\" . 1236726532) (\"数値\" . 1234244577) (\"エンディアンを変換する\" . 1234244574) (\"レコードの初期化をカスタマイズする\" . 1233538776) (\"レコード型を拡張する\" . 1233383241) (\"レコード型を定義する\" . 1233379492) (\"レコード\" . 1233365578) (\"レコード型の詳細を調べる\" . 1233365565) (\"レコード型を拡張できないようにする\" . 1233358211) (\"レコード型の詳細を隠蔽する\" . 1233358167) (\"R6RS と SRFI で非互換な点\" . 1233287037) (\"コンディションを合成する\" . 1233267797) (\"コンディションを定義する\" . 1233267156) (\"例外を発生させる\" . 1233265935) (\"例外を補足する\" . 1233261748) (\"コンディション\" . 1233257321) (\"リスト\" . 1233105288) (\"ベクタの各要素に手続きを適用する\" . 1233088003) (\"リストを定義する\" . 1233062123) (\"逆引きScheme\" . 1233038662) (\"用語集\" . 1233038657) (\"ベクタの内容を変更する\" . 1233021876) (\"ベクタから要素を探す\" . 1233018921) (\"ベクタをソートする\" . 1233018720) (\"逆引きScheme書式\" . 1233015082) (\"ベクタから要素を取り出す\" . 1233013310) (\"ベクタの要素数を取得する\" . 1233013066) (\"ベクタをリストに変換する\" . 1233012569) (\"ベクタを作成する\" . 1233011767) (\"ベクタ\" . 1233011141) (\"識別子の命名規約\" . 1232676886) (\"マクロ\" . 1232448539) (\"識別子を生成する\" . 1232448535) (\"その他\" . 1232012267) (\"ソースファイルの拡張子\" . 1232012254) (\"ライブラリ\" . 1231150135) (\"処理系依存部分のあるライブラリを書く\" . 1231150071) (\"リストの各要素に手続きを適用する\" . 1230954760) (\"文字列を分割する\" . 1230908706) (\"文字列を URI エンコードする\" . 1230361031))")
(" %Tag:FIXME'\"" . "(1581247069)")
(" %Tag:stub\" and \"x\"=\"y" . "(1580892184)")
("リストの各要素に手続きを適用する" . "(:ctime 1230927390 :cuser #f :mtime 1231011574 :muser #f)[[$$tag R6RS リスト]]\n\nリストの各要素に手続きを適用し、その結果をリストとして受け取るには [[$$r6rs map]] 手続きを使う。\n\n{{{\n(import (rnrs))\n\n(map (lambda (x) (* x 2)) '(1 2 3 4 5)) ; => (2 4 6 8 10)\n}}}\n\nmap に渡した手続きの適用順序は規定されていないため、副作用のある手続きを使うと意図しない結果になることがある。\n{{{\n(import (rnrs))\n\n(map display '(1 2 3 4 5)) ; 表示順序は処理系依存\n}}}\nこのような用途には [[$$r6rs for-each]] を使う。このとき手続きの戻り値は単純に無視される。\n{{{\n(import (rnrs))\n\n(for-each display '(1 2 3 4 5)) ; -> 12345\n}}}\n\nリストの各要素について二項演算 ⊕ を畳み込む手続き [[$$r6rs fold-left]], [[$$r6rs fold-right]] がある。 fold-left は\n(... (((0 ⊕ a1) ⊕ a2) ⊕ a3) ...) のように左側から畳み込み、 fold-right は (a1 ⊕ (a2 ⊕ (a3 ⊕ (... (an ⊕ 0) ...)))) のように右側から畳み込む（Cf. http://foldl.com http://foldr.com ）。\n\n例えば a ⊕ b := [[$$r6rs cons]](b, a) と定義すると fold-left ⊕ '() は [[$$r6rs reverse]] と等価になり、 a ⊕ b := b + 10 * a とすると fold-left ⊕  0 は十進数の各桁の数値を要素として持つリストを数値に変換する計算になる。 ⊕ := cons とすると fold-right ⊕ は [[$$r6rs append]] になる。\n\n{{{\n(import (rnrs))\n\n(fold-left (lambda (a b) (cons b a)) '() '(1 2 3 4 5)) ; => (5 4 3 2 1)\n(fold-left (lambda (a b) (+ b (* 10 a))) 0 '(1 2 3 4 5)) ; => 12345\n\n(fold-right cons '(4 5) '(1 2 3)) ; => (1 2 3 4 5)\n}}}\n\n⊕ に結合律が成り立つとき fold-left ⊕ と fold-right ⊕ は同じ結果を返す。ただし、多くの場合 fold-left, fold-right は下のように定義されているため（簡単のために一引数の場合を示す）、 fold-left では末尾呼び出しの最適化が働き、より効率よく動作することが多い。\n\n{{{\n(import (rnrs base))\n\n(define (fold-left kons knil xs)\n  (if (null? xs)\n      seed\n      (fold-left kons (kons knil (car xs)) (cdr xs))))\n\n(define (fold-right kons knil xs)\n  (if (null? xs)\n      seed\n      (kons (car xs) (fold-right kons knil (cdr xs)))))\n}}}\n")
(" %Tag:手続き?p=Tag:手続き" . "(1476570245)")
("quasisyntax を使う" . "(:ctime 1228352468 :cuser #f :mtime 1228352468 :muser #f)[[$$tag R6RS マクロ]]\n\n[[$$r6rs quasisyntax]]（#`）を使うと[[構文キーワード]]で例に挙げた case/pred を補助マクロを使わずに定義できる。 quasisyntax は [[$$r6rs quote]] に対する [[$$r6rs quasiquote]] のようなもので [[$$r6rs unsyntax]] （#,)、 [[$$r6rs unsyntax-splicing]] （#,@）を使ってテンプレート中に式を埋め込むことができる。\n\n{{{\n(define-syntax case/pred\n  (lambda (x)\n    (syntax-case x ()\n      ((_ x c cs ...)\n       #`(let ((v x))\n\t   #,(let loop ((c #'c) (cs #'(cs ...)))\n\t       (if (null? cs)\n\t\t   (syntax-case c (else)\n\t\t     (((p1 p2 ...) expr ...)\n\t\t      #'(if (or (p1 v) (p2 v) ...)\n\t\t\t    (begin #t expr ...)))\n\t\t     ((else expr ...)\n\t\t      #'(begin (if #f #f) expr ...)))\n\t\t   (syntax-case c ()\n\t\t     (((p1 p2 ...) expr ...)\n\t\t      #`(if (or (p1 v) (p2 v) ...)\n\t\t\t    (begin #t expr ...)\n\t\t\t    #,(loop (car cs) (cdr cs))))))))))))\n}}}\n\nまた、この定義では else 節のない場合に余計な (if #f #f) が生成されないようになっている。\n\n同様のことは [[$$r6rs with-syntax]] を使っても可能である（R6RS Standard Libraries 参照）。\n\n")
("末尾呼び出しの最適化" . "(:ctime 1228157227 :cuser #f :mtime 1264385826 :muser #f)[[$$tag R6RS 手続き]]\n\nScheme では末尾文脈での手続き呼び出しが最適化されるので、\n\n{{{\n(import (rnrs))\n\n(define (my-gcd a b)\n  (if (zero? b)\n      a\n      (my-gcd b (mod a b))))\n}}}\nのような手続き定義は、ほかの言語で言うところのループ構造と等価なものに展開されスタックを消費しない。\n\n{{{\ndef gcd(a, b)\n   until b == 0 do\n      a, b = b, a % b\n   end\n\n   return a\nend\n}}}\n\nこれは末尾文脈での呼び出しが自身に対する呼び出しかどうかにかかわらないため、より柔軟に、複数の手続き間で相互に末尾文脈で呼び出し合う場合でもこの最適化が働く。\n\n{{{\n(import (rnrs))\n\n(define (my-even? n)\n  (or (zero? n)\n      (my-odd? (- (abs n) 1))))\n\n(define (my-odd? n)\n  (and (not (zero? n))\n       (my-even? (- (abs n) 1))))\n}}}\n\n----\n\n末尾文脈の定義は R6RS 11.20 にある。まとめると次の通りである。\n- lambda 本体部分の最後の式\n- 次の形式が末尾文脈にあるとき、その下位式の次の部分\n-- if の帰結部と代替部\n-- cond 節の各節の最後の式。および (condition => proc) と書いたときの proc 内部の最後の式\n-- case 節の各節の最後の式\n-- and / or の最後の式\n-- let / let* / letrec / letrec* / let-values / let*-values / let-syntax / letrec-syntax の本体部分の最後の式\n-- begin の最後の式\n\nよって、次の $ で始まる名前の手続きはすべて末尾呼び出しされる。\n\n{{{\n(lambda (x y)\n  ($a y x))\n\n(lambda (x)\n  (b x)\n  ($a x))\n\n(lambda (x)\n  (if (p? x) ($a x) x))\n\n(lambda (x)\n  (and (b x) ($a x)))\n\n(lambda (x)\n  (case (b x)\n    ((c) ($a x))\n    (else ($d x))))\n\n(lambda (x)\n  (cond\n   ((b x) => $a)\n   ((c x) => (d))))\n\n(lambda (x)\n  (let ()\n    (b x)\n    ($a x)))\n}}}\nマクロ展開によって最終的にこれらの式に展開される式の各部分も末尾文脈になる。\n\nここで、 dynamic-wind は末尾文脈に含まれないことに注意。\n{{{\n(define (f n)\n  (if (zero? n)\n      1\n      (dynamic-wind\n        (lambda () (display #f))\n        (lambda () (f (- n 1)))\n        (lambda () (display #f)))))\n}}}\nこのとき、 dynamic-wind の呼び出し自体と f の呼び出し自体は末尾文脈にあるが、 dynamic-wind に渡された thunk は末尾文脈にないため、この手続きは末尾再帰的でない。\n")
(" %Tag:ベクタ" . "(1668279104 (\"ベクタの各要素に手続きを適用する\" :ctime 1233088003 :cuser #f :mtime 1233088003 :muser #f) (\"ベクタの内容を変更する\" :ctime 1233021648 :cuser #f :mtime 1233021876 :muser #f) (\"ベクタから要素を探す\" :ctime 1233014179 :cuser #f :mtime 1233018921 :muser #f) (\"ベクタをソートする\" :ctime 1233018720 :cuser #f :mtime 1233018720 :muser #f) (\"ベクタから要素を取り出す\" :ctime 1233013310 :cuser #f :mtime 1233013310 :muser #f) (\"ベクタの要素数を取得する\" :ctime 1233013066 :cuser #f :mtime 1233013066 :muser #f) (\"ベクタをリストに変換する\" :ctime 1233012569 :cuser #f :mtime 1233012569 :muser #f) (\"ベクタを作成する\" :ctime 1233011767 :cuser #f :mtime 1233011767 :muser #f) (\"ベクタ\" :ctime 1233011016 :cuser #f :mtime 1233011141 :muser #f))")
("ライブラリ" . "(:ctime 1227882981 :cuser #f :mtime 1231150135 :muser #f)[[$$tag ライブラリ R6RS]]\n\n- [[特定の識別子だけを import する]]\n- [[名前を変更して import する]]\n- [[名前を変更して export する]]\n- [[R5RS ライブラリを R6RS ライブラリに加工する]]\n- [[処理系依存部分のあるライブラリを書く]]\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45) -- /* order by 'as /*" . "(1624116235)")
(" %Tag:stub'" . "(1582022287)")
("レコード型を拡張する" . "(:ctime 1233383241 :cuser #f :mtime 1233383241 :muser #f)[[$$tag R6RS レコード]]\n\nR6RS レコードは単一継承により拡張することができる。親となるレコード型は [[$$r6rs define-record-type]] の parent 節で指定する。\n\n例えば直交座標系の点 (x, y) を表すレコード型 point があったとき、それに色をつけた点を表す colored-point は次のように定義できる。\n\n{{{\n(import (rnrs))\n\n(define-record-type point\n  (fields\n   (mutable x)\n   (mutable y)))\n\n(define-record-type colored-point\n  (parent point)\n  (fields\n   (immutable color point-color)))\n}}}\n\n子型の構築子はまず親型のフィールドに対する引数を取り、続いて自身で宣言したフィールドに対する引数を取る。既存のレコード型を拡張したレコード型のインスタンスには親型のインスタンスに対する手続きも適用することができる。逆は真ではない。\n\n{{{\n(define p (make-point 2 7))\n(define cp (make-colored-point 3 5 'blue))\n\n(point? p) ; => #t\n(point? cp) ; => #t\n\n(colored-point? p) ; => #f\n(colored-point? cp) ; => #t\n\n(point-x p) ; => 2\n(point-x cp) ; => 3\n\n(point-x-set! cp 0)\n\n(point-x cp) ; => 0\n(point-y cp) ; => 5\n\n(point-color cp) ; => blue\n(point-color p) ; => &assertion\n}}}\n")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45) --  /*" . "(1624116025)")
("日付に対する加算" . "(:ctime 1227429056 :cuser #f :mtime 1227669157 :muser #f)[[$$tag 日付と時刻 R6RS SRFI]]\n\n* 日付に対する加算\n\n日付と数値を直接演算することはできないので、日付を時間に変換し、数値（秒数）を期間を表す時間オブジェクトに変換したうえで計算し、日付に戻す。\n\n{{{\n(import (rnrs) (srfi :19))\n\n;; 日付 date の seconds 秒後の日付を返す。閏秒は考えない。\n(define (date-add-second date seconds)\n  (time-utc->date\n   (add-duration (date->time-utc date)\n\t\t (make-time time-duration 0 seconds))))\n\n(date-add-second (current-date) 1) ; 1 秒後\n(date-add-second (current-date) -5) ; 5 秒前\n(date-add-second (current-date) (* 60 60 24)) ; 1 日後\n(date-add-second (current-date) (* 60 60 24 7)) ; 1 週間後\n}}}\n\n閏秒を考える場合には date->time-utc ではなく、 date->time-tai を使う。ただしその場合、上のプログラムでは 1 日、 1 週間といった期間は厳密ではなくなる。\n")
("ライセンスについて" . "(:ctime 1227343733 :cuser #f :mtime 1227544026 :muser #f)[[$$toc]]\n\n* 逆引きSchemeのライセンスについて\n\nクリエイティブコモンズライセンス [http://creativecommons.org/licenses/by/2.1/jp/ 表示2.1] とします。\nコード/説明文中のクレジットについては、投稿者はクレジット表示の必要なしと意思表示した上で書き込んでいますので表示の必要はありません。\n\n")
("ハッシュテーブルを空にする" . "(:ctime 1227602126 :cuser #f :mtime 1227602127 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\nハッシュテーブルに格納された要素をすべて削除するには hashtable-clear! を使う。\n\n{{{\n(imort (rnrs))\n\n(hashtable-clear! ht)\n}}}\n")
(" %Tag:関数" . "(1270369433)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45) --  /*" . "(1624116036)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45),CHAR(45,120,50,53,45,81,45) --  /*" . "(1624116212)")
(" %Tag:HTML2121121121212.1" . "(1582392986)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 640 #" . "(1624116992)")
(" %Tag:HTML\" or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- \"x\"=\"x" . "(1582393000)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45) --  /*" . "(1624116058)")
("部分文字列を取り出す" . "(:ctime 1227425232 :cuser #f :mtime 1227425233 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 部分文字列を取り出す\n\n部分文字列の取り出しには substring 手続きを使う。\n\n{{{\n(import (rnrs))\n\n(substring \"0123456\" 2 4) ; => \"234\"\n}}}\n")
("|comments:ãªã¯ã¨ã¹ã::000" . "(:ctime 1340302070 :cuser #f :mtime 1340302071 :muser #f)* gordon (2012/06/21 11:07:50):\n<<<\nNBM5JB http://www.FPU7vqiRhHghotBHegWQdZiVgO8pMSe6.com\n>>>\n")
("文字列の先頭・末尾の空白を削除する" . "(:ctime 1227425646 :cuser #f :mtime 1228802815 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 文字列の先頭・末尾の空白を削除する\n\n[[$$srfi 13]] を使うと簡単。\n\n{{{\n(import (rnrs) (only (srfi :13) string-trim string-trim-right string-trim-both))\n\n(string-trim \" abc \" char-whitespace?) ; => \"abc \"\n(string-trim-right \" abc \" char-whitespace?) ; => \" abc\"\n(string-trim-both \" abc \" char-whitespace?) ; => \"abc\"\n}}}\n\n同様の処理を文字列ポートや string-ref、 substring 手続きを用いて書いてもよい。\n")
(" %Tag:バイトベクタ" . "(1668195748 (\"エンディアンを変換する\" :ctime 1234244573 :cuser #f :mtime 1234244574 :muser #f))")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45) -- /* order by 'as /*" . "(1624116345)")
("閏年か判定する" . "(:ctime 1306940805 :cuser #f :mtime 1330521595 :muser #f)* 閏年か判定する\n\n** 閏年の条件\n\n- 4 で割り切れて 100 で割り切れない\n- 400 で割り切れる\n\n (import (rnrs))\n (define (leap-year? year)\n     (or (and (zero? (mod year 4))\n              (not (zero? (mod year 100))))\n         (zero? (mod year 400))))\n\n↓こう書いたほうが効率が良い。\n\n (import (rnrs))\n (define (leap-year? year)\n   (and (zero? (mod year 4))\n     (or (not (zero? (mod year 100)))\n       (zero? (mod year 400)))))\n")
(" %Tag:スレッド' AnD sLeep(3) ANd '1" . "(1624115937)")
("ベクタの要素数を取得する" . "(:ctime 1233013066 :cuser #f :mtime 1233013066 :muser #f)[[$$tag ベクタ R6RS]]\n\nベクタの要素数は [[$$r6rs vector-length]] 手続きで取得する。 [[$$r6rs length]] と異なりこの操作は定数時間で終了する。\n\n{{{\n(import (rnrs))\n\n(vector-length '#()) ; => 0\n(vector-length '#(1 2 3)) ; => 3\n}}}\n")
("プログラムを終了させる" . "(:ctime 1228701545 :cuser #f :mtime 1228701546 :muser #f)[[$$tag R6RS プログラム]]\n\n実行中のプログラムを終了させるには [[$$r6rs exit]] 手続きを使う。 exit 手続きを引数を与えずに呼び出した場合、プログラムは正常に終了したと見做される。引数を渡した場合、その値の解釈は実行環境に依存する。\n\n例えば Unix 系のシステムの場合では 0 は正常終了、 1 以上は異常終了として扱われる。\n{{{\n(if (null? (cdr (command-line)))\n    (exit 0)\t\t\t\t; 正常終了\n    (exit 1))\t\t\t\t; 異常終了\n}}}\n\nまた、 Plan9 などの OS ではプロセスの終了状態を文字列で表すため、 exit の引数には任意の値を渡すことができる。\n{{{\n(exit \"success\")\n}}}\n\nこれが他の環境でどのように解釈されるかは実装依存である。\n\n引数に #f を渡した場合は常に異常終了として扱われる。よって、正常/異常終了を可搬性を保って書くには\n{{{\n(if (null? (cdr (command-line)))\n    (exit)\t\t\t\t; 正常終了\n    (exit #f))\t\t\t\t; 異常終了\n}}}\nとする。\n")
(" %Tag:SXML and 1=1" . "(1573238422)")
("リストを作成する" . "(:ctime 1227500527 :cuser #f :mtime 1228349150 :muser #f)[[$$tag リスト R6RS]]\n\n[[$$r6rs quote]] を使うとリストを定数として書くことができる。また、 [[$$r6rs list]] 手続きを使うと新たにリストを作成することができる。\n\n{{{\n(import (rnrs))\n\n'(1 2 3 4) ; => (1 2 3 4)\n(list 1 2 3 4) ; => (1 2 3 4)\n}}}\n\nただし、 quote を使って作成したリストを変更しようとすると例外が発生するので注意。\n\n{{{\n(import (rnrs) (rnrs mutable-pair))\n\n(define x '(1 2 3 4))\n(define y x)\n\n(set-car! y 0) ; => &assertion\n}}}\n\nリストは cons セルを数珠繋ぎにしたものなので、 [[$$r6rs cons]] を組み合わせることでもリストを構成できる。\n\n{{{\n(import (rnrs))\n\n(cons 1 '()) ; => (1)\n(cons 1 (cons 2 (cons 3 '(4 5)))) ; => (1 2 3 4 5)\n}}}\n\n入れ子になった cons の代わりには [[$$r6rs cons*]] 手続きを使うと便利である。\n{{{\n(import (rnrs))\n\n(cons* 1 2 3 '(4 5)) ; => (1 2 3 4 5)\n}}}\n\n評価の必要な要素が quote の必要な要素よりも少ない場合や、リストの雛形を用意しておいて、そこに値を埋め込むような場合には [[$$r6rs quasiquote]] を使った方がよいこともある。\n\n{{{\n(import (rnrs))\n\n(define (f x y)\n  `(a b ,x e ,y g h)) ; === (list 'a 'b x 'e y 'g 'h)\n\n(define (make-if c t e)\n  `(if ,c ,t ,e)) ; === (list 'if c t e)\n\n(define (make-when c . body)\n  `(when ,c ,@body)) ; === (cons* 'when c body)\n}}}\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45) -- /* order by \"as /*" . "(1624116630)")
(" %Tag:スレッド\"" . "(1624115828)")
(" %Tag:スレッド' and 'x'='y" . "(1624115893)")
("|comments:ãªã¯ã¨ã¹ã::001" . "(:ctime 1360420966 :cuser #f :mtime 1360420966 :muser #f)* Abigail (2013/02/09 06:42:46):\n<<<\nWhat are the hours of work? http://www.ggiodpc.com propecia best price uk  per unit container. Regulated medical waste also includes microbiological cultures, pathology\n http://www.meosales.com how much does celexa cost without insurance  DIS/LSS or at the Mansfield Library. There are, however, a couple notable exceptions. This document\n http://www.naf2011.com purchase duloxetine  point where they exit from the\n http://www.pinellasanimalfoundation.org purchase generic prozac  American assumption Counter-American assumption\n \n>>>\n")
(" %Tag:システム環境" . "(1668286266 (\"環境変数を取得する\" :ctime 1230276136 :cuser #f :mtime 1230343874 :muser #f))")
("ハッシュテーブル内に値があるかどうか確認する" . "(:ctime 1227601455 :cuser #f :mtime 1227602965 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\nハッシュテーブル内にキーに対応する値がある場合 hashtable-contains? 手続きが真を返す。\n\n{{{\n(import (rnrs base) (rnrs hashtables))\n\n(hashtable-contains? ht 'two)\n}}}\n")
("例外を発生させる" . "(:ctime 1233265934 :cuser #f :mtime 1233265935 :muser #f)[[$$tag R6RS 例外処理]]\n\n例外を発生させる手続きには [[$$r6rs raise]] と [[$$r6rs raise-continuable]] がある。 raise で発生させた例外は例外ハンドラから戻ると &non-continuable コンディションを含む例外をさらに発生させる。一方、例外を raise-continuable で発生させた場合には、ハンドラの戻した値が raise-continuable の継続に引き渡される。\n{{{\n(import (rnrs))\n\n(with-exception-handler\n    (lambda (exc)\n      4)\n  (lambda ()\n    (* (raise-continuable 1)\n       3)))\n;; => 12\n}}}\n\nまたさらに[[エラーを通知する]]ことも例外を発生させることと同義である。例えば、 [[$$r6rs error]] 手続きは次のようにして raise を使って定義することができる。\n{{{\n(import (except (rnrs) error))\n\n(define (error who message . irritants)\n  (raise (apply condition\n\t\t(make-error)\n\t\t(make-message-condition message)\n\t\t(make-irritants-condition irritants)\n\t\t(if who (make-who-condition who) '()))))\n}}}\n")
(" %Tag:HTML\" and \"x\"=\"x" . "(1582392991)")
("ベクタから要素を取り出す" . "(:ctime 1233013310 :cuser #f :mtime 1233013310 :muser #f)[[$$tag ベクタ R6RS]]\n\nベクタの要素は [[$$r6rs vector-ref]] 手続きで参照する。最初の要素は 0 番目である。 [[$$r6rs list-ref]] 手続きと異なりこの手続きは定数時間で終了する。\n\n{{{\n(import (rnrs))\n\n(vector-ref '#(1 2 3) 0) ; => 1\n(vector-ref '#(1 2 3) 2) ; => 3\n(vector-ref '#(1 2 3) 3) ; => &assertion\n}}}\n\n")
(" %Tag:SXML' or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- 'x'='x" . "(1573238436)")
(" %Tag:stub' and 'x'='x" . "(1580892182)")
("R5RS ライブラリを R6RS ライブラリに加工する" . "(:ctime 1227885126 :cuser #f :mtime 1228348606 :muser #f)[[$$tag ライブラリ マクロ R6RS]]\n\nR5RS ライブラリを R6RS ライブラリとして利用する場合、多くは、もとのソースコードに対して\n\n{{{\n(library (htmlprag)\n  (export ...)\n  (import (rnrs) ...)\n\n  ;; copy the original source code here\n  ...\n  )\n}}}\n\nのように適切な [[$$r6rs library]] / [[$$r6rs import]] / [[$$r6rs export]] を指定してやればよい。\n\n何らかの理由でもとのソースコードには手をつけず外部の別ファイルとして置いておきたい場合には\n\n{{{\n(library (util include)\n  (export include)\n  (import (rnrs))\n\n  (define-syntax include\n    (lambda (x)\n      (define (%include ctxt filename)\n\t(call-with-input-file filename\n\t  (lambda (p)\n\t    (let loop ((exp (read p))\n\t\t       (rs '()))\n\t      (if (eof-object? exp)\n\t\t  (reverse rs)\n\t\t  (loop (read p) (cons (datum->syntax ctxt exp) rs)))))))\n      (syntax-case x ()\n\t((ctxt filename)\n\t #`(begin #,@(%include #'ctxt (syntax->datum #'filename)))))))\n  )\n}}}\n\nのようなライブラリを用意しておき、\n\n{{{\n(library (htmlprag)\n  (export ...)\n  (import (rnrs) (util include) ...)\n\n  (include \"/path/to/original/htmlprag\")\n  )\n}}}\n\nのようにするとよい。\n")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45) --  /*" . "(1624115970)")
(" %Tag:HTML\"" . "(1578336114)")
("循環リストを使う" . "(:ctime 1230320100 :cuser #f :mtime 1230322530 :muser #f)[[$$tag R6RS SRFI リスト]]\n\nリストの最後の cdr が自分自身を指すように変更することで循環リストを作ることができる。\n\n{{{\n(import (rnrs)\n\t(rnrs mutable-pairs))\n\n(let ((x (list 0 1)))\n  (set-cdr! (cdr x) x)\n  x)\n;; => (0 1 0 1 0 1 0 1 ...)\n}}}\n\nSRFI 1 にはこれを一般化した circular-list 手続きがある。\n{{{\n(import (rnrs) (only (srfi :1) circular-list))\n\n(circular-list 0) ; => (0 0 0 ...)\n(circular-list 1 3 5) ; => (1 3 5 1 3 5 1 3 5 ...)\n}}}\n\nこれに加えて、 SRFI 1 の map や for-each は不揃いなリスト群を引数に取ることのできることを利用すると、リストの要素に規則的に処理を行なうことができる。例えば、リストの要素を出力し、奇数番目の要素の後には空白を、偶数番目の要素のあとには改行を出力するような処理が次のように書ける。\n\n{{{\n(import (except (rnrs) for-each)\n\t(only (srfi :1) circular-list for-each))\n\n(for-each (lambda (f g x) (f x) (g))\n\t  (circular-list display)\n\t  (circular-list (lambda () (display \" \")) newline)\n\t  '(1 2 3 4 5 6))\n;; -> 1 2\n;;    3 4\n;;    5 6\n;;\n}}}\nリストの要素をカンマ区切りで出力する処理を次のように書ける。\n{{{\n(import (except (rnrs) for-each)\n\t(only (srfi :1) circular-list for-each))\n\n(for-each (lambda (f x) (f x))\n\t  (cons display (circular-list (lambda (x) (display \",\") (display x))))\n\t  '(1 2 3 4))\n;; -> 1,2,3,4\n}}}\n")
(" %Tag:ネットワーク" . "(1668092636 (\"ネットワーク\" :ctime 1227970491 :cuser #f :mtime 1227970705 :muser #f))")
(" %Tag:FIXME?Tag:FIXME" . "(1491321807)")
(" %Tag:日付けと時刻?p=Tag?Tag:日付けと時刻?p=Tag" . "(1476573475)")
(" %Tag:スレッド' and 'x'='x" . "(1624115882)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45) -- /* order by 'as /*" . "(1624116431)")
("XML を処理する" . "(:ctime 1282540270 :cuser #f :mtime 1282540270 :muser #f)[[$$tag R6RS XML SXML]]\n\nXML を処理するライブラリとしては [http://okmij.org/ftp/Scheme/SXML.html SXML] がよく使われる。 SXML は XML Information set の S 式による具象表現であり、 XML 文書とはおおよそ次のように対応する。\n\n{{{\n<head>\n  <title>XML を処理する</title>\n  <base href=\"http://tips.lisp-users.org/scheme/index.cgi\" />\n  <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"http://tips.lisp-users.org/scheme/index.cgi?c=rss\" />\n  <link rel=\"stylesheet\" href=\"wiliki.css\" type=\"text/css\" />\n</head>\n}}}\n===\n{{{\n(*TOP*\n (head\n  (title \"XML を処理する\")\n  (base (¥x0040;\n\t (href \"http://tips.lisp-users.org/scheme/index.cgi\")))\n  (link (¥x0040;\n\t (type \"application/rss+xml\")\n\t (title \"RSS\")\n\t (rel \"alternate\")\n\t (href \"http://tips.lisp-users.org/scheme/index.cgi?c=rss\")))\n  (link (¥x0040;\n\t (type \"text/css\")\n\t (rel \"stylesheet\")\n\t (href \"wiliki.css\")))\n  ))\n}}}\nここで、 `@' が R6RS で妥当なシンボル名ではないために、 Unicode スカラー値による表記になっていることに注意。これについては他のシンボルを使うことも検討されている。 Cf: [http://sourceforge.net/mailarchive/forum.php?thread_name=1214378777.31858.90.camel%40eep&forum_name=ssax-sxml SourceForge.net: ssax-sxml]\n\nXML の読み込みには ssax:xml->sxml 手続きを使う。\n{{{\n(import (rnrs) (sxml ssax))\n\n(call-with-port (open-file-input-port \"index.htm\"\n\t\t\t\t      (file-options)\n\t\t\t\t      (buffer-mode block)\n\t\t\t\t      (make-transcoder (latin-1-codec)))\n  (lambda (p)\n    (ssax:xml->sxml p '())))\n}}}\n\n読み込まれた XML ファイルはリストや文字列といった Lisp オブジェクトに変換されているため、 car や cdr といった標準の操作関数で手軽にあつかうことができる。\n")
(" %Tag:Gauche" . "(1667933826 (\"コマンドライン引数を解析する\" :ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f))")
(" %Tag:手続き?p=Tag?Tag?Tag:手続き?p=Tag?Tag" . "(1476570335)")
("ハッシュテーブルの要素を削除する" . "(:ctime 1227601889 :cuser #f :mtime 1227601889 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\nあるキーに対応する要素を削除するには hashtable-delete! を使う。\n\n{{{\n(import (rnrs))\n\n(hashtable-delete! ht 'one)\n}}}\n")
("レコードの初期化をカスタマイズする" . "(:ctime 1233362979 :cuser #f :mtime 1233538776 :muser #f)[[$$tag R6RS レコード]]\n\nレコードの構築子をカスタマイズするには [[$$r6rs define-record-type]] に protocol 節を指定する。\n\nprotocol 節がない場合にはレコードの構築子は fields 節に指定されたフィールドの値を順に引数として取る手続きになる。\n\nレコード型に parent 節がない場合、 protocol 節には、デフォルトの構築子手続きを受け取り所望の構築子手続きを返す手続きを指定すればよい。\n\n例として、作成された時刻を記録しているレコードを考える。フィールドとしては名前とインスタンスの作成された時刻を設定するものとする。\n\n{{{\n(import (rnrs)\n\t(srfi :19))\n\n(define-record-type person\n  (fields\n   (immutable name)\n   (immutable birth-date)))\n}}}\n\n直截的にはインスタンスを生成するたびに現在の日時を渡してやればよい。\n\n{{{\n(define (make-person 'bob (current-date)))\n\n(person-name bob) ; => bob\n(person-birth-date bob) ; => #<record date 6880000 0 38 9 31 1 2009 32400>\n}}}\n\nしかしこれはインスタンス数が増えると手間なので自動化をしたい。\n\n次のような補助手続きを使って書くこともできるが、\n{{{\n(define (make-person* name)\n  (make-person name (current-date)))\n}}}\n\nprotocol 節を使うと次のように書ける。\n\n{{{\n(import (rnrs)\n\t(srfi :19))\n\n(define-record-type person\n  (fields\n   (immutable name)\n   (immutable birth-date))\n  (protocol\n   (lambda (c)\n     ;; This procedure becomes the actual constructor procedure.\n     (lambda (name)\n       (c name (current-date))))))\n\n(define bob (make-person 'bob))\n\n(person-name bob) ; => bob\n(person-birth-date bob) ; => #<record date 6880000 0 38 9 31 1 2009 32400>\n}}}\n\nレコードに parent 指定のある場合は、 protocol 節に指定する手続きに渡される手続きが、親レコードの初期化を行ない現在のレコードのデフォルト構築子手続きを返す手続きになる。\n\n上の例をレコードの拡張を使って書き直した例を下に示す。\n{{{\n(import (rnrs)\n\t(srfi :19))\n\n(define-record-type person\n  (fields\n   (immutable name)))\n\n(define-record-type person*\n  (parent person)\n  (fields\n   (immutable birth-date))\n  (protocol\n   (lambda (c)\n     (lambda (name)\n       ((c name) (current-date))))))\n\n(define bob (make-person* 'bob))\n\n(person-name bob) ; => bob\n(person*-birth-date bob) ; => #<record date 6880000 0 38 9 31 1 2009 32400>\n}}}\n\nprotocol 節を指定したレコード型を拡張する場合には常にその子レコード型でも protocol を指定しなければならない。\n")
(" %Tag:コンディション" . "(1668286216 (\"コンディションを合成する\" :ctime 1233267797 :cuser #f :mtime 1233267797 :muser #f) (\"コンディションを定義する\" :ctime 1233267117 :cuser #f :mtime 1233267156 :muser #f) (\"コンディション\" :ctime 1228790694 :cuser #f :mtime 1233265097 :muser #f) (\"エラーを通知する\" :ctime 1228790688 :cuser #f :mtime 1228878329 :muser #f))")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45) -- /* order by \"as /*" . "(1624116597)")
("大文字・小文字に揃える" . "(:ctime 1227425017 :cuser #f :mtime 1227425018 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 大文字・小文字に揃える\n\n{{{\n(import (rnrs unicode))\n\n(string-upcase \"Hi, Schemer\") ; => \"HI, SCHEMER\"\n(string-downcase \"Hi, Schemer\") ; => \"hi, schemer\"\n}}}\n")
(" %Tag:マクロ'[0]" . "(1662863474)")
(" %Tag:SXML2121121121212.1" . "(1573238421)")
(" %Tag:stub?Tag:stub" . "(1491321606)")
("識別子の命名規約" . "(:ctime 1227637244 :cuser #f :mtime 1232676886 :muser #f)[[$$tag R6RS]]\n\n[[$$toc]]\n\n* R6RS に挙げられているもの\n** ''procedure''!\n代入を行なうものや、引数として与えられたオブジェクトを変更する可能性のある手続き。\n\n** ''pred''?\n述語（真偽値のみを返す手続き）。\n\n** ''type1''->''type2''\nある型から他の型への変換を行なう手続きには ''変換前の型''->''変換後の型'' という名前をつける。\n\n** &''condition''\n[[コンディション]]型の名前。\n\n** ''an''-''identifier''\n識別子内の単語は `-' で区切る。ただし、 `-' に続く字が記号や数字の場合は `-' をつけない。また、短かくかつ発音のできない接頭辞の後にも `-' をつけない（例: ○ [[$$r6rs fxdiv]] × fx-div）。\n\n** _ （syntax-rules, syntax-case 等のパターン内）\nパターン変数を束縛しないパターン。\n\n※厳密に言うと、これは命名規約ではなく、これらの構文における規則である。\n\n* 慣習としてよく使われるもの\n** %''procedure''\n内部手続きや補助手続き。\n\n** *''variable''*\nトップレベル変数。\n\n** ''name''*\n''name'' の変種など。\n\n** ''namespace'':''name''\n名前空間接頭辞。 [[$$r6rs import]] の prefix 節でつける接頭辞は `:' で終えることが多い。\n\n例:\n{{{\n(import (rnrs) (prefix (only (srfi :1) map) srfi-1:))\n}}}\n\n** _ （手続きの仮引数）\n使用しない引数。ただし、同一の仮引数名を二度使うことはできないことに注意。\n\n例:\n{{{\n(define (constantly x)\n  (lambda _ x))\n}}}\n\n** ?''name'', ''NAME''\n[[$$r6rs syntax-rules]] / [[$$r6rs syntax-case]] のパターン変数。 ?''name'' は Dylan 由来、 ''NAME'' は Prolog 由来か。\n\n** <''class-name''>\nTiny CLOS 風のオブジェクトシステムにおけるクラス名。\n")
(" %Tag:SRFI'A=0" . "(1560177214)")
(" %Tag:stub999999.1 union select unhex(hex(version())) -- and 1=1" . "(1580892187)")
("ファイルを開く" . "(:ctime 1227427294 :cuser #f :mtime 1227427295 :muser #f)[[$$tag 入出力 R6RS]]\n\n* ファイルを開く\n\n読み込み/書き込み用にファイルを開くには open-file-input-port / open-output-file-port を使う。戻り値はポートである。ポートにはバイナリポートとテキストポートがある。\n\n{{{\n(import (rnrs))\n\n(open-file-input-port \"/path/to/file\" (file-options) (buffer-mode block))\n(open-file-output-port \"/path/to/file\" (file-options no-fail))\n}}}\n\nファイル名のあとにはオプションとバッファモードを指定する。\n\nオプションが有効なのは open-file-output-port に対してのみであり、指定可能なのは次のものである。\n\n:no-create: ファイルが存在しなかった場合に例外を発生させる。ファイルが存在した場合にはファイルサイズを 0 に切りつめる。\n:no-fail: ファイルが存在した場合にも例外を発生させない。ファイルサイズを 0 に切りつめる。\n:no-truncate: 上記の場合でもファイルを切りつめない。\n\nバッファモードとして指定可能なものは次の通りである。\n\n:none: バッファリングなし。\n:line: 行単位バッファリング。\n:block: 任意のバッファリング。\n\n何も指定しない場合にはファイルはバイナリモードで開かれる。テキストモードで開くためにはコード変換器を指定する。\n\n{{{\n(import (rnrs))\n\n(open-file-input-port \"/path/to/utf-8.txt\"\n\t\t      (file-options)\n\t\t      (buffer-mode block)\n\t\t      (make-transcoder (utf-8-codec)))\n}}}\n")
(" %Tag:SXML\" or (1,2)=(select*from(select name_const(CHAR(111,108,111,108,111,115,104,101,114),1),name_const(CHAR(111,108,111,108,111,115,104,101,114),1))a) -- \"x\"=\"x" . "(1573238437)")
(" %Tag:SLIB" . "(1668271142 (\"コマンドライン引数を解析する\" :ctime 1228897851 :cuser #f :mtime 1228902514 :muser #f))")
("ループから脱出する" . "(:ctime 1228303091 :cuser #f :mtime 1228347944 :muser #f)[[$$tag R6RS 手続き]]\n\nリストの中から特定の述語を満足する値を見つける手続きを考える。これを一般の言語で考えると\n\n# リストの各要素についてループする\n# 述語を満たす要素を見つけたらループを打ち切り、その要素を返す\n# さもなくはループを繰り返す\n# リストの終端に辿りついた場合は適当な値を返す\n\nここでは、リストの終端に辿りついた場合 #f を返すものとする。リストの要素に関する繰り返しは [[$$r6rs for-each]] で実現でき、打ち切りは [[$$r6rs call/cc]] で実現できる。\n\n{{{\n(import (rnrs))\n\n(define (f pred? xs)\n  (call/cc\n   (lambda (break)\n     (for-each\n      (lambda (x)\n\t(when (pred? x)\n\t  (break x)))\n      xs)\n     #f)))\n}}}\n\nところで、 Scheme ではループは末尾位置における手続き呼び出しで実現されているため、ループの打ち切りは煎じ詰めれば単純にループ手続きを呼び出さないことに一致する。\n\n{{{\n(import (rnrs))\n\n(define (f pred? xs)\n  (let loop ((xs xs))\n    (cond ((null? xs)\n\t   #f)\n\t  ((pred? (car xs))\n\t   (car xs))\n\t  (else\n\t   (loop (cdr xs))))))\n}}}\n\nそもそも求める手続きの動作は (rnrs lists) の [[$$r6rs find]] 手続きと同一である。\n\n{{{\n(import (rnrs))\n\n(define f find)\n}}}\n\n一般に Scheme ではループから脱出するための特定の構文が必要になることは少ない。\n")
(" %Tag:FIXME\" and \"x\"=\"x" . "(1581247074)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45) --  /*" . "(1624115981)")
("レコード型を拡張できないようにする" . "(:ctime 1233357230 :cuser #f :mtime 1233358211 :muser #f)[[$$tag R6RS レコード]]\n\n[[$$r6rs define-record-type]] 中で sealed 属性に #t を指定するとそのレコードを拡張することができなくなる。\n{{{\n(import (rnrs))\n\n(define-record-type a\n  (sealed #t))\n\n(define-record-type b\n  (parent a))\n;; => &assertion\n}}}\n")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45) --  /*" . "(1624116202)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45) -- /* order by 'as /*" . "(1624116257)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45) -- /* order by \"as /*" . "(1624116664)")
(" %Tag:ネットワーク//index.cgi?p=|echo \"Osirys-p0wa\"" . "(1247880494)")
("数値を文字列に変換する" . "(:ctime 1227864472 :cuser #f :mtime 1228202563 :muser #f)[[$$tag 数値 R6RS]]\n\n数値を文字列に変換するには [[$$r6rs number->string]] 手続きを使います。\n\n{{{\n(import (rnrs base))\n\n(number->string 123) ;=> \"123\"\n}}}\n\n第 2 引数に 2, 8, 10, 16 のいずれかの基数を指定できます。\n\n{{{\n(import (rnrs base))\n\n(number->string 1234  2) ;=> \"10011010010\"\n(number->string 1234  8) ;=> \"2322\"\n(number->string 1234 10) ;=> \"1234\"\n(number->string 1234 16) ;=> \"4d2\"\n}}}\n\n変換後の文字列に基数接頭辞は付きません。\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45),CHAR(45,120,50,50,45,81,45),CHAR(45,120,50,51,45,81,45),CHAR(45,120,50,52,45,81,45) -- /* order by 'as /*" . "(1624116475)")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45) -- /* order by \"as /*" . "(1624116530)")
("用語集" . "(:ctime 1233038657 :cuser #f :mtime 1233045160 :muser #f)RnRS 等で使われる用語について説明する。\n\n:代入（assignment）: '''変数'''に'''束縛'''されている'''場所'''の値を変更すること。\n:逆クォート（backquote）: [[$$r6rs quasiquote]] の別称。\n:束縛（binding）: ある'''場所'''に'''識別子'''を対応づけること。あるいは対応づけたもの。\n:束縛構文（binding construct）: '''構文'''を'''キーワード'''に、または'''場所'''を'''変数'''に対応づけるフォーム。\n:本体部分（body）: [[$$r6rs lambda]] 式等の直下の'''フォーム'''。この先頭に現れた'''定義'''群はその本体部分に局所的なものになる。\n:真偽値（boolean）: Scheme の基本型の一。\n:定数（constant）: 変更することのできない値。'''リテラル'''データや [[$$r6rs symbol->string]] の返した'''文字列'''がこれに当たる。これらを変更しようとすると &assertion 例外が発生する。\n:継続可能な例外（continuable exception）: 発生したあとでも例外ハンドラで適切な処置を行なうことによりプログラムの実行を継続することのできる例外。\n:継続（continuation）: ある計算に対する（既定の）未来全体。\n:核形式（core form）: '''マクロ'''をすべて展開した結果として現れる'''フォーム'''。どの'''フォーム'''が核形式に含まれるかは実装系依存である。\n:データ（datum）: '''オブジェクト'''の'''外部表現'''であり、 [[$$r6rs put-datum]] と [[$$r6rs get-datum]] とで書き出し・読み戻しのできるもの。\n:定義（definition）: トップレベルに現れた場合にはトップレベルの'''束縛'''を作り、本体部分の先頭に現れた場合には局所'''束縛'''を作り出す形式。\n:動的環境（dynamic environment）: [[$$r6rs dynamic-wind]] や [[$$r6rs with-exception-handler]] などにより設定され、手続きの引数とは別個に取得できる情報。\n:動的存続期間（dynamic extent）: ある'''手続き呼び出'''しについて、初期化が行なわれてからその'''手続き呼び出し'''から戻るまでの時間。\n:同値述語（equivalence predicate）: 数学の同値関係に対応する'''述語'''。\n:脱出手続き（escape procedure）: [[$$r6rs call-with-current-continuation]] の引数の'''手続き'''に渡される'''手続き'''。\n:エスケープシークェンス（escape sequence）: '''文字列''''''リテラル'''内における \\a, \\n など。\n:正確な（数）（exact）: 正確な数値オブジェクトを正確な操作に対して得られた数。戻り値として返ってきた正確な数は数学的に正しい結果である。\n:正確性（exactness）: 数が近似や丸め誤差を含まないこと。\n:例外的状況（exceptional situation）: 構文違反、手続きの仕様に対する違反、処理系の制約への違反、環境における例外的な状況の総称。\n:式（expression）: 評価されて値を返すもの。\n:外部表現（external representation）: 構文データの別名。\n:偽（false）: #f である値。\n:fixnum: 実装依存のある特定の範囲にある'''正確な'''整数の部分集合。\n:flonum: 実装依存の、'''不正確な'''数の部分集合。\n:フォーム、形式（form）: Scheme プログラムにおける構文上の単位。\n:健全な（マクロ）(hygienic): to-be-written\n:識別子（identifier）: 値を格納している'''場所'''を表しうるもの。\n:変更不可能（immutable）: '''定数'''であること。\n:実装による制約（implementation restriction）: '''不正確な''''''数'''で表しうる値の範囲や、'''非数'''が利用可能であるか、など各実装によって課せられる制約。\n:インポートレベル（import level）: '''識別子'''がどの'''フェーズ'''で参照可能であるかを表す属性。\n:非真正リスト（improper list）: 空リストで終端されない'''リスト'''。\n:不正確な（数）（inexact）: 不正確な数値'''リテラル'''や不正確な演算に由来する数。\n:無限大（infinity）: '''正の無限大'''に同じ。\n:（ライブラリの）インスタンス（instance）: to-be-written\n:インスタンス化（instantiation）: '''ライブラリ'''の'''インスタンス'''を作成する過程。\n:整数オブジェクト（integer object）: 整数数値オブジェクト（integer number object）の別称。\n:キーワード（keyword）: '''構文キーワード'''に同じ。\n:レベル（level）: '''インポートレベル'''に同じ。\n:語彙素（lexme）: 字句構文により規定される有意な文字の並び。\n:ライブラリ（library）: Scheme プログラムの構成要素の一。'''定義'''と'''式'''から成り、他のライブラリから定義を取り込み、他のライブラリへ定義を公開する。\n:リスト（list）: Scheme の基本型の一。'''対'''を数珠つなぎにし空リストで終端したもの。\n:リテラル（literal）: 表記したものそれ自体に評価されるもの。'''数値'''、'''真偽値'''、文字、'''文字列'''、バイトベクタがこれに当たる。リテラルはまた'''定数'''でもある。\n:場所（location）: 値を格納するところ。\n:マクロ（macro）: '''構文抽象'''の別名。\n:マクロキーワード（macro keyword）: '''キーワード'''に同じ。\n:マクロ変換子（macro transformer）: '''マクロ'''の使用がどのようにより原始的な'''形式'''に変換されるか指定するもの。\n:マクロの使用（macro use）: to-be-written\n:変更可能（mutable）: '''代入'''が可能であること。\n:非数（NaN, Not a Number）: 値の決定できない'''不正確な'''実数'''オブジェクト'''と見做されるもの。\n:負の無限大（negative infinity）: '''不正確な'''有理数'''オブジェクト'''で表されるどの数よりも小さい'''不正確な実数'''。\n:数（number）: Scheme の基本型の一。\n:数値型（numerical types）: 複素数型、実数型、有理数型、整数型の総称。\n:オブジェクト（object）: 値の別称。\n:対、ペア（pair）: Scheme の基本型の一。\n:パターン変数（pattern variable）: [[$$r6rs syntax-rules]], [[$$r6rs syntax-case]] のパターン部分に現れる `_' と `...' 以外の'''識別子'''。\n:フェーズ（phase）: '''ライブラリ'''中の'''式'''が評価されるタイミング。\n:正の無限大（positive infinity）: '''不正確な'''有理数'''オブジェクト'''で表されるどの数よりも大きい'''不正確な'''実数。\n:述語（predicate）: 常に #t か #f を返す'''手続き'''。\n:前置記法（prefix notation）: Lisp 族の言語で使われる式の表記法。ポーランド記法。\n:手続き（procedure）: Scheme の基本型の一。\n:手続き呼び出し（procedure call）: '''手続き'''とその引数を不定の順序で評価し、引数をその'''手続き'''に引き渡すこと。\n:真正末尾再帰（proper tail recursion）: '''末尾文脈'''における無制限な'''手続き'''の再帰呼び出し。\n:（例外を）上げる（raise）: 現在の例外ハンドラを起動すること。\n:参照透過（referentially transparent）: to-be-written\n:領域（region）: '''束縛'''が参照可能である範囲。\n:責任（responsibility): （プログラマに課せられる〜）値が実際に仕様で述べられている制約に従っていることを保証すること。（実装者に課せられる〜）妥当な範囲、可能な範囲、特定の操作が成功裏に完了する必要があることを認める範囲で、仕様にある制約が満たされているかどうかを確認すること。\n:安全なライブラリ: R6RS で述べられている'''ライブラリ'''、及び、安全な'''ライブラリ'''だけを取り込んだ'''ライブラリ'''。\n:simplest rational: to-be-written\n:特殊形式（special form）: '''フォーム'''の最初の要素が'''構文キーワード'''である'''フォーム'''。\n:つなぎ合わせ（splicing）:  '''本体部分'''に現れた [[$$r6rs begin]] フォームの'''下位フォーム'''が、あたかも begin フォームで包まれていないかのように、その上位フォームにつぎ合わされること。\n:標準ライブラリ（standard libraries）: R6RS Standard Libraries で言及されるライブラリ。\n:文字列（string）: Scheme の基本型の一。\n:下位フォーム（subform）: ある'''フォーム'''の下位要素である'''フォーム'''。\n:シンボル（symbol）: Scheme の基本型の一。\n:構文抽象（syntactic abstraction）: '''マクロ変換子'''を'''キーワード'''に束縛したもの。\n:構文データ（syntactic datum）: 情報の損失なしに読み書きできる Scheme の'''オブジェクト'''。\n:構文キーワード（syntactic keyword）: 構文に名前をつける識別子。\n:構文違反（syntax violation）: '''ライブラリ'''本体、'''トップレベルプログラム'''、'''構文抽象'''における構文違反。 &syntax 例外が発生する。\n:末尾呼び出し（tail call）: '''末尾文脈'''における手続き呼び出し。\n:末尾文脈（tail context）: R6RS 11.20 参照。\n:トップレベルプログラム（top-level program）: Scheme プログラムを起動する起点。\n:変換子（transformer）: '''マクロ変換子'''に同じ。\n:真（true）: '''偽'''ではない値。\n:未束縛（unbound）: ある'''識別子'''に対する'''束縛'''が存在しないこと。\n:規定されない振る舞い（unspecified behavior）: RnRS の範囲で規定されていない振る舞い。\n:未規定値（unspecified value）: RnRS により規定されていず、実装により異なる値。例えば [[$$r6rs set!]] の戻り値など。\n:変数（variable）: '''場所'''に名前をつける'''識別子'''。\n:ベクタ（vector）: Scheme の基本型の一。\n:（ライブラリの）訪問（visit, visiting）: to-be-written\n")
(" %Tag:スレッド1111111111111\" UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45) -- /* order by \"as /*" . "(1624116686)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45) --  /*" . "(1624116168)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45),CHAR(45,120,49,57,45,81,45),CHAR(45,120,50,48,45,81,45),CHAR(45,120,50,49,45,81,45) -- /* order by 'as /*" . "(1624116442)")
(" %Tag:SRFI'[0]" . "(1614071186)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45),CHAR(45,120,49,56,45,81,45) --  /*" . "(1624116136)")
("ハッシュテーブルの内容を取得する" . "(:ctime 1227602654 :cuser #f :mtime 1227602655 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\nhashtable-entries はハッシュテーブル内のキーの一覧と値の一覧をそれぞれベクタとのふたつの値を返す。\n\n{{{\n(import (rnrs))\n\n(hashtable-entries ht) ; => #(...) #(...)\n}}}\n\nハッシュテーブルの各対応に対して処理を行う場合にはこの値に vector-for-each や vector-map を使う。\n\n{{{\n(import (rnrs))\n\n(let-values (([kv vv] (hashtable-entries ht)))\n  (vector-for-each\n    (lambda (k v)\n      ...)\n    kv vv))\n}}}\n")
("文字列のエンコーディングを変換する" . "(:ctime 1228799761 :cuser #f :mtime 1228799761 :muser #f)[[$$tag R6RS 文字列 入出力 FIXME]]\n\n\nR6RS Scheme では文字列は処理系内部では Unicode スカラー値の列として表現されると規定されている。外部ファイルやバイトベクタの内容と内部エンコーディングを相互に変換するためには [[$$r6rs open-file-input-port]]/[[$$r6rs open-file-output-port]] や [[$$r6rs bytevector->string]]/[[$$r6rs string->bytevector]] の transcoder 引数に適切なコード変換器を指定してやればよいことになっている。\n\nしかしながら、現在のところでは標準の [[$$r6rs latin-1-codec]] や [[$$r6rs utf-8-codec]]、 [[$$r6rs utf-16-codec]] のみをサポートしている処理系しかないのが現状であり、実際上は外部とのやりとりは Unicode を介したものに限定されていると言える。\n")
("エラーを通知する" . "(:ctime 1228790688 :cuser #f :mtime 1228878329 :muser #f)[[$$tag R6RS コンディション 例外処理]]\n\nエラーを通知する手続きには [[$$r6rs error]], [[$$r6rs assertion-violation]], [[$$r6rs syntax-violation]] のみっつがある。 error は何らかのエラーが発生したことを表し、 assertion-violation は手続きに不正な引数が渡されたことを表す。 syntax-violation はマクロ展開時に不正な構文が検知されたことを表す。\n\n簡単な引数のチェックやデバッグには構文の [[$$r6rs assert]] を使うことができる。これは標準 C ライブラリの assert に相当する。ただし標準 C ライブラリの NDEBUG に相当する機能は R6RS では用意されていない。 assert は構文として定義されてい、処理系は通常の手続きでは実現できないような詳細なエラー報告をすることが期待されている。\n\nこれらの手続き・構文で送出されるコンディションはそれぞれ次のような合成コンディションである。\n\n:error: [[$$r6rs &who]] + [[$$r6rs &message]] + [[$$r6rs &irritants]] + [[$$r6rs &error]]\n:assertion-violation: &who + &message + &irritants + [[$$r6rs &assertion]]\n:syntax-violation: &who + &message + [[$$r6rs &syntax]]\n:assert: &assertion + &message\n\nただし、いずれの手続きも who 引数に #f を渡した場合は &who コンディションを含まない。\n\n* 例\n{{{\n(import (rnrs))\n\n(define *init-file* \"/usr/home/schemer/init.rc\")\n\n;; 初期化ファイルがない場合エラーを通知する\n(unless (file-exists? *init-file*)\n  (error 'load-init-file \"Initialization file does not exist.\" *init-file*))\n}}}\n\n{{{\n(import (rnrs))\n\n;; 実数の平方根を求める\n(define (real-sqrt x)\n  (unless (and (real? x) (>= x 0))\n    (assertion-violation 'real-sqrt \"non-negative real number required\" x))\n  (sqrt x))\n}}}\n\n{{{\n(import (rnrs))\n\n(define-syntax identifier-append\n  (lambda (x)\n    (syntax-case x ()\n      ((k i is ...)\n       (for-all identifier? #'(i is ...))\n       (datum->syntax #'k\n\t\t      (string->symbol\n\t\t       (apply string-append\n\t\t\t      (map (lambda (i)\n\t\t\t\t     (symbol->string (syntax->datum i)))\n\t\t\t\t   #'(i is ...))))))\n      ((_ . xs)\n       (syntax-violation 'identifier-append\n\t\t\t \"each argument must be an identifier\"\n\t\t\t x #'xs)))))\n\n#|\n(display (identifier-append a ppend)) ; -> #<procedure append>\n(display (identifier-append \"a\" ppend)) ; => &syntax\n|#\n}}}\n\n{{{\n(import (rnrs))\n\n(define *counter* 0)\n(define (inc! n)\n  (assert (and (integer? n) (exact? n)))\n  (set! *counter* (+ *counter* n)))\n\n(inc! 1)\n(inc! \"hello\") ; エラーが通知される。メッセージの内容は実装依存となる。\n}}}\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45) -- /* order by 'as /*" . "(1624116311)")
("リクエスト" . "(:ctime 1227362758 :cuser #f :mtime 1233324652 :muser #f)[[$$comment]]\n\n----\n\n- コードに色をつけたいです。\n-- [http://community.schemewiki.org/ tekili] みたいに [http://community.schemewiki.org/?wiki-patch-format-scheme WiLiKi を改造する]か、 [http://softwaremaniacs.org/soft/highlight/en/ highlight.js] とかですかねえ。\n-- めも: [http://search.cpan.org/~geoffr/Text-VimColor-0.11/lib/Text/VimColor.pm Text::VimColor], [http://coderepos.org/share/browser/lang/ruby/vimcolor/trunk 同 Ruby 版]\n-- leque(2008/12/31 03:53:17 PST): それっぽく使えそうなものを書いてみました: http://www.katch.ne.jp/~leque/software/gauche/r6rs-shtml-markup/\n-- おおー。すばらしい。ありがとうございます。負担のかかりそうな処理はクライアント側でやるようにしてるんですね。リンクが便利そうです。さっそく組み込んでみます。(...WiLiKiの改造に苦戦中)\n- シンボルから R6RS.org を参照したい。\n{{{\n[[$$r6rs シンボル]] と書くと R6RS.org へのリンクになります。\n}}}\n-- データファイルは [http://tips.lisp-users.org/scheme/link-r6rs.dat link-r6rs.dat] にあります。よかったら使ってください。\n--- + や - などが抜けてるみたいです。\n--- イプシロンのマニュアルの作成にありがたく使わせていただきました m(_ _)m　追加分は[http://codepad.org/2KdBiYl1 ここに]書き出しておきました。では！\n- RSS にページタイトルだけでなく全文を含めたい。\n-- WiLiKi本体を対応しました(rev420)。[[WiLiKi:WiLiKi:更新履歴]]を参照してください。\n-- WiLiKi最新版に入れ替えました。ありがとうございますー m(_ _)m\n- CPUのワードサイズの取得の方法があれば知りたいです\n-- 試しに書いてみました : [[プラットフォームに関する情報を得る]]\n- リクエストがしやすいようにフォームを設置していただけるとうれしいです。\n- 基礎的なCGIの書き方があるとうれしいです。\n-- 書いてみました : [[CGI を作る]]\n")
(" %Tag:htmlprag" . "(1667933876 (\"XPath を使う\" :ctime 1228228236 :cuser #f :mtime 1228351743 :muser #f) (\"HTML を処理する\" :ctime 1228218142 :cuser #f :mtime 1228237475 :muser #f))")
("データを読み書きする" . "(:ctime 1228778287 :cuser #f :mtime 1228784319 :muser #f)[[$$tag R6RS 入出力]]\n\nR6RS 4.3 節に <datum> として説明されている値は [[$$r6rs read]]/[[$$r6rs write]] （[[$$r6rs get-datum]]/[[$$r6rs put-datum]]）によって [[$$r6rs equal?]] において等しいオブジェクトとして読み書きできる。このような性質を '''Read/Write Invariance''' （読み書き不変性）と言う。この性質のおかげで、 Lisp ではプログラム中で必要なデータ構造の多くを、直接手で書き下したり、簡単にファイルに保存したりすることができる。\n\n<<<\n{{{\n<datum> → <lexeme datum>\n         | <compound datum>\n<lexeme datum> → <boolean> | <number>\n         | <character> | <string> | <symbol>\n<symbol> → <identifier>\n<compound datum> → <list> | <vector> | <bytevector>\n<list> → (<datum>*) | [<datum>*]\n         | (<datum>+ . <datum>) | [<datum>+ . <datum>]\n         | <abbreviation>\n<abbreviation> → <abbrev prefix> <datum>\n<abbrev prefix> → ’ | ‘ | , | ,@\n         | #’ | #‘ | #, | #,@\n<vector> → #(<datum>*)\n<bytevector> → #vu8(<u8>*)\n<u8> → <{0, ..., 255} の範囲の正確な整数を表現する任意の <number>>\n}}}\nR6RS 4.3 Datum syntax より\n>>>\n\nこの事実を次のような簡単な手続きとマクロを書いて確かめてみる。手続き read-write-invariant? は、受け取ったオブジェクトを文字列ポートに write し、それを read したものがもとのオブジェクトと equal? であるかどうかを返す。 test マクロは結果確認用のユーティリティである。\n\n{{{\n(import (rnrs))\n\n(define (read-write-invariant? obj)\n  (call-with-port (open-string-input-port\n\t\t   (call-with-string-output-port\n\t\t    (lambda (p) (write obj p))))\n    (lambda (p) (equal? obj (read p)))))\n\n(define-syntax test\n  (syntax-rules ()\n    ((_ obj)\n     (begin\n       (write obj)\n       (display \": \")\n       (display (read-write-invariant? obj))\n       (newline)))))\n}}}\nテスト結果、\n{{{\n(test #f)                               ; -> #f: #t\n(test 1/2)                              ; -> 1/2: #t\n(test -12)                              ; -> -12: #t\n(test 2+5i)                             ; -> 2+5i #t\n(test 3.141592653589793)                ; -> 3.141592653589793: #t\n(test +inf.0)                           ; -> +inf.0: #t\n(test +nan.0)                           ; -> +nan.0: #t\n(test #\\nul)                            ; -> #\\nul: #t\n(test #\\linefeed)                       ; -> #\\linefeed: #t\n(test #\\vtab)                           ; -> #\\vtab: #t\n(test #\\page)                           ; -> #\\page: #t\n(test #\\return)                         ; -> #\\return: #t\n(test #\\esc)                            ; -> #\\esc: #t\n(test #\\delete)                         ; -> #\\delete: #t\n(test \"\\a\")                             ; -> \"\\a\": #t\n(test \"\\b\")                             ; -> \"\\b\": #t\n(test \"\\t\")                             ; -> \"\\t\": #t\n(test \"\\v\")                             ; -> \"\\v\": #t\n(test \"\\r\")                             ; -> \"\\r\": #t\n(test \"ab\\\n c\")                                    ; -> \"abc\": #t\n(test 'abc)                             ; -> abc: #t\n(test '\\x40;)                           ; -> \\x40;: #t\n(test 'a\\x20;c)                         ; -> a\\x20;c: #t\n(test '(1 2 3))                         ; -> (1 2 3): #t\n(test '(1 #\\2 \"3\"))                     ; -> (1 #\\2 \"3\"): #t\n(test '#(a b c))                        ; -> #(a b c): #t\n(test '#((a b) c))                      ; -> #((a b) c): #t\n(test #vu8(0 128 255))                  ; -> #vu8(0 128 255): #t\n}}}\n")
(" %Tag:HTML" . "(1667933832 (\"HTML を処理する\" :ctime 1228218142 :cuser #f :mtime 1228237475 :muser #f))")
(" %Tag:日付けと時刻" . "(1668278687 (\"ユリウス日からグレゴリオ暦を計算する\" :ctime 1307027894 :cuser #f :mtime 1307576867 :muser #f))")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45) --  /*" . "(1624116069)")
("ハッシュテーブルの値を参照する" . "(:ctime 1227601383 :cuser #f :mtime 1227601995 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\n値の参照には hashtable-ref 手続きを使う。\n\n{{{\n(import (rnrs base) (rnrs hashtables))\n\n(hashtable-ref ht 'one #f)\n}}}\n\n最後の引数にはハッシュテーブル内にキーに対応する値のなかった場合のデフォルト値を指定する。\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45) -- /* order by 'as /*" . "(1624116322)")
("文字列を一文字づつ処理する" . "(:ctime 1227425322 :cuser #f :mtime 1227425322 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 文字列を一文字ずつ処理する\n\n単純に一文字ずつ繰返しをするのなら string-for-each を使うのが簡単。\n\n{{{\n(import (rnrs))\n\n(string-for-each display \"abc\")\n(newline)\n}}}\n\n複雑な処理をする場合には string->list でリストに変換したり、 open-string-input-port を使って文字列ポートとして処理をしてもよい。文字のリストから文字列への変換には list->string 手続きを使う。\n")
("ベクタ" . "(:ctime 1233011016 :cuser #f :mtime 1233011141 :muser #f)[[$$tag ベクタ]]\n\nベクタは他の言語で言う配列のようなものである。各要素に定数時間でアクセスすることができ、大きさを動的に変更することはできない。[[リスト]]が純粋関数型の用途を指向しているのに対し、ベクタは破壊的操作を前提としている。一般に、ベクタはリストよりも空間効率がよい。\n\n- [[ベクタを作成する]]\n- [[ベクタの要素数を取得する]]\n- [[ベクタから要素を取り出す]]\n- [[ベクタの内容を変更する]]\n- [[ベクタから要素を探す]]\n- [[ベクタをソートする]]\n- [[ベクタの各要素に手続きを適用する]]\n- [[ベクタをリストに変換する]]\n")
("ベクタの内容を変更する" . "(:ctime 1233021648 :cuser #f :mtime 1233021876 :muser #f)[[$$tag ベクタ R6RS SRFI]]\n\nベクタの任意番目の要素を変更するには [[$$r6rs vector-set!]] 手続きを使う。\n\n{{{\n(define v (vector 0 3 5))\n\n(vector-set! v 0 1)\nv ; => #(1 3 5)\n}}}\n\nベクタの全要素を置き換えるには [[$$r6rs vector-fill!]] 手続きを使う。\n{{{\n(define v (make-vector 4 'a))\nv ; => #(a  a a a)\n\n(vector-fill! v 'b)\nv ; => #(b b b b)\n}}}\nこのとき置き換えに使われるオブジェクトは [[$$r6rs make-vector]] の ''fill'' 引数と同様に同一のオブジェクトであるので注意が必要である。\n{{{\n(define v (vector 1 2 3))\n\n(vector-fill! v (list 'a))\nv ; => ((a) (a) (a))\n\n(set-car! (vector-ref v 0) 1)\nv ; => ((1) (1) (1))\n}}}\n\nSRFI 43 を使うと vector-fill! に範囲を指定できるようになる。\n{{{\n(import (except (rnrs) vector-fill!)\n\t(only (srfi :43) vector-fill!))\n\n(define v (vector 0 1 2 3 4 5))\n\n(vector-fill! v 'a 2)\nv ; => #(0 1 a a a a)\n\n(vector-fill! v 'b 3 4)\nv ; => #(0 1 a b b a)\n}}}\n\n")
(" %Tag:スレッド or (1,2)=(select*from(select name_const(CHAR(118,118,69,76,71,89,97,114,77,74),1),name_const(CHAR(118,118,69,76,71,89,97,114,77,74),1))a) -- and 1=1" . "(1624117037)")
("大文字と小文字を入れ替える" . "(:ctime 1227425090 :cuser #f :mtime 1227425090 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 大文字と小文字を入れ替える\n\n{{{\n(import (rnrs unicode))\n\n(string-foldcase \"Hi, Schemer\") ; \"hI, sCHEMER\"\n}}}\n\n以上の手続きでの大文字・小文字の対応は Unicode Consortium の UnicodeData.txt、 SpecialCasing.txt、 WordBreakProperty.txt、CaseFolding.txt に従う。\n")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45),CHAR(45,120,49,55,45,81,45) -- /* order by 'as /*" . "(1624116399)")
(" %Tag:スレッド1111111111111 UNION SELECT CHAR(45,120,49,45,81,45) --  /*" . "(1624115948)")
(" %Tag:スレッド' And SLeep(3) UniON SEleCT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643 #" . "(1624117026)")
(" %Tag:HTML\" and \"x\"=\"y" . "(1582392992)")
(" %Tag:SRFI//index.cgi?p=|echo \"Osirys-p0wa\"" . "(1247879191)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45) -- /* order by 'as /*" . "(1624116355)")
(" %Tag:スレッド' AND SLEEP(3) oRDeR BY 641 #" . "(1624117002)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45) -- /* order by 'as /*" . "(1624116333)")
("文字とUnicodeスカラー値を相互変換する" . "(:ctime 1227425943 :cuser #f :mtime 1227425944 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 文字と Unicode スカラー値を相互変換する\n\n{{{\n(import (rnrs))\n\n(char->integer (string-ref \"a\" 0)) ; => 97\n(string (integer->char 97)) ; => \"a\"\n}}}\n")
(" %Tag:stub' and 'x'='y" . "(1580892183)")
(" %Tag:スレッド1111111111111' UNION SELECT CHAR(45,120,49,45,81,45),CHAR(45,120,50,45,81,45),CHAR(45,120,51,45,81,45),CHAR(45,120,52,45,81,45),CHAR(45,120,53,45,81,45),CHAR(45,120,54,45,81,45),CHAR(45,120,55,45,81,45),CHAR(45,120,56,45,81,45),CHAR(45,120,57,45,81,45),CHAR(45,120,49,48,45,81,45),CHAR(45,120,49,49,45,81,45),CHAR(45,120,49,50,45,81,45),CHAR(45,120,49,51,45,81,45),CHAR(45,120,49,52,45,81,45),CHAR(45,120,49,53,45,81,45),CHAR(45,120,49,54,45,81,45) -- /* order by 'as /*" . "(1624116388)")
("文字列を結合する" . "(:ctime 1227424944 :cuser #f :mtime 1227811722 :muser #f)[[$$tag 文字列 R6RS]]\n\n* 文字列を結合する\n\n{{{\n(import (rnrs base))\n(string-append \"foo\" \"bar\") ; => \"foobar\"\n}}}\n\nこのとき、もとの文字列は変更されない。\n\n複数回文字列を結合する場合には文字列ポートを使った方が余計な文字列オブジェクトが生成されず効率がよい。\n\n{{{\n(import (rnrs))\n\n(call-with-output-string\n  (lambda (p)\n    (do ((ss (reverse '(\"foo\" \"bar\" \"baz\" \"quux\")) (cdr ss)))\n\t((null? ss))\n      (display (car ss) p)))) ; => \"foobarbazquux\"\n}}}\n")
("ハッシュテーブルに値を設定する" . "(:ctime 1227601175 :cuser #f :mtime 1227602027 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\n値の設定には hashtable-set! 手続きを使う。\n\n{{{\n(import (rnrs base) (rnrs hashtables))\n\n(hashtable-set! ht 'one 1)\n}}}\n")
("ハッシュテーブルを作成する" . "(:ctime 1227601018 :cuser #f :mtime 1227601255 :muser #f)[[$$tag ハッシュテーブル R6RS]]\n\n空のハッシュテーブルは make-hashtable 手続きで作成する。\nmake-hashtable 手続きには内容に応じて適当な同値手続きとハッシュ関数を渡す。\n\n{{{\n(import (rnrs))\n\n(make-hashtable string=? string-hash)\n(make-hashtablel equal? equal-hash)\n}}}\n\n特に、同値手続きに eq? や eqv? を使うハッシュテーブルの構築手続きは別に用意されている。\n{{{\n(import (rnrs))\n\n(make-eq-hashtable)\n(make-eqv-hashtable)\n}}}\n\nハッシュテーブルに対応するリテラルはないため、特定の内容を持つハッシュテーブルは連想リストなどから変換することが多い。\n\n{{{\n(import (rnrs))\n\n(define (alist->hashtable alis equiv hash-fun)\n  (let ((ht (make-hashtable equiv hash-fun)))\n    (for-each (lambda (p)\n      (hashtable-set! ht (car p) (cdr p)))\n      alis)\n    ht))\n\n(alist->hashtable\n  '((a . Ancona) (b . Bologna) (c . Como) (d . Domodossola) (e . Empoli)\n    (f . Firenze) (g . Genova) (h . hotel) (i . Imperia) (j . jersey)\n    (k . kukrsaal) (l . Livorno) (m . Milano) (n . Napoli) (o . Otranto)\n    (p . Padova) (q . Quarto) (r . Roma) (s . Savona) (t . Tranto) (u . Udine)\n    (v . Venezia) (w . Washington) (x . xeres) (y . yacht) (z . Zara))\n  eq? eq-hash)\n}}}\n")
