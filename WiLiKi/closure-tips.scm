("簡単なDNSルックアップ" . "(:ctime 1230782977 :cuser #f :mtime 1317765182 :muser #f)\nhttp://rd.clojure-users.org/entry/view/69006\n")
("Short Coding" . "(:ctime 1227696977 :cuser #f :mtime 1227701642 :muser #f){{{\n(multiple-value-bind (q r) (floor 5 3)\n  (list q r))\n;=> (1 2)\n\n(multiple-value-call #'list (floor 5 3))\n;=> (1 2)\n\n(multiple-value-list (floor 5 3))\n;=> (1 2)\n}}}\n{{{\n(let ((a 1) (b 2) (c 3) (d 4))\n   (list\n    ;; long\n    (1- (+ a b c d))\n    ;; short\n    (+ -1 a b c d)))\n;=> (9 9)\n}}}\n{{{\n;; long\n(let ((a 1) (b 2) (c 3) (d 4))\n   (list a b c d))\n;=> (1 2 3 4)\n\n;; short\n((lambda (a b c d)\n   (list a b c d))\n 1 2 3 4)\n;=> (1 2 3 4)\n\n;; cf.\n(destructuring-bind (a b c d) '(1 2 3 4)\n  (list a b c d))\n}}}\n{{{\n;; long\n(case :foo\n  (:foo (format t \"foo!~%\"))\n  (:bar (format t \"bar!~%\"))\n  (:baz (format t \"baz!~%\")))\n;-> foo!\n;=> nil\n\n;; short\n(format t (case :foo\n\t    (:foo \"foo!~%\")\n\t    (:bar \"bar!~%\")\n\t    (:baz \"baz!~%\")))\n;-> foo!\n;=> nil\n}}}\n")
(" %Tag:日付と時刻" . "(1338612762 (\"日付が何曜日、何日、年初から何日め、年初から何週めになるかを求める\" :ctime 1232880617 :cuser #f :mtime 1232880617 :muser #f) (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f) (\"時刻中の曜日を日本語に変換する\" :ctime 1227414645 :cuser #f :mtime 1228696999 :muser #f) (\"現在の日付を求める\" :ctime 1227414677 :cuser #f :mtime 1227947512 :muser #f) (\"うるう年かどうか判定する\" :ctime 1227414804 :cuser #f :mtime 1227714916 :muser #f) (\"月の最後の日を調べる\" :ctime 1227414848 :cuser #f :mtime 1227425023 :muser #f) (\"何日後、何日前/何ヶ月後、何ヶ月前の日付を求める\" :ctime 1227414763 :cuser #f :mtime 1227414763 :muser #f) (\"指定の日付が存在するかどうか調べる\" :ctime 1227414725 :cuser #f :mtime 1227414726 :muser #f) (\"2つの時刻の差を求める\" :ctime 1227414623 :cuser #f :mtime 1227414623 :muser #f) (\"時刻に任意の時間を加減する\" :ctime 1227414597 :cuser #f :mtime 1227414597 :muser #f) (\"Universal Timeを文字列に変換する\" :ctime 1227414526 :cuser #f :mtime 1227414526 :muser #f) (\"時刻の表現からUniversal Timeを作成する\" :ctime 1227414501 :cuser #f :mtime 1227414501 :muser #f) (\"現在の時刻(Universal Time)を取得する\" :ctime 1227414467 :cuser #f :mtime 1227414468 :muser #f) (\"Universal Time\" :ctime 1227414433 :cuser #f :mtime 1227414433 :muser #f))")
("指定値までの指定ステップ毎に繰り返し" . "(:ctime 1227415969 :cuser #f :mtime 1229527109 :muser #f)[[$$tag 制御構造]]\n* 指定値までの指定ステップ毎に繰り返し\n指定値まで繰り返します。 \n{{{\n(loop :for i :from 5 :to 10 :by 2\n      :do (print i))\n;=> 5,7,9\n; この例では、5から2ステップ毎に10を超えないように繰り返します。\n}}}\n\n** リスト上での指定ステップ毎の繰り返し\nby キーワードでリストの次のステップの取り出し方を指定できます。\n{{{\n(loop for i in '(1 2 3 4 5) by #'cddr\n      while (<= i 4)\n      do (print i))\n;=> 1,3\n; 要素を先頭からひとつ飛び毎に4以下のあいだ繰り返します。\n}}}\n")
("リストから要素を取り出す" . "(:ctime 1227519371 :cuser #f :mtime 1228192411 :muser #f)[[$$tag リスト]]\nリストの n 番目の要素を参照するには nth 手続きを使います。\nより汎用なシーケンス用の関数としてeltも利用できます。(汎用のかわりリスト専用のnthより低速です)\n\n{{{\n(defparameter *xs* '(0 1 2 3 4 5))\n\n(nth 0 *xs*) ;=> 0\n(nth 4 *xs*) ;=> 4\n(elt *xs* 4) ;=> 4\n}}}\n\nリストの先頭要素を参照するには car 手続きも使えます。\nまた first から tenth までのリスト参照手続きが用意されています。\n\n{{{\n(first '(1 2 3)) ; => 1\n(ninth '(1 3 5 7 9 11 13 15 17 19 21)) ; => 19\n}}}\n\nリストを cons セルの列なりや木構造として考える場合には car, cdr, caar といった手続きを使うことが多くなります。\n{{{\n(car '(a b)) ;=> a\n(caar '((a 1) (b 2) (c 3)) ;=> a\n}}}\n\n\n")
(" %Tag:制御構造" . "(1339768306 (\"制御構造\" :ctime 1227174305 :cuser #f :mtime 1235474147 :muser #f) (\"有意な値を返さない\" :ctime 1232958366 :cuser #f :mtime 1233045023 :muser #f) (\"一時変数を使わずに値を交換する\" :ctime 1230918931 :cuser #f :mtime 1230918931 :muser #f) (\"多値を変数に代入する\" :ctime 1229603159 :cuser #f :mtime 1230340071 :muser #f) (\"リスト構造を分解して変数に代入する\" :ctime 1229602567 :cuser #f :mtime 1229602567 :muser #f) (\"繰り返し(loop)\" :ctime 1227416023 :cuser #f :mtime 1229556523 :muser #f) (\"ブロックからの脱出\" :ctime 1229520442 :cuser #f :mtime 1229549658 :muser #f) (\"繰り返しからの脱出\" :ctime 1227416045 :cuser #f :mtime 1229529032 :muser #f) (\"繰り返しの前処理・後処理\" :ctime 1229528833 :cuser #f :mtime 1229528833 :muser #f) (\"指定値までの繰り返し\" :ctime 1227416057 :cuser #f :mtime 1229527990 :muser #f) (\"指定回数の繰り返し\" :ctime 1227415941 :cuser #f :mtime 1229527683 :muser #f) (\"指定値までの指定ステップ毎に繰り返し\" :ctime 1227415969 :cuser #f :mtime 1229527109 :muser #f) (\"goto文\" :ctime 1229522369 :cuser #f :mtime 1229522369 :muser #f) (\"確実に後処理を行なう\" :ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f) (\"条件判断(cond マクロ)\" :ctime 1228888426 :cuser #f :mtime 1228888426 :muser #f) (\"条件判断(if スペシャルフォーム)\" :ctime 1228888390 :cuser #f :mtime 1228888391 :muser #f) (\"繰り返し(do)\" :ctime 1227416036 :cuser #f :mtime 1227416036 :muser #f) (\"条件判断(case)\" :ctime 1227415897 :cuser #f :mtime 1227415897 :muser #f))")
("リスト同士の和・差・積を取る" . "(:ctime 1228451910 :cuser #f :mtime 1228451910 :muser #f)[[$$tag リスト]]\n\n* リスト同士の和・差・積を取る\n\nリストの和集合を得るには、[[$$hs union]]\n\nリストの差集合を得るには、[[$$hs set-difference]]\n\nリストの積集合を得るには、[[$$hs intersection]]\n\nが使えます。\n結果リストの要素の順番については、保証されていません。\n{{{\n(union '(1 3 5 7) '(2 4 6 8)) ;=> (8 6 4 2 1 3 5 7)\n(union '(1 2 3 4) '(3 4 5 6) :test #'eql) ;=> (6 5 1 2 3 4)\n\n(set-difference '(1 3 5 7) '(2 4 6 8)) ;=> (7 5 3 1)\n(set-difference '(1 2 3 4) '(3 4 5 6)) ;=> (2 1)\n\n(intersection '(1 3 5 7) '(2 4 6 8)) ;=> ()\n(intersection '(i 2 3 4) '(3 4 5 6)) ;=> (4 3)\n}}}\nまた、処理系依存で与えられたリストと結果の内容が同一の場合は、元のリストを返却しても構わないことになっていますので、上記3つの処理の結果のリストを破壊的に変更する場合にはコピーを渡してやる必要があります。\n{{{\n(let ((x '(1 2 3 4)))\n  (eq x (union x ())))\n;=> T(or nil 処理系依存)\n}}}\n\n")
("リストから重複した要素を取り除く" . "(:ctime 1227610615 :cuser #f :mtime 1227610724 :muser #f)[[$$tag リスト]]\n\nremove-duplicates や delete-duplicates を使います。delete-duplicates は引数として与えられたリストの内容を処理系が返り値を効率よく作成するために破壊しても構わないことになっています。\nまた、値をテストするための関数を :test キーワードにて与えることができます。(デフォルトではeql)\n返り値のリストは、基本では、前に出現した重複分が消去されますので、前のものを優先したい場合は、 :from-end に非nil値を与えます。\n{{{\n(remove-duplicates '(\"abc\" \"cba\" \"abc\") :test #'equal) \n;=> (\"cba\" \"abc\")\n\n(remove-duplicates '(\"abc\" \"cba\" \"abc\") :test #'equal :from-end T) \n;=> (\"abc\" \"cba\")\n\n(let ((list (copy-list '(a b c a a b a c))))\n  (list (delete-duplicates list)\n        list))\n;=> ((B A C) (A B C A A B A C)) \n}}}\n")
("URIエンコード" . "(:ctime 1227424464 :cuser #f :mtime 1317763635 :muser #f)\nhttp://rd.clojure-users.org/entry/view/69004\n")
("現在の時刻(Universal Time)を取得する" . "(:ctime 1227414467 :cuser #f :mtime 1227414468 :muser #f)[[$$tag 日付と時刻]]\n* 現在の時刻(Universal Time)を取得する\nget-universal-timeで取得できる\n{{{\n(get-universal-time)\n;=> 3436143023\n}}}\n通常は、decode-universal-timeで取得した時刻を変換して利用する\n{{{\n(decode-universal-time 3436143023)\n;=> 23\n    10\n    13\n    20\n    11\n    2008\n    3\n    NIL\n    -9\n}}}\ndecode-universal-timeは9つの[[多値]]で\nsecond, minute, hour, date, month, year, day, daylight-p, zone\nを返す\n")
("指定値までの繰り返し" . "(:ctime 1227416057 :cuser #f :mtime 1229527990 :muser #f)* 指定値までの繰り返し\n[[$$tag 制御構造]]\n{{{\n;; この例では、3から5まで繰り返します。\n(loop :for i :from 3 :upto 5 :do (print i))\n;-> 3\n    4\n    5\n;=> nil\n}}}\n{{{\n;; この例では、5から3まで繰り返します。\n(loop :for i :from 5 :downto 3 :do (print i))\n;-> 5\n    4\n    3\n;=> nil\n}}}\n{{{\n;; この例では、リストの要素が3を超えるまで繰り返します。\n(loop for i in '(1 2 3 4 5) until (< 3 i) collect i)\n;=> (1 2 3)\n}}}\n")
(" %Tag:FIXME" . "(1337411881 (\"一時的にリードテーブルを変更して読み込む\" :ctime 1229846380 :cuser #f :mtime 1229846380 :muser #f) (\"外部からの入力バイト列を文字列にしたい(文字コード変換含む)\" :ctime 1229261302 :cuser #f :mtime 1229518681 :muser #f))")
("2つのハッシュの両方にあるキー、または一方にしかないキーを見つける" . "(:ctime 1231752347 :cuser #f :mtime 1231752347 :muser #f)[[$$tag ハッシュテーブル]]\n\n* 2つのハッシュの両方にあるキー、または一方にしかないキーを見つける\n\nハッシュテーブルを対象にした集合演算の関数は標準にはありませんのでライブラリを利用するか自作することになるでしょう。\n\n2つのハッシュの両方にあるキーを見つける\n{{{\n;; 素朴な実装\n(defun hash-key-and (tab1 tab2)\n  (loop :for k :being :each :hash-key :of tab1\n        :when (gethash k tab2) :collect k))\n}}}\n{{{\n;; 実行例\n(import 'alexandria:plist-hash-table)\n\n(let ((tab1 (plist-hash-table \n              '(:a \"foo\" :b \"bar\" :c \"baz\")))\n      (tab2 (plist-hash-table\n              '(:a \"foo\" :b \"bar\" :c \"baz\" :q \"quux\"))))\n  (hash-key-and tab1 tab2))\n;=> (:A :C :B)\n}}}\n\n2つのハッシュで一方にしかないキーを見つける\n{{{\n;; 素朴な実装\n(defun hash-key-xor (tab1 tab2)\n  (let (ans)\n    (flet ((frob (tab1 tab2)\n             (loop :for k :being :each :hash-key :of tab1\n                   :do (unless (gethash k tab2) (push k ans)))))\n      (frob tab1 tab2)\n      (frob tab2 tab1))\n    ans))\n}}}\n{{{\n;; 実行例\n(import 'alexandria:plist-hash-table)\n\n(let ((tab1 (plist-hash-table \n              '(:a \"foo\" :b \"bar\" :c \"baz\" :z \"zot\")))\n      (tab2 (plist-hash-table\n              '(:a \"a\" :b \"b\" :d \"d\"))))\n  (hash-key-xor tab1 tab2))\n;=> (:D :Z :C)\n}}}\n\n** 議論\n\n\n\n\n")
("配列から指定条件を満たす要素を取り除く" . "(:ctime 1228980663 :cuser #f :mtime 1228980664 :muser #f)[[$$tag 配列]]\n\n* 配列から指定条件を満たす要素を取り除く\n\n[[$$hs remove-if]] [[$$hs delete-if]] は第1引数に与えられた関数が真(非nil)値を返した要素を除外したベクタを返します。\n{{{\n(let ((a (vector 30 100 50 80 79 40 95)))\n  (list (remove-if (lambda (x) (< x 80)) a)\n        a))\n;=> (#(100 80 95) #(30 100 50 80 79 40 95))\n}}}\n{{{\n(let ((a (vector 30 100 50 80 79 40 95)))\n  (list (delete-if (lambda (x) (< x 80)) a)\n        a))\n;=> (#(100 80 95) \n     #(100 80 95)) ;処理系依存\n}}}\n[[$$hs delete-if]] は破壊的に与えられたベクタを変更し結果を生成しますが、変更された元のベクタが結果と一致するとは限りません(処理系依存)ので処理系に依らず確実にしたい場合は、再度代入する必要があります。\n{{{\n(let ((a (vector 30 100 50 80 79 40 95)))\n  (setq a (delete-if (lambda (x) (< x 80)) a)))\n#(100 80 95)\n}}}\n")
("任意のビット位置の値を参照する" . "(:ctime 1230696694 :cuser #f :mtime 1230696734 :muser #f)[[$$tag 数値]]\n\n* 任意のビット位置の値を参照する\n\n任意のビット位置の値を参照するには[[$$hs ldb]]を使用し、数値とバイト指定子を与えます。\n{{{\n(let ((i #x10)\n      (pos 0))\n  (ldb (byte 1 pos) i))\n;=> 0\n\n(let ((i #x10)\n      (pos 4))\n  (ldb (byte 1 pos) i))\n;=> 1\n}}}\n任意のビット位置の値が1であるかを確かめるには、[[$$hs logbitp]]を使用します。\n{{{\n(let ((i #x10))\n  (logbitp 4 i))\n;=> T\n}}}\n")
("ソースファイルの拡張子" . "(:ctime 1232299882 :cuser #f :mtime 1232306612 :muser #f)ここでは、慣習として使われている拡張子を挙げます\n\n* プログラムの拡張子\n:.lisp:\nもっともオーソドックスなものです。\nLispマシンの時代(80年代初頭)から使われていますので、拡張子だけではCommon Lispのプログラムがどうかは分かりませんが、現状ほぼCommon Lispのプログラムだと思って良いでしょう。\n\n:.cl:\nCommon Lispの頭文字から由来していると思われますが、.lispほどは一般的でありません。Franz社のCommon Lispのプログラム等では良くみかけるようです。\n\n:.lsp:\nMS-DOSや、古くは、MS-DOSが影響を受けたTOPS-20の命名規則により拡張子が3文字の環境で使われていました。\n\n:.l:\n80年代のUNIX環境で使われることが多かったようですが、Common LispというよりFranz Lispの場合が多いようです。\nEmacs系のエディタであるxyzzyでもプログラムの拡張子は、.lが用いられるようです。\n\n* コンパイル済みのファイル\nコンパイル済みのファイルの拡張子は、処理系が自動で付けますので手動で付けることはありませんが、代表的なものを挙げます。\n\n:.fasl:\nfast loadの略で、様々なバリエーションがあります。.fas、.ufasl等\n\n:.bin:\nあまり見掛けませんが、Symbolics等で用いられました。\n\n* ASDF定義ファイル\n\n:.asd:\n最近だと.asdというファイルを目にすることが多いかと思いますが、ASDFで利用する定義ファイルです。\n")
("指定回数の繰り返し" . "(:ctime 1227415941 :cuser #f :mtime 1229527683 :muser #f)[[$$tag 制御構造]]\n* 指定回数の繰り返し\n指定回数だけ繰り返します。\n{{{\n(dotimes (i 3) (print i))\n;>>> 0,1,2\n\n(loop :for i :from 0 :repeat 3\n      :do (print i))\n;>>> 0,1,2\n; この例では、0から2まで繰り返します。\n\n(loop :repeat 3 :do (print 1))\n; 単純に指定回数だけ繰り返します。\n; カウントする変数を指定していないので何回目の繰り返しかは得られません。\n}}}\n")
("逆引きCommonLisp書式" . "(:ctime 1227277418 :cuser #f :mtime 1227368746 :muser #f)書式の指針を以下に示します。\n絶対に従わなければならないというものではありません。\n多少間違っていても、他の人が直してくれるので大丈夫です。\n\n* 文体\nですます調で書きましょう。文章の終わりを気をつければ十分です。\n* 戻り値の書き方\n次の行に「;=> 」に続けて書きます。\nもしくは一覧性を考慮しS式と同一行に書きます。~%\n例)\n{{{\n(+ 1 1)\n;=> 2\n\n(+ 1 1)  ;=> 2\n}}}\n* 多値の書き方\n一つ目の戻り値を次の行に「;=> 」に続けて書きます。\n以降の戻り値は一つ目の戻り値と桁を揃えて書きます。~%\n例)\n{{{\n(values 1 2)\n;=> 1\n;   2\n}}}\n* 戻り値無しの書き方\n「;=> 」に続けて斜体で「''No value''」と書きます。~%\n例)\n{{{\n(values)\n;=> No value\n}}}\n* 標準出力の書き方\n「;-> 」に続けて書きます。\n複数行の場合は一行目に桁を揃えます。\n戻り値よりも先に書きます。~%\n例)\n{{{\n(format t \"~@{~D~%~}\" 1 2 3)\n;-> 1\n;   2\n;   3\n;=> NIL\n}}}\n")
("Tutorial on Good Lisp Programming Style" . "(:ctime 1227969021 :cuser #f :mtime 1227971205 :muser #f)[[$$tag コーディングスタイル 参考文献]]\n\n* Tutorial on Good Programming Style\nPeter Norvig氏とKent Pitman氏がまとめたCLプログラミング指南書\n-- [http://norvig.com/luv-slides.ps PostScript版]\n-- [http://www.cs.umd.edu/~nau/cmsc421/norvig-lisp-style.pdf PDF版]\n-- [http://www010.upp.so-net.ne.jp/okshirai/tutorial-on-good-lisp-programming-style-ja.txt 日本語訳]\n")
("リードテーブルを標準の状態に復元する方法" . "(:ctime 1229195021 :cuser #f :mtime 1229195129 :muser #f)[[$$tag マクロ リーダーマクロ]]\n\n* リードテーブルを標準の状態に復元する方法\n\n[[$$hs set-macro-character]] 等で色々と変更を加えた [[$$hs *readtablbe*]] を標準の状態に戻すには、[[$$hs copy-readtable]] にnilを指定し、[[$$hs *readtablbe*]]に再度セットします。\n{{{\n(setq *readtable* (copy-readtable nil))\n}}}\n")
("asdf-installでインストールできるもの" . "(:ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f)* asdf-installでインストールできるもの\n[[$$tag asdf-install asdf ANSI規定外]]\n\nasdf-install:installで引数として処理できるものには、\n# パッケージの名前(キーワードで渡す)\n# URLの文字列\n# ファイルのパス名があります。\n\nパッケージの名前を指定した場合は、[[cliki]]に登録された内容を元にURLが割出されダウンロードされてきます。\nURLや、パス名で指定する場合は、tar.gzファイルを指定します。(インストール対象のファイルは、ASDFに対応している必要あり)\nそれぞれの例を挙げます。\n{{{\n;; パッケージの名前\n(asdf-install:install :foo)\n\n;; URL\n(asdf-install:install \"http://example.com/foo.tar.gz\")\n\n;; パス名\n(asdf-install:install \"/tmp/foo.tar.gz\")\n}}}\n\n\n\n\n\n\n\n\n\n")
("配列の各要素に関数を適用し配列を作成する" . "(:ctime 1228101170 :cuser #f :mtime 1228112053 :muser #f)[[$$tag 配列]]\n\n* 配列の各要素に関数を適用し配列を作成する\n\n[[$$hs map]] はシークエンス全般に使用できます。第1引数にシークエンスの型を指定することにより任意のシークエンスが作成可能です。\n{{{\n(let ((v (vector 1 2 3 2 1 2 3 2 1)))\n  (map 'vector #'1+ v ))\n;=> #(2 3 4 3 2 3 4 3 2)\n}}}\nまた、[[$$hs map-into]] は、第1引数にシークエンスそのものを指定することにより、結果を元のシークエンスに代入して返します。\n元のシークエンスは破壊的に変更されます。\n{{{\n(let ((v (vector 1 2 3 2 1 2 3 2 1)))\n  (map-into v #'1+ v ))\n;=> #(2 3 4 3 2 3 4 3 2)\n}}}\n")
("大文字と小文字の使い分け" . "(:ctime 1232667473 :cuser #f :mtime 1233408501 :muser #f)[[$$tag コーディングスタイル]]\n\nCommon Lispでは伝統的なLISPと同様シンボルの大文字と小文字を標準では区別しません。\n\n伝統的なLISPでは、この性質を利用してソースコード上で見やすさへの配慮や、単に個人的な趣味で大文字小文字を使い分けることが行なわれています。\n下記に代表的な例を挙げます。\n\n*** [[$$hs format]]のフォーマット指示記号だけ大文字にする\n大文字と小文字の使い分けの最も一般的なものですが、主に見やすさと伝統に由来するものと思われます\n{{{\n(format nil \"~A: ~D => ~A~%\" foo bar baz)\n}}}\n\n*** 返り値を強調するために大文字にする\n{{{\n(defun foo (x)\n  ...\n  ....\n  (return-from foo NIL)\n  ...)\n}}}\n\n*** 関数名だけ大文字にする\n{{{\n(defun FOO-to-BAR (..)\n  ...)\n}}}\n\n*** 間に挟まるものが長くなる場合、対になるものを大文字にする\n{{{\n;; mapcar\n(MAPCAR (lambda (x y z)\n          .....\n          (let ((...))\n            .....\n            .....\n            (cond ((...))\n                  ....)\n            (let ((....))\n              ....\n              ....\n              ....)))\n        (LIST X Y Z))\n\n;; coerce\n(COERCE (list ....\n          .....\n          (let ((...))\n            .....\n            .....\n            (cond ((...))\n                  ....)\n            (let ((....))\n              ....\n              ....\n              ....)))\n        'VECTOR)\n}}}\n\n*** [[$$hs if]]で述語/then部が長い場合、各部分の開始行を大文字にする\n{{{\n(IF (AND FOO BAR BAZ\n         ...\n         ...)\n    (COND ((...)\n           (let ((...))\n             .....\n             .....\n             (cond ((...))\n                   ....)\n             (let ((....))\n               ....\n               ....\n               ....)))\n          (...)\n          (t ...))\n    (LET ((X Y Z))\n      .....\n      .....\n      (cond ((...))\n            ....)\n      (let ((....))\n        ....\n        ....\n        ....)))\n}}}\n\n*** [[$$hs cond]]のデフォルト節のTを区別しやすいように大文字にする\n{{{\n(cond ((...)\n       (..)\n      ((...))\n      ((......))\n      (T ...)))\n}}}\n\n** その他\n\n*** マクロの定義で展開結果となる部分(可変ではない部分)を大文字にする\n{{{\n(defmacro ONCE-ONLY (variable-list &body body)\n  (dolist (variable variable-list)\n    (if (not (symbolp variable))\n        (error \"~S is not a variable\" variable)))\n  (let ((bind-vars (gensym))\n        (bind-vals (gensym))\n        (tem (gensym)))\n    `(LET ((,bind-vars NIL)\n           (,bind-vals NIL))\n       (LET ((RESULT ((LAMBDA ,variable-list ,@body)\n                       ,@(loop for variable in variable-list\n                               collect `(IF (OR (ATOM ,variable)\n                                                (EQ (CAR ,variable) 'QUOTE)\n                                                (EQ (CAR ,variable) 'FUNCTION))\n                                            ,variable\n                                          (LET ((,tem (GENSYM)))\n                                            (PUSH ,tem ,bind-vars)\n                                            (PUSH ,variable ,bind-vals)\n                                            ,tem))))))\n         (IF (NULL ,bind-vars)\n             RESULT\n           `((LAMBDA ,(nreverse ,bind-vars) ,result) ,@(nreverse ,bind-vals)))))))\n}}}\n\n*** パッケージ名付きの場合、シンボル名だけを大文字にする\n{{{\n(drakma:HTTP-REQUEST ...)\n}}}\n\n*** 恐らく個人的なこだわり\n{{{\n(DefMacro MY-MACRO (... ) )\n\n(DefClass FOO ()\n  ...)\n\n(DefMethod MY-METHOD (...) \n  ...)\n}}}\n\n** 議論\n- clispの「-modern」オプションのように大文字と小文字を区別する(read時に大文字にしない)環境も存在するので、大文字と小文字を区別しないことに過度に依存するのはよくないかもしれません。\n- Allegro CLのmlisp等CLISP以外にもあるかと思いますが、処理系のオプションで大文字小文字を有効にすることの是非についてはc.l.lでも激しい議論になりがちですね。\n今のところ大文字と小文字を区別した環境で動くこと考慮するということは仕様外の可搬性を求めることになるかと思いますし、どちらかといえば過度に依存して良くないのは「大文字と小文字を区別することを前提としたコード」ではないでしょうか。詳しい議論はc.l.l等で度々されているようですね。 --g000001\n- 上の発言は大文字小文字を区別しない環境で動作することを前提に、大文字小文字を区別する環境でも動くことを意識した方がいいんじゃないかなぁという意図でした。「大文字と小文字を区別することを前提としたコード」はCLとしては間違っているので全く意識していませんでした。 -- NANRI\n")
("mudballsを使う" . "(:ctime 1229134338 :cuser #f :mtime 1229510204 :muser #f)[[$$tag mudballs 【募集中】]]\n* mudballsを使う\n\nhttp://mudballs.com/\n\n- (mb:search \"ppcre\")\n- (mb:install :cl-ppcre)\n- (mb:load :cl-ppcre)\n")
("入出力" . "(:ctime 1227443658 :cuser #f :mtime 1235474167 :muser #f)[[$$tag 入出力]]\n\n;; - [[処理系を起動したディレクトリのパスネームを返す]]\n;; - [[テキストファイルをオープンして内容を出力する]]\n;; - [[ファイルに書き込む]]\n;; - [[ベクタをバイナリのストリームとして扱いたい]]\n;; - [[ストリームを扱うように出力先としてシーケンスを指定したい]]\n;; - [[外部からの入力バイト列を文字列にしたい(文字コード変換含む)]]\n;; - [[プログラムの出力を収集する]]\n;; - [[別のプログラムを起動する]]\n;; - [[ファイルをリネームする]]\n;; - [[ファイルから行をランダムに取り出す]]\n;; - [[ファイル内の特定の行を読み込む]]\n;; - [[NULLストリームを使う]]\n;; - [[ディレクトリ内のすべてのファイルを再帰的に処理する]]\n")
("マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい" . "(:ctime 1228627796 :cuser #f :mtime 1228627796 :muser #f)[[$$tag SLIME 開発環境]]\n\n* マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい\n\nslime-who-macroexpands(C-c C-w C-m)を使用します。\n\n下記のようにmy-incというマクロがあり、fooとbarがmy-incを利用していて両者ともコンパイルされているとします。\n{{{\n(defmacro my-inc (var)\n  `(incf ,var))\n\n(defun foo (n)\n  (my-inc n))\n\n(defun bar (n)\n  (my-inc n))\n}}}\nここでマクロ定義を変更したとすると、fooとbarもコンパイルしなおす必要がありますが、探し出すのが面倒です。\n\nマクロ名のシンボルの上でC-c C-w C-m(slime-who-macroexpands)すると、そのマクロを利用している関数/マクロ一覧が*XREF[:macroexpands: 〜]*に表示されますので、\n{{{\n*XREF[:macroexpands: my-inc]*\n#<buffer cl-2008-12-07.lisp>\n  (DEFUN BAR)\n  (DEFUN FOO)\n〜\n}}}\n関数名のところでC-c C-cするか、C-c C-kで*XREFバッファ全体を指定してコンパイルすることが可能です。\n")
(" %Tag:ハッシュ" . "(1338428847 (\"最もよく現れるデータを見つけたい\" :ctime 1231407996 :cuser #f :mtime 1231407997 :muser #f) (\"ハッシュの全エントリに対して処理を実行する\" :ctime 1227413710 :cuser #f :mtime 1229517972 :muser #f) (\"ハッシュのキーに任意のオブジェクトを使用する\" :ctime 1229510098 :cuser #f :mtime 1229510099 :muser #f) (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f) (\"ハッシュをシーケンス(alist、plist、その他)に変換する\" :ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f) (\"ハッシュの要素をランダムに抽出する\" :ctime 1227413899 :cuser #f :mtime 1227413900 :muser #f) (\"ハッシュを値で降順、値が等しい場合キーで昇順にソートする\" :ctime 1227413847 :cuser #f :mtime 1227413848 :muser #f) (\"ハッシュを空にする\" :ctime 1227413762 :cuser #f :mtime 1227413763 :muser #f) (\"ハッシュからエントリを削除する\" :ctime 1227413680 :cuser #f :mtime 1227413680 :muser #f) (\"キーが存在しない場合のデフォルト値を設定する\" :ctime 1227413661 :cuser #f :mtime 1227413661 :muser #f) (\"ハッシュの要素数を取得する\" :ctime 1227413641 :cuser #f :mtime 1227413641 :muser #f) (\"ハッシュ内にキーが存在するかどうか調べる\" :ctime 1227413596 :cuser #f :mtime 1227413596 :muser #f) (\"ハッシュに要素を追加する\" :ctime 1227413572 :cuser #f :mtime 1227413572 :muser #f) (\"キーに関連付けられた値を取得する\" :ctime 1227413525 :cuser #f :mtime 1227413525 :muser #f))")
("確実に後処理を行なう" . "(:ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f)[[$$tag 例外処理 制御構造 マクロ]]\n\n* 確実に後処理を行なう\n\t\nファイルを開いた場合やネットワークに接続した場合、例外が発生した場合でもその後処理を確実に行ないたいことがあります。そのような場合、 [[$$hs unwind-protect]] を使い例外が発生しても後処理を確実に行なうようにします。\n{{{\n(let ((in (open \"foo.txt\")) \n      (delete? t))                        ;後処理確認のためのフラグ\n  (unwind-protect \n       (multiple-value-prog1 \n           (progn \n             (job1)\n             (job2)\n             (job3)) \n         (setq delete? nil))              ;無事に辿り着いたらフラグをnilに\n    (when in\n      (close in :abort delete?))))        ;delete? => T ならば\n                                          ; close が後処理をする\n}}}\nこの一連の流れは定型となっていて標準のマクロ with-open-file 等も内部で [[$$hs unwind-protect]] を利用しています。\n\n上記は、 [[$$hs with-open-file]] を利用すると下記のように書けます。\n{{{\n(with-open-file (in \"foo.txt\")\n  (job1)\n  (job2)\n  (job3))\n}}}\n")
("InterWikiName" . "(:ctime 1228811927 :cuser #f :mtime 1228813752 :muser #f):CLiki:\nwww.cliki.net/\n\n:WiLiKi:\npractical-scheme.net/wiliki/wiliki.cgi?p= \n\n:isbn:\nwww.amazon.co.jp/exec/obidos/ASIN/ \n\n:Wikipedia:\nwww.wikipedia.org/wiki/ \n\n\n:Wikipedia-ja:\nja.wikipedia.org/wiki/ \n")
("CPUのワードサイズを調べる" . "(:ctime 1230404121 :cuser #f :mtime 1230404181 :muser #f)[[$$tag プラットフォーム固有の情報]]\n\n* CPUのワードサイズを調べる\n\nCPUのワードサイズを調べる確実な方法はありませんが、 [[$$hs machine-type]] にて主にアーキテクチャの情報、 [[$$hs machine-version]] でプロセッサ等のバージョンの情報を得られますので、これからマシンのアーキテクチャを割り出し判断することも可能でしょう。\nまた、多くの処理系では、アーキテクチャを*features*に格納していますので、これから判断する材料を得ることも可能でしょう。\n\n[[$$hs machine-version]]で確認\n{{{\n(machine-version)\n;=> \"AMD64\"                                           ;Scineer CL\n;=> \"Intel(R) Core(TM)2 CPU          6600  @ 2.40GHz\" ;SBCL\n;=> \"X86_64\"                                          ;CLISP\n\n;; AMD64アーキテクチャなので64bit\n}}}\n[[$$hs machine-type]]で確認\n{{{\n(machine-type)\n;=> \"X86_64\" ;clisp\n;=> \"X86-64\" ;sbcl\n;=> \"AMD64\"  ;scl\n\n;; AMD64アーキテクチャなので64bit\n}}}\n*features*で確認\n{{{\n;; SBCL\n(find :x86-64 *features*)\n;=> :X86-64\n}}}\nまた、確実ではありませんが、fixnumのサイズから推し量る方法も考えられるでしょう\n{{{\n(integer-length most-positive-fixnum)\n;=> 60 ;60bit以上の可能性が高い\n}}}\n")
("現在読み込まれているライブラリを確認する" . "(:ctime 1271356837 :cuser #f :mtime 1317762970 :muser #f)- http://rd.clojure-users.org/entry/view/69002\n")
(" %Tag:プラットフォーム固有の情報" . "(1337531014 (\"CPUのワードサイズを調べる\" :ctime 1230404121 :cuser #f :mtime 1230404181 :muser #f))")
("ライブラリ管理" . "(:ctime 1227511449 :cuser #f :mtime 1235474294 :muser #f);; - [[asdf-installでインストールできるもの]]\n;; - [[mudballsを使う]]\n;; - [[clbuildを使う]]\n")
("インスタンス生成を記録しておき後で条件を満すものを抽出したい" . "(:ctime 1227530644 :cuser #f :mtime 1227531695 :muser #f)[[$$tag MOP c2mop ライブラリ]]\n* インスタンス生成を記録しておき後で条件を満すものを抽出したい\n\n記録するためのメタクラスを定義し、そのスロットに記録します。\n\n下記の例では、list-metaclassを定義し、list-metaclassをメタクラスとしたboxクラスのインスタンスが生成される度にメタクラスのスロット(all-instances)に生成されたインスタンスがpushされるようにします。\n\nMOPの互換性のため[[Closer to MOP]]を利用しています。\n{{{\n;; メタクラス\n(defclass list-metaclass (standard-class)\n  ((all-instances :initform () :accessor class-all-instances)))\n\n#-(or clisp allegro)\n(defmethod c2mop:validate-superclass ((class list-metaclass) \n                                      (super standard-class))\n  T)\n\n(defmethod allocate-instance ((class list-metaclass) &key)\n  (let ((new-instance (call-next-method)))\n    (push new-instance (class-all-instances class))\n    new-instance))\n\n;; list-metaclassをメタクラスとしたboxクラス\n(defclass box () \n  ((color :initform 'white :initarg :color :accessor box-color)\n   size)\n  (:metaclass list-metaclass))\n}}}\n{{{\n;; 動作\n(make-instance 'box :color 'green)\n(make-instance 'box :color 'black)\n...\n\n(mapc #'describe \n      (remove-if-not (lambda (box) (eq (box-color box) 'black))\n\t\t     (class-all-instances (find-class 'box))))\n\n;-> #<BOX {100A12CB51}> is an instance of class #<LIST-METACLASS BOX>.\n;   The following slots have :INSTANCE allocation:\n;    COLOR    BLACK\n;    SIZE     #<unbound slot>\n;...\n;=> (#<BOX {100A12CB51}> ...)\n}}}\n\n")
("Universal Time" . "(:ctime 1227414433 :cuser #f :mtime 1227414433 :muser #f)[[$$tag 日付と時刻]]\n* Universal Time\nCLでは、1900年を基点とした秒数(非負のinteger)をUniversal timeと呼ぶ。\n- [http://www.lispworks.com/documentation/HyperSpec/Body/25_adb.htm universal time]\n;;bignumがウタガワし。非負の整数？そして閏秒は無視される。\n")
("ハッシュからエントリを削除する" . "(:ctime 1227413680 :cuser #f :mtime 1227413680 :muser #f)[[$$tag ハッシュ]]\n* ハッシュからエントリを削除する\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  ;; 削除\n  (remhash \"apple\" ht)\n\n  (gethash \"apple\" ht))\n;=> nil\n    nil(存在しない)\n}}}\n")
("文字列を Base64 エンコードする" . "(:ctime 1229665104 :cuser #f :mtime 1317765808 :muser #f)http://rd.clojure-users.org/entry/view/72004\n")
(" %Tag:正規表現" . "(1335705044)")
(" %Tag:R6RS" . "(1271448752)")
(" %Tag:数値" . "(1340811423 (\"数値\" :ctime 1227412843 :cuser #f :mtime 1235474062 :muser #f) (\"#xNNNNNNという16進RGB形式を色ごとに分解する\" :ctime 1235192973 :cuser #f :mtime 1235213428 :muser #f) (\"数値を位取り用のカンマで区切る\" :ctime 1232874597 :cuser #f :mtime 1232879591 :muser #f) (\"数値に応じて複数形と単数形を切り換える\" :ctime 1232048921 :cuser #f :mtime 1232048967 :muser #f) (\"ローマ数字を扱う\" :ctime 1230925747 :cuser #f :mtime 1230925748 :muser #f) (\"任意のビット位置の値を参照する\" :ctime 1230696694 :cuser #f :mtime 1230696734 :muser #f) (\"対数を計算する\" :ctime 1230695185 :cuser #f :mtime 1230695227 :muser #f) (\"除算の商と余りを求める\" :ctime 1227870704 :cuser #f :mtime 1227878024 :muser #f) (\"数値を2進数・8進数・16進数表現の文字列に変換するには\" :ctime 1227837042 :cuser #f :mtime 1227842291 :muser #f) (\"2進数・8進数・16進数で数値を扱うには\" :ctime 1227836450 :cuser #f :mtime 1227836450 :muser #f) (\"平方根を求める\" :ctime 1227495967 :cuser #f :mtime 1227495986 :muser #f) (\"計算結果を分数から小数にしたい\" :ctime 1227349345 :cuser #f :mtime 1227371838 :muser #f))")
("インスタンス変数へアクセスするメソッドを簡単に定義する" . "(:ctime 1230699674 :cuser #f :mtime 1230699675 :muser #f)[[$$hs オブジェクトシステム(CLOS)]]\n\n* インスタンス変数へアクセスするメソッドを簡単に定義する\n\n[[$$hs defclass]] でのクラスの定義では :reader(読み出し専用)、 :writer(書き込み専用)、 accessor(読み書き)を指定することにより総称関数(メソッド)も一緒に定義できます。\n{{{\n(defclass sample-class ()\n  ((a :initform 0 :reader a)     ;aというリーダを設定\n   (b :initform 0 :writer b)     ;bというライタを設定\n   (c :initform 0 :accessor c))) ;cというアクセサを設定\n\n(let ((inst (make-instance 'sample-class)))\n  (b 10 inst)                    ;bメソッドでbスロットに10を設定\n  (setf (c inst) 100)            ;cメソッドでcスロットに100を設定\n  \n  (describe inst))\n;-> Instance: #<SAMPLE-CLASS {4002406CD2}>\n;   Class: #<STANDARD-CLASS SAMPLE-CLASS {40036857E2}>\n;    The following slots have :instance allocation:\n;     A   0\n;     B   10\n;     C   100\n}}}\n")
(" %Tag:url-encode" . "(1227425286)")
("ディレクトリ内のすべてのファイルを再帰的に処理する" . "(:ctime 1232597586 :cuser #f :mtime 1317764975 :muser #f)\nhttp://rd.clojure-users.org/entry/view/73002\n")
("SETF関数を取り出す" . "(:ctime 1233974927 :cuser #f :mtime 1233975138 :muser #f)[[$$tag 関数]]\n\n[[$$hs setf]]は汎変数を扱い、読み出されてくる場所(読み出す関数)に応じて関数を設定することが可能です。\n\n通常関数は、関数名のシンボルに束縛されていますので、[[$$hs symbol-function]]にて関数オブジェクトを取り出すことが可能ですが、対象は名前の通りシンボルのみですので、[[$$hs setf]]の場合は、[[$$hs fdefinition]]を利用します。\n\n[[$$hs fdefinition]]は、シンボルも取り扱うことが可能です。\n{{{\n(setf (fdefinition 'set-car)\n      (fdefinition '(setf car)))\n\n(let ((list (list 1 2 3 4)))\n  (set-car 'foo list)\n  list)\n\n;=> (FOO 2 3 4)\n}}}\n\nまた、(function (setf 名前))もしくは#'(setf 名前)という形で直接利用することも可能です。\n{{{\n(let ((list (list 1 2 3 4)))\n  (funcall #'(setf car) 'foo list)\n  list)\n\n;=> (FOO 2 3 4)\n}}}\n\n** 議論\n")
("ベクタをバイナリのストリームとして扱いたい" . "(:ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f)[[$$tag 入出力 ライブラリ flexi-streams]]\n\n* ベクタをバイナリのストリームとして扱いたい\n\n自作するかライブラリを利用します。\n\n下記の例では、 [[ライブラリ:flexi-streams]]を利用しています。\n{{{\n(flexi-streams:with-input-from-sequence (in #(#x31 #x32))\n  (loop for i = (read-byte in nil) while i\n        collect (code-char i)))\n;=> (#\\1 #\\2)\n}}}\n")
("ドキュメンテーション" . "(:ctime 1229516095 :cuser #f :mtime 1229517828 :muser #f)[[$$tag ドキュメント]]\n* ドキュメンテーション文字列\n\n関数や変数、クラス定義にはドキュメント文字列を付ける事ができます。\nコメントと違い読み飛ばされないのでプログラム内から読み出すこともできます。\n\n (defun foo (x)\n    \"ドキュメント文字列\"\n    (+ x x))\n\n (defvar bar 10\n    \"ドキュメント文字列\")\n (defparameter baz 10\n    \"ドキュメント文字列\")\n\n (defclass bee ()\n    ()\n    (:documentation \"ドキュメント文字列\"))\n\nドキュメント文字列を取り出すには、総称関数 [[$$hs documentation]] を使用します。 \n\n (documentation 'foo 'function)\n (documentation 'bar 'variable)\n (documentation 'bee 'type)\n\n")
("文字列中の関数と式を展開する" . "(:ctime 1232079306 :cuser #f :mtime 1232090805 :muser #f)[[$$tag 文字列]]\n\nANSI CL標準にPerlのように文字列に含まれる変数を展開する文字列補間は含まれていませんが、[[CLiki:cl-interpol]]のようなライブラリを利用することで文字列補間を実現できるでしょう。\n\n{{{\n(cl-interpol:enable-interpol-syntax)\n\n(let ((x 10000))\n  (multiple-value-bind (ig no re d mo y)\n      (decode-universal-time (- (get-universal-time) \n                                (* 60 60 24 (1- x))))\n    (declare (ignore ig no re))\n  #?\"こんにちは、人が生まれてから${x}日目を迎えるのは、${(truncate (/ x 365))}歳のときですが、\\n本日${x}日目を迎えるのは、${y}年${mo}月${d}日生まれの方です。\\nおめでとう。\"))\n;=> \"こんにちは、人が生まれてから10000日目を迎えるのは、27歳のときですが、\n本日10000日目を迎えるのは、1981年9月1日生まれの方です。\nおめでとう。\"\n}}}\n")
("処理系" . "(:ctime 1227545106 :cuser #f :mtime 1227968573 :muser #f)[[$$tag 処理系]]\n\n- [[各処理系毎に違うところ]]\n- [[処理系を表すfeature一覧]]\n")
("最適化" . "(:ctime 1228170916 :cuser #f :mtime 1235474325 :muser #f)[[$$tag 最適化]]\n\n;; - [[末尾呼び出しの最適化]]\n\n\n")
(" %Tag:drakma" . "(1338387596 (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f) (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
("編集記録" . "(:ctime 1227239300 :cuser #f :mtime 1228111859 :muser #f)[[$$hs format]]\n[[$$hs destructuring-bind]]\n[[$$mop compute-slots]]\n")
("ハッシュのキーに任意のオブジェクトを使用する" . "(:ctime 1229510098 :cuser #f :mtime 1229510099 :muser #f)[[$$tag ハッシュ 【募集中】]]\n* ハッシュのキーに任意のオブジェクトを使用する\n\nハッシュテーブルのキーの比較に用いる関数は :test キーワードパラメタで指定できます。\n\nただし、指定できるのは #'eq #'eql #'equal #'equalp のいずれかだけです。\nつまり、キーに使用できるオブジェクトはこれらの関数で同値判定できるものに限られます。\n\n処理系の独自拡張で任意の比較関数を指定できる場合があります。\n比較関数とハッシュ値計算関数の両方をあたえる必要があるようです。\n\n (make-hash-table :test #'my-eql :hash-function #'my-hash)\n\nor\n\n (sb-int:define-hash-table-test 'my-test #'my-eql #'my-hash)\n (make-hash-table :test 'my-test)\n\nmore【募集中】\n")
(" %Tag:net-telent-date" . "(1337528385 (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f) (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f))")
("日付が何曜日、何日、年初から何日め、年初から何週めになるかを求める" . "(:ctime 1232880617 :cuser #f :mtime 1232880617 :muser #f)[[$$tag 日付と時刻]]\n\n日付についての操作は、標準の組み合わせでも賄えますが、PerlのDate::Calc互換を目指した[[CLiki:date-calc]]ようなライブラリもあり、日付についての関数がまとめられています。\n\n日付が何曜日、何日、年初から何日め、年初から何週めになるかを求めるのは下記のように書けるでしょう。\n{{{\n;; Date::Calc\n(multiple-value-bind (s m h day month year) \n    (decode-universal-time (get-universal-time))\n  (declare (ignore s m h))\n  (list \n   (date-calc:day-of-week year month day)\n   (date-calc:week-number year month day)\n   (date-calc:day-of-year year month day)))\n;; Sun 25 Jan 2009 19:43:42 の場合\n;=> (7 4 25)\n}}}\n")
("スレッド" . "(:ctime 1229079964 :cuser #f :mtime 1235474220 :muser #f)[[$$tag スレッド]]\n\n* スレッド\n\n;; スレッドについては、ANSI Common Lispの仕様では決められておらず、処理系が各々実装している状況です。\n;; \n;; 処理系間のポータビリティの確保のためのパッケージはいくつか存在し、 [[CLiki:Portable-Threads]] [[CLiki:Bordeaux-Threads]] 等が主なものです。\n;; \n;; - [[スレッドを生成する]]\n;; - [[スレッドに引数を渡す]]\n;; - [[スレッドの終了を待つ]]\n;; - [[スレッドの実行を終了させる]]\n;; - [[スレッドを停止する]]\n;; - [[実行中のスレッド一覧を取得する]]\n;; - [[スレッド間で通信する]]\n;; - [[スレッド間の競合を回避する(Mutex)]]\n;; - [[操作をタイムアウトにする]]\n")
("別のプログラムを起動する" . "(:ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f)[[$$tag 入出力 ライブラリ kmrcl]]\n\n* 別のプログラムを起動する\n\n下記の例では、[[CLiki:KMRCL]] の run-shell-command を利用して、firefoxで/etc/fstabを開いています。\nrun-shell-command はシェルを呼び出しシェルの返したステータスを返します。\n{{{\n(let ((myfile \"/etc/fstab\"))\n  (let ((status (kmrcl:run-shell-command \"firefox ~A\" myfile)))\n    status))\n;=> 0 ;成功\n}}}\n")
(" %Tag:bordeaux-threads" . "(1335371305 (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f))")
("ハッシュをシーケンス(alist、plist、その他)に変換する" . "(:ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f)[[$$tag ハッシュ Alexandria ライブラリ]]\n* ハッシュをシーケンス(alist、plist、その他)に変換する\n自作するか、ライブラリを利用します。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (let ((alist () ))\n    (maphash (lambda (key val)\n               (push (cons key val) alist))\n             ht)\n    alist))\n}}}\n[[ライブラリ:Alexandria]]を利用し、ハッシュテーブルからplistへ変換\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (alexandria:hash-table-plist ht))\n;=> (\"lemon\" 300 \"banana\" 300 \"apple\" 150)\n}}}\n")
("平方根を求める" . "(:ctime 1227495967 :cuser #f :mtime 1227495986 :muser #f)[[$$tag 数値]]\n* 平方根を求める\nsqrt 関数を使います\n{{{\n(sqrt 9.0) ;=>  3.0\n}}}\n負の数を与えると複素数が得られます\n{{{\n(sqrt -9.0) ;=>  #C(0.0 3.0)\n}}}\nisqrt は自然数の正確な整の平方根を超えない整数値を返します\n{{{\n(isqrt 2) ;=>  1\n}}}\n\n- 参照：[http://www.lispworks.com/documentation/HyperSpec/Body/f_sqrt_.htm CLHS: Function SQRT, ISQRT]\n")
("ハッシュテーブル" . "(:ctime 1227248242 :cuser #f :mtime 1235474095 :muser #f);; - [[プログラム中でハッシュを定義する]]\n;; - [[キーに関連付けられた値を取得する]]\n;; - [[ハッシュに要素を追加する]]\n;; - [[ハッシュ内にキーが存在するかどうか調べる]]\n;; - [[ハッシュの要素数を取得する]]\n;; - [[キーが存在しない場合のデフォルト値を設定する]]\n;; - [[ハッシュからエントリを削除する]]\n;; - [[ハッシュの全エントリに対して処理を実行する]]\n;; - [[ハッシュをシーケンス(alist、plist、その他)に変換する]]\n;; - [[ハッシュを空にする]]\n;; - [[ハッシュを値で降順、値が等しい場合キーで昇順にソートする]]\n;; - [[ハッシュの要素をランダムに抽出する]]\n;; - [[ハッシュのキーに任意のオブジェクトを使用する]]\n;; - [[最もよく現れるデータを見つけたい]]\n;; - [[ハッシュのキーと値を反転する]]\n;; - [[2つのハッシュの両方にあるキー、または一方にしかないキーを見つける]]\n")
("NULLストリームを使う" . "(:ctime 1232161530 :cuser #f :mtime 1232167438 :muser #f)[[$$tag 入出力]]\n\nUNIXで言うところの/dev/nullのようなビットバケツ(ビットシンク)を実現するには、様々な方法があります。\n\n*** 自作する\n\n自作の場合は、読み込みでEOFを返すのに[[$$hs make-concatenated-stream]]や、[[$$hs make-string-input-stream]]に\"\"の引数を与えたもの、出力には[[$$hs make-broadcast-stream]]を利用し作成することが多いようです。\n処理系に依存しませんので最も可搬性が高い方法になります。\n{{{\n(defvar *null-stream* (make-two-way-stream \n                        (make-concatenated-stream) \n                        (make-broadcast-stream))）\n(time\n (loop :repeat 10000 \n       :do\n       (format *null-stream* \"こんにちは!\")\n       (read *null-stream* nil :eof)))\n;-> cpu time (non-gc) 180 msec user, 0 msec system\n;   cpu time (gc)     0 msec user, 0 msec system\n;   cpu time (total)  180 msec user, 0 msec system\n;   real time  187 msec\n;   space allocation:\n;    230,354 cons cells, 271,024 other bytes, 0 static bytes\n;=> NIL\n\n;; 他に\n(make-two-way-stream (make-string-input-stream \"\")\n                     (make-broadcast-stream))\n}}}\n\n*** 処理系備え付けを利用する\n\n処理系によっては、ビットバケツを用意している場合があります。Allegro CLのexcl::*null-stream*等。\n\n下記では、simple-streamなどでNULLストリームを作成しています。\n{{{\n(let ((null-stream \n       #+LispWorks (make-instance 'stream::null-stream)\n       #+Allegro (make-instance 'stream::null-stream)\n       #+sbcl (make-instance 'sb-simple-streams:null-simple-stream)\n       ))\n (time\n  (loop :repeat 10000 \n        :do\n        (format null-stream \"こんにちは!\")\n        (read null-stream nil :eof))))\n}}}\n\n*** UNIXの/dev/nullを利用する\n\nUNIX限定となりますが、下記のようなものを利用する場合もあるようです\n{{{\n(defvar *null-stream* \n        (open #p\"/dev/null\" :direction :output :if-exists :overwrite))\n}}}\n\n*** ライブラリを利用する\n[[CLiki:KMRCL]]にはnull-output-streamがありますが、UNIXの/dev/nullを利用する実装になっています。\n\n** 議論\n")
("繰り返し(do)" . "(:ctime 1227416036 :cuser #f :mtime 1227416036 :muser #f)[[$$tag 制御構造 【募集中】]]\n【募集中】\n")
("#xNNNNNNという16進RGB形式を色ごとに分解する" . "(:ctime 1235192973 :cuser #f :mtime 1235213428 :muser #f)[[$$tag 数値]]\n\nHTMLの色の指定などで利用される、16進のRGB形式(#00ff00 etc)ですが、色ごとに分解して扱うには、[[$$hs ldb]]等でビットフィールドを操作することになるでしょう。\n下記では、#xNNNNNNという数値を、NN. NN. NN. のR、G、Bの数値とみなして分解し、他の形式(1を最高値に設定したsingle-floatの数値のリスト)に変換しています。\n{{{\n(defun |#xNNNNNN-to-(N.N N.N N.N)| (num)\n  (mapcar (lambda (x) (/ x 255s0))\n          (list (ldb (byte 8 16) num)\n                (ldb (byte 8  8) num)\n                (ldb (byte 8  0) num))))\n}}}\n\n使用例\n{{{\n;; LispWorks\n(apply #'color:make-rgb\n       (|#xNNNNNN-to-(N.N N.N N.N)| #xabcdef))\n;=> #(:RGB 0.67058826 0.8039216 0.9372549)\n}}}\n\n** 変更履歴\n{{{\n(defun |#xNNNNNN-to-(N.N N.N N.N)| (num)\n  (mapcar (lambda (x) (/ x 255s0))\n          (list (ldb (byte 8 16) num)\n                (ldb (byte 8  8) num)\n                (ldb (byte 8  0) num))))\n}}}\nで良いような気がします。\n\nその通りでした!\n当初255で割るコードでなかったのを、そのまま引き継いでいました。\n頂いた例に変更しました。 --g000001\n\n")
(" %Tag:コーディングスタイル" . "(1339645592 (\"コーディングスタイル\" :ctime 1227967130 :cuser #f :mtime 1235474378 :muser #f) (\"大文字と小文字の使い分け\" :ctime 1232667473 :cuser #f :mtime 1233408501 :muser #f) (\"コメント\" :ctime 1227971104 :cuser #f :mtime 1227971659 :muser #f) (\"Tutorial on Good Lisp Programming Style\" :ctime 1227969021 :cuser #f :mtime 1227971205 :muser #f))")
("配列を空にする" . "(:ctime 1228630645 :cuser #f :mtime 1228630645 :muser #f)[[$$tag 配列]]\n\n* 配列を空にする\n\n配列の要素を削除して空にする訳ではありませんが、フィルポインタ付きのベクタの場合、フィルポインタを0にセットすることにより空にすることが可能です。FIXME\n{{{\n(let ((a (make-array 3 :adjustable T \n                       :fill-pointer 3\n                       :initial-contents '(1 2 3))))\n  (print a)\n  (setf (fill-pointer a) 0)             ;フィルポインタを0にセット\n  (print a)                             ;#()になった\n  (vector-push 'a a)                    ;'Aをプッシュ\n  (print a))                            ;#(A)になった\n;-> #(1 2 3) \n;-> #() \n;-> #(A)\n;=> #(A)\n}}}\n")
(" %Tag:ソート" . "(1334276173)")
("配列に要素を追加する" . "(:ctime 1228549816 :cuser #f :mtime 1228549869 :muser #f)[[$$tag 配列]]\n\n* 配列に要素を追加する\nフィルポインタ付きでベクタを作成すると後に要素を追加することが可能です。\n追加には、 [[$$hs vector-push]] や、 [[$$hs vector-push-extend]] を使用します。\nリストと違い要素は末尾に追加されて行きます。\n{{{\n(let ((a (make-array 10 :adjustable T :fill-pointer 0)))\n  (vector-push 1 a)\n  (vector-push 2 a)\n  (vector-push 3 a)\n  a)\n;=> #(1 2 3)\n}}}\n先頭に追加する場合\nvector-push-frontという関数を自作 FIXME \n;; 他にもっと良い方法がある気がする…。\n{{{\n(defun vector-push-front (new-el array)\n  (incf (fill-pointer array))\n  (setf (subseq array 1) (subseq array 0)\n        (aref array 0) new-el))\n\n(let ((a (make-array 1 :adjustable T :fill-pointer 0)))\n  (vector-push 1 a)\n  (vector-push 2 a)\n  (vector-push 3 a)\n  (vector-push-front 0 a)\n  a)\n;=> #(0 1 2 3)\n}}}\n")
("配列の各要素に対して関数を適用する" . "(:ctime 1228103803 :cuser #f :mtime 1228111982 :muser #f)[[$$tag 配列]]\n\n* 配列の各要素に対して関数を適用する\n\n[[$$hs map]]はシークエンス全般に使用できます。第1引数にnilを指定する場合返り値はnilとなり主に副作用目的で使用できます。\n{{{\n(let ((v (vector 1 2 3 2 1 2 3 2 1)))\n  (map nil #'print v))\n;-> 1 \n;   2 \n;   3 \n;   2 \n;   1 \n;   2 \n;   3 \n;   2 \n;   1 \n;=> nil\n}}}\n")
("HTML を処理する" . "(:ctime 1231232078 :cuser #f :mtime 1231232289 :muser #f)[[$$tag インターネットサービス html]]\n\n* HTML を処理する\n\nHTML から必要な情報を抜き出すためのライブラリは様々ありますが、下記では、[[CLiki:closure-html]]を使用しています。\n\n# drakma:http-requestでWilikiのページ一覧を取得し\n# <li>の項目の数を数える\n\n{{{\n(defun count-pages (url)\n  (let* ((page (drakma:http-request url))\n         (doc (chtml:parse page (cxml-stp:make-builder)))\n         (ans 0))\n    (stp:do-recursively (a doc)\n      (when (and (typep a 'stp:element)\n                 (equal (stp:local-name a) \"li\"))\n        (incf ans)))\n    ans))\n\n;; 試してみる\n(mapcar #'count-pages\n        '(\"http://practical-scheme.net/wiliki/wiliki.cgi?c=a\"\n          \"http://tips.lisp-users.org/common-lisp/index.cgi?c=a\"\n          \"http://tips.lisp-users.org/scheme/index.cgi?c=a\"))\n;=>(942 202 114)\n}}}\n# drakma:http-requestでWilikiのページ一覧を取得し\n# <li>の項目の中の文字列を取得する\n\n{{{\n(defun all-items (url)\n  (let* ((page (drakma:http-request url))\n         (doc (chtml:parse page (cxml-stp:make-builder)))\n         (ans () ))\n    (stp:do-recursively (a doc)\n      (when (and (typep a 'stp:element)\n                 (equal (stp:local-name a) \"li\"))\n        (push (stp:string-value a) ans)))\n    ans))\n\n;; 逆引きSchemeに存在して 逆引きCLに存在しない項目をリストにする\n(let ((p1 (all-items \"http://tips.lisp-users.org/common-lisp/index.cgi?c=a\"))\n      (p2 (all-items \"http://tips.lisp-users.org/scheme/index.cgi?c=a\")))\n  (set-difference p2 p1 :test #'string=))\n;=> (\"CGI を作る\" \"CPUのエンディアンを調べる\" ...)\n}}}\n")
("計算結果を分数から小数にしたい" . "(:ctime 1227349345 :cuser #f :mtime 1227371838 :muser #f)[[$$tag 数値]]\n* 計算結果を分数から小数にしたい\n分数の状態は、計算結果が ratio となっているので float 関数で変換します。\n{{{\n(float (/ 2 3)) ;=> 0.6666667\n}}}\ndouble-floatにしたい場合は二番目の引数に適当に double-float を指定します。\n{{{\n(float (/ 2 3) 1.0d0)                   ;=> 0.6666666666666666d0\n}}}\n変換するだけならば、coerce を使ったり適当に演算したりという方法もあります。\n{{{\n(coerce 2/3 'double-float)              ;=> 0.6666666666666666d0\n(* 2/3 1.0d0)                           ;=> 0.6666666666666666d0\n(+ 2/3 0.0d0)                           ;=> 0.6666666666666666d0\n}}}\n")
("パッケージを作りたい" . "(:ctime 1227800307 :cuser #f :mtime 1227800464 :muser #f)[[$$tag パッケージ]]\n* パッケージを作りたい\n一番オーソドックスな方法としては、defpackageを利用してパッケージを作ります。\n\nfooというパッケージを作る場合\n{{{\n(defpackage :foo (:use :cl))\n}}}\nこれは、fooという名前のパッケージを作り、cl(common-lisp)パッケージのシンボルをuseしています。\n通常clパッケージは常にuseされます。\nclパッケージのシンボルはuseしないことも可能ですが、その場合、clパッケージのシンボルはすべてプレフィクス付きで記述する必要があります。\n\nまた、defpackageでのパッケージ名では、fooと書かれたり、:foo、#:foo、\"FOO\"と様々ありますが、パッケージ名は、[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_designator string designator]であること、と規定されていますので、どれも同じ意味を持ちます。\n\ndefpackageはマクロで上記の内容は、\n{{{\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (make-package :foo)      ; fooパッケージを作成\n  (use-package :cl :foo))  ; clパッケージをfooでuseする\n}}}\nに近いものになります。\n")
(" %Tag:fare-utils" . "(1338299632 (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f))")
("スーパークラスのメソッドを呼び出す" . "(:ctime 1230216117 :cuser #f :mtime 1230216117 :muser #f)[[$$hs オブジェクトシステム(CLOS)]]\n\n* スーパークラスのメソッドを呼び出す\n\nスーパークラスのメソッドを呼び出すには、メソッド定義の中で [[$$hs call-next-method]] を使用します。\n標準のメソッド結合(メソッドコンビネーション)では、プライマリメソッドとaroundメソッドの中で [[$$hs call-next-method]] が利用できます。\nまた、aroundメソッドを利用した場合 [[$$hs call-next-method]] を呼びださないとプライマリメソッドが呼びだされません。\n{{{\n(defclass foo () ())\n(defclass bar (foo) ())\n\n(defgeneric foo (self))\n(defmethod foo ((self foo))\n  \"foo!!\")\n(defmethod foo ((self bar))\n  (call-next-method))\n(defmethod foo :around ((self bar))\n  (format nil \"<bar>~A</bar>\" (call-next-method)))\n\n;; 試してみる\n(foo (make-instance 'bar))\n;=> \"<bar>foo!!</bar>\"\n}}}\n\n標準のメソッド結合以外では、aroundメソッドの中から [[$$hs call-next-method]] が使用できます。\nそれ以外から呼び出すとエラーになります。\n{{{\n(defclass foo () ())\n(defclass bar (foo) ())\n\n(defgeneric foo-list (self)\n  (:method-combination list))\n(defmethod foo-list list ((self foo))\n  \"foo!!\")\n(defmethod foo-list :around ((self foo))\n  (cons \"foo:around!!\" (call-next-method)))\n(defmethod foo-list list ((self bar))\n  \"bar!!\")\n(defmethod foo-list :around ((self bar))\n  (cons \"bar:around!!\" (call-next-method)))\n\n;; 試してみる\n(foo-list (make-instance 'bar))\n;=> (\"bar:around!!\" \"foo:around!!\" \"bar!!\" \"foo!!\")\n}}}\n")
(" %Tag:マクロ" . "(1339158978 (\"マクロ\" :ctime 1229194985 :cuser #f :mtime 1235474188 :muser #f) (\"一時的にリードテーブルを変更して読み込む\" :ctime 1229846380 :cuser #f :mtime 1229846380 :muser #f) (\"リードテーブルを標準の状態に復元する方法\" :ctime 1229195021 :cuser #f :mtime 1229195129 :muser #f) (\"確実に後処理を行なう\" :ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f))")
(" %Tag:オブジェクトシステム(CLOS)" . "(1338426607 (\"サブクラス関係かどうか判定する\" :ctime 1233062751 :cuser #f :mtime 1233062836 :muser #f) (\"インスタンス変数・クラス変数を定義する\" :ctime 1230290536 :cuser #f :mtime 1230290689 :muser #f) (\"メソッドの可視性を定義する\" :ctime 1230214962 :cuser #f :mtime 1230214962 :muser #f) (\"匿名クラスをつくりたい\" :ctime 1230011124 :cuser #f :mtime 1230029900 :muser #f) (\"オブジェクトの初期化を行う\" :ctime 1229748239 :cuser #f :mtime 1229748296 :muser #f) (\"メソッドを定義するには\" :ctime 1229673282 :cuser #f :mtime 1229673589 :muser #f) (\"クラスを定義する\" :ctime 1229668892 :cuser #f :mtime 1229668892 :muser #f) (\"定義されていないスーパクラスメソッドの呼び出しを防ぎたい\" :ctime 1228017976 :cuser #f :mtime 1228017977 :muser #f) (\"同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい\" :ctime 1228012693 :cuser #f :mtime 1228012694 :muser #f) (\"インスタンス初期化時に複数のスロットを同じ値で埋めたい\" :ctime 1228011914 :cuser #f :mtime 1228011915 :muser #f) (\"インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい\" :ctime 1227349451 :cuser #f :mtime 1227349532 :muser #f))")
("条件判断(cond マクロ)" . "(:ctime 1228888426 :cuser #f :mtime 1228888426 :muser #f)[[$$tag 制御構造 【募集中】]]\n* 条件判断(cond :マクロ)\n【募集中】\n")
("リストの要素数を取得する" . "(:ctime 1227517615 :cuser #f :mtime 1235480699 :muser #f)[[$$tag リスト]]\n\nリストの長さは count 関数で調べることができます。\n{{{\n(count '(1 2 3 4)) ;=> 4\n}}}\n無限リストや遅延リストでは停止しないので注意が必要です。\n\n;; }}}\n;; 同様のアイディアとして、Paul Graham著の[[On Lisp]]にsingleという例があります。\n;; 要素が1つならば真を返しますが、長さではなく、1つ目の要素の後が終端(nil)かどうかを判定しています。\n;; {{{\n;; (defun single (lst)\n;;   (and (consp lst) (not (cdr lst))))\n;; }}}\n\n")
("同一のインターンされないシンボルを複数個所で使う" . "(:ctime 1233607862 :cuser #f :mtime 1233794032 :muser #f)[[$$tag シンボル]]\n\nCLでは、インターンされないシンボルを記述することができ、#:fooのように記述します。\n#:はリーダマクロで、リーダは#:に遭遇する度にインターンされないシンボルを新しく生成しますので、字面上同じにみえても同一のシンボルではありません\n{{{\n(eq '#:foo '#:foo)\n;=> nil\n}}}\nなんらかの事情でインターンされないシンボルを複数箇所で利用したい場合は、リーダーマクロのラベル記法を用いることになります。\n{{{\n(eq #1='#:foo #1#)\n;=> T\n}}}\nラベルは複数利用することが可能です。\n{{{\n(let ((#1=#:foo 1)\n      (#2=#:bar 2)\n      #3=#:baz)\n  (list #1# #2# #3#))\n;=> (1 2 NIL)\n}}}\nまた、このラベルはリードマクロであり、変数のスコープとは有効範囲が異なります。競合するとエラーになります。\n{{{\n(let ((#1=#:foo 1))\n  (let ((#1=#:foo 2))\n    #1#))\n;>>> エラー\n}}}\n{{{\n(let ((#1=#:foo 1))\n  (eval \n   (read-from-string \n    \"(let ((#1=#:foo 42))\n      #1#)\")))\n;=> 42\n}}}\nまた、インターンされないシンボルについては、インターンされないこと以外は通常のシンボルと同様です([[$$hs symbol-package]]はNILを返します)\n{{{\n(progn\n  (defconstant #1=#:constant 42)\n  \n  (let ((#1# 44))\n    #1#))\n;>>> エラー\n\n(progn\n  (defvar #1=#:special)\n  \n  (let ((#1# 100))\n    (symbol-value '#1#)))\n;=> 100\n}}}\n** 議論\n")
("メソッドの可視性を定義する" . "(:ctime 1230214962 :cuser #f :mtime 1230214962 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* メソッドの可視性を定義する\n\nCLOSの場合、Rubyのpublic、private、protectedのように呼び出し制限機構はありません。\n\n情報の隠蔽については、専らパッケージでエクスポートするかどうかで制御することが一般的でしょう。\n")
("プログラムの出力を収集する" . "(:ctime 1230407977 :cuser #f :mtime 1230408268 :muser #f)[[$$tag 入出力 ライブラリ kmrcl cl-ppcre ]]\n\n* プログラムの出力を収集する\n\n外部のプログラムを呼ぶ方法については処理系依存になりますが、大抵の処理系は呼び出す機能を備えています。\n下記の例では、[[CLiki:KMRCL]] の command-outputを利用しています。\n\n出力を一つの文字列として収集\n{{{\n(let ((output (kmrcl:command-output \"ls /bin/z*\")))\n  output)\n;=> \"/bin/zcat\n/bin/zcmp\n/bin/zdiff\n/bin/zegrep\n/bin/zfgrep\n/bin/zforce\n/bin/zgrep\n/bin/zless\n/bin/zmore\n/bin/znew\n/bin/zsh\n/bin/zsh4\n\"\n}}}\n\n出力を行ごとに分けたリストにする\n[[CLiki:cl-ppcre]] を利用\n{{{\n(let ((output (ppcre:split \"\\\\n\" \n                (kmrcl:command-output \"ls /bin/z*\"))))\n  output)\n;=> (\"/bin/zcat\" \"/bin/zcmp\" \"/bin/zdiff\" \"/bin/zegrep\" \n     \"/bin/zfgrep\" \"/bin/zforce\" \"/bin/zgrep\" \"/bin/zless\"\n     \"/bin/zmore\" \"/bin/znew\" \"/bin/zsh\" \"/bin/zsh4\")\n}}}\n")
("ローマ数字を扱う" . "(:ctime 1230925747 :cuser #f :mtime 1230925748 :muser #f)[[$$tag 数値]]\n\n* ローマ数字を扱う\nアラビア数字からローマ数字への変換は、[[$$hs format]]関数が使えます。\n[[$$hs format]]関数は通常の書式と古い書式をオプションで切り換えることが可能です。\n\nアラビア数字→ローマ数字(文字列)\n{{{\n(mapcar (lambda (x) (format nil \"~@R\" x))\n        '(1 2 3 4 500 999))\n;=> (\"I\" \"II\" \"III\" \"IV\" \"D\" \"CMXCIX\")\n\n;; 古い書式\n(mapcar (lambda (x) (format nil \"~@:R\" x))\n        '(1 2 3 4 500 999))\n;=> (\"I\" \"II\" \"III\" \"IIII\" \"D\" \"DCCCCLXXXXVIIII\")\n}}}\nローマ数字からアラビア数字へ変換するための関数はANSI CLには含まれていませんので自作するかライブラリを利用することになります。\n\nローマ数字(文字列)→アラビア数字\n{{{\n;; 素朴な実装 FIXME\n(defun roman-to-arabic (str)\n  (let ((nums (nreverse (map 'list #'*roman-to-arabic str))))\n    (reduce #'+ (mapcar (lambda (x y) (if (> x y) (- y) y))\n                        (cons 0 nums)\n                        nums))))\n\n(defun *roman-to-arabic (char)\n  (case (intern (string-upcase char) :keyword)\n    (:I 1)\n    (:V 5)\n    (:X 10)\n    (:L 50)\n    (:C 100)\n    (:D 500)\n    (:M 1000)))\n\n;; 動作\n(mapcar #'roman-to-arabic\n        '(\"I\" \"II\" \"III\" \"IV\" \"D\" \"CMXCIX\"))\n;=> (1 2 3 4 500 999)\n\n;; 古い書式\n(mapcar #'roman-to-arabic\n        '(\"I\" \"II\" \"III\" \"IIII\" \"D\" \"DCCCCLXXXXVIIII\"))\n;=> (1 2 3 4 500 999)\n}}}\n\n\n\n")
("匿名クラスをつくりたい" . "(:ctime 1230011124 :cuser #f :mtime 1230029900 :muser #f)[[$$tag オブジェクトシステム(CLOS) MOP]]\n\n* 匿名クラスをつくりたい\n\n匿名クラスは名前がNILのクラスとなり、[[$$hs standard-class]]のインスタンスとして作成できるでしょう。\n\n{{{\n(defclass foo () \n  ((x :initarg :x :accessor foo-x)))\n\n;; fooを継承した匿名クラス FIXME\n(let ((anon (make-instance 'standard-class\n                           :direct-superclasses \n                           (list (find-class 'foo))\n                           :direct-slots \n                           ;; スロット(Y)を追加\n                           '((:name y)))))\n  (let ((inst (make-instance anon :x 42)))\n    (with-slots (y) inst\n      (setf y 100)\n      (list (foo-x inst) y))))\n;=> (42 100)\n}}}\n\n*** 参考\n- [http://www.lisp.org/mop/concepts.html#metaobject-initialization-protocols Metaobject Initialization Protocols]\n")
("cljスクリプトを用意する" . "(:ctime 1271499721 :cuser #f :mtime 1317762613 :muser #f)- http://rd.clojure-users.org/entry/view/70001\n")
("逆引きClojure書式" . "(:ctime 1235473614 :cuser #f :mtime 1235473614 :muser #f)書式の指針を以下に示します。\n絶対に従わなければならないというものではありません。\n多少間違っていても、他の人が直してくれるので大丈夫です。\n\n* 文体\nですます調で書きましょう。文章の終わりを気をつければ十分です。\n* 戻り値の書き方\n次の行に「;=> 」に続けて書きます。\nもしくは一覧性を考慮しS式と同一行に書きます。~%\n例)\n{{{\n(+ 1 1)\n;=> 2\n\n(+ 1 1)  ;=> 2\n}}}\n* 多値の書き方\n一つ目の戻り値を次の行に「;=> 」に続けて書きます。\n以降の戻り値は一つ目の戻り値と桁を揃えて書きます。~%\n例)\n{{{\n(values 1 2)\n;=> 1\n;   2\n}}}\n* 戻り値無しの書き方\n「;=> 」に続けて斜体で「''No value''」と書きます。~%\n例)\n{{{\n(values)\n;=> No value\n}}}\n* 標準出力の書き方\n「;-> 」に続けて書きます。\n複数行の場合は一行目に桁を揃えます。\n戻り値よりも先に書きます。~%\n例)\n{{{\n(format t \"~@{~D~%~}\" 1 2 3)\n;-> 1\n;   2\n;   3\n;=> NIL\n}}}\n")
(" %Tag:arnesi" . "(1340146173 (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f))")
("逆引きCommon Lisp" . "(:ctime 1228398922 :cuser #f :mtime 1228398922 :muser #f)")
("goto文" . "(:ctime 1229522369 :cuser #f :mtime 1229522369 :muser #f)[[$$tag 制御構造]]\n* goto文\n\n手続き型言語でいうところのgoto文も使えます。\nLispらしくないとか構造化言語には不要であるとかいろいろあるでしょうが、用意はされているので使うかどうかはあなた次第です。\n\n制御を任意の場所に移すには、 tagbody と go を使います。\n{{{\n(defun foo ()\n  (tagbody\n   label1\n     (print 1)\n     (go label3)\n   label2\n     (print 2)\n     (return-from foo 2)\n   label3\n     (print 3)\n     (go label2)))\n}}}\n")
("何日後、何日前/何ヶ月後、何ヶ月前の日付を求める" . "(:ctime 1227414763 :cuser #f :mtime 1227414763 :muser #f)[[$$tag 日付と時刻]]\n* 何日後、何日前/何ヶ月後、何ヶ月前の日付を求める\nUniversal Timeは秒数を表す数値なので、加減算は自由にできる。\n{{{\n;; 2000/1/1の100日後を求める\n(+ (encode-universal-time 0 0 0 1 1 2000)\n   (* 100 24 60 60))\n;=> 3164281200\n\n(metatilities:date-string-brief 3164281200)\n\"4-10-2000\"\n}}}\n")
("数値" . "(:ctime 1227412843 :cuser #f :mtime 1235474062 :muser #f)[[$$tag 数値]]\n\n;; - [[計算結果を分数から小数にしたい]]\n;; - [[平方根を求める]]\n;; - [[乱数を生成する]]\n;; - [[2進数・8進数・16進数で数値を扱うには]]\n;; - [[数値を2進数・8進数・16進数表現の文字列に変換するには]]\n;; - [[除算の商と余りを求める]]\n;; - [[数値を文字列に変換する]]\n;; - [[四捨五入する]]\n;; - [[数値を2進数・8進数・16進数表現の文字列に変換するには]]\n;; - [[任意のビット位置の値を参照する]]\n;; - [[絶対値を求める]]\n;; - [[小数点を切り上げ・切り捨て]]\n;; - [[三角関数を計算する]]\n;; - [[対数を計算する]]\n;; - [[整数と浮動小数点を相互変換する（精度の変換）]]\n;; - [[ローマ数字を扱う]]\n;; - [[数値に応じて複数形と単数形を切り換える]]\n;; - [[数値を位取り用のカンマで区切る]]\n;; - [[#xNNNNNNという16進RGB形式を色ごとに分解する]]\n")
("繰り返し(loop)" . "(:ctime 1227416023 :cuser #f :mtime 1229556523 :muser #f)[[$$tag 制御構造 【募集中】]]\n* 繰り返し(loop)\n\n*** 無限ループ\nloopキーワードをなにも指定しなければ無限ループです。\n{{{\n(loop (print \"hello\")\n      (print (random 100)))\n;-> \"hello\" \n    49 \n    \"hello\" \n    37\n    ... \n}}}\n\n*** シーケンス上でのループ\nforキーワードでループ変数を宣言できます。\n続けて in でリスト上を across でベクタ上を渡り歩きます。\nハッシュテーブルには being hash-key of または being hash-value of を使います。\n{{{\n;; 奇数の要素のみ取り出して、その二乗した値をリストにして返します。\n(loop for i in '(1 2 3 4 5) if (oddp i) collect (* i i))\n;=> (1 9 25)\n\n;; 文字コードが奇数の文字のみ取り出してリストにして返します。\n(loop for i across \"hello\" if (oddp (char-code i)) collect i)\n;=> (#\\e #\\o)\n\n;; ハッシュテーブルを渡り歩きます。順序は定義されていません。\n(loop for i being the hash-keys of (make-hash-table)\n      do (print i))\n;; キーだけでなく値も参照したい場合は using で指定します。\n(loop for i being the hash-keys of (make-hash-table)\n      using (hash-value j)\n      do (print (cons i j)))\n}}}\n\n複数のforを指定できますが、入れ子になるのではなく並列して処理されます。\n最初に終端にきたところでループは終わります。\n{{{\n(loop for i in '(1 2 3)\n      for j in '(4 5)\n      do (print (cons i j)))\n;-> (1 . 4) \n    (2 . 5)\n;=> NIL\n}}}\n\n*** 補助変数の導入\nwithキーワードでループ内変数を宣言できます。\n初期値を指定しない場合はnilになります。\nforと違い値は勝手に更新されません。\n{{{\n(loop with x = 1\n      with y\n      repeat 3\n      do (setf y x)\n         (print y))\n}}}\n\n*** ループ変数の型指定\nof-type キーワードでループ変数の型を指定できます。\nコンパイラが優秀であれば効率の良いコード生成の助けになるでしょう。\n{{{\n;; i の型を fixnum と宣言します。\n(loop for i of-type fixnum from 0 to 10 do (print i))\n}}}\n")
("ハッシュの全エントリに対して処理を実行する" . "(:ctime 1227413710 :cuser #f :mtime 1229517972 :muser #f)[[$$tag ハッシュ]]\n* ハッシュの全エントリに対して処理を実行する\n専用の構文maphashがあります。他loop等でも処理が可能です。\nまた、このような処理の構文を自作したい場合には、with-hash-table-iteratorを利用します。\n{{{\n(let ((ht (make-hash-table :test #'equal))\n      (default 100))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (maphash (lambda (key val)\n             (format t \"key => ~A, val => ~A~%\" key val))\n           ht))\n\n;-> key => apple, val => 150\n    key => banana, val => 300\n    key => lemon, val => 300\n;=> nil\n}}}\n\n{{{\n;; ht は上の例のハッシュテーブルと同じもの。\n(loop for key being the hash-keys in ht\n      using (hash-value val)\n      do (format t \"key => ~A, val => ~A~%\" key val))\n}}}\n")
("配列の要素数を取得する" . "(:ctime 1228547522 :cuser #f :mtime 1228547523 :muser #f)[[$$tag 配列]]\n* 配列の要素数を取得する\n\n[[$$hs length]] はシーケンス全体に適用できますのでベクタにも使用できます。\n{{{\n(length #(foo bar baz))\n;=> 3\n}}}\n")
("オブジェクトシステム(CLOS)" . "(:ctime 1227412906 :cuser #f :mtime 1233062412 :muser #f)- [[CLOSの読みはシーロスとクロスどちらが正しいか]]\n- [[クラスを定義する]]\n- [[メソッドを定義するには]]\n- [[オブジェクトの初期化を行う]]\n- [[インスタンス変数・クラス変数を定義する]]\n- [[インスタンス変数へアクセスするメソッドを簡単に定義する]]\n- [[メソッドの可視性を定義する]]\n- [[スーパークラスのメソッドを呼び出す]]\n- [[インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい]]\n- [[インスタンス生成を記録しておき後で条件を満すものを抽出したい]]\n- [[インスタンス初期化時に複数のスロットを同じ値で埋めたい]]\n- [[同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい]]\n- [[定義されていないスーパクラスメソッドの呼び出しを防ぎたい]]\n- [[匿名クラスをつくりたい]]\n- [[サブクラス関係かどうか判定する]]\n")
(" %Tag:puri" . "(1340260408 (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
("乱数を生成する" . "(:ctime 1227497166 :cuser #f :mtime 1317765367 :muser #f)http://rd.clojure-users.org/entry/view/75002\n")
(" %Tag:ABCL" . "(1338213900 (\"ABCLでDISASSEMBLEする\" :ctime 1230125046 :cuser #f :mtime 1230125046 :muser #f))")
("逆引きClojure" . "(:ctime 1235473365 :cuser #f :mtime 1317766323 :muser #f)* 逆引きClojure\nhttp://rd.clojure-users.org/\nへ記述をマージしました。これまで記述して頂いた方々ありがとうございました。~%\n※なお移行先の作成者の名前が移行した者の名前になってしまっています。オリジナルの記述の作者の方には大変申し訳ありませんが、何卒ご理解の程よろしくお願いします。\n")
(" %Tag:配列" . "(1338213993 (\"配列\" :ctime 1228095119 :cuser #f :mtime 1235474083 :muser #f) (\"配列をリストに変換する\" :ctime 1234352506 :cuser #f :mtime 1234352916 :muser #f) (\"多次元の配列を1つのインデックスで扱う\" :ctime 1233973763 :cuser #f :mtime 1234161455 :muser #f) (\"指定した位置の要素を取り除く\" :ctime 1229191528 :cuser #f :mtime 1229256880 :muser #f) (\"プログラムで配列を定義する\" :ctime 1229189109 :cuser #f :mtime 1229232047 :muser #f) (\"配列の配列を検索する\" :ctime 1228981495 :cuser #f :mtime 1228981573 :muser #f) (\"配列から指定条件を満たす要素を取り除く\" :ctime 1228980663 :cuser #f :mtime 1228980664 :muser #f) (\"配列中の要素を探す\" :ctime 1228889710 :cuser #f :mtime 1228889710 :muser #f) (\"配列から重複した要素を取り除く\" :ctime 1228889087 :cuser #f :mtime 1228889113 :muser #f) (\"条件式を指定したソート\" :ctime 1228809412 :cuser #f :mtime 1228809413 :muser #f) (\"配列の要素をランダムに抽出する\" :ctime 1228749208 :cuser #f :mtime 1228749208 :muser #f) (\"複数の要素を変更する\" :ctime 1228748252 :cuser #f :mtime 1228748509 :muser #f) (\"配列を空にする\" :ctime 1228630645 :cuser #f :mtime 1228630645 :muser #f) (\"部分配列を取りだす\" :ctime 1228629635 :cuser #f :mtime 1228629814 :muser #f) (\"配列の先頭または末尾から要素を取りだす\" :ctime 1228558271 :cuser #f :mtime 1228558271 :muser #f) (\"配列に要素を追加する\" :ctime 1228549816 :cuser #f :mtime 1228549869 :muser #f) (\"配列の要素数を取得する\" :ctime 1228547522 :cuser #f :mtime 1228547523 :muser #f) (\"配列を逆順にする\" :ctime 1228464721 :cuser #f :mtime 1228464722 :muser #f) (\"配列同士の和・差・積を取る\" :ctime 1228453798 :cuser #f :mtime 1228453798 :muser #f) (\"配列同士を結合する\" :ctime 1228193096 :cuser #f :mtime 1228193097 :muser #f) (\"配列を任意の値で埋める\" :ctime 1228105446 :cuser #f :mtime 1228112194 :muser #f) (\"配列をソートする\" :ctime 1228095583 :cuser #f :mtime 1228112150 :muser #f) (\"配列の各要素に関数を適用し配列を作成する\" :ctime 1228101170 :cuser #f :mtime 1228112053 :muser #f) (\"配列の各要素に対して関数を適用する\" :ctime 1228103803 :cuser #f :mtime 1228111982 :muser #f) (\"一致する要素を全て取り除く\" :ctime 1228100675 :cuser #f :mtime 1228100675 :muser #f) (\"配列要素をカンマ区切りで出力する\" :ctime 1228099965 :cuser #f :mtime 1228099995 :muser #f))")
("ファイルに書き込む" . "(:ctime 1227946735 :cuser #f :mtime 1227946736 :muser #f)[[$$tag 入出力]]\n* ファイルに書き込む\nwith-open-file マクロで :direction :output を指定してファイルをオープンします。既にあるファイルを上書きする場合は :if-exists :supersede を指定します。ファイルをオープンしたら write-line や format でファイルに出力します。\n{{{\n(with-open-file (out \"/tmp/a.txt\" :direction :output :if-exists :supersede)\n  (write-line \"Hello\" out)\n  (format out \"~:d\" 1000))\n}}}\n")
(" %Tag:Alexandria" . "(1338295749 (\"ハッシュをシーケンス(alist、plist、その他)に変換する\" :ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f))")
("数値に応じて複数形と単数形を切り換える" . "(:ctime 1232048921 :cuser #f :mtime 1232048967 :muser #f)[[$$tag 数値]]\n\n* 数値に応じて複数形と単数形を切り換える\n\n多機能な[[$$hs format]]の機能の一つとして数値に応じて複数形と単数形を切り換える機能がありますので、これが利用できるでしょう。\n\n-[http://www.lispworks.com/documentation/HyperSpec/Body/22_chc.htm Tilde P: Plural]\n{{{\n(dotimes (i 5)\n  (format t \"~D: tom~P and jerr~@P~%\" i i i))\n;-> 0: toms and jerries\n;   1: tom and jerry\n;   2: toms and jerries\n;   3: toms and jerries\n;   4: toms and jerries\n;=> NIL\n}}}\n")
(" %Tag:シーケンス" . "(1338213282 (\"文字列\" :ctime 1227101219 :cuser #f :mtime 1235474028 :muser #f) (\"文字列の先頭・末尾の空白を削除する\" :ctime 1227347967 :cuser #f :mtime 1227369742 :muser #f) (\"文字列を一行ずつ処理する\" :ctime 1227347907 :cuser #f :mtime 1227347907 :muser #f))")
(" %Tag:mudballsを使う【募集中】" . "(1231676044)")
("文字列" . "(:ctime 1227101219 :cuser #f :mtime 1235474028 :muser #f);; -*- outline -*-\n[[$$tag 文字列 シーケンス]]\n;; - [[文字列を結合する]]\n;; - [[大文字・小文字に揃える]]\n;; - [[大文字と小文字を入れ替える]]\n;; - [[複数行の文字列を作成する]]\n;; - [[部分文字列を取り出す]]\n;; - [[文字列を一文字ずつ処理する]]\n;; - [[文字列を一行ずつ処理する]]\n;; - [[文字列の先頭・末尾の空白を削除する]]\n;; - [[文字列を数値に変換する]]\n;; - [[文字列の中に「hoge」が含まれている場合、その開始位置を知るには]]\n;; - [[シンボルを文字列として扱いたい]]\n;; - [[文字列中の関数と式を展開する]]\n")
("繰り返しの前処理・後処理" . "(:ctime 1229528833 :cuser #f :mtime 1229528833 :muser #f)[[$$tag 制御構造]]\n* 繰り返しの前処理・後処理 (loop)\n\nloopの開始処理・終了処理を initially finally キーワードを使って書けます。\n{{{\n(loop for i in '(1 2 3)\n      do (print i)\n      initially (print \"begin\")\n      finally (print \"end\"))\n;-> \"begin\"\n    1\n    2\n    3\n    \"end\"\n;=> NIL\n}}}\n\ninitially で指定されたフォームは繰り返しが一度もなくても必ず評価されます。\n\nfinally で指定されたフォームは return キーワードで中断された場合など必ずしも評価されません。=> [[確実に後処理を行なう]]\n")
(" %Tag:%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF" . "(1282110438)")
(" %Tag:例外処理//index.cgi?p=|echo \"Osirys-p0wa\"" . "(1247879158)")
("配列中の要素を探す" . "(:ctime 1228889710 :cuser #f :mtime 1228889710 :muser #f)[[$$tag 配列]]\n\n* 配列中の要素を探す\n\n[[$$hs position]] もしくは、 [[$$hs find]] を利用することにより配列から要素を検索することができます。\n\n[[$$hs position]] は指定された要素が見つかればその位置を、見つからなければnilを返します。\n\n[[$$hs find]] は指定された要素が見つかればその要素を、見つからなければnilを返します。\n\n両者とも :test キーワードに比較用関数を指定することが可能です。\n\n{{{\n(let ((a #(\"apple\" 10 \"orange\" #(\"lemon\" \"vine\")))\n      (test  #'equal))\n  (list\n   (position \"apple\" a :test test)\n   (position 10 a :test test)\n   (position #(\"lemon\" \"vine\") a :test test)\n   (position #(\"fruit\") a :test test)))\n;=> (0 1 NIL NIL)\n}}}\n{{{\n(let ((a #(\"apple\" 10 \"orange\" #(\"lemon\" \"vine\")))\n      (test  #'equalp))                 ;equalpに変更\n  (list\n   (position \"apple\" a :test test)\n   (position 10 a :test test)\n   (position #(\"lemon\" \"vine\") a :test test)\n   (position #(\"fruit\") a :test test)))\n;=> (0 1 3 NIL)\n}}}\n{{{\n(let ((a #(\"apple\" 10 \"orange\" #(\"lemon\" \"vine\")))\n      (test  #'equalp))                \n  (list\n   (find \"apple\" a :test test)\n   (find 10 a :test test)\n   (find #(\"lemon\" \"vine\") a :test test)\n   (find #(\"fruit\") a :test test)))\n;=> (\"apple\" 10 #(\"lemon\" \"vine\") NIL)\n}}}\n")
(" %Tag:Java" . "(1335408894)")
("日付と時刻" . "(:ctime 1227154105 :cuser #f :mtime 1235474117 :muser #f);; - [[Universal Time]]\n;; - [[現在の時刻(Universal Time)を取得する]]\n;; - [[時刻の表現からUniversal Timeを作成する]]\n;; - [[Universal Timeを文字列に変換する]]\n;; - [[時刻に任意の時間を加減する]]\n;; - [[2つの時刻の差を求める]]\n;; - [[時刻中の曜日を日本語に変換する]]\n;; - [[現在の日付を求める]]\n;; - [[指定の日付が存在するかどうか調べる]]\n;; - [[何日後、何日前/何ヶ月後、何ヶ月前の日付を求める]]\n;; - [[うるう年かどうか判定する]]\n;; - [[文字列の日付をUniversal Timeに変換する]]\n;; - [[月の最後の日を調べる]]\n;; - [[日付が何曜日、何日、年初から何日め、年初から何週めになるかを求める]]\n")
(" %Tag:portable-threads" . "(1338292900 (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f) (\"操作をタイムアウトにする\" :ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f))")
(" %Tag:XML" . "(1335569472)")
("パッケージ" . "(:ctime 1227799412 :cuser #f :mtime 1235474199 :muser #f);; - [[パッケージとは]]\n;; - [[パッケージを作りたい]]\n")
("インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい" . "(:ctime 1227349451 :cuser #f :mtime 1227349532 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい\ninitialize-instanceにafterメソッドを追加するのが一般的。\n{{{\n;; クラス\n(defclass *time ()\n  ((universal-time :initform () :initarg :universal-time :accessor universal-time)\n   (sec :initform () :initarg :sec :accessor sec)\n   (minute :initform () :initarg :minute :accessor minute)\n   (hour :initform () :initarg :hour :accessor hour)\n   (date :initform () :initarg :date :accessor date)\n   (month :initform () :initarg :month :accessor month)\n   (year :initform () :initarg :year :accessor year)\n   (day :initform () :initarg :day :accessor day)\n   (daylight-p :initform () :initarg :daylight-p :accessor daylight-p)\n   (zone :initform () :initarg :zone :accessor zone)))\n}}}\n下記の例では、初期化時にuniversal-timeスロットの値が与えられれば、他のスロットの値を割り出して初期化する。\n{{{\n;; 初期化\n(defmethod initialize-instance :after ((*time *time) &key)\n  (with-accessors ((universal-time universal-time)\n                   (sec sec)\n                   (minute minute)\n                   (hour hour)\n                   (date date)\n                   (month month)\n                   (year year)\n                   (day day)\n                   (daylight-p daylight-p)\n                   (zone zone)) *time\n    (when universal-time\n      (setf (values sec minute hour date month year day daylight-p zone)\n            (decode-universal-time (or universal-time (get-universal-time)))))))\n\n(let ((time (make-instance '*time :universal-time 0)))\n  (date time))\n;=> 1\n}}}\n;; 書いてみたけど、あまり良い例でない気がする --g1\n\n")
("インターネットサービス" . "(:ctime 1227177157 :cuser #f :mtime 1235474247 :muser #f)[[$$tag インターネットサービス]]\n\n;; * インターネットサービス\n;; \n;; - [[簡単なDNSルックアップ]]\n")
(" %Tag:osicat" . "(1280761390)")
(" %Tag:ライブラリ" . "(1338299026 (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f) (\"操作をタイムアウトにする\" :ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f) (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f) (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f) (\"別のプログラムを起動する\" :ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f) (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1230408268 :muser #f) (\"ストリームを扱うように出力先としてシーケンスを指定したい\" :ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f) (\"ベクタをバイナリのストリームとして扱いたい\" :ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f) (\"文字列の中に「hoge」が含まれている場合、その開始位置を知るには\" :ctime 1227690765 :cuser #f :mtime 1228304424 :muser #f) (\"新規ページ作成の手順\" :ctime 1227422988 :cuser #f :mtime 1228111845 :muser #f) (\"インスタンス生成を記録しておき後で条件を満すものを抽出したい\" :ctime 1227530644 :cuser #f :mtime 1227531695 :muser #f) (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f) (\"ハッシュをシーケンス(alist、plist、その他)に変換する\" :ctime 1227413735 :cuser #f :mtime 1227424805 :muser #f) (\"複数行の文字列を作成する\" :ctime 1227347816 :cuser #f :mtime 1227424718 :muser #f))")
("文字列を数値に変換する" . "(:ctime 1227348006 :cuser #f :mtime 1317763435 :muser #f)\nhttp://rd.clojure-users.org/entry/view/72002\n")
("SLIME:日本語関係の設定" . "(:ctime 1229489203 :cuser #f :mtime 1229489661 :muser #f)[[$$tag SLIME]]\n\n- [[SLIME:日本語関係の設定:LispWorks]]\n\n")
("複数行の文字列を作成する" . "(:ctime 1227347816 :cuser #f :mtime 1227424718 :muser #f)[[$$tag 文字列 cl-interpol ライブラリ]]\n* 複数行の文字列を作成する\n文字列リテラルには改行を含めることができます。\n{{{\n\"abc\ndef\nghi\"\n}}}\ncl-interpol を使えばエスケープシーケンスが使えるようになります。\n{{{\nCL-USER> (cl-interpol:enable-interpol-syntax)\n; No value\nCL-USER> #?\"abc\\ndef\\nghi\"\n\"abc\ndef\nghi\"\n}}}\n")
("配列の配列を検索する" . "(:ctime 1228981495 :cuser #f :mtime 1228981573 :muser #f)[[$$tag 配列]]\n\n* 配列の配列を検索する\n\nベクタの入れ子による連想リスト(alist)のようなものがあり、これに適用できるベクタ版の [[$$hs assoc]] のようなものは、 [[$$hs find]] や [[$$hs find-if]] で実現できるでしょう。\n{{{\n(let ((a #(#(\"apple\" 100)\n           #(\"vine\" 500)\n           #(\"orange\" 300))))\n  (find \"apple\" a \n        :key (lambda (x) (aref x 0))\n        :test #'equal))\n;=> #(\"apple\" 100)\n}}}\n{{{\n(let ((a #(#(\"apple\" 100)\n           #(\"vine\" 500)\n           #(\"orange\" 300))))\n  (find-if (lambda (x) (equal \"apple\" (aref x 0)))  \n           a))\n;=> #(\"apple\" 100)\n}}}\n")
("ブロックからの脱出" . "(:ctime 1229520442 :cuser #f :mtime 1229549658 :muser #f)[[$$tag 制御構造]]\n* ブロックからの脱出\n\nブロックを定義するとその中から return-from を使って脱出できます。\n{{{\n(block foo\n  (print 1)\n  (return-from foo 2)\n  (print 3))\n}}}\n\nreturn-from には脱出するブロックの名前と戻り値となる値を指定します。\n指定した値がブロック全体の値になります。\n\n暗黙のブロック名 nil から脱出する return もあります。\n{{{\n(block nil\n  (print 1)\n  (return 2)\n  (print 3))\n}}}\n\ndefun による関数定義は関数名を名前とするブロックで自動的につつまれます。\nですから、 return-from で脱出できます。\n{{{\n(defun foo ()\n  (print 1)\n  (return-from foo 2)\n  (print 3))\n}}}\n\nloop は名前 nil のブロックで自動的につつまれます。\nですから、 return で脱出できます。\n{{{\n(loop for i in '(1 2 3 4 5)\n      if (= i 3)\n      do (return i))\n}}}\n\nnamed キーワードでブロックの名前を明示することもできます。\n入れ子の loop から脱出する場合に便利です。\n{{{\n(loop named a\n      for i in '((1) (2 3) (4 5 6 7))\n      do (loop for j in i\n               do (print (cons i j))\n               if (= j 3)\n               do (return-from a)))\n;-> ((1) . 1) \n    ((2 3) . 2) \n    ((2 3) . 3) \n;=> NIL\n}}}\n")
("ハッシュ内にキーが存在するかどうか調べる" . "(:ctime 1227413596 :cuser #f :mtime 1227413596 :muser #f)[[$$tag ハッシュ]]\n* ハッシュ内にキーが存在するかどうか調べる\n検索に失敗すると2値目はnilとなるので、この値でキーが存在するかを判別できます。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (gethash \"banana\" ht))\n;=> nil\n    nil ;(存在しない)\n\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"banana\" ht) 100)\n  (gethash \"banana\" ht))\n;=> 100\n    T ;(存在する)\n}}}\n")
(" %Tag:パッケージ" . "(1337518032 (\"パッケージを作りたい\" :ctime 1227800307 :cuser #f :mtime 1227800464 :muser #f))")
(" %Tag:【募集中】" . "(1338365437 (\"繰り返し(loop)\" :ctime 1227416023 :cuser #f :mtime 1229556523 :muser #f) (\"繰り返しからの脱出\" :ctime 1227416045 :cuser #f :mtime 1229529032 :muser #f) (\"mudballsを使う\" :ctime 1229134338 :cuser #f :mtime 1229510204 :muser #f) (\"ハッシュのキーに任意のオブジェクトを使用する\" :ctime 1229510098 :cuser #f :mtime 1229510099 :muser #f) (\"条件判断(cond マクロ)\" :ctime 1228888426 :cuser #f :mtime 1228888426 :muser #f) (\"繰り返し(do)\" :ctime 1227416036 :cuser #f :mtime 1227416036 :muser #f) (\"条件判断(case)\" :ctime 1227415897 :cuser #f :mtime 1227415897 :muser #f) (\"指定の日付が存在するかどうか調べる\" :ctime 1227414725 :cuser #f :mtime 1227414726 :muser #f) (\"ハッシュの要素をランダムに抽出する\" :ctime 1227413899 :cuser #f :mtime 1227413900 :muser #f) (\"ハッシュを値で降順、値が等しい場合キーで昇順にソートする\" :ctime 1227413847 :cuser #f :mtime 1227413848 :muser #f))")
("月の最後の日を調べる" . "(:ctime 1227414848 :cuser #f :mtime 1227425023 :muser #f)[[$$tag 日付と時刻 metatilities]]\n* 月の最後の日を調べる \n単純な計算によるもの。(Universal Timeをとって月末のUniversal Timeを返却) [[ライブラリ:Metatilities]]を利用\n{{{\n(defun the-last-day-in-the-month (ut)\n  (multiple-value-bind (s m h d mo y) (decode-universal-time ut)\n    (declare (ignore s m d h))\n    (let ((d (or (aref #(31 nil 31 30 31 30 31 31 30 31 30 31) (1- mo))\n                 (if (metatilities:leap-year-p y) 29 28))))\n      (encode-universal-time 0 0 0 d mo y))))\n}}}\n")
("変数とスコープ" . "(:ctime 1228128306 :cuser #f :mtime 1235474136 :muser #f)* 変数とスコープ\n;; \n;; CommonLispでの変数は、大きく分けて3種類あります。\n;; （ここでは、定数も変数に含めて話をします）\n;; \n;; - 定数変数\n;; - スペシャル変数\n;; - レキシカル変数\n;; \n;; ** 定数変数\n;; [[$$hs defconstant]]で定義でき、再代入も再バインドもできません。\n;; \n;; 「本物の」定数（数学的な定数など）に使います。逆に言うと、それ以外の場合にはあまり使う機会は少ないでしょう。慣例により、定数変数名の前後に+を付けることが多いです。\n;; \n;; {{{\n;; (defconstant +pi+ 3.14)\n;; \n;; +pi+\n;; ; => 3.14\n;; \n;; ;;; 再バインドしようとするとエラーになる\n;; (let ((+pi+ 3.1415))\n;;   (+pi+))\n;; ; => ERROR\n;; }}}\n;; \n;; ** スペシャル変数（ダイナミック変数）\n;; スペシャル変数（またはダイナミック変数）は、他の言語でいうところのグローバル変数に相当します（ただし、いくつか特長があります）。スペシャル変数は、慣例により名前の前後に*を付けて表され、[[$$hs setf]]による代入が可能です。\n;; \n;; スペシャル変数を定義するには、[[$$hs defvar]] を使う方法と [[$$hs defparameter]] を使う方法があります。\n;; ２つの違いは、[[$$hs defvar]] は初期値なしでもスペシャル変数を定義でき、初期値を指定した場合は、その変数が未定義だった場合のみ初期値を代入します。一方、[[$$hs defparameter]]は、初期値を必ず指定する必要があり、すでにその変数に値が存在するかどうかにかかわらず初期値を設定します。\n;; ;; 一般には、[[$$hs defparameter]]の方が動作が明快なので、こちらが好まれる傾向が多いようです。\n;; ;; 明快さというより、使いわけになると思います (g1)\n;; \n;; {{{\n;; (defvar *foo* 1)\n;; *foo*\n;; ; => 1\n;; \n;; (defvar *bar*)\n;; *bar*\n;; ; => エラー（ *bar* は unbound ）\n;; \n;; \n;; (defparameter *baz* \"baz\")\n;; *baz*\n;; ; => \"baz\"\n;; }}}\n;; \n;; ;; スペシャル変数は、[[$$hs let]] 形式を用いて「一時的に」再定義することができます。[[$$hs let]] が終了すると、再び以前の値に戻ります（これが、「ダイナミック変数」と呼ばれる理由です）。つまり、「グローバル変数がレキシカルに変化」するように見えます\n;; ;; (g1)\n;; スペシャル変数は、[[$$hs let]] 形式を用いて実行時に再束縛することができます。[[$$hs let]] が終了すると、再び以前の値に戻ります。（実行時に決定されることが、「ダイナミック変数」と呼ばれる理由です）。\n;; 詳細は、HyperSpecの[[$$hs let]]の例を参照して下さい。\n;; {{{\n;; (defparameter *foo* 100)\n;; (defun print-foo ()\n;;   (format t \"~D~%\" *foo*))\n;; \n;; (print-foo)\n;; ;-> 100\n;; \n;; (let ((*foo* 200))\n;;   (print-foo))\n;; ;-> 200\n;; \n;; (print-foo)\n;; ;-> 100\n;; }}}\n;; \n;; ** レキシカル変数\n;; [[$$hs let]] 形式を使って、ローカルに使う変数を定義できます。他の言語でのローカル変数に相当します。変数は内側のスコープで再バインドでき、最も内側の [[$$hs let]] 形式でバインドされた値が使用されます。スコープはレキシカルになります。\n;; \n;; {{{\n;; (let ((a 10))\n;;   (format t \"~D~%\" a)\n;;   (let ((a 20))\n;;     (format t \"~D~%\" a))\n;;   (format t \"~D~%\" a))\n;; ;-> 10\n;;     20\n;;     10\n;; }}}\n;; \n;; ** 手引書\n;; - [[Common Lisp の スコープ と エクステント]]\n;; \n")
("逆アセンブルした結果を確認したい" . "(:ctime 1228810111 :cuser #f :mtime 1228810112 :muser #f)[[$$tag 開発環境 SLIME]]\n\n* 逆アセンブルした結果を確認したい\n定義した関数名のシンボル上で、C-c M-d(slime-disassemble-symbol)すると、一時バッファに逆アセンブルした結果([[$$hs disassemble]]の結果)が表示されます。\n{{{\n(foo 3) ; C-c M-d ...\n\n; disassembly for FOO\n; 0BC44B65:       488D65F0         LEA RSP, [RBP-16]          ; no-arg-parsing entry point\n;       69:       F8               CLC\n;       6A:       488B6DF8         MOV RBP, [RBP-8]\n;       6E:       C20800           RET 8\n;       71:       CC0A             BREAK 10                   ; error trap\n;       73:       02               BYTE #X02\n;       74:       18               BYTE #X18                  ; INVALID-ARG-COUNT-ERROR\n;       75:       4E               BYTE #X4E                  ; RCX\n}}}\n")
(" %Tag:並行処理" . "(1329382620)")
("その他" . "(:ctime 1227970629 :cuser #f :mtime 1235474397 :muser #f);; - [[Short Coding]]\n\n;; - [[ABCLでDISASSEMBLEする]]\n;; - [[プラットフォームに関する情報を得る]]\n;; - [[ソースファイルの拡張子]]\n;; - [[環境変数を取得する]]\n\n\n")
(" %Tag:ハッシュテーブル" . "(1340415821 (\"2つのハッシュの両方にあるキー、または一方にしかないキーを見つける\" :ctime 1231752347 :cuser #f :mtime 1231752347 :muser #f) (\"ハッシュのキーと値を反転する\" :ctime 1231474598 :cuser #f :mtime 1231474872 :muser #f))")
(" %Tag:その他" . "(1338214004 (\"プラットフォームに関する情報を得る\" :ctime 1230403551 :cuser #f :mtime 1230403551 :muser #f) (\"ABCLでDISASSEMBLEする\" :ctime 1230125046 :cuser #f :mtime 1230125046 :muser #f))")
("多値を変数に代入する" . "(:ctime 1229603159 :cuser #f :mtime 1230340071 :muser #f)[[$$tag 制御構造]]\n\n多値（複数の値）を返す関数があります。\n単純に[[$$hs let]]で変数に束縛しただけでは最初の値しか得られません。\n多値のそれぞれを変数に束縛するには[[$$hs multiple-value-bind]]を使います。\n{{{\n(multiple-value-bind (q r)\n    (truncate 11 3)\n  (format t \"~A ~A~%\" q r))\n;-> 3 2\n;=> NIL\n}}}\n\n多値をリストに格納して返してくれる[[$$hs multiple-value-list]]もあります。\n\nsetf と values を使って代入することもできます。\n{{{\n(let (q r)\n  (setf (values q r) (truncate 11 3))\n  (format t \"~A ~A~%\" q r))\n;-> 3 2\n;=> NIL\n}}}\n")
(" %Tag:リスト" . "(1339359875 (\"リストの要素数を取得する\" :ctime 1227517615 :cuser #f :mtime 1235480699 :muser #f) (\"リスト\" :ctime 1227346989 :cuser #f :mtime 1235480493 :muser #f) (\"非真正リストを真正リストに変換する\" :ctime 1231231029 :cuser #f :mtime 1231316965 :muser #f) (\"リストの各要素に手続きを適用する\" :ctime 1229558079 :cuser #f :mtime 1229600569 :muser #f) (\"リストから指定条件を満たす要素を取り除く\" :ctime 1228980905 :cuser #f :mtime 1229557393 :muser #f) (\"リスト同士の和・差・積を取る\" :ctime 1228451910 :cuser #f :mtime 1228451910 :muser #f) (\"リストから要素を探す\" :ctime 1228221887 :cuser #f :mtime 1228221887 :muser #f) (\"リストから要素を取り出す\" :ctime 1227519371 :cuser #f :mtime 1228192411 :muser #f) (\"リストをソートする\" :ctime 1227975489 :cuser #f :mtime 1227975489 :muser #f) (\"リストを結合する\" :ctime 1227520956 :cuser #f :mtime 1227610857 :muser #f) (\"リストから重複した要素を取り除く\" :ctime 1227610615 :cuser #f :mtime 1227610724 :muser #f) (\"連想リストを使う\" :ctime 1227518778 :cuser #f :mtime 1227518941 :muser #f))")
(" %Tag:文字列" . "(1340829128 (\"文字列\" :ctime 1227101219 :cuser #f :mtime 1235474028 :muser #f) (\"文字列中の関数と式を展開する\" :ctime 1232079306 :cuser #f :mtime 1232090805 :muser #f) (\"大文字と小文字を入れ替える\" :ctime 1231317189 :cuser #f :mtime 1231317189 :muser #f) (\"文字列の中に「hoge」が含まれている場合、その開始位置を知るには\" :ctime 1227690765 :cuser #f :mtime 1228304424 :muser #f) (\"シンボルを文字列として扱いたい\" :ctime 1227898595 :cuser #f :mtime 1227899843 :muser #f) (\"複数行の文字列を作成する\" :ctime 1227347816 :cuser #f :mtime 1227424718 :muser #f) (\"文字列の先頭・末尾の空白を削除する\" :ctime 1227347967 :cuser #f :mtime 1227369742 :muser #f) (\"文字列を一行ずつ処理する\" :ctime 1227347907 :cuser #f :mtime 1227347907 :muser #f))")
("時刻に任意の時間を加減する" . "(:ctime 1227414597 :cuser #f :mtime 1227414597 :muser #f)[[$$tag 日付と時刻]]\n* 時刻に任意の時間を加減する\n秒数を表す数値なので、加減算は自由にできる。\n{{{\n;; 現時刻から一時間後\n(decode-universal-time (+ (* 60 60)\n                          (get-universal-time)))\n;=> 46\n    27\n    15\n    22\n    11\n    2008\n    5\n    NIL\n    -9\n}}}\n")
(" %Tag:例外処理" . "(1338870540 (\"確実に後処理を行なう\" :ctime 1228888055 :cuser #f :mtime 1228922530 :muser #f))")
(" %Tag:インターネットサービス" . "(1338213292 (\"インターネットサービス\" :ctime 1227177157 :cuser #f :mtime 1235474247 :muser #f) (\"HTML を処理する\" :ctime 1231232078 :cuser #f :mtime 1231232289 :muser #f))")
("プラットフォームに関する情報を得る" . "(:ctime 1230403551 :cuser #f :mtime 1230403551 :muser #f)[[$$tag その他]]\n* プラットフォームに関する情報を得る\n\n- [[CPUのワードサイズを調べる]]\n")
("編集に関する基本方針" . "(:ctime 1227343206 :cuser #f :mtime 1270598027 :muser #f)[[$$toc]]\n* 編集に関する基本方針\nこのコンテンツはWiLiKiというWikiエンジンで構築されており、以下の基本方針に同意していただける方であれば、どなたでもコンテンツの追加、修正をすることが可能です。\n** 引用先でのクレジット表示不要の確認\n引用先でのクレジット表示が必要な投稿はご遠慮下さい。\n** 著作権を侵害しない\n他者の著作権を侵害する内容を書き込むことはご遠慮ください。\n** 改変・削除される可能性があることに同意してください\n自分が書き込んだ内容が改変、もしくは削除される可能性があることに同意してください。\n")
("環境変数を取得する" . "(:ctime 1232400758 :cuser #f :mtime 1317763959 :muser #f)\nhttp://rd.clojure-users.org/entry/view/70002\n")
("部分配列を取りだす" . "(:ctime 1228629635 :cuser #f :mtime 1228629814 :muser #f)[[$$tag 配列]]\n\n* 部分配列を取りだす\n\n[[$$hs subseq]] 関数により配列の一部分を取りだすことができます。\n{{{\n(let ((a (vector 1 2 3 4 5)))\n  (list \n   (subseq a 1 2)\n   (subseq a 2)))\n;=> #((2) #(3 4 5))\n}}}\nまた、 [[$$hs setf]] と組み合わせることも可能です。\n{{{\n(let ((a (vector 1 2 3 4 5)))\n  (setf (subseq a 2)\n        (nreverse (subseq a 2)))\n  a)\n;=> #(1 2 5 4 3)\n}}}\n")
("Clojureのバージョンを調べる" . "(:ctime 1271265129 :cuser #f :mtime 1317763346 :muser #f)http://rd.clojure-users.org/entry/view/73001\n")
("マクロ展開を確認したい" . "(:ctime 1229603579 :cuser #f :mtime 1229603942 :muser #f)[[$$tag SLIME 開発環境]]\n* マクロ展開を確認したい\n\nslime-macroexpand-1 (C-c C-m) を使います。\n\n展開したいフォームの先頭の括弧にカーソルを置いて、C-c C-mで展開形があたらしいバッファに表示されます。そのバッファで slime-popup-buffer-quit-function (q) を入力すればバッファは閉じます。\n")
("構造体を作成する" . "(:ctime 1229600738 :cuser #f :mtime 1317764649 :muser #f)http://rd.clojure-users.org/entry/view/74002\n")
("構造体のキーに関連付けられた値を取得する" . "(:ctime 1270742608 :cuser #f :mtime 1317764246 :muser #f)\n\n\nhttp://rd.clojure-users.org/entry/view/71002\n")
("マクロ" . "(:ctime 1229194985 :cuser #f :mtime 1235474188 :muser #f)[[$$tag マクロ]]\n\n* マクロ\n\n;; * リーダーマクロ\n;; - [[リードテーブルを標準の状態に復元する方法]]\n;; - [[一時的にリードテーブルを変更して読み込む]]\n\n\n\n")
("|comments:リクエスト::002" . "(:ctime 1277746697 :cuser #f :mtime 1317767597 :muser #f)http://rd.clojure-users.org/entry/view/70005\n")
("リスト" . "(:ctime 1227346989 :cuser #f :mtime 1235480493 :muser #f)[[$$tag リスト]]\n\n- [[リストを作成する]]\n- [[リストの要素数を取得する]]\n;; - [[リストから要素を取り出す]]\n;; - [[リストから要素を探す]]\n;; - [[リストから重複した要素を取り除く]]\n;; - [[リストをソートする]]\n;; - [[リストを逆順にする]]\n;; - [[リストを結合する]]\n;; - [[リストの各要素に手続きを適用する]]\n;; - [[リストの各要素をカンマ区切りで出力する]]\n;; - [[リストから指定条件を満たす要素を取り除く]]\n;; - [[連想リストを使う]]\n;; - [[リスト同士の和・差・積を取る]]\n;; - [[非真正リストを真正リストに変換する]]\n")
("操作をタイムアウトにする" . "(:ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f)[[$$tag スレッド ライブラリ portable-threads]]\n\n* 操作をタイムアウトにする\n\nタイムアウトについてはANSI仕様外ですが、大抵の処理系がwith-timeoutや、類似したものを持っています。\n下記では、[[CLiki:Portable-Threads]]を利用しています。\n{{{\n;; 書式\n(with-timeout (seconds &body timeout-body) &body timed-body)\n}}}\n{{{\n(import 'portable-threads:with-timeout)\n\n;; 3秒でタイムアウト\n(with-timeout (3 (print \"時間切れ!\"))\n  (if (y-or-n-p \"スフィンクスは、なぞなぞに答えられなくて死んだ~%\")\n      (print \"はずれ\")\n      (print \"はずれていない\")))\n\n;-> スフィンクスは、なぞなぞに答えられなくて死んだ\n;   (y or n)\n;  ... 3秒経過\n;   \"時間切れ!\"\n;=> \"時間切れ!\"\n}}}\n\n** 議論\n")
("数値を位取り用のカンマで区切る" . "(:ctime 1232874597 :cuser #f :mtime 1232879591 :muser #f)[[$$tag 数値]]\n\n多機能な[[$$hs format]]には、位取りの間隔と文字を指定して出力する機能があります。\n\n下記のように[http://www.lispworks.com/documentation/HyperSpec/Body/22_cbb.htm ~D]に:を与えます。\n{{{\n(format nil \"~:D\" 10000000)\n;=> \"10,000,000\"\n}}}\n\n{{{\n;; 引数詳細\n~mincol,padchar,commachar,comma-intervalD.\n}}}\n{{{\n;; 4つ置きに:で区切る\n(format nil \"~,,':,4:D\" 1000000000000)\n;=> \"1:0000:0000:0000\"\n}}}\n")
("引数のリストに関数を適用する" . "(:ctime 1230115720 :cuser #f :mtime 1230115720 :muser #f)[[$$tag 関数]]\n\n* 引数のリストに関数を適用する\n\n引数のリストに手続きを適用するには [[$$hs apply]] 手続きを使います。\n\n{{{\n(apply #'+ '(1 2 3 4)) ; => 10\n\n(apply #'list 'a 'b '(c d e)) ; => (A B C D E) \n}}}\n")
("|comments:リクエスト::001" . "(:ctime 1276009489 :cuser #f :mtime 1276009489 :muser #f)* ことり (2010/06/08 08:04:49):\n<<<\nファイルにある数値をベクターかリストにしたいのに、文字列になってしまいます。\nどうすれば良いのですか？\nuser=> (slurp \"dat.txt\")\n\"1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\"\n\n>>>\n")
(" %Tag:kmrcl" . "(1340771364 (\"別のプログラムを起動する\" :ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f) (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1230408268 :muser #f))")
("条件式を指定したソート" . "(:ctime 1228809412 :cuser #f :mtime 1228809413 :muser #f)[[$$tag 配列]]\n\n* 条件式を指定したソート\n\n[[$$hs sort]] は比較の為の関数を取りますので、比較条件を任意に指定することが可能です。\n{{{\n(let ((v (vector \"Hitoshi,045\" \"Sizuo,046\" \"Yoshi,0138\")))\n  (flet ((getn (x) (1+ (position #\\, x))))\n    (sort v (lambda (x y)\n              (string< x y :start1 (getn x) :start2 (getn y))))))\n;=> #(\"Yoshi,0138\" \"Hitoshi,045\" \"Sizuo,046\")\n}}}\n")
("リストをソートする" . "(:ctime 1227975489 :cuser #f :mtime 1227975489 :muser #f)[[$$tag リスト]]\n\nリストを並べ替えるには、sort 関数を使います。sort 関数は引数のリストを破壊的に変更します。よって、新たなリストを得るには copy-list を使います。第１引数に並べ替えたいリスト、第２引数に比較に使う関数( #'< など)を指定します。\n\n{{{\n(let ((my-list '(2 3 1 5 4)))\n  (sort (copy-list my-list) #'<))\n;=> (1 2 3 4 5)\n}}}\n\n比較に使う関数を変えれば、逆順に並べ替えたり、特殊な並べ替えをすることもできます。\n\n{{{\n;; 逆順に並び替える\n(let ((my-list '(2 3 1 5 4)))\n             (sort (copy-list my-list) #'>))\n;=> (5 4 3 2 1)\n\n;; 各要素の絶対値で並び替える\n(let ((my-list '(-2 3 5 1 -7 -4)))\n  (sort (copy-list my-list) \n        #'(lambda (a b) (< (abs a) (abs b)))))\n;=> (1 -2 3 -4 5 -7)\n\n}}}\n\nまた、:key キーワードを使うと、比較関数に渡される前に要素に対して適用される関数を指定できます。上記の絶対値の例は、以下のように書いても同等です\n\n{{{\n(let ((my-list '(-2 3 5 1 -7 -4)))\n  (sort (copy-list my-list) #'< :key #'abs))\n;=> (1 -2 3 -4 5 -7)\n}}}\n\nこのように、第２引数の比較関数と :key キーワードパラメーターを用いることで、複雑なソートを簡潔に書くことができます。\n")
("配列の要素をランダムに抽出する" . "(:ctime 1228749208 :cuser #f :mtime 1228749208 :muser #f)[[$$tag 配列]]\n\n* 配列の要素をランダムに抽出する\n\n[[$$hs aref]] と [[$$hs random]] と [[$$hs length]] を組み合わせることで実現できます。\n{{{\n(let* ((a #(a b c d e))\n       (len (length a)))\n  (aref a (random len)))\n;=> B ;実行ごとにランダム\n}}}\n")
("関数に別名をつけたい" . "(:ctime 1228257394 :cuser #f :mtime 1228257557 :muser #f)プログラミングをするなかで、問題領域にあわせた語彙を使った方がコードが読みやすい場合があります。そういうときは、関数を別名で呼ぶことができると便利です。\n\n例えば、find-all-ifという語彙を使いたいとします。ただし機能的には、ANSIのremove-if-notという関数と同等だとしましょう。そんなときは、シンボル間で関数定義をコピーすればOKです。\n\n{{{\nCL-USER: (remove-if-not #'evenp '(1 2 3 4 5))\n(2 4)\nCL-USER: (setf (symbol-function 'find-all-if) #'remove-if-not)\n#<Function REMOVE-IF-NOT>\nCL-USER: (find-all-if #'evenp '(1 2 3 4 5))\n(2 4)\nCL-USER:\n}}}\n\n")
(" %Tag:スレッド" . "(1339719834 (\"スレッド\" :ctime 1229079964 :cuser #f :mtime 1235474220 :muser #f) (\"スレッドを生成する\" :ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f) (\"操作をタイムアウトにする\" :ctime 1231938586 :cuser #f :mtime 1231938745 :muser #f))")
(" %Tag:シンボル" . "(1339703868 (\"シンボル\" :ctime 1227906107 :cuser #f :mtime 1235474044 :muser #f) (\"同一のインターンされないシンボルを複数個所で使う\" :ctime 1233607862 :cuser #f :mtime 1233794032 :muser #f) (\"キーワードを生成したい\" :ctime 1227906421 :cuser #f :mtime 1227906474 :muser #f))")
("コメント" . "(:ctime 1227971104 :cuser #f :mtime 1227971659 :muser #f)[[$$tag コーディングスタイル]]\n\n* コメント\n大体の慣習は下記の様なスタイルです。\n{{{\n;;;; 4つはタイトルや\n;;;; セクションヘッダに対して使用\n\n;;; 3つは、関数や、ブロックに使用\n(cond ((atom x) \"atom!\")\t\t; アトムか? (1つは、インラインコメントに使用)\n      ((listp x) \"list!\")\t\t; リストか?\n      ;; 上記以外のすべて (2つはインデントを合せてフォームに使用)\n      (t (cons x)))\n}}}\n\n* 参考文献\n- [http://www.lispworks.com/documentation/HyperSpec/Body/02_ddb.htm HyperSpec/Notes about Style for Semicolon]\n- [[COMMON LISP 第2版]] P464\n\n")
("|comments:リクエスト::000" . "(:ctime 1232205586 :cuser #f :mtime 1232205587 :muser #f)* 匿名希望 (2009/01/17 07:19:46):\n<<<\nLISPのマクロと、Cのマクロの違いを教えて\n>>>\n")
(" %Tag:変数とスコープ" . "(1335557673)")
("ライブラリをロードする" . "(:ctime 1270749320 :cuser #f :mtime 1317763552 :muser #f)http://rd.clojure-users.org/entry/view/74001\n")
("2進数・8進数・16進数で数値を扱うには" . "(:ctime 1227836450 :cuser #f :mtime 1227836450 :muser #f)[[$$tag 数値]]\n* 2進数・8進数・16進数で数値を扱うには\n2進数、8進数、16進数は以下のように記述します。\n{{{\n#b10000 ;=> 16\n#o20    ;=> 16\n#x10    ;=> 16\n}}}\n")
("ハッシュを値で降順、値が等しい場合キーで昇順にソートする" . "(:ctime 1227413847 :cuser #f :mtime 1227413848 :muser #f)[[$$tag ハッシュ 【募集中】]]\n* ハッシュを値で降順、値が等しい場合キーで昇順にソートする\n【募集中】\n\n")
(" %Tag:入出力" . "(1338396675 (\"入出力\" :ctime 1227443658 :cuser #f :mtime 1235474167 :muser #f) (\"NULLストリームを使う\" :ctime 1232161530 :cuser #f :mtime 1232167438 :muser #f) (\"ファイル内の特定の行を読み込む\" :ctime 1231655622 :cuser #f :mtime 1231655622 :muser #f) (\"ファイルから行をランダムに取り出す\" :ctime 1231136258 :cuser #f :mtime 1231164888 :muser #f) (\"ファイルをリネームする\" :ctime 1231087938 :cuser #f :mtime 1231087938 :muser #f) (\"別のプログラムを起動する\" :ctime 1230408629 :cuser #f :mtime 1230595157 :muser #f) (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1230408268 :muser #f) (\"外部からの入力バイト列を文字列にしたい(文字コード変換含む)\" :ctime 1229261302 :cuser #f :mtime 1229518681 :muser #f) (\"ストリームを扱うように出力先としてシーケンスを指定したい\" :ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f) (\"ベクタをバイナリのストリームとして扱いたい\" :ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f) (\"ファイルに書き込む\" :ctime 1227946735 :cuser #f :mtime 1227946736 :muser #f) (\"処理系を起動したディレクトリのパスネームを返す\" :ctime 1227447346 :cuser #f :mtime 1227447347 :muser #f))")
("スレッドを生成する" . "(:ctime 1229081794 :cuser #f :mtime 1232412613 :muser #f)[[$$tag スレッド ライブラリ portable-threads bordeaux-threads]]\n\n* スレッドを生成する\n\n** portable-threadsでの例\n\nportable-threadsは主にネイティブスレッドを提供している処理系のコンパチブルレイヤです。\nスレッドの生成には、 spawn-thread スレッドの生存の確認には、 thread-alive-p を利用します。\n{{{\n(defpackage :thread-test\n  (:use :cl :portable-threads))\n(in-package :thread-test)\n\n(progn\n  (print \"Test start\")\n  (print \"Create thread\")\n\n  (let ((th (spawn-thread \"foo\" (lambda ()\n                                  (let ((*standard-output* #.*standard-output*)) ;printの出力を一箇所に纏めるため\n                                    (print \"Start thread\")\n                                    (sleep 3)\n                                    (print \"End thread\"))))))\n    (loop :while (thread-alive-p th) \n          :do (sleep 0.005)) ;wait FIXME(joinとかないのだろうか。)\n    (print \"Test compleated\")))\n;-> \"Test start\" \n;   \"Create thread\" \n;   \"Start thread\" \n;   \"End thread\" \n;   \"Test compleated\" \n;=> \"Test compleated\"\n}}}\n** bordeaux-threadsでの例\n\n{{{\n(defpackage :thread-test\n  (:use :cl :bordeaux-threads))\n(in-package :thread-test)\n\n(progn\n  (print \"Test start\")\n  (print \"Create thread\")\n\n  (let ((th (make-thread (lambda ()\n                           (let ((*standard-output* #.*standard-output*)) ;printの出力を一箇所に纏めるため\n                             (print \"Start thread\")\n                             (sleep 3)\n                             (print \"End thread\")))\n                         :name \"foo\")))\n    #+sbcl (join-thread th)\n    #-sbcl (loop :while (thread-alive-p th) :do (sleep 0.005))\n    (print \"Test compleated\")))\n;-> \"Test start\" \n;   \"Create thread\" \n;   \"Start thread\" \n;   \"End thread\" \n;   \"Test compleated\" \n;=> \"Test compleated\"\n}}}\n\n- [[スレッドを生成する:AllegroCL]]\n- [[スレッドを生成する:ScineerCL]]\n")
("配列同士の和・差・積を取る" . "(:ctime 1228453798 :cuser #f :mtime 1228453798 :muser #f)[[$$tag 配列]]\n\n* 配列同士の和・差・積を取る FIXME\n\n集合を扱う関数は標準ではリストにのみ準備されていますので、配列の場合は自作するか、リスト用の関数の結果を型変換することが考えられるでしょう。\n\nオペレータを作成するマクロ\n{{{\n(defmacro list-op->seq-op (result-type list-op-name)\n  `(defun ,(intern \n            (concatenate 'string (string result-type) \n                                 \"-\"\n                                 (string list-op-name))) \n       (x y &rest keys)\n     (COERCE\n      (apply #',list-op-name (coerce x 'list) (coerce y 'list)\n             keys)\n      ',RESULT-TYPE)))\n}}}\n上記で作成したものを試してみる。cf. [[リスト同士の和・差・積を取る]]\n{{{\n(list-op->seq-op vector set-difference)\n(list-op->seq-op vector union)\n(list-op->seq-op vector intersection)\n\n(vector-union #(1 3 5 7) #(2 4 6 8)) ;=> #(8 6 4 2 1 3 5 7)\n(vector-union #(1 2 3 4) #(3 4 5 6) :test #'eql) ;=> #(6 5 1 2 3 4)\n\n(vector-set-difference #(1 3 5 7) #(2 4 6 8)) ;=> #(7 5 3 1)\n(vector-set-difference #(1 2 3 4) #(3 4 5 6)) ;=> #(2 1)\n\n(vector-intersection #(1 3 5 7) #(2 4 6 8)) ;=> #()\n(vector-intersection #(i 2 3 4) #(3 4 5 6)) ;=> #(4 3)\n}}}\n")
("配列要素をカンマ区切りで出力する" . "(:ctime 1228099965 :cuser #f :mtime 1228099995 :muser #f)[[$$tag 配列]]\n\n* 配列要素をカンマ区切りで出力する\n\nCLではこの様な場合、データをリストに格納することが多くライブラリもリストを扱うものが多いのでベクタの場合、ベクタをリストに型変換するか、ベクタ用に自作するかになります。\n{{{\n(let ((v (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")))\n  (with-output-to-string (s)\n    (loop :with last := (1- (length v))\n\t  :for i :from 0 :to last\n\t  :do (princ (aref v i) s)\n\t  :unless (= i last) :do (princ \",\" s))))\n;=> \"はちべえ,やしち,かくさん,すけさん\"\n}}}\n型変換してformatに渡す\n{{{\n(let ((v (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")))\n  (format nil \"~{~A~}\" (coerce v 'list)))\n;=> \"はちべえ,やしち,かくさん,すけさん\"\n}}}\nフォーマッタ関数を作成してformatへ渡す\n{{{\n(defun join-strings (s char v)\n  (loop :with last := (1- (length v))\n\t:for i :from 0 :to last\n\t:do (princ (aref v i) s)\n\t:unless (= i last) :do (princ char s)))\n\n(defun join/comma (s arg)\n  (join-strings s #\\, arg))\n\n(format nil #'join/comma (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\"))\n;=> \"はちべえ,やしち,かくさん,すけさん\"\n}}}\n")
("特定のURLからドキュメントを抽出する" . "(:ctime 1227424335 :cuser #f :mtime 1317762038 :muser #f)- http://rd.clojure-users.org/entry/view/69001\n")
("条件判断(case)" . "(:ctime 1227415897 :cuser #f :mtime 1227415897 :muser #f)[[$$tag 制御構造 【募集中】]]\n* 条件判断(case文)\n【募集中】\n")
("リストを作成する" . "(:ctime 1229551584 :cuser #f :mtime 1235478875 :muser #f)Clojureでリストを作成するには、他のLISP方言と同じく\n{{{\n(list 1 2 3)\n;=> (1 2 3)\n}}}\nとします。\nClojure のプログラムはリストです。\nプログラムのリストとデータのリストを区別するため、データのリストは quote する必要があます。\n{{{\n(quote (1 2 3))\n}}}\nquote には標準で「'」というリーダーマクロが定義されていますので略記として「'」を使うことができます。\n{{{\n'(1 2 3)\n}}}\n「`」バッククオート を使うとリスト内に式を含むことができます。\n「~」チルダ は式を一つ取り、式の結果がリスト内の要素になります。\n「~@」チルダアットマーク はリストを返す式を一つ取り、式の結果をリスト内に展開します。\n\n※「,」コンマはClojureでは空白と同じ扱いになっているところが主な他の方言とは違います。\n{{{\n`(1 2 ~(+ 1 2) 4 5)\n;=> (1 2 3 4 5)\n\n`(1 2 ~@(list 3 4 5) 6 7 8)\n;=> (1 2 3 4 5 6 7 8)\n\n`(1 2 ~@(list 3 4 5) 6 7 8)\n;=> (1 2 3 4 5 6 7 8)\n}}}\n\n{{{\n;; 0から10までの数値のリストを作成する。\n(range 0 11)\n;=> (0 1 2 3 4 5 6 7 8 9 10)\n}}}\n\n{{{\n;; 乱数を10個生成してリストを作成する。\n(for [x (range 10)] (rand-int 100))\n;=> (53 60 33 9 2 62 37 50 88 60) ; 評価のたびに異なります。\n\n(defn randoms [] (lazy-cons (rand-int 100) (randoms)))\n(take 10 (randoms))\n;=> (61 90 55 5 1 98 52 78 8 80) ; 評価のたびに異なります。\n\n(loop [cnt 10, res () ]\n  (if (zero? cnt)\n    res\n    (recur (- cnt 1) \n           (conj res (rand-int 100)))))\n;=> (2 6 66 57 80 53 2 11 88 12) ; 評価のたびに異なります。\n}}}\n")
("プログラムで配列を定義する" . "(:ctime 1229189109 :cuser #f :mtime 1229232047 :muser #f)[[$$tag 配列]]\n\n* プログラム中で配列を定義する\n\nプログラム中で配列(一次元配列=>ベクタ)を得るには [[$$hs vector]] が利用できます。\n{{{\n(vector \"foo\" \"bar\" \"baz\")\n;=> #(\"foo\" \"bar\" \"baz\")\n}}}\nまた、直に#()を用いて記述することも可能です。[http://www.lispworks.com/documentation/HyperSpec/Body/02_dhc.htm #(] はリーダーマクロで#(から)までで構成される要素を含む単純ベクタとしてリーダーに読まれます。また、10進の数値を取ることができ、指定した要素より少ない場合はエラー、多い場合は最後の要素が長さを満すまで繰り返されます。\nクオートは付ける必要はありません\n{{{\n#(\"foo\" \"bar\" \"baz\")\n;=> #(\"foo\" \"bar\" \"baz\")\n\n#2(\"foo\" \"bar\" \"baz\")\n;>>> error\n\n#10(\"foo\" \"bar\" \"baz\")\n;=> #(\"foo\" \"bar\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\" \"baz\")\n}}}\nまた、バッククオート記法も利用可能です。\n{{{\n(let ((foo 1) (bar 2) (baz '(3 4)))\n  `#(,foo ,bar ,@baz))\n;=> #(1 2 3 4)\n}}}\n\n----\n\nちょっと細かい注記：\nvectorを使う例と#()を使う例は、結果として同じような値が得られますが、\n意味的に違いがあります。\n\n- (vector x ...) はその式が実行される度に、新たな配列のインスタンスが作られます。\n- #(x ...) はその式が読み込まれた時に一度だけ、配列のインスタンスが作られます。\n(特にあらかじめコンパイルした場合、配列はコンパイルされたコードの一部になります)。\n\n前者はコンストラクタ呼び出し、後者はリテラルと言うこともできます。\n(バッククオートの場合、基本的にはvectorなどを使った呼び出しへと展開されますが、\n処理系依存なので例えばコンパイラが不変であると証明できる部分については\nリテラル扱いになるかもしれません。)\n\n{{{\n(defun vec1 () (vector 1 2 3))\n(defun vec2 () #(1 2 3))\n\n(eq (vec1) (vec1))  ;=> NIL\n(eq (vec2) (vec2))  ;=> T\n}}}\n")
("一致する要素を全て取り除く" . "(:ctime 1228100675 :cuser #f :mtime 1228100675 :muser #f)[[$$tag 配列]]\n\n* 一致する要素を全て取り除く\n\nremove や delete はシークエンス全般に適用できますのでベクタにも利用可能です。\n{{{\n(let ((v (vector \"はちべえ\" \"やしち\" \"うっかりはちべえ\" \n\t\t \"かくさん\" \"うっかりはちべえ\" \"すけさん\"\n\t\t \"うっかりはちべえ\")))\n  (remove \"うっかりはちべえ\" v :test #'string=))\n;=> #(\"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")\n}}}\n")
("制御構造" . "(:ctime 1227174305 :cuser #f :mtime 1235474147 :muser #f)[[$$tag 制御構造]]\n\n;; - [[条件判断(if スペシャルフォーム)]]\n;; - [[条件判断(cond マクロ)]]\n;; - [[条件判断(case)]]\n;; - [[繰り返し(loop)]]\n;; - [[繰り返し(do)]]\n;; - [[繰り返しからの脱出]]\n;; - [[ブロックからの脱出]]\n;; - [[指定回数の繰り返し]]\n;; - [[指定値までの繰り返し]]\n;; - [[指定値までの指定ステップ毎に繰り返し]]\n;; - [[繰り返しの前処理・後処理]]\n;; - [[確実に後処理を行なう]]\n;; - [[goto文]]\n;; - [[リスト構造を分解して変数に代入する]]\n;; - [[多値を変数に代入する]]\n;; - [[一時変数を使わずに値を交換する]]\n;; - [[有意な値を返さない]]\n")
("一定の値を返す関数を得る" . "(:ctime 1229257495 :cuser #f :mtime 1229257495 :muser #f)[[$$tag 関数]]\n\n* 一定の値を返す関数を得る\n\n[[$$hs constantly]] は引数に与えられた値を返す関数を作成して返します。関数を引数に取るものと組み合わせて使用することが多いでしょう。\n{{{\n(mapcar (constantly 1) '(a b c d e f))\n;=> (1 1 1 1 1 1)\n\n(defun my-length (list)\n  (apply #'+ (mapcar (constantly 1) list)))\n\n(my-length '(1 2 3 4 5))\n;=> 5\n}}}\n")
("ハッシュの要素をランダムに抽出する" . "(:ctime 1227413899 :cuser #f :mtime 1227413900 :muser #f)[[$$tag ハッシュ 【募集中】]]\n* ハッシュの要素をランダムに抽出する\n【募集中】\n")
("除算の商と余りを求める" . "(:ctime 1227870704 :cuser #f :mtime 1227878024 :muser #f)[[$$tag 数値]]\n* 除算の商と余りを求める\n余りを求めるには mod 関数もしくは rem 関数を使用します。\n商も同時に求めるには floor 関数もしくは truncate 関数を使用します。\n商と余りを多値で返します。\n{{{\n(mod 10 3)        ;=> 1\n(rem 10 3)        ;=> 1\n\n(mod -10 3)       ;=> 2\n(rem -10 3)       ;=> -1\n\n(floor 10 3)\n;=> 3\n;   1\n(truncate 10 3)\n;=> 3\n;   1\n(floor -10 3)\n;=> -4\n;    2\n(truncate -10 3)\n;=> -3\n;   -1\n}}}\n")
(" %Tag:scl" . "(1281271020)")
("ファイルから行をランダムに取り出す" . "(:ctime 1231136258 :cuser #f :mtime 1231164888 :muser #f)[[$$tag 入出力]]\n\n* ファイルから行をランダムに取り出す\n\n乱数の生成に、[[$$hs random]]、ファイルのポジション移動に[[$$hs file-position]]を利用した例\n{{{\n(defun picking-random-nline (nline file)\n  (with-open-file (in file)\n    (let ((tab (make-hash-table))\n          (lnum 0))\n      (setf (gethash 0 tab) 0)\n      (loop :for c := (read-char in nil) :while c\n            :do (when (char= #\\Newline c) \n                  (setf (gethash (incf lnum) tab)\n                        (file-position in))))\n      (flet ((random-line ()\n               (file-position in (gethash (random lnum) tab))\n               (read-line in nil)))\n        (loop :repeat nline :collect (random-line))))))\n\n;; 試してみる\n(picking-random-nline 4 \"/usr/share/dict/words\")\n;=> (\"whirligig's\" \"sluicing\" \"hovercraft\" \"Sterno\")\n}}}\n\n[[CLiki:SERIES]]を使った実装\n{{{\n(in-package :series)\n\n(defun picking-random-nline (nline file)\n  (let* ((lines (scan-file file #'read-line))\n         (len (collect-length lines))\n         (rands (sort (loop :repeat nline :collect (random len)) \n                      #'<)))\n    (collect (choose (mask (scan rands)) \n                     lines))))\n\n;; 注. 結果がファイルの先頭からの順番になっています。\n(picking-random-nline 4 \"/usr/share/dict/words\")\n;=> (\"Chirico's\" \"ritually\" \"sweetie's\" \"sycophant\")\n}}}\nファイルの長さを求めるのに[[$$hs file-length]]を利用しファイルの長さでランダムに収集した例\n\n行数を知らなくても動作するメリットはありますが、長い行の次の行が出現しやすくなり、行の長さが均一でないとランダムになりません。\n{{{\n(defun picking-random-nline (nline file)\n  (with-open-file (in file)\n    (let ((len (file-length in)))\n      (flet ((random-line ()\n               (file-position in (random len))\n               (read-line in)           ;捨て\n               (or (read-line in nil)\n                   (progn (file-position in 0)\n                          (read-line in nil)))))\n        (loop :repeat nline :collect (random-line))))))\n\n(picking-random-nline 4 \"/usr/share/dict/words\")\n;=> (\"tumid\" \"Judaic\" \"grownups\" \"telecommunications\")\n}}}\n\n** 議論\n- これ、行の長さが同じでないとランダムにならないんじゃないでしょうか。注記があった方が良いのでは (←こういうコメントが邪魔だったら消してください)。\n-- おお、気付かれましたか(笑) 長い行の確率が高くなるんですよね。\n\n\n")
(" %Tag:mudballs" . "(1338213979 (\"mudballsを使う\" :ctime 1229134338 :cuser #f :mtime 1229510204 :muser #f))")
("ファイル内の特定の行を読み込む" . "(:ctime 1231655622 :cuser #f :mtime 1231655622 :muser #f)[[$$tag 入出力]]\n\n* ファイル内の特定の行を読み込む\n\n標準にファイルの読み込みで行を指定する方法ははありませんので、ライブラリを利用するか、自作することになるでしょう。\n\n[[CLiki:Series]] を利用した例\n{{{\n(in-package :series)\n\n(defun read-nth-line (pos file)\n  (collect-nth pos\n    (scan-file file #'read-line)))\n}}}\n{{{\n;; 実行例\n(read-nth-line 666 \"/usr/share/dict/words\")\n;=> \"Andrianampoinimerina's\"\n}}}\n\n[[$$hs file-position]]を利用した例\n{{{\n(defun read-nth-line (pos file)\n  (with-open-file (in file)\n    (let ((pos (nth-beginning-of-line-position pos file)))\n      (when pos\n        (file-position in pos)\n        (read-line in)))))\n\n(defun nth-beginning-of-line-position (n file &optional (newline-char #\\Newline))\n  (with-open-file (in file)\n    (loop :with newline := newline-char\n          :for char := (read-char in nil nil) :while char\n          :when (eql newline char) :count :it :into cnt\n          :when (>= cnt n) :return (file-position in)\n          :finally (return NIL))))\n}}}\n** 議論\n\n")
(" %Tag:flexi-streams" . "(1340274292 (\"ストリームを扱うように出力先としてシーケンスを指定したい\" :ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f) (\"ベクタをバイナリのストリームとして扱いたい\" :ctime 1228564299 :cuser #f :mtime 1228564299 :muser #f))")
(" %Tag:usocket" . "(1318778690)")
("数値を2進数・8進数・16進数表現の文字列に変換するには" . "(:ctime 1227837042 :cuser #f :mtime 1227842291 :muser #f)[[$$tag 数値]]\n* 数値を2進数・8進数・16進数表現の文字列に変換するには\n*print-base* で基数を指定するか、format で ~b, ~o, ~x, ~r を使います。\n{{{\n(let ((*print-base* 2))\n  (prin1-to-string 255)) ;=> \"11111111\"\n\n(format nil \"~b\" 255)    ;=> \"11111111\"\n(format nil \"~o\" 255)    ;=> \"377\"\n(format nil \"~x\" 255)    ;=> \"FF\"\n\n(format nil \"~vr\" 2 255)    ;=> \"11111111\"\n(format nil \"~vr\" 8 255)    ;=> \"377\"\n(format nil \"~vr\" 16 255)   ;=> \"FF\"\n}}}\n")
("コンディション" . "(:ctime 1229668291 :cuser #f :mtime 1235474157 :muser #f)[[$$tag コンディション]]\n\n;; - [[コンディションを発生させる]]\n;; - [[コンディションを捕捉する]]\n;; - [[特定のコンディションだけを捕捉する]]\n;; - [[コンディション処理の後に処理をやり直す]]\n;; - [[コンディションの内容を受け取る]]\n;; - [[独自のコンディションを定義し発生させる]]\n")
("サブクラス関係かどうか判定する" . "(:ctime 1233062751 :cuser #f :mtime 1233062836 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\nCommon Lispでは組み込み型とクラスは統合されていますので判定には[[$$hs subtypep]]が利用できます。\n[[$$hs subtypep]]は2値を返し、第1引数が第2引数のサブタイプ/クラスである場合は、1値目がTになります。\nサブクラスでない場合は、1値目がNILになり、判定できない場合は、2値目がNILとなります。(T,NILという組み合わせはありません。)\n{{{\n(defclass foo () ())\n(defclass bar (foo) ())\n(defclass baz () ())\n\n(subtypep 'foo 'bar)\n;=> NIL\n;   T\n\n(subtypep 'foo 'baz)\n;=> NIL\n;   T\n\n(subtypep 'bar 'foo)\n;=> T\n;   T\n}}}\n\n\n")
(" %Tag:GUI" . "(1334849792)")
(" %Tag:ライブラリ管理" . "(1333864498)")
(" %Tag:" . "(1338747009 (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1230408268 :muser #f) (\"オブジェクトの初期化を行う\" :ctime 1229748239 :cuser #f :mtime 1229748296 :muser #f))")
("逆引きCommonLisp" . "(:ctime 1227150447 :cuser #f :mtime 1231579474 :muser #f)* 逆引きCommon Lisp\n- [[逆引きCommonLisp書式]]\n- [[ライセンスについて]]\n- [[編集に関する基本方針]]\n- [[新規ページ作成の手順]]\n----\n- [[文字列]]\n- [[シンボル]]\n- [[数値]]\n- [[リスト]]\n- [[配列]]\n- [[ハッシュテーブル]]\n- [[構造体]]\n- [[日付と時刻]]\n- [[変数とスコープ]]\n- [[制御構造]]\n- [[コンディション]]\n- [[入出力]]\n- [[関数]]\n- [[マクロ]]\n- [[パッケージ]]\n- [[オブジェクトシステム(CLOS)]]\n- [[正規表現]]\n- [[スレッド]]\n- [[ネットワーク]]\n- [[GUI]]\n- [[インターネットサービス]]\n- [[Webオートメーション]]\n- [[データベース]]\n- [[ライブラリ]]\n- [[ライブラリ管理]]\n- [[開発環境]]\n- [[最適化]]\n- [[処理系]]\n- [[コーディングスタイル]]\n- [[仕様/ドキュメント]]\n- [[その他]]\n- [[Tag:【募集中】]]\n----\n欲しい項目、質問事項があれば直接編集、もしくは[[リクエスト]]へどうぞ！\n")
(" %Tag:SLIME" . "(1340229310 (\"マクロ展開を確認したい\" :ctime 1229603579 :cuser #f :mtime 1229603942 :muser #f) (\"SLIME:日本語関係の設定:LispWorks\" :ctime 1229489628 :cuser #f :mtime 1229489727 :muser #f) (\"SLIME:日本語関係の設定\" :ctime 1229489203 :cuser #f :mtime 1229489661 :muser #f) (\"SLIME\" :ctime 1229489124 :cuser #f :mtime 1229489124 :muser #f) (\"逆アセンブルした結果を確認したい\" :ctime 1228810111 :cuser #f :mtime 1228810112 :muser #f) (\"マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい\" :ctime 1228627796 :cuser #f :mtime 1228627796 :muser #f))")
(" %Tag:ネットワーク" . "(1336201399)")
("配列" . "(:ctime 1228095119 :cuser #f :mtime 1235474083 :muser #f)[[$$tag 配列]]\n\n;; - [[プログラムで配列を定義する]]\n;; - [[配列要素をカンマ区切りで出力する]]\n;; - [[配列の要素数を取得する]]\n;; - [[配列に要素を追加する]]\n;; - [[配列の先頭または末尾から要素を取りだす]]\n;; - [[部分配列を取りだす]]\n;; - [[配列を任意の値で埋める]]\n;; - [[配列を空にする]]\n;; - [[配列同士を結合する]]\n;; - [[配列同士の和・差・積を取る]]\n;; - [[複数の要素を変更する]]\n;; - [[配列の配列をフラットな配列にする]]\n;; - [[配列をソートする]]\n;; - [[条件式を指定したソート]]\n;; - [[配列を逆順にする]]\n;; - [[指定した位置の要素を取り除く]]\n;; - [[一致する要素を全て取り除く]]\n;; - [[配列から重複した要素を取り除く]]\n;; - [[配列から指定条件を満たす要素を取り除く]]\n;; - [[配列中の要素を探す]]\n;; - [[配列の配列を検索する]]\n;; - [[配列の各要素に関数を適用し配列を作成する]]\n;; - [[配列の各要素に対して関数を適用する]]\n;; - [[配列の要素をランダムに抽出する]]\n;; - [[多次元の配列を1つのインデックスで扱う]]\n;; - [[配列をリストに変換する]]\n")
("リストから指定条件を満たす要素を取り除く" . "(:ctime 1228980905 :cuser #f :mtime 1229557393 :muser #f)[[$$tag リスト]]\n\n[[$$hs remove-if]] [[$$hs delete-if]] は第1引数に与えられた関数が真(非nil)値を返した要素を除外したリストを返します。\n{{{\n(let ((a (list 30 100 50 80 79 40 95)))\n  (list (remove-if (lambda (x) (< x 80)) a)\n        a))\n;=> ((100 80 95) (30 100 50 80 79 40 95))\n}}}\n{{{\n(let ((a (list 30 100 50 80 79 40 95)))\n  (list (delete-if (lambda (x) (< x 80)) a)\n        a))\n;=> ((100 80 95) \n     (30 100 80 95)) ;処理系依存\n}}}\n[[$$hs delete-if]] は破壊的に与えられたリストを変更し結果を生成しますが、元のリストが結果と一致するとは限りません(処理系依存)ので確実にしたい場合は、再度代入する必要があります。\n{{{\n(let ((a (list 30 100 50 80 79 40 95)))\n  (setq a (delete-if (lambda (x) (< x 80)) a)))\n;=> (100 80 95)\n}}}\n\n[[$$hs loop]] でも書けます。結果のリストは新しく生成されたものです。\n{{{\n(loop for x in (list 30 100 50 80 79 40 95)\n      unless (< x 80) collect x)\n;=> (100 80 95)\n\n;; 条件を満たすものとそうでないものに分割。\n(loop for x in (list 30 100 50 80 79 40 95)\n      unless (< x 80) collect x into i\n      else collect x into j\n      finally (return (list i j)))\n;=> ((100 80 95) (30 50 79 40))\n}}}\n")
("関数" . "(:ctime 1228173344 :cuser #f :mtime 1235474177 :muser #f)[[$$tag 関数]]\n\n;; - [[一定の値を返す関数を得る]]\n;; - [[状態を持った手続きを作る]]\n;; - [[引数のリストに関数を適用する]]\n;; - [[QUOTEとFUNCTIONを使い分ける]]\n;; - [[SETF関数を取り出す]]\n")
("ハッシュに要素を追加する" . "(:ctime 1227413572 :cuser #f :mtime 1227413572 :muser #f)[[$$tag ハッシュ]]\n* ハッシュに要素を追加する\n以下のようにするとハッシュへ要素を追加することができます。~%\nCLでは空のハッシュテーブルを作成して追加という手順となるので、初期化/追加は同じ流れです。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  ;; 追加\n  (setf (gethash \"apple\" ht) 150)\n  ;; 検索 => 表示\n  (print (gethash \"apple\" ht)))\n;-> 150\n;=> 150\n}}}\n")
("シンボルを文字列として扱いたい" . "(:ctime 1227898595 :cuser #f :mtime 1227899843 :muser #f)[[$$tag 文字列]]\n* シンボルを文字列として扱いたい\n\nCommon Lispでは、シンボルのシンボル名が文字列で格納されているため、シンボルも文字列のように扱うことが可能な場合が多くあります。\nCLでは、これを[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_designator string_designator]と呼び規定しています。\n\n{{{\n■利用例\n(defpackage :foo ...)\n(defpackage #:foo ...)\n(in-package :foo)\n...\n}}}\nシンボルからシンボル名を取り出すには、symbol-nameかstringを利用します。\n{{{\n\"FOO\"\n;=> \"FOO\"\n\n(symbol-name '#:foo)\n;=> \"FOO\"\n\n(symbol-name :foo)\t\t\t;':foo, 'keyword:fooでも同じ。\n;=> \"FOO\"\n\n(symbol-name 'foo)\n;=> \"FOO\"\n\n\"foo bar baz\"\n;=> \"foo bar baz\"\n\n(symbol-name '|foo bar baz|)\n;=> \"foo bar baz\"\n\n(symbol-name :|foo bar baz|)\n;=> \"foo bar baz\"\n\n(symbol-name '#:|foo bar baz|)\n;=> \"foo bar baz\"\n\n(symbol-name '#:\\f\\o\\o\\ \\b\\a\\r\\ \\b\\a\\z)\n;=> \"foo bar baz\"\n\n(string '#:\\f\\o\\o\\ \\b\\a\\r\\ \\b\\a\\z)\n;=> \"foo bar baz\"\n\n(string= \"FOO\" 'foo)\n;=> T\n\n(equalp \"FOO\" 'FOO)\n;=> nil\n}}}\n\ndefpackage等で、#:fooや、:fooが利用される理由ですが、fooとするとfooシンボルがインターンされてしまい、意図しない名前の競合が発生することがあるためで、#:fooならば、どのパッケージにもインターンされず、:fooならば、キーワードパッケージにインターンされるのみとなります。この場合(defpackage \"FOO\" ..)と直接大文字で書いてしまえば良いのですが、主に大文字をタイプするのが面倒等の理由で最近では、#:fooや、:fooと書かれる傾向が強いようです。\n")
("時刻の表現からUniversal Timeを作成する" . "(:ctime 1227414501 :cuser #f :mtime 1227414501 :muser #f)[[$$tag 日付と時刻]]\n* 時刻の表現からUniversal Timeを作成する\nencode-universal-timeを使用する。\n(encode-universal-time second minute hour date month year [time-zone])\nという形式で呼び出すとUniversal Timeが取得できる\n{{{\n;; 2008/11/20 13:10:23\n(encode-universal-time 23 10 13 20 11 2008 -9)\n;=> 3436143023\n}}}\n")
("配列同士を結合する" . "(:ctime 1228193096 :cuser #f :mtime 1228193097 :muser #f)[[$$tag 配列]]\n\n* 配列同士を結合する\n\nシークエンスを結合する関数 [[$$hs concatenate]] が使えます。第一引数に戻り型を指定し、その後ろに結合する配列を渡します。配列の個数は任意です。\n{{{\n(let ((v1 (vector 0 1 2))\n      (v2 (vector 3 4 5))\n      (v3 (vector 6 7 8)))\n  (concatenate 'vector v1 v2 v3))\n;=> #(0 1 2 3 4 5 6 7 8)\n\n(concatenate 'vector)\n;=> #()\n}}}\n")
(" %Tag:コンディション" . "(1338213289 (\"コンディション\" :ctime 1229668291 :cuser #f :mtime 1235474157 :muser #f))")
("ネストされたシーケンスをフラットにする" . "(:ctime 1271355214 :cuser #f :mtime 1317763130 :muser #f)http://rd.clojure-users.org/entry/view/69003\n")
("大文字・小文字に揃える" . "(:ctime 1227347707 :cuser #f :mtime 1317765604 :muser #f)http://rd.clojure-users.org/entry/view/75003\n")
(" %Tag:lbg[N" . "(1302336030)")
("状態を持った手続きを作る" . "(:ctime 1228173536 :cuser #f :mtime 1228173569 :muser #f)[[$$tag 関数]]\n\n* 状態を持った手続きを作る\n\n関数にレキシカルな環境を閉じ込むことで状態を持った手続きを作ることができます。\n\n下記の例では、GoFデザインパターンのIteratorパターンをクロージャで真似ています。\n{{{\n(defun make-iterator (sequence)\n  (let ((idx 0)\n\t(len (length sequence)))\n    (values (lambda () (setq idx 0))\n\t    (lambda () (incf idx))\n\t    (lambda () (elt sequence idx))\n\t    (lambda () (<= len idx)))))\n\n(multiple-value-bind (first! next! current-item done?)\n    (make-iterator '(1 2 3 4))\n  (do ()\n      ((funcall done?))\n    (print (funcall current-item))\n    (funcall next!))\n  (print \"Reset!\")\n  (funcall first!)\n  (print (funcall current-item)))\n;-> 1 \n;   2 \n;   3 \n;   4 \n;   Reset!\n;   1 \n;=> 1\n}}}\nこうすることで大域的な名前空間を汚染せずに関数に状態を持たせることができます。\n\n** 参考\n- [http://homepage1.nifty.com/bmonkey/lisp/sacla/html/lisp/sequence.lisp.html Yuji Minejimaさんのmake-iterator]\n")
(" %Tag:パスネーム" . "(1338515780 (\"処理系を起動したディレクトリのパスネームを返す\" :ctime 1227447346 :cuser #f :mtime 1227447347 :muser #f))")
("COMMON LISP 第2版" . "(:ctime 1227971790 :cuser #f :mtime 1228812722 :muser #f)[[$$tag 参考文献]]\n\n* COMMON LISP 第2版\n\nGuy L. Steele Jr.著 井田昌之翻訳監修\n[[isbn:4320025881]]\n")
("絶対値を求める" . "(:ctime 1229676067 :cuser #f :mtime 1317765504 :muser #f)\nhttp://rd.clojure-users.org/entry/view/76001\n")
(" %Tag:リーダーマクロ" . "(1337384046 (\"リードテーブルを標準の状態に復元する方法\" :ctime 1229195021 :cuser #f :mtime 1229195129 :muser #f))")
(" %Tag:処理系" . "(1338213999 (\"処理系\" :ctime 1227545106 :cuser #f :mtime 1227968573 :muser #f))")
("うるう年かどうか判定する" . "(:ctime 1227414804 :cuser #f :mtime 1227714916 :muser #f)[[$$tag 日付と時刻 metatilities]]\n* うるう年かどうか判定する\n自作するか、ライブラリを利用する\n下記では、[[ライブラリ:Metatilities]]を利用\n{{{\n(metatilities:leap-year-p 2000)\n;=> T\n\n(metatilities:leap-year-p 2001)\n;=> nil\n}}}\n----\n{{{\n(defun leap-year-p ( y )\n   (and (zerop (mod y 4))\n       (or (plusp (mod y 100))(zerop (mod y 400)))))\n}}}\n")
("ABCLでDISASSEMBLEする" . "(:ctime 1230125046 :cuser #f :mtime 1230125046 :muser #f)[[$$tag その他 ABCL]]\n\n* ABCLでDISASSEMBLEする\n\nABCLは [[$$hs disassemble]] に外部コマンドのjadを利用しますのでjadを導入すれば結果が表示されます。\n\n- [http://www.kpdus.com/jad.html jad]\n")
(" %Tag:仕様/ドキュメント" . "(1340461473 (\"仕様/ドキュメント\" :ctime 1227970340 :cuser #f :mtime 1229515250 :muser #f))")
("ライブラリ:Metatilities" . "(:ctime 1227244104 :cuser #f :mtime 1227244126 :muser #f)[[$$toc]]\nGary King氏によるCLのユーティリティ集\nhttp://common-lisp.net/project/metatilities/\n")
("コーディングスタイル" . "(:ctime 1227967130 :cuser #f :mtime 1235474378 :muser #f)[[$$tag コーディングスタイル]]\n\n* コーディングスタイル\n;; - [[コメント]]\n;; - [[命名の慣習]]\n;; - [[大文字と小文字の使い分け]]\n;; \n;; * 参考文献\n;; - [[Tutorial on Good Lisp Programming Style]]\n\n\n\n")
(" %Tag:最適化" . "(1340299162 (\"最適化\" :ctime 1228170916 :cuser #f :mtime 1235474325 :muser #f) (\"末尾呼び出しの最適化\" :ctime 1228171120 :cuser #f :mtime 1228812122 :muser #f))")
(" %Tag:参考文献" . "(1338981073 (\"COMMON LISP 第2版\" :ctime 1227971790 :cuser #f :mtime 1228812722 :muser #f) (\"Common Lisp の スコープ と エクステント\" :ctime 1228170031 :cuser #f :mtime 1228170119 :muser #f) (\"新規ページ作成の手順\" :ctime 1227422988 :cuser #f :mtime 1228111845 :muser #f) (\"Tutorial on Good Lisp Programming Style\" :ctime 1227969021 :cuser #f :mtime 1227971205 :muser #f))")
("ハッシュを空にする" . "(:ctime 1227413762 :cuser #f :mtime 1227413763 :muser #f)[[$$tag ハッシュ]]\n* ハッシュを空にする\n[http://www.lispworks.com/documentation/HyperSpec/Body/f_clrhas.htm clrhash]を利用します。\nclrhashの返却値は、内容がクリアされたハッシュテーブルです。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n\n  (clrhash ht))\n;=> #<HASH-TABLE :TEST EQUAL :COUNT 0 {100AF5A1E1}>\n}}}\n")
("SLIME:日本語関係の設定:LispWorks" . "(:ctime 1229489628 :cuser #f :mtime 1229489727 :muser #f)[[$$tag SLIME]]\n\n* SLIME:日本語関係の設定:LispWorks\n\n最新のCVS版SLIMEでは、UTF-8に設定することによりSLIMEでも日本語を扱うことが可能です。\n- [[CLiki:flexi-streams]]\nが必要です。\n\n*** 処理系側(SWANK側)の設定\n\n{{{\n(lw:set-default-character-element-type 'lw:simple-char)\n(setq STREAM::*DEFAULT-EXTERNAL-FORMAT* '(:utf-8 :eol-style :lf))\n}}}\n\n*** SLIME側の設定\n{{{\n(setq slime-net-coding-system 'utf-8-unix)\n}}}\n\n*** 注意点\nLispWorksの試用版では、Emacs内から起動できないので、SWANKを別起動して、slime-connectで接続する利用形態になります。\n\n** 参考\n- [http://common-lisp.net/pipermail/slime-devel/2008-September/015580.html slime-devel:UTF-8 support for slime in Lispworks back end]\n\n\n")
("ファイルをリネームする" . "(:ctime 1231087938 :cuser #f :mtime 1231087938 :muser #f)[[$$tag 入出力]]\n\n* ファイルをリネームする\n\nファイルのリネームには、[[$$hs rename-file]]が利用できます。\n[[$$hs rename-file]]は、返り値として3つの値を返し、(デフォルトの新ファイル名 変更前のファイル名 新ファイルの[[$$hs truename]]を返します。\n{{{\n;; foo.lispからbar.lispへ\n(rename-file \"/tmp/foo.lisp\" \"/tmp/bar.lisp\")\n;=> #P\"/tmp/bar.lisp\"\n;   #P\"/tmp/foo.lisp\"\n;   #P\"/tmp/bar.lisp\"\n}}}\n\n\n\n\n")
(" %Tag:【参考文献】" . "(1227971135 (\"Tutorial on Good Lisp Programming Style\" :ctime 1227969021 :cuser #f :mtime 1227971111 :muser #f))")
("リストを逆順にする" . "(:ctime 1227519902 :cuser #f :mtime 1317763248 :muser #f)\nhttp://rd.clojure-users.org/entry/view/72001\n")
(" %Tag:html" . "(1336745994 (\"HTML を処理する\" :ctime 1231232078 :cuser #f :mtime 1231232289 :muser #f))")
("Webオートメーション" . "(:ctime 1231579501 :cuser #f :mtime 1235474258 :muser #f)[[$$tag Webオートメーション]]\n\n* Webオートメーション\n\n;; - [[特定のURLからドキュメントを抽出する]]\n;; - [[URIエンコード]]\n;; - [[MIMEのパース・作成]]\n;; - [[HTML を処理する]]\n;; - [[HTMLのパース・作成]]\n;; - [[文字列を Base64 エンコードする]]\n;; - [[切れたリンクを見つける]]\n;; - [[ページの最終更新日を調べる]]\n")
("命名の慣習" . "(:ctime 1232523500 :cuser #f :mtime 1233368665 :muser #f)ここでは、関数名や変数名の主な命名の慣習を挙げます。\n\n** 変数名\n\n:*global-variable*:\n大域変数で用いられます。Common Lispの場合は、更にスペシャル変数であることを意味することが多いようです。\n\n:+constant-variable+:\n比較的最近の慣習のようですがユーザ定義の定数で用いられます。\n\n** 関数名\n:foo1:\n:foo-1:\nfooの補助関数を表わすことが多いようです。foo1の補助関数は、foo2となります。かなり古くからある慣習のようでLISP 1.5時代からあるようです。\n\n:foo-aux:\n:foo-internal:\nfooの補助関数を表わします。\n\n:%foo: \n:|foo-internal|:\nユーザが使うことを意図していない、内部的な関数を意味することが多いようです。\n||で囲むのは、伝統的に大文字小文字を区別しない処理系で敢えて区別を付けることにより内部的なものであることを強調する意図があるようです。\n\n:nfoo:\nfooと同じ結果を返す破壊的な関数です。例えばreverseに対するnreverseなどです。Nは「No Consing」からのようです。\n\n** 述語\n:foo-p:\n:foo?:\n述語(predicate)の場合、最後にpを付けることが昔からの伝統になっています。foo?も多く使われます。\n\n** 変換するもの\n:foo-to-bar:\n:bar-from-foo:\n:foo->bar:\nfooからbarへ変換するようなものに付けられます。\n\n** CLOS\n:foo-mixin:\nmixinという考えは、Rubyで有名になりましたが、それ自体はインスタンスを作らず何かと混ぜて利用するクラスをfoo-mixinのように命名する慣習は、CLOS以前のFlavorsの時代からあるようです。\n\n** マクロ\n:deffoo:\n:define-foo:\nfooを定義するようなマクロに付けられます。\n\n:with-foo:\n:without-foo:\n何かの処理を準備し、本体が終了すれば、後始末をするようなマクロに付けられることが多いようです。\nwith-open-file等。\n\n:do-foo:\n主に副作用目的で何かをするマクロに付けられることが多いようです。\n\n:make-foo:\nfooを生成する場合に用いられます。[[$$hs defstruct]]の定義では自動で生成もされます。\n\n:foof:\n[[$$hs setf]]のように汎変数を扱うfooマクロを表わします。FはFieldの略だそうです。\n\n:set-foo:\nfooになにかを設定する場合に使われますが、CLの場合、[[$$hs setf]]での汎変数の仕組みがありますので、(setf (foo x) val)とする場合が多いようです。\n\n:fooq:\n# (foo 'bar)というものがあった場合、quoteの省略としてqを付けます。[[$$hs setq]]等。かなり古くからの伝統のようですが、CLでは、[[$$hs setq]]に残るのみです。\n# (foo 'bar :test #'eq)というものがあった場合、省略形態としてqを付けます。CL以前の処理系の慣習です。CL以前の処理系では、CLのようにテスト関数を取ることはありませんでしたので、比較関数に応じたものが存在していました。memq等([[$$hs eq]]で比較する[[$$hs member]])等。\n\n** その他\n:*foo:\n# fooの補助関数を表わしますが、fooよりも機能が足りないものを表わすことがあるようです。固定引数の*my-equalを定義し、それを利用して可変引数のmy-equalを定義する、等。\n# fooという関数が先にあった場合、名前の衝突を避けるために付けることがあるようです。\n\n:foo*:\n# 主に束縛をするマクロの場合、パラレルに束縛するのではなくシリアルに束縛する場合に付けられます。[[$$hs let]]と[[$$hs let*]]、[[$$hs do]]と[[$$hs do*]]等。\n# fooの補助関数を表わしますが、fooよりも機能が多い万能的な関数を表わすことがあるようです。万能的な関数としてmap*を定義し、それに与えるオプションを変えることにより、mapcar、mapc、maplist、maplを作成する等。\n\n* 参考\n[[CLiki:Naming conventions]]\n")
("Common Lisp の スコープ と エクステント" . "(:ctime 1228170031 :cuser #f :mtime 1228170119 :muser #f)[[$$tag 参考文献]]\n\n* Common Lisp の スコープ と エクステント\n株式会社数理システム 黒田 寿男氏による、ANSI Common Lispの変数のスコープ、エクステント仕様を正しく理解できるようになるための手引書\n- [http://cl-www.msi.co.jp/solutions/knowledge/lisp-world/tutorial/scope-and-extent.pdf Common Lisp の スコープ と エクステント(PDF)]\n")
("ライブラリ:KMRCL" . "(:ctime 1227238969 :cuser #f :mtime 1227238969 :muser #f)[[$$toc]]\nKevin Rosenberg氏によるユーティリティ集\nhttp://www.cliki.net/kmrcl\n")
("最もよく現れるデータを見つけたい" . "(:ctime 1231407996 :cuser #f :mtime 1231407997 :muser #f)[[$$tag ハッシュ]]\n\n* 最もよく現れるデータを見つけたい\n\nアイテムの出現数を記録し、最大のものを見付けるにはハッシュテーブルを利用する方法等が考えられるでしょう。FIXME\n{{{\n(defgeneric most-common (container &key test)\n  (:method (container &key (test #'equal))\n    (let ((count (count-item (make-hash-table :test test) \n                             container))\n          (max 0) \n          max-var)\n      (loop :for val :being :each :hash-value :of count \n                                  :using (:hash-key key)\n            :do (when (< max val) \n                  (setq max val\n                        max-var key)))\n      (values max-var max)))))\n(defmethod most-common ((table null) &key test) \n  (values nil nil))\n\n(defgeneric count-item (table container))\n(defmethod count-item (table (list list))\n  (symbol-macrolet ((hv (gethash elt table)))\n    (loop :for elt :in list\n          :do (multiple-value-bind (val win) hv\n                (if win (incf hv) (setf hv 1)))))\n  table)\n\n;; 実行例\n(let ((list '(1 2 3 1 2 3 1 2 3 4 5 4 2 1 2 3 3 2 5 8)))\n  (most-common list :test #'eql))\n;=> 2 ;値\n;   6 ;回数\n}}}\n\n** 議論\n")
("定義されていないスーパクラスメソッドの呼び出しを防ぎたい" . "(:ctime 1228017976 :cuser #f :mtime 1228017977 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* 定義されていないスーパクラスメソッドの呼び出しを防ぎたい\n\nnext-method-pを使用するとスーパクラスにメソッドが定義されているかを確認してから呼び出せます。\n{{{\n(defclass one () ())\n(defclass two (one) ())\n\n(defmethod meth1 ((c two))\n  (print \"2!\")\n  (and (next-method-p)\n       (call-next-method)))\n\n(defmethod meth1 ((c one))\n  (print \"1!\")\n  (and (next-method-p)\n       (call-next-method)))\n\n;=> nil\n(meth1 (make-instance 'two))\n;-> \"2!\" \n;   \"1!\" \n;=> nil\n}}}\nもしくは、定義されていないスーパクラスメソッドを呼び出した場合に呼ばれる no-next-method の動作を定義することでも対処できます。\n{{{\n(defclass one () ())\n(defclass two (one) ())\n\n(defmethod meth2 ((c two))\n  (print \"2!\")\n  (call-next-method))\n\n(defmethod meth2 ((c one))\n  (print \"1!\")\n  (call-next-method))\n\n(defmethod no-next-method ((gf (eql #'meth2)) (meth T) &rest args)\n  (declare (ignore args))\n  nil)\n\n(meth2 (make-instance 'two))\n;-> \"2!\" \n;   \"1!\" \n;=> nil\n}}}\n")
(" %Tag:cl-interpol" . "(1338400404 (\"複数行の文字列を作成する\" :ctime 1227347816 :cuser #f :mtime 1227424718 :muser #f))")
(" %Tag:Metatilities" . "(1227414987 (\"現在の日付を求める\" :ctime 1227414677 :cuser #f :mtime 1227414949 :muser #f) (\"うるう年かどうか判定する\" :ctime 1227414804 :cuser #f :mtime 1227414922 :muser #f) (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1227414906 :muser #f) (\"月の最後の日を調べる\" :ctime 1227414848 :cuser #f :mtime 1227414871 :muser #f))")
("指定の日付が存在するかどうか調べる" . "(:ctime 1227414725 :cuser #f :mtime 1227414726 :muser #f)[[$$tag 日付と時刻 【募集中】]]\n* 指定の日付が存在するかどうか調べる\n【募集中】\n")
("ページの最終更新日を調べる" . "(:ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f)[[$$tag Webオートメーション ライブラリ drakma net-telent-date]]\n\n* ページの最終更新日を調べる\n\n下記の例では、Webクライアントに[[CLiki:DRAKMA]]、日付文字のパーズに[[CLiki:net-telent-date]]を利用しています。\n{{{\n;; 素朴な実装\n(defun sort-url (urls &key (test #'<))\n  (flet ((ut-date-url (urls)\n           (MAPCAR (lambda (url &aux (lastmod (last-modified url)))\n                     (list (if lastmod (date:parse-time lastmod) 0)\n                           (or lastmod \"<NONE SPECIFIED>\")\n                           url))\n                   URLS)))\n    (format T \"~:{~*~&~29A: ~A~%~}\" \n            (sort (ut-date-url urls) test :key #'first))))\n\n(defun last-modified (url)\n  (macrolet ((%header (req) `(nth-value 2 ,req)))\n    (drakma:header-value :last-modified\n      (%header (drakma:http-request url :method :head)))))\n}}}\n{{{\n;; 実行例\n(sort-url '(\"http://tips.lisp-users.org\"\n            \"http://tips.lisp-users.org/common-lisp/\"\n            \"http://tips.lisp-users.org/scheme\"\n            \"http://shibuya.lisp-users.org/\"))\n;-> <NONE SPECIFIED>             : http://tips.lisp-users.org/common-lisp/\n;   <NONE SPECIFIED>             : http://tips.lisp-users.org/scheme\n;   <NONE SPECIFIED>             : http://shibuya.lisp-users.org/\n;   Thu, 20 Nov 2008 02:33:58 GMT: http://tips.lisp-users.org\n;=> NIL\n}}}\n\n** 議論\n")
("一時的にリードテーブルを変更して読み込む" . "(:ctime 1229846380 :cuser #f :mtime 1229846380 :muser #f)[[$$tag マクロ FIXME]]\n\n* 一時的にリードテーブルを変更して読み込む\n\n一時的にリードテーブルを変更するには様々は方法が考えられますが、何がリード時に作用するのかを良く考える必要があるでしょう。\n下記の例では、一時的に!をquoteに定義してみています。\n{{{\n(let ((*readtable* (copy-readtable))) ;引数を省略するとカレントのものが渡る\n  (set-syntax-from-char #\\! #\\')\n  (eval (read-from-string \"!(foo bar baz)\")))\n;=> (FOO BAR BAZ)\n}}}\nその他の例\n{{{\n(progn\n  #.(defparameter *rt* *readtable*) ;リード時に作用\n  #.(set-syntax-from-char #\\! #\\')  ;リード時に作用\n\n  (prog1 !(foo bar baz)\n         #.(setq *readtable* (copy-readtable *rt*)))) ;リード時に作用\n;=> (FOO BAR BAZ)\n}}}\n\n")
(" %Tag:ドキュメント" . "(1340719016 (\"ドキュメンテーション\" :ctime 1229516095 :cuser #f :mtime 1229517828 :muser #f))")
("有意な値を返さない" . "(:ctime 1232958366 :cuser #f :mtime 1233045023 :muser #f)[[$$tag 制御構造]]\n\n有意な値を返さないことを示すイディオムとしては、[[$$hs values]]を利用するものがあり、\n{{{\n(values)\n}}}\nのように書かれます。\nこれは、0個の多値を返すことを示します。\n{{{\n(defun hello ()\n  (format t \"こんにちは!!~%\")\n  (values))\n\n(hello)\n;-> こんにちは!!\n;=> No values\n}}}\n\n** 参考\n0個の返り値は、フォームの用いられる場所によっては値がnilとして扱われます。\n{{{\n(if (values) \"はい\" \"いいえ\")\n;=> \"いいえ\"\n\n(or (values) (values) (values))\n;=> No values\n(or (values) (values) (values 1))\n;=> 1\n}}}\n\n** 議論\n\n- 「0個の返り値は〜nilとして扱われます」というのは、単に\n「期待されている値より少ない値が返ってきた場合、足りない値はnilとして扱う」\nという一般的なルールの1インスタンスにすぎないのでは。\n\n- \n{{{\n(multiple-value-bind (a b c d e) (values 1)\n  (list a b c d e))\n;=> (1 NIL NIL NIL NIL)\n\n(multiple-value-bind (a b c d e) (values)\n  (list a b c d e))\n;=> (NIL NIL NIL NIL NIL)\n}}}\nというところですね。\n確かにその方が統一的で綺麗ですし、「0個の返り値は〜nilとして扱われます」と書いたのは曖昧な含みがあるかと思いました。\nただ、[http://www.lispworks.com/documentation/HyperSpec/Body/03_ag.htm 3.1.7 Return Values]を参照すると0個の多値の扱われ方については親切に解説しているのですが、「期待されている値より少ない値が返ってきた場合、足りない値はnilとして扱う」という取り決めからの帰結かどうかは確認できなかったので、インスタンス的な解説個所をそのまま引いて来た感じになりました。自分の解釈では、「受取側は必ず1つ以上の返り値を期待していて、0個の場合はnilになる」のかなと思えました。\n{{{\n(values (values))\n;=> NIL\n}}}\n等。また、[[$$hs multiple-value-bind]]等でも、足りない場合にどうするかはインスタンスの事例的に書かれているように思われました。\n個人的には、「期待されている値より少ない値が返ってきた場合、足りない値はnilとして扱う」の記述がどこかにあっても良いような気がしますし、確認できたら記載したいと思います。 \nどちらかというと、「(values)は有意な値を返さないイディオムなんですが、(values)自体はNILとして扱われてしまいますよー」ということが記述の意図だったのですが、追及すると深いので曖昧にしてしまいました。\nまた、関連してですが、CLとSchemeでの未定義値的な扱いの違いについて別項目を立てるのも有意義かなと思いました(CLでは実際のところNILになってしまいますが…) --g000001\n\n")
("Leiningenをインストールする" . "(:ctime 1270663424 :cuser #f :mtime 1317764879 :muser #f)http://rd.clojure-users.org/entry/view/70003\n")
("数値を文字列に変換する" . "(:ctime 1228788799 :cuser #f :mtime 1317765078 :muser #f)\nhttp://rd.clojure-users.org/entry/view/75001\n")
("正規表現で文字列を分割する" . "(:ctime 1270745035 :cuser #f :mtime 1317764065 :muser #f)http://rd.clojure-users.org/entry/view/69005\n")
("リストから要素を探す" . "(:ctime 1228221887 :cuser #f :mtime 1228221887 :muser #f)[[$$tag リスト]]\nリストから要素を探すには [[$$hs find]] または [[$$hs member]] を使います。find は見つけた要素を、member は見つけた要素以降のリストを返します。見つからない場合はいずれも nil を返します。\n\n{{{\n(find 1 '(0 1 2 3 4))\n; => 1\n\n(member 1 '(0 1 2 3 4))\n; => (1 2 3 4)\n\n(find nil '(t nil t nil))\n; => nil\n\n(member nil '(t nil t nil))\n; => (nil t nil)\n}}}\n\nfind, member はデフォルトでは比較に [[$$hs eql]] を使います。文字列を探す場合など、eql 以外の比較関数を使いたい場合は :test, :test-not を指定します。\n\n{{{\n(find \"bar\" '(\"foo\" \"bar\" \"baz\"))\n; => nil\n\n(find \"bar\" '(\"foo\" \"bar\" \"baz\") :test #'string=)\n; => \"bar\"\n\n(find \"bar\" '(\"foo\" \"bar\" \"baz\") :test-not #'string=)\n; => \"foo\"\n}}}\n\n要素ではなく述語を満たす(あるいは満たさない)ものを探す場合は find-if, find-if-not, member-if, member-if-not を使います。\n\n{{{\n(find-if #'oddp '(0 1 2 3 4))\n; => 1\n\n(find-if-not #'minusp '(-2 -1 0 1 2))\n; => 0\n}}}\n")
("非真正リストを真正リストに変換する" . "(:ctime 1231231029 :cuser #f :mtime 1231316965 :muser #f)[[$$tag リスト]]\n\n* 非真正リストを真正リストに変換する\n\n最後の cdr が '() でないリストを普通の（真正）リスト([http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#proper_list proper_list])と区別して非真正リスト([http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_i.htm#improper_list improper_list])と呼びます。\n循環リスト、点対リストは、非真正リストです。\n\nこのコード例だと、(foo . #0=(bar baz . #0#)) のように途中で循環しているリストを与えたら無限ループに入りますので「うさぎと亀」アルゴリズムなどを使った方が良いでしょう。\n{{{\n;; 非真正リストを真正リストに変換\n(defun improper-list->proper-list (list)\n  (check-type list list)\n  (do ((again? nil)\n       (x list (cdr x))\n       (ans () (cons (car x) ans)))\n      (nil)\n    (typecase x\n      (null (return (nreverse ans)))\n      (atom (return (nreconc ans (list x))))\n      (T (when (and (eq x list)\n                    (prog1 again? (setq again? T)))\n           (return (nreverse ans)))))))\n\n;; 試してみる\n\n;; 真正リスト\n(improper-list->proper-list '(foo bar baz))\n;=> (FOO BAR BAZ)\n\n;; 点対リスト\n(improper-list->proper-list '(foo bar . baz))\n;=> (FOO BAR BAZ)\n\n;; 循環リスト\n(let ((circl (list 'foo 'bar 'baz)))\n  (setf (cdr (last circl)) circl)\n  (improper-list->proper-list circl))\n;=> (FOO BAR BAZ)\n}}}\n\n* 議論\n\n- このコードだと、(foo #0=(bar baz . #0#)) のように途中で循環しているリストを与えたら無限ループに入っちゃいます。「うさぎと亀」アルゴリズムなどを使った方が良いでしょう。(直したらこのコメントは消しちゃって構いません)\n- (foo #0=(bar baz . #0#)) だと proper list なので (foo . #0=(bar baz . #0#)) ですよね。お手軽にチェックするならlist-lengthを使ってこういうのとかでしょうか。\n{{{\n(defun check-list (list)\n  (handler-case \n      (typecase (list-length list)\n        (null 'circular-list)\n        (number 'proper-list))\n    (type-error (c) 'dotted-list)))\n}}}\n")
("処理系を起動したディレクトリのパスネームを返す" . "(:ctime 1227447346 :cuser #f :mtime 1227447347 :muser #f)[[$$tag 入出力 パスネーム]]\n* 処理系を起動したディレクトリのパスネームを返す\n少なくともSBCL,CLISP,CMUCLではtruename関数で取得できます．\n{{{\n(truename \"./\")  ;=>#P\"処理系を起動したディレクトリ\"\n}}}\n各処理系でのカレントディレクトリの取得と設定は,以下のように行えます．\nSBCLなら\n{{{\n(sb-posix:getcwd) ;=>#P\"カレントディレクトリ\"\n(sb-posix:chdir #P\"設定したいディレクトリ\")\n}}}\nCLISPなら\n{{{\n(ext:default-directory) ;=>#P\"カレントディレクトリ\"\n(ext:cd #P\"設定したいディレクトリ\")\n}}}\nCMUCLなら\n{{{\n(extensions:default-directory) ;=>#P\"カレントディレクトリ\"\n(setf (extensions:default-directory) #P\"設定したいディレクトリ\")\n}}}\nカレントディレクトリの設定後に(truename \"./\")が返す値が変化しているかは処理系により異なるようです．\nまた，処理系によっては*default-pathname-defaults*に起動時のディレクトリが入っています．\n")
("ハッシュの要素数を取得する" . "(:ctime 1227413641 :cuser #f :mtime 1227413641 :muser #f)[[$$tag ハッシュ]]\n* ハッシュの要素数を取得する\nhash-table-countで要素数を取得することができます。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  (hash-table-count ht))\n;=> 3\n}}}\n")
(" %Tag:sequence" . "(1229668730)")
("連想リストを使う" . "(:ctime 1227518778 :cuser #f :mtime 1227518941 :muser #f)[[$$tag リスト]]\n\n対をリストにしたものを連想リスト（association list）([[alist]]とも呼ばれる)と呼びます。 Lisp では簡単なテーブルが必要な場合に[[ハッシュテーブル]]の代わりに、リストの要素である対の car をキーとし cdr を値とする連想リストをテーブルとして使うことがあります。要素が少ない場合にはハッシュ値の計算などのオーバーヘッドもあり、ハッシュテーブルの方が低速になることもあります。\n\n連想リストを生成する場合には単純に quote や list を使ったり、必要に応じて バッククォート を使ったりします。\n\n{{{\n(defparameter *alist*\n  '((one . 1)\n    (two . 2)\n    (three . 3)))\n}}}\n\n要素を追加するには cons を使います。\n\n{{{\n(cons (cons 'four 4) *alist*) \n;=> ((FOUR . 4) (ONE . 1) (TWO . 2) (THREE . 3))\n}}}\n\n便利な専用の関数として、acons があります。\n\n{{{\n(acons 'four 4 alist) \n;=> ((FOUR . 4) (ONE . 1) (TWO . 2) (THREE . 3))\n}}}\n\n連想リストの参照には assoc 関数を使います。与えられたオブジェクトとキーの一致をテストする為の関数は、:testキーワードで指定でき省略するとデフォルトのeqlが使用されます。\nまた、assoc-ifは、テストする関数を引数にとり結果が真となるものを返します。\n{{{\n(assoc 'one *alist*) \n;=> (ONE . 1)\n(assoc 'five *alist* :test #'eq) \n;=> nil\n(assoc-if (lambda (x) (eq x 'one)) *alist*) \n;=> (ONE . 1)\n}}}\nキーではなく、値の方で検索する場合には、rassocを利用します。\n{{{\n(rassoc 1 *alist*) \n;=> (ONE . 1)\n(rassoc-if (lambda (x) (eq x 1)) *alist*) \n;=> (ONE . 1)\n}}}\n\n;;値だけを取り出したい場合には\n;;\n;;{{{\n;;(import (rnrs) (srfi :2))\n;;\n;;(cond ((assq 'one alist) => cdr)\n;;      (else #f)) ; => 1\n;;\n;;(cond ((assq 'six alist) => cdr)\n;;      (else #f)) ; => #f\n;;\n;;(and-let* ((p (assq 'three alist)))\n;;  (cdr p)) ; => 3\n;;}}}\n\n")
("キーに関連付けられた値を取得する" . "(:ctime 1227413525 :cuser #f :mtime 1227413525 :muser #f)[[$$tag ハッシュ]]\n* キーに関連付けられた値を取得する\nキーに関連づけられた値を取得するにはgethash関数を使用します。指定したキーが存在しない場合、nilが返却されます。gethashは多値を返し、2値目で検索に成功したかをT/nilで返します。\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  (print (gethash \"apple\" ht))\n  (print (gethash \"banana\" ht))\n  (print (gethash \"lemon\" ht))\n  (print (gethash \"papaia\" ht)))\n;-> 150 \n    300 \n    300 \n    nil \n;=> nil\n}}}\n")
("インスタンス初期化時に複数のスロットを同じ値で埋めたい" . "(:ctime 1228011914 :cuser #f :mtime 1228011915 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* インスタンス初期化時に複数のスロットを同じ値で埋めたい\n\n複数のスロットの初期化引数に同じ名前を与えることが可能です。\n同名の初期化引数を持つスロットは同じ値で初期化されます。\n\n下記の例では、start、currentスロットの両方に初期化引数名:startを指定しています。\n{{{\n(defclass stopwatch () \n  ((start :initarg :start :reader start-time)\n   (current :initarg :start :accessor current-time)))\n\n(let ((obj (make-instance 'stopwatch :start (get-universal-time))))\n  (format t \"~A ==> ~A~%\" (start-time obj) (current-time obj))\n  (sleep 3)\n  (setf (current-time obj) (get-universal-time))\n  (format t \"~A ==> ~A~%\" (start-time obj) (current-time obj)))\n\n;-> 3437000414 ==> 3437000414\n;   3437000414 ==> 3437000417\n;=> nil\n}}}\n")
("リストを結合する" . "(:ctime 1227520956 :cuser #f :mtime 1227610857 :muser #f)[[$$tag リスト]]\n* リストを結合する\nリストを結合するには様々な方法があり、それぞれ性質が異なります。\n\nappend 新規のリストが作成されますが、最後の要素はコピーされたものではなく連結されたものになります。\n{{{\n(append '(1 2 3) '(a b c))\n;=> (1 2 3 A B C)\n\n(let* ((a (list 1 2 3))\n       (b (list 'a 'b 'c))\n       (c (list 'i 'ii 'iii))\n       (a+b (append a b)))\n  (nconc b c) ; bとcを破壊的に連結\n  a+b)\n;=> (1 2 3 A B C I II III)\n}}}\nconcatenate すべての要素が連結された新規のリストを返します。\n{{{\n(concatenate 'list '(1 2 3) '(a b c))\n;=> (1 2 3 A B C)\n\n(let* ((a (list 1 2 3))\n       (b (list 'a 'b 'c))\n       (c (list 'i 'ii 'iii))\n       (a+b (concatenate 'list a b)))\n  (nconc b c) ; bとcを破壊的に連結\n  a+b)\n;=> (1 2 3 A B C)\n}}}\nnconc 先頭のリストと後のリストを破壊的に結合します。結果としてリストは破壊的に修正されます。\n{{{\n(nconc (list 1 2 3) (list 4 5 6))\n;=> (1 2 3 4 5 6)\n\n(let ((a (list 1 2 3))\n      (b (list 'a 'b 'c)))\n  (nconc a b)\n  (list a b))\n;=> ((1 2 3 A B C) (A B C))\n}}}\n\nFIXME\n{{{\n`(,@(list 1 2 3) ,@(list 'a 'b 'c))\n;=> (1 2 3 A B C)\n}}}\nFIXME\n{{{\n`(,.(list 1 2 3) ,.(list 4 5 6))\n;=> (1 2 3 4 5 6)\n}}}\n")
(" %Tag:データベース" . "(1336190780)")
("配列の先頭または末尾から要素を取りだす" . "(:ctime 1228558271 :cuser #f :mtime 1228558271 :muser #f)[[$$tag 配列]]\n\n* 配列の先頭または末尾から要素を取りだす\n\nフィルポインタ付きのベクタは [[$$hs vector-pop]] で末尾から要素を取り出すことができ、取り出した要素の分ベクタは縮みます。\n{{{\n(let ((v (make-array 5 :adjustable T\n                       :fill-pointer 5\n                       :initial-contents '(1 2 3 4 5))))\n  (list (vector-pop v)\n        (vector-pop v)\n        (vector-pop v)\n        v))\n;=> (5 4 3 #(1 2))\n}}}\n先頭から取り出したい場合は、自作することになるでしょう。FIXME\n{{{\n(defun vector-pop-front (vec)\n  (prog1 (aref vec 0)\n         (replace vec vec :start2 1)\n         (decf (fill-pointer vec))))\n\n(let ((v (make-array 5 :adjustable T\n                       :fill-pointer 5\n                       :initial-contents '(1 2 3 4 5))))\n  (vector-pop-front v) ;=> 1\n  v)\n;=> #(2 3 4 5)\n}}}\n")
("繰り返しからの脱出" . "(:ctime 1227416045 :cuser #f :mtime 1229529032 :muser #f)[[$$tag 制御構造 【募集中】]]\n【募集中】\n\n** loopの場合\n通常の終了は loop-finish を使います。\n{{{\n(loop for i in '(1 2 3 4 5)\n      do (print i)\n         (loop-finish))\n}}}\n\nreturnキーワードでも脱出できます。\n{{{\n(loop for i in '(1 2 3 4 5)\n      do (print i)\n      return i)\n}}}\nreturn による脱出は finally キーワードで指定されたフォームが実行されないので、脱出というより中断的な意味合いになると思います。([[繰り返しの前処理・後処理]])\n\n無条件に脱出するのはあまり役に立たないので、普通は条件指定します。\n{{{\n(loop for i in '(1 2 3 4 5)\n      if (evenp i)\n      do (print i)\n         (loop-finish))\n}}}\n")
("時刻中の曜日を日本語に変換する" . "(:ctime 1227414645 :cuser #f :mtime 1228696999 :muser #f)[[$$tag 日付と時刻]]\n* 時刻中の曜日を日本語に変換する\ndecode-universal-timeの7番目の値が曜日を数値で表現したものになります。dayの値は0が月曜日で、6が日曜日に対応します。これにより、例えば以下のようにして曜日を日本語で得ることができます。\n{{{\n(defconstant +wdays+ #(\"月\" \"火\" \"水\" \"木\" \"金\" \"土\" \"日\"))\n\n(format nil \n        \"今日は、~A曜日です。\"\n        (aref +wdays+\n              (nth-value 6\n                (decode-universal-time (get-universal-time)))))\n\n;=> \"今日は、金曜日です。\"\n}}}\n")
(" %Tag:c2mop" . "(1339092247 (\"インスタンス生成を記録しておき後で条件を満すものを抽出したい\" :ctime 1227530644 :cuser #f :mtime 1227531695 :muser #f))")
("現在の日付を求める" . "(:ctime 1227414677 :cuser #f :mtime 1227947512 :muser #f)[[$$tag 日付と時刻 metatilities]]\n* 現在の日付を求める\n自作するか、ライブラリを使用する。下記では、[[ライブラリ:Metatilities]]を利用\n{{{\n(metatilities:date-string)\n;=>\"Saturday, November 22, 2008\"\n\n(metatilities:date-string-brief)\n;=> \"11-22-2008\"\n}}}\n\nget-decoded-time は多値で秒、分、時、日、月、年、曜日、サマータイム、タイムゾーンを返すのでそれを利用することもできます。\n{{{\n(get-decoded-time)\n;=> 38\n;   28\n;   17\n;   29\n;   11\n;   2008\n;   5\n;   NIL\n;   -9\n(multiple-value-bind (second\n                      minute\n                      hour\n                      date\n                      month\n                      year\n                      day-of-weak\n                      daylight-p\n                      time-zone)\n    (get-decoded-time)\n  (format nil \"~d-~d-~d\" year month date))\n;=> \"2008-11-29\"\n}}}\n\n")
("文字列を一文字ずつ処理する" . "(:ctime 1227347873 :cuser #f :mtime 1317765736 :muser #f)http://rd.clojure-users.org/entry/view/76003\n")
("文字列の日付をUniversal Timeに変換する" . "(:ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f)[[$$tag 日付と時刻 metatilities net-telent-date local-time]]\n* 文字列の日付をUniversal Timeに変換する\nパーズするライブラリが様々存在するので利用できます。\n\n[[CLiki:Metatilities]]\n{{{\n(metatilities:parse-date-and-time \"Saturday, November 22, 2008\")\n;=> 3436268400\n}}}\n\n[[CLiki:net-telent-date]]\n{{{\n(date:parse-time \"Mon, 04 Jun 2001 17:16:05\")\n;=> 3200631365\n\n(date:parse-time \"Mon, 04 Jun 2001\")\n;=> 3200569200\n\n(date:parse-time \"1999/12/31\")\n;=> 3155554800\n}}}\n\n[[CLiki:local-time]]\n{{{\n;; ISO 8601形式\n(local-time:parse-timestring \"1985-04-12T23:20:50.52Z\")\n;=> @1985-04-12T23:20:50.520000Z\n}}}\n")
("Universal Timeを文字列に変換する" . "(:ctime 1227414526 :cuser #f :mtime 1227414526 :muser #f)[[$$tag 日付と時刻]]\n* Universal Timeを文字列に変換する\nライブラリで提供されていることも多い。[[ライブラリ:KMRCL]]等\n{{{\n(multiple-value-bind (sec min hr day mon year dow daylight-p zone)\n    (decode-universal-time 3436143023)\n  (declare (ignore daylight-p zone))\n  (format nil \"~[Mon~;Tue~;Wed~;Thu~;Fri~;Sat~;Sun~] ~d ~[Jan~;Feb~;Mar~;Apr~;May~;Jun~;Jul~;Aug~;Sep~;Oct~;Nov~;Dec~] ~d ~2,'0d:~2,'0d:~2,'0d\"\n          dow\n          day\n          (1- mon)\n          year\n          hr min sec))\n;=> \"Thu 20 Nov 2008 13:10:23\"\n}}}\n{{{\n(format nil \"~{~A~^-~}\" (reverse \n                       (butlast \n                        (multiple-value-list \n                            (decode-universal-time 3436143023))\n                        3)))\n;=> \"2008-11-20-13-10-23\"\n}}}\n")
("配列を任意の値で埋める" . "(:ctime 1228105446 :cuser #f :mtime 1228112194 :muser #f)[[$$tag 配列]]\n\n* 配列を任意の値で埋める\n\n[[$$hs fill]] はシークエンス全般に適用できます。:start と :end で範囲を指定できます。省略すればすべての要素が指定したアイテムで埋まります。\nまた、 [[$$hs fill]] は破壊的に変更された元の配列を返します。\n{{{\n(let ((v (vector 0 1 2 3 4 5 6 7 8 9)))\n  (fill v 88 :start 1 :end 4)\n  v)\n;=> #(0 88 88 88 4 5 6 7 8 9)\n}}}\n")
("リストの各要素をカンマ区切りで出力する" . "(:ctime 1229550300 :cuser #f :mtime 1317764158 :muser #f)\nhttp://rd.clojure-users.org/entry/view/72003\n")
("シンボル" . "(:ctime 1227906107 :cuser #f :mtime 1235474044 :muser #f)[[$$tag シンボル]]\n\n;; - [[シンボルの一覧を表示したい]]\n;; - [[キーワードを生成したい]]\n;; - [[関数に別名をつけたい]]\n;; - [[同一のインターンされないシンボルを複数個所で使う]]\n")
(" %Tag:開発環境" . "(1340436823 (\"マクロ展開を確認したい\" :ctime 1229603579 :cuser #f :mtime 1229603942 :muser #f) (\"逆アセンブルした結果を確認したい\" :ctime 1228810111 :cuser #f :mtime 1228810112 :muser #f) (\"マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい\" :ctime 1228627796 :cuser #f :mtime 1228627796 :muser #f))")
("四捨五入する" . "(:ctime 1228831221 :cuser #f :mtime 1317765438 :muser #f)http://rd.clojure-users.org/entry/view/69007\n")
("開発環境" . "(:ctime 1228626894 :cuser #f :mtime 1235474311 :muser #f)* 開発環境\n\n;; EmacsをインターフェースとするSLIME等、現在主流となっているものには、Emacs系が多いようです。\n;; \n;; * Emacs Lisp系\n;; - [[SLIME]]\n;; - [[ELI]]\n;; - [[ILISP]]\n;; \n;; * Vi系\n;; - [[Limp]]\n;; \n;; * IDEプラグイン系\n;; - [[Cusp]]\n;; \n;; * 独自系\n;; \n;; - [[ABLE]]\n;; \n;; * 処理系付属\n;; - LispWorksのエディタ\n;; - Allegro CLのIDE\n;; - Hemlock(MCL、Clozure CL)\n;; \n;; ----\n;; \n;; - [[マクロ展開を確認したい]]\n;; - [[マクロ再定義したのでそのマクロを利用している関数すべてをリコンパイルしたい]]\n;; - [[逆アセンブルした結果を確認したい]]\n")
(" %Tag:ANSI規定外" . "(1339100029 (\"asdf-installでインストールできるもの\" :ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f))")
("リクエスト" . "(:ctime 1227262129 :cuser #f :mtime 1235473962 :muser #f)* リクエスト と ネタ集積場\n\n** リクエスト\n[[$$comment]]\n")
(" %recent-changes" . "((\"|comments:リクエスト::002\" . 1317767597) (\"逆引きClojure\" . 1317766323) (\"部分文字列を取り出す\" . 1317765945) (\"文字列を Base64 エンコードする\" . 1317765808) (\"文字列を一文字ずつ処理する\" . 1317765736) (\"文字列を結合する\" . 1317765667) (\"大文字・小文字に揃える\" . 1317765604) (\"絶対値を求める\" . 1317765504) (\"四捨五入する\" . 1317765438) (\"乱数を生成する\" . 1317765367) (\"テキストファイルをオープンして内容を出力する\" . 1317765297) (\"簡単なDNSルックアップ\" . 1317765182) (\"数値を文字列に変換する\" . 1317765078) (\"ディレクトリ内のすべてのファイルを再帰的に処理する\" . 1317764975) (\"Leiningenをインストールする\" . 1317764879) (\"構造体を作成する\" . 1317764649) (\"構造体のキーに関連付けられた値を取得する\" . 1317764246) (\"リストの各要素をカンマ区切りで出力する\" . 1317764158) (\"正規表現で文字列を分割する\" . 1317764065) (\"環境変数を取得する\" . 1317763959) (\"URIエンコード\" . 1317763635) (\"ライブラリをロードする\" . 1317763552) (\"文字列を数値に変換する\" . 1317763435) (\"Clojureのバージョンを調べる\" . 1317763346) (\"リストを逆順にする\" . 1317763248) (\"ネストされたシーケンスをフラットにする\" . 1317763130) (\"現在読み込まれているライブラリを確認する\" . 1317762970) (\"シーケンスからXMLを生成する\" . 1317762793) (\"cljスクリプトを用意する\" . 1317762613) (\"特定のURLからドキュメントを抽出する\" . 1317762038) (\"リクエスト\" . 1277746697) (\"編集に関する基本方針\" . 1270598027) (\"リストの要素数を取得する\" . 1235480699) (\"リスト\" . 1235480493) (\"リストを作成する\" . 1235478875) (\"その他\" . 1235474397) (\"コーディングスタイル\" . 1235474378) (\"最適化\" . 1235474325) (\"開発環境\" . 1235474311) (\"ライブラリ管理\" . 1235474294) (\"ライブラリ\" . 1235474271) (\"Webオートメーション\" . 1235474258) (\"インターネットサービス\" . 1235474247) (\"スレッド\" . 1235474220) (\"パッケージ\" . 1235474199) (\"マクロ\" . 1235474188) (\"関数\" . 1235474177) (\"入出力\" . 1235474167) (\"コンディション\" . 1235474157))")
("配列をソートする" . "(:ctime 1228095583 :cuser #f :mtime 1228112150 :muser #f)[[$$tag 配列 ベクタ]]\n\n[[$$hs sort]] はシーケンス全般に使えますので、ベクタ(一次元のアレイ)にも利用できます。\n\n[[$$hs sort]] は破壊的に変更しますので元のベクタを破壊したくない場合は、コピーしたものを渡します。\nまた、値を生成するための変更になりますので破壊されたベクタが結果の内容と一致している必要はありません。そのため場合によっては再度変数に結果を代入する必要があります。\n{{{\n(let ((v (vector 1 3 2 4)))\n  (setq v (sort v #'<))\n  v)\n;=> #(1 2 3 4)\n\n(let ((v (vector \"はちべえ\" \"やしち\" \"かくさん\" \"すけさん\")))\n  (setq v (sort v #'string<))\n  v)\n;=> #(\"かくさん\" \"すけさん\" \"はちべえ\" \"やしち\")\n}}}\n")
(" %Tag:構造体" . "(1338214008 (\"構造体\" :ctime 1229599940 :cuser #f :mtime 1235474105 :muser #f))")
("オブジェクトの初期化を行う" . "(:ctime 1229748239 :cuser #f :mtime 1229748296 :muser #f)[[$$tag オブジェクトシステム(CLOS) ]]\n\n* オブジェクトの初期化を行う\n\n[[$$hs defclass]] で定義する際に初期値を設定することが可能です。\n初期値の指定には、:initform、:initarg、:default-initargs等を状況に応じて使い分けます。\n# :initform で指定した値はインスタンスが作成された時や、クラスを変更して新しく追加されたスロットの初期値となります。\n# :initargは [[$$hs make-instance]] でのインスタンス作成時に指定するキーワードを指定します。\n# :default-initargs は、インスタンス作成時にキーワードでの初期値設定が省略された場合のデフォルト値をplist形式で設定します。\n{{{\n(defclass foo ()\n  ((x :initform 0)\n   (y :initform 10\n      :initarg :y)\n   (z :initarg :z))\n  (:default-initargs :z 100))\n\n(describe (make-instance 'foo))\n;-> #<FOO 20095F07> is a FOO\n;   X      0\n;   Y      10\n;   Z      100\n\n;; キーワードにより初期値を与える。\n;; (xスロットは:initargを設定していないため、この方法では初期値を設定できない)\n(describe (make-instance 'foo :y 20 :z 30))\n;-> #<FOO 232B438B> is a FOO\n;   X      0\n;   Y      20\n;   Z      30\n\n(defclass bar ()\n  ((x :initform 1)\n   (y :initform 2)\n   (z :initform 3)\n   (a :initarg :a))\n  (:default-initargs :a 4))\n\n(describe (change-class (make-instance 'foo) 'bar))\n\n;-> #<BAR 232FA22B> is a BAR\n;   X      0\n;   Y      10\n;   Z      100\n;   A      #<unbound slot>\n}}}\nまた、オブジェクトの生成は[[$$hs make-instance]]メソッドで行いますが、[[$$hs make-instance]]メソッドは、初期化のために [[$$hs initialize-instance]] を呼び出しますのでカスタマイズしたい場合には、[[$$hs initialize-instance]]に:afterメソッドを追加することが一般的に行なわれています。\n\n** 関連\n[[インスタンス作成時にあるスロットの値を元に他のスロットの値を初期化したい]]\n")
("仕様/ドキュメント" . "(:ctime 1227970340 :cuser #f :mtime 1229515250 :muser #f)[[$$tag 仕様/ドキュメント]]\n\n- [[Tag:参考文献]]\n- [[ドキュメンテーション]]\n- [[ドキュメント生成]]\n")
("インスタンス変数・クラス変数を定義する" . "(:ctime 1230290536 :cuser #f :mtime 1230290689 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* インスタンス変数・クラス変数を定義する\n\nインスタンス変数・クラス変数の違いは、[[$$hs defclass]]でのスロットの定義で :allocation に:classか:instanceを指定することにより定義します。 :allocation の指定が省略された場合は、:instanceの指定となります。\n{{{\n(defclass foo ()\n  ((class-var :initform () \n              :allocation :class\n              :accessor class-var)\n   (instance-var :initform () \n                 :allocation :instance\n                 :accessor instance-var)))\n\n(let ((foo-1 (make-instance 'foo))\n      (foo-2 (make-instance 'foo)))\n\n  ;; foo-1の値を変更\n  (setf (class-var foo-1) 100\n        (instance-var foo-1) 50)\n\n  ;; foo-2の値を確認\n  (list (class-var foo-2)\n        (instance-var foo-2)))\n;=> (100 NIL)\n}}}\nクラス変数とした場合、継承した子クラスの同名スロットを変更すると親クラスのスロットまで変更されるので、これを意図しない場合注意が必要です。\n{{{\n(defclass bar (foo) ())\n\n(let ((foo-1 (make-instance 'foo))      \n      (bar-1 (make-instance 'bar)))\n\n  ;; foo-1のclass-varに100を設定\n  (setf (class-var foo-1) 100)\n\n  ;; bar-1の値を変更\n  (setf (class-var bar-1) 'bar\n        (instance-var bar-1) 50)\n\n  ;; foo-1の値を確認\n  (list (class-var foo-1)\n        (instance-var foo-1)))\n;=> (BAR NIL)\n}}}\n上記を回避するには、子クラスで再度スロットの定義をし、インスタンス変数であることを明記する必要があります。\n{{{\n(defclass baz (foo) \n  (;; allocation指定を省略するとデフォルトは:instance\n   (class-var :accessor class-var))) \n\n(let ((foo-1 (make-instance 'foo))      \n      (baz-1 (make-instance 'baz)))\n\n  ;; foo-1のclass-varに100を設定\n  (setf (class-var foo-1) 100)\n\n  ;; baz-1の値を変更\n  (setf (class-var baz-1) 'baz\n        (instance-var baz-1) 50)\n\n  ;; foo-1の値を確認\n  (list (class-var foo-1)\n        (instance-var foo-1)))\n;=> (100 NIL)\n}}}\n")
("文字列を一行ずつ処理する" . "(:ctime 1227347907 :cuser #f :mtime 1227347907 :muser #f)[[$$tag 文字列 シーケンス]]\n* 文字列を一行ずつ処理する\n{{{\n(with-input-from-string (in \"abc\ndef\nghi\")\n  (loop :for line := (read-line in nil nil) :while line\n        :do (print line)))\n\n;-> \"abc\" \n    \"def\" \n    \"ghi\" \n;=> nil\n}}}\n")
(" %Tag:alexandria" . "(1338307638 (\"プログラム中でハッシュを定義する\" :ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f))")
("対数を計算する" . "(:ctime 1230695185 :cuser #f :mtime 1230695227 :muser #f)[[$$tag 数値]]\n\n* 対数を計算する\n\n対数を計算するための関数には、[[$$hs exp]]、[[$$hs log]]等々が提供されています。FIXME\n\n([[$$hs log]] number &optional base)はbaseを底とするnumberの対数を返します。\n{{{\n(log 10 10)\n;=> 1.0\n}}}\n([[$$hs exp]] number)はeのn乗を返します。\n{{{\n(exp 0) ;=> 1.0\n}}}\n")
("一時変数を使わずに値を交換する" . "(:ctime 1230918931 :cuser #f :mtime 1230918931 :muser #f)[[$$tag 制御構造]]\n\n* 一時変数を使わずに値を交換する\n\n様々な方法がありますが、主に[[$$hs rotatef]]を使う方法が一般的でしょう。\n下記はそれぞれマクロで結果は大体同じようなものに展開されます。\n{{{\n(let ((x 10) (y 20))\n  (rotatef x y)\n  (list x y))\n;=> (20 10)\n\n(let ((x 10) (y 20))\n  (psetq x y y x)\n  (list x y))\n;=> (20 10)\n\n(let ((x 10) (y 20))\n  (setf (values x y) (values y x))\n  (list x y))\n;=> (20 10)\n\n(let ((x 10) (y 20))\n  (multiple-value-setq (x y) (values y x))\n  (list x y))\n;=> (20 10)\n}}}\nまれに[[$$hs prog2]]を利用したコードに遭遇することがありますが、Common Lisp以前のイディオムです。\n{{{\n;; 太古のイディオム\n(let ((x 10) (y 20))\n  ;; 太古にはprog1が存在しなかったためprog2\n  (setq x (prog2 nil y (setq y x))) \n  (list x y))\n;=> (20 10)\n}}}\n\n")
("リストの各要素に手続きを適用する" . "(:ctime 1229558079 :cuser #f :mtime 1229600569 :muser #f)[[$$tag リスト]]\n\n[[$$hs map]]を使う方法です。\n{{{\n(map 'list '1+ '(1 2 3))   ;=> (2 3 4)\n(map 'vector '1+ '(1 2 3)) ;=> #(2 3 4)\n\n(map 'list 'cons '(1 2 3) '(4 5 6))\n;=> ((1 . 4) (2 . 5) (3 . 6))\n}}}\n\n[[$$hs mapcar]]を使う方法です。\n{{{\n(mapcar #'1+ '(1 2 3))   ;=> (2 3 4)\n;#'1+ は、'1+ でもいいです。\n(mapcar #'cons '(1 2 3) '(4 5 6))\n;=> ((1 . 4) (2 . 5) (3 . 6))\n}}}\n\n[[$$hs loop]]を使う方法です。\n{{{\n(loop for i in '(1 2 3) collect (1+ i)) ;=> (2 3 4)\n\n(loop for i in '(1 2 3)\n      for j in '(4 5 6)\n      collect (cons i j))\n;=> ((1 . 4) (2 . 5) (3 . 6))\n}}}\n")
("ハッシュのキーと値を反転する" . "(:ctime 1231474598 :cuser #f :mtime 1231474872 :muser #f)[[$$tag ハッシュテーブル]]\n\n* ハッシュのキーと値を反転する\n\n値からキーを検索したいことがありますが、キーと値の逆転は下記のように書けるでしょう。(FIXME)\n\nキーと値の両方から検索する場合、[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#association_list alist]と[[$$hs assoc]]/[[$$hs rassoc]]の組み合わせも検討できるでしょう。\n{{{\n;; 逆転に際してキーの重複は後のものが有効\n(defun invert (table &key (test #'eql))\n  (let ((newtab (make-hash-table :test test)))\n    (maphash (lambda (k v)\n               (setf (gethash v newtab) k))\n             table)\n    newtab))\n\n;; 実行例\n(let ((turtles (alexandria:plist-hash-table\n                '(Howard-Kaylan (Musician Lead-Singer)\n                  John-Barbata  (Musician Drummer)\n                  Leonardo      (Ninja Leader Blue)\n                  Donatello     (Ninja Machines Purple)\n                  Al-Nichol     (Musician Guitarist)\n                  Mark-Volman   (Musician Great-Hair)\n                  Raphael       (Ninja Cool Rude Red)\n                  Michaelangelo (Ninja Party-Dude Orange)\n                  Jim-Pons      (Musician Bassist)))))\n\n  (gethash '(musician bassist) (invert turtles :test #'equal)))\n;=> JIM-PONS\n;   T\n}}}\n\n** 議論\n")
(" %Tag:Webオートメーション" . "(1338213291 (\"Webオートメーション\" :ctime 1231579501 :cuser #f :mtime 1235474258 :muser #f) (\"ページの最終更新日を調べる\" :ctime 1231832109 :cuser #f :mtime 1231833970 :muser #f) (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
(" %Tag:§" . "(1307922942)")
("シンボルの一覧を表示したい" . "(:ctime 1228125924 :cuser #f :mtime 1228125924 :muser #f)CLではシンボルは、見える化いじれる化がされています。~%\n現在のパッケージに含まれているシンボルを確認したいとか、シンボルについてまとめて処理をしたいときなどはdo-symbolsを使います。最も簡単な例として一覧表示の場合を記載します。\n\n{{{\n(do-symbols (sym)\n  (print sym))\n}}}\n\n")
("多次元の配列を1つのインデックスで扱う" . "(:ctime 1233973763 :cuser #f :mtime 1234161455 :muser #f)[[$$tag 配列]]\n\n[[$$hs row-major-aref]]を利用すれば、多次元の配列を1つのインデックスで扱うことができます。\n{{{\n(let ((a10x10 (make-array '(10 10))))\n  (dotimes (i (floor (array-total-size a10x10) 2))\n    (setf (row-major-aref a10x10 i) 1))\n  a10x10)\n;=> #2A((1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (1 1 1 1 1 1 1 1 1 1)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0)\n;       (0 0 0 0 0 0 0 0 0 0))\n}}}\n\n上記は、[[$$hs make-array]]のオプションである:displaced-toを利用し、元の多次元配列をベクタにマッピングしたものと同様の効果を持ちます。\n{{{\n(let* ((a10x10 (make-array '(10 10)))\n       (a100 (make-array 100 :displaced-to a10x10)))\n  (dotimes (i 50)\n    (setf (aref a100 i) 1))\n  a10x10)\n}}}\n** 議論\n")
("文字列の中に「hoge」が含まれている場合、その開始位置を知るには" . "(:ctime 1227690765 :cuser #f :mtime 1228304424 :muser #f)[[$$tag 文字列 cl-ppcre ライブラリ]]\n* 文字列の中に「hoge」が含まれている場合、その開始位置を知るには\n文字列はシーケンスですので、[[$$hs search]]が利用できます。\n{{{\n(search seq-s seq)\n以下の指定ができます。\n:from-end bool\n:test function\n:test-not function\n:start1 position\n:start2 position\n:end1 position\n:end2 position\n:key function\n}}}\n{{{\n(search \"hoge\" \"foo bar hoge hage huge hege\")\n;=>8\n}}}\n[[ライブラリ:cl-ppcre]]を利用した例\n{{{\nscan書式\n(scan regex target-string &key start end)\n => match-start, match-end, reg-starts, reg-ends\n}}}\n{{{\n(ppcre:scan \"(はちべえ)\" \"すけさんかくさんはちべえやしち\")\n;=> 8    ;マッチ開始位置\n;   12   ;マッチ終了位置\n;   #(8) ;マッチレジスタ開始位置 FIXME\n;   #(12);マッチレジスタ終了位置 \n}}}\n\n")
("末尾呼び出しの最適化" . "(:ctime 1228171120 :cuser #f :mtime 1228812122 :muser #f)[[$$tag 最適化]]\n\n* 末尾呼び出しの最適化\n\nSchemeと異なり、ANSI Common Lispでは、末尾呼び出しの最適化は仕様で要求されていないため、処理系により最適化の条件/状況が異なります。\n下記のClikiのまとめを参照して下さい。\n- [[CLiki:Tail Recursion]]\n")
("テキストファイルをオープンして内容を出力する" . "(:ctime 1227871186 :cuser #f :mtime 1317765297 :muser #f)http://rd.clojure-users.org/entry/view/73003\n")
(" %Tag:ベクタ" . "(1340822613 (\"配列をソートする\" :ctime 1228095583 :cuser #f :mtime 1228112150 :muser #f))")
("ライブラリ" . "(:ctime 1227239160 :cuser #f :mtime 1235474271 :muser #f)[[$$toc]]\n;; * 総合ユーティリティ系\n;; - [[Tag:kmrcl]]\n;; - [[Tag:fare-utils]]\n;; - [[Tag:arnesi]]\n;; - [[Tag:metatilities]]\n;; * 文字列操作\n;; - [[Tag:cl-ppcre]]\n;; - [[Tag:cl-interpol]]\n;; * インターネットサービス\n;; - [[Tag:drakma]]\n;; - [[Tag:url-rewrite]]\n;; \n;; \n")
(" %Tag:local-time" . "(1335319037 (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f))")
("リスト構造を分解して変数に代入する" . "(:ctime 1229602567 :cuser #f :mtime 1229602567 :muser #f)[[$$tag 制御構造]]\n\nリストを形(木構造)に着目して要素に分解して、それぞれを変数に束縛できます。\n{{{\n(destructuring-bind ((a b &key k) ((c &rest d)))\n    '((1 2 :k 0) ((3 4 5)))\n  (list k a b c d))\n;=> (0 1 2 3 (4 5))\n}}}\n\nリストの入れ子構造の解析だけでなく、関数定義[[$$hs defun]]のラムダリストのようにキーワードパラメタやレストパラメタの解析もできます。\n")
("複数の要素を変更する" . "(:ctime 1228748252 :cuser #f :mtime 1228748509 :muser #f)[[$$tag 配列]]\n\n* 複数の要素を変更する\n\n[[$$hs setf]] とsetfを組み合わせることにより読み出した列に値を格納できます。\n格納する値が切り出した配列のサイズより大きい場合は、切り出したサイズに切り詰められます。\n{{{\n(let ((a (vector 1 2 3 4 5)))\n  (setf (subseq a 2)\n        (nreverse (subseq a 2)))\n  a)\n;=> #(1 2 5 4 3)\n\n(let ((a (vector 1 2 3 4 5)))\n  (setf (subseq a 2)\n        #(a b c d e f g))\n  a)\n;=> #(1 2 A B C)\n}}}\n")
("条件判断(if スペシャルフォーム)" . "(:ctime 1228888390 :cuser #f :mtime 1228888391 :muser #f)[[$$tag 制御構造]]\n* 条件判断(if :スペシャルフォーム)\nif文は条件式を評価し結果が真であればthen部を実行し、真でなければelseで指定した式を実行します。構文と例を以下に示します。\n{{{\n■構文\n(if 条件式 [then] [else])\n}}}\n{{{\n■例\n(if (= a 0)\n    (format t \"a is zero.\")\n    (if (< a 0)\n        (format t \"a is negative.\")\n        (format t \"a = ~A\" a)))\n}}}\n")
("切れたリンクを見つける" . "(:ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f)[[$$tag Webオートメーション ライブラリ closure-html drakma puri]]\n\n* 切れたリンクを見つける\n\n[[CLiki:DRAKMA]]のようなウェブクライアントには一通りの機能が揃っていますので、このようなクライアントとページからのリンクの切り出しを組み合わせて実現できるでしょう。\n\n下記の例では、[[CLiki:DRAKMA]]、[[CLiki:closure-html]]、[[CLiki:PURI]]を利用しています。\n{{{\n;; 素朴な実装\n(defun churl (url &optional (out *standard-output*))\n  (format out \"~A:~%\" url)\n  (dolist (u (get-links url))\n    (destructuring-bind (name link) u\n      (declare (ignore name))\n      (unless (search \"mailto:\" link)\n        (let ((stat (http-request-stat\n                     (drakma:http-request (puri:merge-uris link url)\n                                          :method :head\n                                          :force-binary T))))\n          (format out \"~2T~A: ~D~%\" link stat))))))\n\n(defmacro http-request-stat (req)\n  `(nth-value 6 ,req))\n\n(defun get-links (url)\n  (let* ((page (drakma:http-request url))\n         (doc (chtml:parse page (cxml-stp:make-builder)))\n         (ans () ))\n    (stp:do-recursively (a doc)\n      (when (and (typep a 'stp:element)\n                 (equal (stp:local-name a) \"a\"))\n        (push (list (stp:string-value a)\n                    (stp:attribute-value a \"href\"))\n              ans)))\n    ans))\n}}}\n{{{\n;; 実行例\n(churl \"http://www.lisp.org/alu/home\")\n\n;-> http://www.lisp.org/alu/home:\n;     http://www.franz.com/support/tech_corner/using-webactions.html:  OK\n;     http://allegroserve.sourceforge.net: OK\n;     http://www.lispworks.com/products/ilc-goodies.html: OK\n;     http://www.international-lisp-conference.org/2007/:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-contact:  OK\n;     http://www.international-lisp-conference.org/:  OK\n;     http://www.international-lisp-conference.org/:  OK\n;     http://planet.lisp.org: OK\n;     http://wiki.alu.org: Not Found\n;     /alu/~19782bb4773d45b47701c907~/res-research:  OK\n;     /alu/~19782bb4773d45b47701c907~/res-local:  OK\n;     /alu/~19782bb4773d45b47701c907~/res-lisp:  OK\n;     http://www.alu.org/mailman/listinfo:  OK\n;     http://wiki.alu.org/: Not Found\n;     /alu/~19782bb4773d45b47701c907~/conf-all:  OK\n;     /alu/~19782bb4773d45b47701c907~/conf-lugm:  OK\n;     http://www.international-lisp-conference.org/2002/:  OK\n;     http://www.international-lisp-conference.org/2003/index.html:  OK\n;     http://www.international-lisp-conference.org/2005/:  OK\n;     http://www.international-lisp-conference.org/2007/:  OK\n;     http://www.international-lisp-conference.org/2009/:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-contact:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-membership:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-sponsors:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-minutes:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-board:  OK\n;     /alu/~19782bb4773d45b47701c907~/alu-history:  OK\n;     http://www.alu.org:  OK\n;=> NIL\n}}}\n\n** 議論\n")
("2つの時刻の差を求める" . "(:ctime 1227414623 :cuser #f :mtime 1227414623 :muser #f)[[$$tag 日付と時刻]]\n* 2つの時刻の差を求める\n秒数を表す数値なので、加減算は自由にできる。\n{{{\n;; 2000/1/1から現時刻までの秒数\n(- (get-universal-time)\n   (encode-universal-time 0 0 0 1 1 2000))\n;=> 280679398\n}}}\n")
(" %Tag:cl-ppcre" . "(1338391937 (\"プログラムの出力を収集する\" :ctime 1230407977 :cuser #f :mtime 1230408268 :muser #f) (\"文字列の中に「hoge」が含まれている場合、その開始位置を知るには\" :ctime 1227690765 :cuser #f :mtime 1228304424 :muser #f))")
(" %Tag:MOP" . "(1340716475 (\"匿名クラスをつくりたい\" :ctime 1230011124 :cuser #f :mtime 1230029900 :muser #f) (\"インスタンス生成を記録しておき後で条件を満すものを抽出したい\" :ctime 1227530644 :cuser #f :mtime 1227531695 :muser #f))")
("ライセンスについて" . "(:ctime 1227334285 :cuser #f :mtime 1227542200 :muser #f)[[$$toc]]\n* 逆引きCommon Lispのライセンスについて\nクリエイティブコモンズライセンス [http://creativecommons.org/licenses/by/2.1/jp/ 表示2.1] とします。\nコード/説明文中のクレジットについては、投稿者はクレジット表示の必要なしと意思表示した上で書き込んでいますので表示の必要はありません。\n\n")
(" %Tag:関数" . "(1340178357 (\"関数\" :ctime 1228173344 :cuser #f :mtime 1235474177 :muser #f) (\"SETF関数を取り出す\" :ctime 1233974927 :cuser #f :mtime 1233975138 :muser #f) (\"引数のリストに関数を適用する\" :ctime 1230115720 :cuser #f :mtime 1230115720 :muser #f) (\"一定の値を返す関数を得る\" :ctime 1229257495 :cuser #f :mtime 1229257495 :muser #f) (\"状態を持った手続きを作る\" :ctime 1228173536 :cuser #f :mtime 1228173569 :muser #f))")
("クラスを定義する" . "(:ctime 1229668892 :cuser #f :mtime 1229668892 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* クラスを定義する\n\nクラスを定義するには、 [[$$hs defclass]] を使用します。\n[[$$hs defclass]] には様々なオプションがありますが、最も簡単な定義は下記のようなものになるでしょう。\n\nまた、スーパークラスの指定を省略した場合、 [[$$hs standard-object]] をスーパークラスに指定したことになります。\n{{{\n;; 構文\n(defclass クラス名 (スーパークラス*)\n  (スロット*))\n\n;; 例\nx yというスロットを持つfooクラスを定義\n(defclass foo () \n  (x y))\n\n(defclass bar (foo) ;fooを継承\n  (z))\n\n;; 確かめる\n(describe (make-instance 'bar))\n;-> #<BAR 23498C67> is a BAR\n;   Z      #<unbound slot>\n;   X      #<unbound slot>\n;   Y      #<unbound slot>\n}}}\n")
("同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい" . "(:ctime 1228012693 :cuser #f :mtime 1228012694 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n* 同じスロットに読み書きできるアクセサと読み出し専用のアクセサをつけたい\n\ndefclassの定義で一つのスロットに複数のアクセサを記述することが可能です。\nまた、総称関数を別に定義することでも可能です。\n{{{\n(defclass foo ()\n  ((x :initform 42\n      :accessor foo-accessor\n      :reader foo-reader)))\n\n(defparameter *obj* (make-instance 'foo))\n\n(foo-reader *obj*)\n;=> 42\n(setf (foo-accessor *obj*) 100)\n\n(foo-accessor *obj*)\n;=> 100\n\n(setf (foo-reader *obj*) 200)\n;-> error The function (SETF FOO-READER) is undefined.\n}}}\n")
(" %Tag:url-rewrite" . "(1318384624)")
("SLIME" . "(:ctime 1229489124 :cuser #f :mtime 1229489124 :muser #f)[[$$tag SLIME]]\n\n- [[SLIME:日本語関係の設定]]\n")
("キーワードを生成したい" . "(:ctime 1227906421 :cuser #f :mtime 1227906474 :muser #f)[[$$tag シンボル]]\n\n* キーワードを生成したい\n\n{{{\n(intern \"FOO\" :keyword)\n;=> :FOO\n}}}\n\n':fooのようなシンボルはkeywordパッケージのシンボルの略記で、'keyword:fooの略記ともみなせますので、keywordパッケージにインターンすることによって作成します。\n{{{\n(intern \":FOO\")\n}}}\nとしても|:FOO|というシンボルが作成されるだけですので注意してください。\n")
(" %Tag:metatilities" . "(1340414727 (\"文字列の日付をUniversal Timeに変換する\" :ctime 1227414826 :cuser #f :mtime 1231835076 :muser #f) (\"現在の日付を求める\" :ctime 1227414677 :cuser #f :mtime 1227947512 :muser #f) (\"うるう年かどうか判定する\" :ctime 1227414804 :cuser #f :mtime 1227714916 :muser #f) (\"月の最後の日を調べる\" :ctime 1227414848 :cuser #f :mtime 1227425023 :muser #f))")
("ストリームを扱うように出力先としてシーケンスを指定したい" . "(:ctime 1228565141 :cuser #f :mtime 1228565141 :muser #f)[[$$tag 入出力 ライブラリ flexi-streams]]\n\n* ストリームを扱うように出力先としてシーケンスを指定したい\n\n自作するかライブラリを利用します。\n\n下記の例では、 [[ライブラリ:flexi-streams]]を利用しています。\n{{{\n(flexi-streams:with-output-to-sequence (out :as-list t)\n  (loop for i across (flexi-streams:string-to-octets \"あいう\" :external-format :utf-8)\n        do (write-byte i out)))\n;=> (227 129 130 227 129 132 227 129 134)\n}}}\n")
(" %Tag:closure-html" . "(1338815167 (\"切れたリンクを見つける\" :ctime 1231579919 :cuser #f :mtime 1231827406 :muser #f))")
("キーが存在しない場合のデフォルト値を設定する" . "(:ctime 1227413661 :cuser #f :mtime 1227413661 :muser #f)[[$$tag ハッシュ]]\n* キーが存在しない場合のデフォルト値を設定する\nハッシュテーブルのデフォルト値は処理系依存になっています。~%\n-[http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_has.htm make-hash-table]~%\nデフォルトの値を設定しキーが存在しない場合に返すとすると、2値目を判定して動作する、下記のようなコードが考えられるでしょう。\n{{{\n(let ((ht (make-hash-table :test #'equal))\n      (default 100))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300)\n  (multiple-value-bind (val win) (gethash \"papaia\" ht)\n    (if win val default)))\n;=> 100\n}}}\n")
("大文字と小文字を入れ替える" . "(:ctime 1231317189 :cuser #f :mtime 1231317189 :muser #f)[[$$tag 文字列]]\n\n* 大文字と小文字を入れ替える\n\n標準で大文字と小文字を入れ替える方法はありませんので自作するかライブラリを利用することになるでしょう。\n\n文字列/文字の大文字/小文字変換については、[[$$hs string-upcase]]、[[$$hs char-upcase]]等の仲間が利用できます。\n{{{\n(defun string-invertcase (str)\n  (map 'string (lambda (x y)\n                 (if (eql x y) \n                     (char-downcase x)\n                     y))\n       str\n       (string-upcase str)))\n\n(string-invertcase \"Hi, CLer\")\n;=> \"hI, clER\"\n}}}\n\n大文字小文字については、Schemeの様にASCII以外に決まっているということもありませんので、ASCIIの範囲でのみ有効になります。\n")
("配列をリストに変換する" . "(:ctime 1234352506 :cuser #f :mtime 1234352916 :muser #f)[[$$tag 配列]]\n\n1次元の配列であるベクタをリストに変換するには、[[$$hs coerce]]を利用します。\n{{{\n(coerce #(1 2 3 4) 'list)\n;=> (1 2 3 4)\n}}}\n多次元配列の場合は、ライブラリを利用するか自作することになるでしょう\n{{{\n(import 'mycl-util:group) ; On Lispのgroup\n(import 'mycl-util:single); On Lispのsingle\n\n;; (group-n-dim '(1 2 3 4) '(2 2)) ;=> '((1 2) (3 4))\n(defun group-n-dim (list dim)\n  (if (single dim)\n      list\n      (group-n-dim (group list (car (last dim)))\n                   (butlast dim))))\n\n(defun array->list (array)\n  (let ((vec (make-array (array-total-size array)\n                         :displaced-to array)))\n    (group-n-dim (coerce vec 'list)\n                 (array-dimensions array))))\n}}}\n{{{\n;; 動作例\n(array->list #2a((1 2) (3 4)))\n;=> ((1 2) (3 4))\n}}}\n** 注記(編集する方へ)\n多次元の配列→リストへの変換でANSI標準のもの(もしくは、良く知られたライブラリ)があったら記述を置き換えてください。\n** 議論\n\n")
("シーケンスからXMLを生成する" . "(:ctime 1271266909 :cuser #f :mtime 1317762793 :muser #f)- http://rd.clojure-users.org/entry/view/71001\n")
("部分文字列を取り出す" . "(:ctime 1227347845 :cuser #f :mtime 1317765945 :muser #f)\nhttp://rd.clojure-users.org/entry/view/70004\n")
("配列から重複した要素を取り除く" . "(:ctime 1228889087 :cuser #f :mtime 1228889113 :muser #f)[[$$tag 配列]]\n\n* 配列から重複した要素を取り除く\n\nremove-duplicates や delete-duplicates を使います。\ndelete-duplicates は引数として与えられたリストの内容を処理系が返り値を効率よく作成するために破壊しても構わないことになっています。\n\nまた、値をテストするための関数を :test キーワードにて与えることができます。(デフォルトではeql)\n\n返り値のリストは、基本では、前に出現した重複分が消去されますので、前のものを優先したい場合は、 :from-end に非nil値を与えます。\n{{{\n(remove-duplicates #(\"abc\" \"cba\" \"abc\") :test #'equal) \n;=> #(\"cba\" \"abc\")\n\n(remove-duplicates #(\"abc\" \"cba\" \"abc\") :test #'equal :from-end T) \n;=> #(\"abc\" \"cba\")\n\n(let ((a (copy-seq #(a b c a a b a c))))\n  (list (delete-duplicates a)\n        a))\n;=> (#(B A C) #(A B C A A B A C)) \n}}}\n")
("新規ページ作成の手順" . "(:ctime 1227422988 :cuser #f :mtime 1228111845 :muser #f)* 新規ページ作成の手順\n# 項目のページに新しいエントリを作成します。\n{{{\n[[文字列を複製]] \n}}}\n# ?をクリックして編集を開始します。\n# 雛型を参考に作成します。ライブラリを利用する場合は、ライブラリ名と「ライブラリ」タグをタグ名に追加します。\n{{{\n[[$$tag タグ名 ライブラリ名 ライブラリ]]\n* タイトル\n\n...\n}}}\n* 項目だけ作成して、内容は募集したい場合\nタグに【募集中】といれます。\n{{{\n[[$$tag タグ【募集中】]]\n* タイトル\n\n...\n}}}\n* 参考文献\n1文献1ページとし、タグに 参考文献 といれます。\n{{{\n[[$$tag 参考文献]]\nドキュメント/書籍の説明 ...\n...\n}}}\n* HyperSpec へのリンク\n{{{\n[[$$hs format]]\n}}}\nのように書くとHyperSpecへのリンクになります。\n同様に\n{{{\n[[$$mop compute-slots]]\n}}}\nと書くと、MOPへのリンクになります。\n\n")
(" %Tag:asdf" . "(1340787624 (\"asdf-installでインストールできるもの\" :ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f))")
(" %Tag:asdf-install" . "(1340793651 (\"asdf-installでインストールできるもの\" :ctime 1227511770 :cuser #f :mtime 1227511888 :muser #f))")
("文字列の先頭・末尾の空白を削除する" . "(:ctime 1227347967 :cuser #f :mtime 1227369742 :muser #f)[[$$tag 文字列 シーケンス]]\n* 文字列の先頭・末尾の空白を削除する\n{{{\n(string-right-trim '(#\\Space) \" abc \") ;=> \" abc\"\n(string-left-trim '(#\\Space) \" abc \")  ;=> \"abc \"\n(string-trim '(#\\Space) \" abc \")       ;=> \"abc\"\n}}}\n")
("構造体" . "(:ctime 1229599940 :cuser #f :mtime 1235474105 :muser #f)[[$$tag 構造体]]\n\n;; - [[構造体を作成する]]\n;; - [[構造体要素をカンマ区切りで出力する]]\n;; - [[構造体の要素数を取得する]]\n;; - [[構造体を任意の初期値で埋める]]\n")
("配列を逆順にする" . "(:ctime 1228464721 :cuser #f :mtime 1228464722 :muser #f)[[$$tag 配列]]\n\nベクタを逆順にするには [[$$hs reverse]] 関数を使います。\n\n{{{\n(reverse #(1 2 3 4)) ; => #(4 3 2 1)\n(reverse #()) ; => #()\n}}}\n\n[[$$hs reverse]] には破壊的変更版として [[$$hs nreverse]] もあります。\n\n{{{\n(let ((v (copy-seq #(1 2 3 4))))\n  (setq v (nreverse v)))\n;=> #(4 3 2 1)\n}}}\n[[$$hs nreverse]] は結果の生成の為にベクタを破壊的に変更するのみで、必ずしも元のベクタを逆順にするわけではありませんので、必要な場合には元の変数に値をセットし直す必要があります。\n")
("指定した位置の要素を取り除く" . "(:ctime 1229191528 :cuser #f :mtime 1229256880 :muser #f)[[$$tag 配列]]\n\n* 指定した位置の要素を取り除く\n\nRubyのArray#delete_atメソッドのようなものはANSI CLの標準には含まれていませんが、下記のようなものが考えられるでしょう。\n\n{{{\n(defun remove-at (pos seq)\n  (remove-if (constantly T) seq :start pos :count 1))\n\n(let ((a (vector 5 1 4 2 3)))\n  (remove-at 0 (remove-at 0 a)))\n;=> #(4 2 3)\n}}}\n\n;; ↑改善案を参考にしました↓\nremove-at別解\n{{{\n(defun remove-at (pos seq)\n  (remove nil seq :start pos :count 1 :test (constantly T)))\n\n;; 破壊的変更版\n(defun delete-at (pos seq)\n  (delete nil seq :start pos :count 1 :test (constantly T)))\n}}}\n")
("メソッドを定義するには" . "(:ctime 1229673282 :cuser #f :mtime 1229673589 :muser #f)[[$$tag オブジェクトシステム(CLOS)]]\n\n* メソッドを定義するには\n\n標準のCLOSでのメソッドの定義とは総称関数を定義することになり、[[$$hs defgeneric]]、[[$$hs defmethod]] を使用して定義します。\n\nCLOSの特徴としてメソッドが特定のクラスに属していないことが挙げられますが、メソッドは通常 [[$$hs defclass]] で定義する [[$$hs standard-object]] のオブジェクト以外にも、[[$$hs built-in-class]] (リストやベクタ、数値等々)、 [[$$hs structure-class]](構造体) にも定義することが可能です。\n\nまた、EQLスペシャライザ(特定子)により特定のオブジェクトそのものに対してメソッドを設定することも可能です。\n{{{\n(defclass foo () ())                    ;fooクラス\n(defstruct foo-struct)                  ;構造体\n\n(defgeneric foo (obj))                  ;総称関数を定義\n\n;; fooクラス\n(defmethod foo ((x foo))\n  \"foo class!\")\n\n;; foo-struct構造体\n(defmethod foo ((x foo-struct))\n  \"foo struct!\")\n\n;; built-in-class float\n(defmethod foo ((x float))\n  \"float!\")\n\n;; built-in-class function\n(defmethod foo ((x function))\n  \"function!\")\n\n;; eql特定子\n(defmethod foo ((x (eql 1)))\n  \"one!\")\n\n;;; 試してみる\n(let ((a (make-instance 'foo))\n      (b (make-foo-struct))\n      (c pi)\n      (d #'car)\n      (e 1))\n  (mapcar #'foo (list a b c d e)))\n;=> (\"foo class!\" \"foo struct!\" \"float!\" \"function!\" \"one!\")\n}}}\n")
("文字列を結合する" . "(:ctime 1227347577 :cuser #f :mtime 1317765667 :muser #f)\nhttp://rd.clojure-users.org/entry/view/76002\n")
("プログラム中でハッシュを定義する" . "(:ctime 1227413441 :cuser #f :mtime 1227424867 :muser #f)[[$$tag ハッシュ ライブラリ fare-utils alexandria arnesi]]\n* プログラム中でハッシュを定義する\n以下のようにするとプログラム中でハッシュを定義することができます。\n検索用のテスト関数も:testで指定することが可能です。(デフォルトでは、eql)\n{{{\n(let ((ht (make-hash-table :test #'equal)))\n  (setf (gethash \"apple\" ht) 150\n        (gethash \"banana\" ht) 300\n        (gethash \"lemon\" ht) 300))\n}}}\n見ての通りやや面倒なので、便利にするライブラリも様々提供されています。\n{{{\n;; alexandria\n(alexandria:plist-hash-table '(\"apple\" 150\n                               \"banana\" 300\n                               \"lemon\" 300)\n                             :test #'equal)\n\n;; fare-utils\n(fare-utils:alist->hash-table '((\"apple\" 150)\n                                (\"banana\" 300)\n                                (\"lemon\" 300))\n                              :test #'equal)\n\n;; arnesi\n(arnesi:build-hash-table (list :test #'equal)\n                         '((\"apple\" 150)\n                           (\"banana\" 300)\n                           (\"lemon\" 300)))\n}}}\n")
("外部からの入力バイト列を文字列にしたい(文字コード変換含む)" . "(:ctime 1229261302 :cuser #f :mtime 1229518681 :muser #f)[[$$tag 入出力 FIXME]]\n\n*  外部からの入力バイト列を文字列にしたい(文字コード変換含む)\n\nWebページを取得しページを加工することを考えてみます。\nCLでは処理系依存で文字コードを指定し扱う方法がそれぞれありますが、Webページ取得の場合にはエンコードを決め打ちにしてしまうと、指定したエンコードのページしか正しく処理できないことになってしまいます。これでは、現在の日本のようにエンコードが複数使われている状況では不便です。\n\n下記の例では[http://lispuser.net/ onjo氏]作のjpパッケージを利用し、文字エンコーディングを自動判別してバイト列を文字列に変換しています。\n\njpパッケージの詳細については[http://lispuser.net/commonlisp/japanese.html Common Lisp と 日本語 と 文字コード]を参照して下さい\n{{{\n(let ((vec (drakma:http-request \"http://tips.lisp-users.org/common-lisp/\" :force-binary T)))\n  (jp:decode vec :guess))\n;=> \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\n;       \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\n; <html><head><title>逆引きCommonLisp</title\n; ... \"\n}}}\n\n----\n- '''decode''' ''vector external-format'' &key ''(start 0) end''\n")
